// https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#metadata DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#metadata}
  */
  readonly metadata: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#spec DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#spec}
  */
  readonly spec?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec;
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#annotations DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#labels DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadataToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_request_bytes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBufferToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBufferToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBufferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxRequestBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxRequestBytes = value.maxRequestBytes;
    }
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#exact DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#suffix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_vary_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_vary_headers}
  */
  readonly allowedVaryHeaders?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#caching_service_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#caching_service_ref}
  */
  readonly cachingServiceRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_payload_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_payload_size}
  */
  readonly maxPayloadSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_vary_headers: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersToTerraform, false)(struct!.allowedVaryHeaders),
    caching_service_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRefToTerraform(struct!.cachingServiceRef),
    max_payload_size: cdktf.numberToTerraform(struct!.maxPayloadSize),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_vary_headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersToHclTerraform, false)(struct!.allowedVaryHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersList",
    },
    caching_service_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRefToHclTerraform(struct!.cachingServiceRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef",
    },
    max_payload_size: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedVaryHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedVaryHeaders = this._allowedVaryHeaders?.internalValue;
    }
    if (this._cachingServiceRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingServiceRef = this._cachingServiceRef?.internalValue;
    }
    if (this._maxPayloadSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSize = this._maxPayloadSize;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedVaryHeaders.internalValue = undefined;
      this._cachingServiceRef.internalValue = undefined;
      this._maxPayloadSize = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedVaryHeaders.internalValue = value.allowedVaryHeaders;
      this._cachingServiceRef.internalValue = value.cachingServiceRef;
      this._maxPayloadSize = value.maxPayloadSize;
      this._timeout = value.timeout;
    }
  }

  // allowed_vary_headers - computed: false, optional: true, required: false
  private _allowedVaryHeaders = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeadersList(this, "allowed_vary_headers", false);
  public get allowedVaryHeaders() {
    return this._allowedVaryHeaders;
  }
  public putAllowedVaryHeaders(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingAllowedVaryHeaders[] | cdktf.IResolvable) {
    this._allowedVaryHeaders.internalValue = value;
  }
  public resetAllowedVaryHeaders() {
    this._allowedVaryHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedVaryHeadersInput() {
    return this._allowedVaryHeaders.internalValue;
  }

  // caching_service_ref - computed: false, optional: true, required: false
  private _cachingServiceRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRefOutputReference(this, "caching_service_ref");
  public get cachingServiceRef() {
    return this._cachingServiceRef;
  }
  public putCachingServiceRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingCachingServiceRef) {
    this._cachingServiceRef.internalValue = value;
  }
  public resetCachingServiceRef() {
    this._cachingServiceRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingServiceRefInput() {
    return this._cachingServiceRef.internalValue;
  }

  // max_payload_size - computed: false, optional: true, required: false
  private _maxPayloadSize?: number; 
  public get maxPayloadSize() {
    return this.getNumberAttribute('max_payload_size');
  }
  public set maxPayloadSize(value: number) {
    this._maxPayloadSize = value;
  }
  public resetMaxPayloadSize() {
    this._maxPayloadSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeInput() {
    return this._maxPayloadSize;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#delay_before_close DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#delay_before_close}
  */
  readonly delayBeforeClose?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_active_connections DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_active_connections}
  */
  readonly maxActiveConnections?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimitToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay_before_close: cdktf.stringToTerraform(struct!.delayBeforeClose),
    max_active_connections: cdktf.numberToTerraform(struct!.maxActiveConnections),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimitToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay_before_close: {
      value: cdktf.stringToHclTerraform(struct!.delayBeforeClose),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delayBeforeClose !== undefined) {
      hasAnyValues = true;
      internalValueResult.delayBeforeClose = this._delayBeforeClose;
    }
    if (this._maxActiveConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveConnections = this._maxActiveConnections;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delayBeforeClose = undefined;
      this._maxActiveConnections = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delayBeforeClose = value.delayBeforeClose;
      this._maxActiveConnections = value.maxActiveConnections;
    }
  }

  // delay_before_close - computed: false, optional: true, required: false
  private _delayBeforeClose?: string; 
  public get delayBeforeClose() {
    return this.getStringAttribute('delay_before_close');
  }
  public set delayBeforeClose(value: string) {
    this._delayBeforeClose = value;
  }
  public resetDelayBeforeClose() {
    this._delayBeforeClose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayBeforeCloseInput() {
    return this._delayBeforeClose;
  }

  // max_active_connections - computed: false, optional: true, required: false
  private _maxActiveConnections?: number; 
  public get maxActiveConnections() {
    return this.getNumberAttribute('max_active_connections');
  }
  public set maxActiveConnections(value: number) {
    this._maxActiveConnections = value;
  }
  public resetMaxActiveConnections() {
    this._maxActiveConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveConnectionsInput() {
    return this._maxActiveConnections;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#exact DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#suffix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#denominator DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#numerator DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#default_value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#runtime_key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#denominator DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#numerator DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#default_value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#runtime_key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#additional_origins DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#additional_origins}
  */
  readonly additionalOrigins?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#filter_enabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#filter_enabled}
  */
  readonly filterEnabled?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#shadow_enabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#shadow_enabled}
  */
  readonly shadowEnabled?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_origins: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsToTerraform, false)(struct!.additionalOrigins),
    filter_enabled: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledToTerraform(struct!.filterEnabled),
    shadow_enabled: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledToTerraform(struct!.shadowEnabled),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_origins: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsToHclTerraform, false)(struct!.additionalOrigins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsList",
    },
    filter_enabled: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledToHclTerraform(struct!.filterEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled",
    },
    shadow_enabled: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledToHclTerraform(struct!.shadowEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalOrigins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalOrigins = this._additionalOrigins?.internalValue;
    }
    if (this._filterEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterEnabled = this._filterEnabled?.internalValue;
    }
    if (this._shadowEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadowEnabled = this._shadowEnabled?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = undefined;
      this._filterEnabled.internalValue = undefined;
      this._shadowEnabled.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = value.additionalOrigins;
      this._filterEnabled.internalValue = value.filterEnabled;
      this._shadowEnabled.internalValue = value.shadowEnabled;
    }
  }

  // additional_origins - computed: false, optional: true, required: false
  private _additionalOrigins = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOriginsList(this, "additional_origins", false);
  public get additionalOrigins() {
    return this._additionalOrigins;
  }
  public putAdditionalOrigins(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable) {
    this._additionalOrigins.internalValue = value;
  }
  public resetAdditionalOrigins() {
    this._additionalOrigins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalOriginsInput() {
    return this._additionalOrigins.internalValue;
  }

  // filter_enabled - computed: false, optional: true, required: false
  private _filterEnabled = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabledOutputReference(this, "filter_enabled");
  public get filterEnabled() {
    return this._filterEnabled;
  }
  public putFilterEnabled(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfFilterEnabled) {
    this._filterEnabled.internalValue = value;
  }
  public resetFilterEnabled() {
    this._filterEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterEnabledInput() {
    return this._filterEnabled.internalValue;
  }

  // shadow_enabled - computed: false, optional: true, required: false
  private _shadowEnabled = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabledOutputReference(this, "shadow_enabled");
  public get shadowEnabled() {
    return this._shadowEnabled;
  }
  public putShadowEnabled(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfShadowEnabled) {
    this._shadowEnabled.internalValue = value;
  }
  public resetShadowEnabled() {
    this._shadowEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowEnabledInput() {
    return this._shadowEnabled.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
      this._subgroup = value.subgroup;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#mask_char DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#percent DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex_actions DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex_actions}
  */
  readonly regexActions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToTerraform(struct!.percent),
    regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regex),
    regex_actions: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToTerraform, false)(struct!.regexActions),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent",
    },
    regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    regex_actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToHclTerraform, false)(struct!.regexActions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._regexActions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexActions = this._regexActions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
      this._regex = undefined;
      this._regexActions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
      this._regex = value.regex;
      this._regexActions.internalValue = value.regexActions;
    }
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string[]; 
  public get regex() {
    return this.getListAttribute('regex');
  }
  public set regex(value: string[]) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // regex_actions - computed: false, optional: true, required: false
  private _regexActions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsList(this, "regex_actions", false);
  public get regexActions() {
    return this._regexActions;
  }
  public putRegexActions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions[] | cdktf.IResolvable) {
    this._regexActions.internalValue = value;
  }
  public resetRegexActions() {
    this._regexActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexActionsInput() {
    return this._regexActions.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#key_to_mask DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#key_to_mask}
  */
  readonly keyToMask?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#mask_char DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#percent DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key_to_mask: cdktf.stringToTerraform(struct!.keyToMask),
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToTerraform(struct!.percent),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key_to_mask: {
      value: cdktf.stringToHclTerraform(struct!.keyToMask),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keyToMask !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyToMask = this._keyToMask;
    }
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keyToMask = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keyToMask = value.keyToMask;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
    }
  }

  // key_to_mask - computed: false, optional: true, required: false
  private _keyToMask?: string; 
  public get keyToMask() {
    return this.getStringAttribute('key_to_mask');
  }
  public set keyToMask(value: string) {
    this._keyToMask = value;
  }
  public resetKeyToMask() {
    this._keyToMask = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyToMaskInput() {
    return this._keyToMask;
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#action_type DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#action_type}
  */
  readonly actionType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#custom_action DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#custom_action}
  */
  readonly customAction?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#key_value_action DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#key_value_action}
  */
  readonly keyValueAction?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#shadow DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#shadow}
  */
  readonly shadow?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_type: cdktf.stringToTerraform(struct!.actionType),
    custom_action: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionToTerraform(struct!.customAction),
    key_value_action: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToTerraform(struct!.keyValueAction),
    shadow: cdktf.booleanToTerraform(struct!.shadow),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_type: {
      value: cdktf.stringToHclTerraform(struct!.actionType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_action: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionToHclTerraform(struct!.customAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction",
    },
    key_value_action: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToHclTerraform(struct!.keyValueAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction",
    },
    shadow: {
      value: cdktf.booleanToHclTerraform(struct!.shadow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionType !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionType = this._actionType;
    }
    if (this._customAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAction = this._customAction?.internalValue;
    }
    if (this._keyValueAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueAction = this._keyValueAction?.internalValue;
    }
    if (this._shadow !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadow = this._shadow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionType = undefined;
      this._customAction.internalValue = undefined;
      this._keyValueAction.internalValue = undefined;
      this._shadow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionType = value.actionType;
      this._customAction.internalValue = value.customAction;
      this._keyValueAction.internalValue = value.keyValueAction;
      this._shadow = value.shadow;
    }
  }

  // action_type - computed: false, optional: true, required: false
  private _actionType?: string; 
  public get actionType() {
    return this.getStringAttribute('action_type');
  }
  public set actionType(value: string) {
    this._actionType = value;
  }
  public resetActionType() {
    this._actionType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionTypeInput() {
    return this._actionType;
  }

  // custom_action - computed: false, optional: true, required: false
  private _customAction = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomActionOutputReference(this, "custom_action");
  public get customAction() {
    return this._customAction;
  }
  public putCustomAction(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsCustomAction) {
    this._customAction.internalValue = value;
  }
  public resetCustomAction() {
    this._customAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customActionInput() {
    return this._customAction.internalValue;
  }

  // key_value_action - computed: false, optional: true, required: false
  private _keyValueAction = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionOutputReference(this, "key_value_action");
  public get keyValueAction() {
    return this._keyValueAction;
  }
  public putKeyValueAction(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction) {
    this._keyValueAction.internalValue = value;
  }
  public resetKeyValueAction() {
    this._keyValueAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueActionInput() {
    return this._keyValueAction.internalValue;
  }

  // shadow - computed: false, optional: true, required: false
  private _shadow?: boolean | cdktf.IResolvable; 
  public get shadow() {
    return this.getBooleanAttribute('shadow');
  }
  public set shadow(value: boolean | cdktf.IResolvable) {
    this._shadow = value;
  }
  public resetShadow() {
    this._shadow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowInput() {
    return this._shadow;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#case_sensitive DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#case_sensitive}
  */
  readonly caseSensitive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#connect_matcher DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#connect_matcher}
  */
  readonly connectMatcher?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#exact DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#methods DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#methods}
  */
  readonly methods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#query_parameters DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#query_parameters}
  */
  readonly queryParameters?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    case_sensitive: cdktf.booleanToTerraform(struct!.caseSensitive),
    connect_matcher: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectMatcher),
    exact: cdktf.stringToTerraform(struct!.exact),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersToTerraform, false)(struct!.headers),
    methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.methods),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    query_parameters: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToTerraform, false)(struct!.queryParameters),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    case_sensitive: {
      value: cdktf.booleanToHclTerraform(struct!.caseSensitive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connect_matcher: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectMatcher),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersList",
    },
    methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.methods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_parameters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToHclTerraform, false)(struct!.queryParameters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersList",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caseSensitive !== undefined) {
      hasAnyValues = true;
      internalValueResult.caseSensitive = this._caseSensitive;
    }
    if (this._connectMatcher !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectMatcher = this._connectMatcher;
    }
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._methods !== undefined) {
      hasAnyValues = true;
      internalValueResult.methods = this._methods;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._queryParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParameters = this._queryParameters?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caseSensitive = undefined;
      this._connectMatcher = undefined;
      this._exact = undefined;
      this._headers.internalValue = undefined;
      this._methods = undefined;
      this._prefix = undefined;
      this._queryParameters.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caseSensitive = value.caseSensitive;
      this._connectMatcher = value.connectMatcher;
      this._exact = value.exact;
      this._headers.internalValue = value.headers;
      this._methods = value.methods;
      this._prefix = value.prefix;
      this._queryParameters.internalValue = value.queryParameters;
      this._regex = value.regex;
    }
  }

  // case_sensitive - computed: false, optional: true, required: false
  private _caseSensitive?: boolean | cdktf.IResolvable; 
  public get caseSensitive() {
    return this.getBooleanAttribute('case_sensitive');
  }
  public set caseSensitive(value: boolean | cdktf.IResolvable) {
    this._caseSensitive = value;
  }
  public resetCaseSensitive() {
    this._caseSensitive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caseSensitiveInput() {
    return this._caseSensitive;
  }

  // connect_matcher - computed: false, optional: true, required: false
  private _connectMatcher?: { [key: string]: string }; 
  public get connectMatcher() {
    return this.getStringMapAttribute('connect_matcher');
  }
  public set connectMatcher(value: { [key: string]: string }) {
    this._connectMatcher = value;
  }
  public resetConnectMatcher() {
    this._connectMatcher = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectMatcherInput() {
    return this._connectMatcher;
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // methods - computed: false, optional: true, required: false
  private _methods?: string[]; 
  public get methods() {
    return this.getListAttribute('methods');
  }
  public set methods(value: string[]) {
    this._methods = value;
  }
  public resetMethods() {
    this._methods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodsInput() {
    return this._methods;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // query_parameters - computed: false, optional: true, required: false
  private _queryParameters = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersList(this, "query_parameters", false);
  public get queryParameters() {
    return this._queryParameters;
  }
  public putQueryParameters(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters[] | cdktf.IResolvable) {
    this._queryParameters.internalValue = value;
  }
  public resetQueryParameters() {
    this._queryParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParametersInput() {
    return this._queryParameters.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#actions DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#actions}
  */
  readonly actions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#matcher DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#matcher}
  */
  readonly matcher?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsToTerraform, false)(struct!.actions),
    matcher: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherToTerraform(struct!.matcher),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsToHclTerraform, false)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsList",
    },
    matcher: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherToHclTerraform(struct!.matcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._matcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matcher = this._matcher?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions.internalValue = undefined;
      this._matcher.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions.internalValue = value.actions;
      this._matcher.internalValue = value.matcher;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // matcher - computed: false, optional: true, required: false
  private _matcher = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcherOutputReference(this, "matcher");
  public get matcher() {
    return this._matcher;
  }
  public putMatcher(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesMatcher) {
    this._matcher.internalValue = value;
  }
  public resetMatcher() {
    this._matcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matcherInput() {
    return this._matcher.internalValue;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dlp_rules DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dlp_rules}
  */
  readonly dlpRules?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#enabled_for DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#enabled_for}
  */
  readonly enabledFor?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dlp_rules: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesToTerraform, false)(struct!.dlpRules),
    enabled_for: cdktf.stringToTerraform(struct!.enabledFor),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dlp_rules: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesToHclTerraform, false)(struct!.dlpRules),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesList",
    },
    enabled_for: {
      value: cdktf.stringToHclTerraform(struct!.enabledFor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dlpRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dlpRules = this._dlpRules?.internalValue;
    }
    if (this._enabledFor !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabledFor = this._enabledFor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dlpRules.internalValue = undefined;
      this._enabledFor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dlpRules.internalValue = value.dlpRules;
      this._enabledFor = value.enabledFor;
    }
  }

  // dlp_rules - computed: false, optional: true, required: false
  private _dlpRules = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRulesList(this, "dlp_rules", false);
  public get dlpRules() {
    return this._dlpRules;
  }
  public putDlpRules(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpDlpRules[] | cdktf.IResolvable) {
    this._dlpRules.internalValue = value;
  }
  public resetDlpRules() {
    this._dlpRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dlpRulesInput() {
    return this._dlpRules.internalValue;
  }

  // enabled_for - computed: false, optional: true, required: false
  private _enabledFor?: string; 
  public get enabledFor() {
    return this.getStringAttribute('enabled_for');
  }
  public set enabledFor(value: string) {
    this._enabledFor = value;
  }
  public resetEnabledFor() {
    this._enabledFor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledForInput() {
    return this._enabledFor;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#no_default_search_domain DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#no_default_search_domain}
  */
  readonly noDefaultSearchDomain?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#use_tcp_for_dns_lookups DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#use_tcp_for_dns_lookups}
  */
  readonly useTcpForDnsLookups?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    no_default_search_domain: cdktf.booleanToTerraform(struct!.noDefaultSearchDomain),
    use_tcp_for_dns_lookups: cdktf.booleanToTerraform(struct!.useTcpForDnsLookups),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    no_default_search_domain: {
      value: cdktf.booleanToHclTerraform(struct!.noDefaultSearchDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_tcp_for_dns_lookups: {
      value: cdktf.booleanToHclTerraform(struct!.useTcpForDnsLookups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._noDefaultSearchDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.noDefaultSearchDomain = this._noDefaultSearchDomain;
    }
    if (this._useTcpForDnsLookups !== undefined) {
      hasAnyValues = true;
      internalValueResult.useTcpForDnsLookups = this._useTcpForDnsLookups;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._noDefaultSearchDomain = undefined;
      this._useTcpForDnsLookups = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._noDefaultSearchDomain = value.noDefaultSearchDomain;
      this._useTcpForDnsLookups = value.useTcpForDnsLookups;
    }
  }

  // no_default_search_domain - computed: false, optional: true, required: false
  private _noDefaultSearchDomain?: boolean | cdktf.IResolvable; 
  public get noDefaultSearchDomain() {
    return this.getBooleanAttribute('no_default_search_domain');
  }
  public set noDefaultSearchDomain(value: boolean | cdktf.IResolvable) {
    this._noDefaultSearchDomain = value;
  }
  public resetNoDefaultSearchDomain() {
    this._noDefaultSearchDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noDefaultSearchDomainInput() {
    return this._noDefaultSearchDomain;
  }

  // use_tcp_for_dns_lookups - computed: false, optional: true, required: false
  private _useTcpForDnsLookups?: boolean | cdktf.IResolvable; 
  public get useTcpForDnsLookups() {
    return this.getBooleanAttribute('use_tcp_for_dns_lookups');
  }
  public set useTcpForDnsLookups(value: boolean | cdktf.IResolvable) {
    this._useTcpForDnsLookups = value;
  }
  public resetUseTcpForDnsLookups() {
    this._useTcpForDnsLookups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useTcpForDnsLookupsInput() {
    return this._useTcpForDnsLookups;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#mode}
  */
  readonly mode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#path DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.numberToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.numberToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: number; 
  public get mode() {
    return this.getNumberAttribute('mode');
  }
  public set mode(value: number) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ipv4_compat DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ipv4_compat}
  */
  readonly ipv4Compat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#named_port DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#named_port}
  */
  readonly namedPort?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#port_value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#port_value}
  */
  readonly portValue?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#protocol DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#resolver_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#resolver_name}
  */
  readonly resolverName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    ipv4_compat: cdktf.booleanToTerraform(struct!.ipv4Compat),
    named_port: cdktf.stringToTerraform(struct!.namedPort),
    port_value: cdktf.numberToTerraform(struct!.portValue),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    resolver_name: cdktf.stringToTerraform(struct!.resolverName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4_compat: {
      value: cdktf.booleanToHclTerraform(struct!.ipv4Compat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    named_port: {
      value: cdktf.stringToHclTerraform(struct!.namedPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_value: {
      value: cdktf.numberToHclTerraform(struct!.portValue),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resolver_name: {
      value: cdktf.stringToHclTerraform(struct!.resolverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._ipv4Compat !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4Compat = this._ipv4Compat;
    }
    if (this._namedPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.namedPort = this._namedPort;
    }
    if (this._portValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portValue = this._portValue;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._resolverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverName = this._resolverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._ipv4Compat = undefined;
      this._namedPort = undefined;
      this._portValue = undefined;
      this._protocol = undefined;
      this._resolverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._ipv4Compat = value.ipv4Compat;
      this._namedPort = value.namedPort;
      this._portValue = value.portValue;
      this._protocol = value.protocol;
      this._resolverName = value.resolverName;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // ipv4_compat - computed: false, optional: true, required: false
  private _ipv4Compat?: boolean | cdktf.IResolvable; 
  public get ipv4Compat() {
    return this.getBooleanAttribute('ipv4_compat');
  }
  public set ipv4Compat(value: boolean | cdktf.IResolvable) {
    this._ipv4Compat = value;
  }
  public resetIpv4Compat() {
    this._ipv4Compat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4CompatInput() {
    return this._ipv4Compat;
  }

  // named_port - computed: false, optional: true, required: false
  private _namedPort?: string; 
  public get namedPort() {
    return this.getStringAttribute('named_port');
  }
  public set namedPort(value: string) {
    this._namedPort = value;
  }
  public resetNamedPort() {
    this._namedPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namedPortInput() {
    return this._namedPort;
  }

  // port_value - computed: false, optional: true, required: false
  private _portValue?: number; 
  public get portValue() {
    return this.getNumberAttribute('port_value');
  }
  public set portValue(value: number) {
    this._portValue = value;
  }
  public resetPortValue() {
    this._portValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portValueInput() {
    return this._portValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // resolver_name - computed: false, optional: true, required: false
  private _resolverName?: string; 
  public get resolverName() {
    return this.getStringAttribute('resolver_name');
  }
  public set resolverName(value: string) {
    this._resolverName = value;
  }
  public resetResolverName() {
    this._resolverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverNameInput() {
    return this._resolverName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#pipe DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#pipe}
  */
  readonly pipe?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#socket_address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#socket_address}
  */
  readonly socketAddress?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pipe: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToTerraform(struct!.pipe),
    socket_address: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToTerraform(struct!.socketAddress),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pipe: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe",
    },
    socket_address: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToHclTerraform(struct!.socketAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._socketAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketAddress = this._socketAddress?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pipe.internalValue = undefined;
      this._socketAddress.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pipe.internalValue = value.pipe;
      this._socketAddress.internalValue = value.socketAddress;
    }
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // socket_address - computed: false, optional: true, required: false
  private _socketAddress = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressOutputReference(this, "socket_address");
  public get socketAddress() {
    return this._socketAddress;
  }
  public putSocketAddress(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress) {
    this._socketAddress.internalValue = value;
  }
  public resetSocketAddress() {
    this._socketAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketAddressInput() {
    return this._socketAddress.internalValue;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_resolver_options DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_resolver_options}
  */
  readonly dnsResolverOptions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#resolvers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#resolvers}
  */
  readonly resolvers?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dns_resolver_options: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToTerraform(struct!.dnsResolverOptions),
    resolvers: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToTerraform, false)(struct!.resolvers),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dns_resolver_options: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToHclTerraform(struct!.dnsResolverOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions",
    },
    resolvers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToHclTerraform, false)(struct!.resolvers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dnsResolverOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolverOptions = this._dnsResolverOptions?.internalValue;
    }
    if (this._resolvers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolvers = this._resolvers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dnsResolverOptions.internalValue = undefined;
      this._resolvers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dnsResolverOptions.internalValue = value.dnsResolverOptions;
      this._resolvers.internalValue = value.resolvers;
    }
  }

  // dns_resolver_options - computed: false, optional: true, required: false
  private _dnsResolverOptions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsOutputReference(this, "dns_resolver_options");
  public get dnsResolverOptions() {
    return this._dnsResolverOptions;
  }
  public putDnsResolverOptions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions) {
    this._dnsResolverOptions.internalValue = value;
  }
  public resetDnsResolverOptions() {
    this._dnsResolverOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverOptionsInput() {
    return this._dnsResolverOptions.internalValue;
  }

  // resolvers - computed: false, optional: true, required: false
  private _resolvers = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversList(this, "resolvers", false);
  public get resolvers() {
    return this._resolvers;
  }
  public putResolvers(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers[] | cdktf.IResolvable) {
    this._resolvers.internalValue = value;
  }
  public resetResolvers() {
    this._resolvers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolversInput() {
    return this._resolvers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_pending_requests DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_pending_requests}
  */
  readonly maxPendingRequests?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_pending_requests: cdktf.numberToTerraform(struct!.maxPendingRequests),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_pending_requests: {
      value: cdktf.numberToHclTerraform(struct!.maxPendingRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxPendingRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPendingRequests = this._maxPendingRequests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxPendingRequests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxPendingRequests = value.maxPendingRequests;
    }
  }

  // max_pending_requests - computed: false, optional: true, required: false
  private _maxPendingRequests?: number; 
  public get maxPendingRequests() {
    return this.getNumberAttribute('max_pending_requests');
  }
  public set maxPendingRequests(value: number) {
    this._maxPendingRequests = value;
  }
  public resetMaxPendingRequests() {
    this._maxPendingRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPendingRequestsInput() {
    return this._maxPendingRequests;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#base_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#base_interval}
  */
  readonly baseInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_interval}
  */
  readonly maxInterval?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_interval: cdktf.stringToTerraform(struct!.baseInterval),
    max_interval: cdktf.stringToTerraform(struct!.maxInterval),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_interval: {
      value: cdktf.stringToHclTerraform(struct!.baseInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_interval: {
      value: cdktf.stringToHclTerraform(struct!.maxInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseInterval = this._baseInterval;
    }
    if (this._maxInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInterval = this._maxInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseInterval = undefined;
      this._maxInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseInterval = value.baseInterval;
      this._maxInterval = value.maxInterval;
    }
  }

  // base_interval - computed: false, optional: true, required: false
  private _baseInterval?: string; 
  public get baseInterval() {
    return this.getStringAttribute('base_interval');
  }
  public set baseInterval(value: string) {
    this._baseInterval = value;
  }
  public resetBaseInterval() {
    this._baseInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseIntervalInput() {
    return this._baseInterval;
  }

  // max_interval - computed: false, optional: true, required: false
  private _maxInterval?: string; 
  public get maxInterval() {
    return this.getStringAttribute('max_interval');
  }
  public set maxInterval(value: string) {
    this._maxInterval = value;
  }
  public resetMaxInterval() {
    this._maxInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIntervalInput() {
    return this._maxInterval;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ipv4_compat DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ipv4_compat}
  */
  readonly ipv4Compat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#named_port DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#named_port}
  */
  readonly namedPort?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#port_value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#port_value}
  */
  readonly portValue?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#protocol DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#resolver_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#resolver_name}
  */
  readonly resolverName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    ipv4_compat: cdktf.booleanToTerraform(struct!.ipv4Compat),
    named_port: cdktf.stringToTerraform(struct!.namedPort),
    port_value: cdktf.numberToTerraform(struct!.portValue),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    resolver_name: cdktf.stringToTerraform(struct!.resolverName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4_compat: {
      value: cdktf.booleanToHclTerraform(struct!.ipv4Compat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    named_port: {
      value: cdktf.stringToHclTerraform(struct!.namedPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_value: {
      value: cdktf.numberToHclTerraform(struct!.portValue),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resolver_name: {
      value: cdktf.stringToHclTerraform(struct!.resolverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._ipv4Compat !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4Compat = this._ipv4Compat;
    }
    if (this._namedPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.namedPort = this._namedPort;
    }
    if (this._portValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portValue = this._portValue;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._resolverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverName = this._resolverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._ipv4Compat = undefined;
      this._namedPort = undefined;
      this._portValue = undefined;
      this._protocol = undefined;
      this._resolverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._ipv4Compat = value.ipv4Compat;
      this._namedPort = value.namedPort;
      this._portValue = value.portValue;
      this._protocol = value.protocol;
      this._resolverName = value.resolverName;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // ipv4_compat - computed: false, optional: true, required: false
  private _ipv4Compat?: boolean | cdktf.IResolvable; 
  public get ipv4Compat() {
    return this.getBooleanAttribute('ipv4_compat');
  }
  public set ipv4Compat(value: boolean | cdktf.IResolvable) {
    this._ipv4Compat = value;
  }
  public resetIpv4Compat() {
    this._ipv4Compat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4CompatInput() {
    return this._ipv4Compat;
  }

  // named_port - computed: false, optional: true, required: false
  private _namedPort?: string; 
  public get namedPort() {
    return this.getStringAttribute('named_port');
  }
  public set namedPort(value: string) {
    this._namedPort = value;
  }
  public resetNamedPort() {
    this._namedPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namedPortInput() {
    return this._namedPort;
  }

  // port_value - computed: false, optional: true, required: false
  private _portValue?: number; 
  public get portValue() {
    return this.getNumberAttribute('port_value');
  }
  public set portValue(value: number) {
    this._portValue = value;
  }
  public resetPortValue() {
    this._portValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portValueInput() {
    return this._portValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // resolver_name - computed: false, optional: true, required: false
  private _resolverName?: string; 
  public get resolverName() {
    return this.getStringAttribute('resolver_name');
  }
  public set resolverName(value: string) {
    this._resolverName = value;
  }
  public resetResolverName() {
    this._resolverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverNameInput() {
    return this._resolverName;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#apple_dns DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#apple_dns}
  */
  readonly appleDns?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cares_dns DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cares_dns}
  */
  readonly caresDns?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_cache_circuit_breaker DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_cache_circuit_breaker}
  */
  readonly dnsCacheCircuitBreaker?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_failure_refresh_rate DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_failure_refresh_rate}
  */
  readonly dnsFailureRefreshRate?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_lookup_family DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_lookup_family}
  */
  readonly dnsLookupFamily?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_query_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_query_timeout}
  */
  readonly dnsQueryTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_refresh_rate DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_refresh_rate}
  */
  readonly dnsRefreshRate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#host_ttl DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#host_ttl}
  */
  readonly hostTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_hosts DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_hosts}
  */
  readonly maxHosts?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#preresolve_hostnames DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#preresolve_hostnames}
  */
  readonly preresolveHostnames?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apple_dns: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.appleDns),
    cares_dns: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToTerraform(struct!.caresDns),
    dns_cache_circuit_breaker: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToTerraform(struct!.dnsCacheCircuitBreaker),
    dns_failure_refresh_rate: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToTerraform(struct!.dnsFailureRefreshRate),
    dns_lookup_family: cdktf.stringToTerraform(struct!.dnsLookupFamily),
    dns_query_timeout: cdktf.stringToTerraform(struct!.dnsQueryTimeout),
    dns_refresh_rate: cdktf.stringToTerraform(struct!.dnsRefreshRate),
    host_ttl: cdktf.stringToTerraform(struct!.hostTtl),
    max_hosts: cdktf.numberToTerraform(struct!.maxHosts),
    preresolve_hostnames: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToTerraform, false)(struct!.preresolveHostnames),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apple_dns: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.appleDns),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cares_dns: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToHclTerraform(struct!.caresDns),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns",
    },
    dns_cache_circuit_breaker: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToHclTerraform(struct!.dnsCacheCircuitBreaker),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker",
    },
    dns_failure_refresh_rate: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToHclTerraform(struct!.dnsFailureRefreshRate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate",
    },
    dns_lookup_family: {
      value: cdktf.stringToHclTerraform(struct!.dnsLookupFamily),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_query_timeout: {
      value: cdktf.stringToHclTerraform(struct!.dnsQueryTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_refresh_rate: {
      value: cdktf.stringToHclTerraform(struct!.dnsRefreshRate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_ttl: {
      value: cdktf.stringToHclTerraform(struct!.hostTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_hosts: {
      value: cdktf.numberToHclTerraform(struct!.maxHosts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    preresolve_hostnames: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToHclTerraform, false)(struct!.preresolveHostnames),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appleDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.appleDns = this._appleDns;
    }
    if (this._caresDns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caresDns = this._caresDns?.internalValue;
    }
    if (this._dnsCacheCircuitBreaker?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsCacheCircuitBreaker = this._dnsCacheCircuitBreaker?.internalValue;
    }
    if (this._dnsFailureRefreshRate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsFailureRefreshRate = this._dnsFailureRefreshRate?.internalValue;
    }
    if (this._dnsLookupFamily !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsLookupFamily = this._dnsLookupFamily;
    }
    if (this._dnsQueryTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsQueryTimeout = this._dnsQueryTimeout;
    }
    if (this._dnsRefreshRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsRefreshRate = this._dnsRefreshRate;
    }
    if (this._hostTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostTtl = this._hostTtl;
    }
    if (this._maxHosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxHosts = this._maxHosts;
    }
    if (this._preresolveHostnames?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preresolveHostnames = this._preresolveHostnames?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appleDns = undefined;
      this._caresDns.internalValue = undefined;
      this._dnsCacheCircuitBreaker.internalValue = undefined;
      this._dnsFailureRefreshRate.internalValue = undefined;
      this._dnsLookupFamily = undefined;
      this._dnsQueryTimeout = undefined;
      this._dnsRefreshRate = undefined;
      this._hostTtl = undefined;
      this._maxHosts = undefined;
      this._preresolveHostnames.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appleDns = value.appleDns;
      this._caresDns.internalValue = value.caresDns;
      this._dnsCacheCircuitBreaker.internalValue = value.dnsCacheCircuitBreaker;
      this._dnsFailureRefreshRate.internalValue = value.dnsFailureRefreshRate;
      this._dnsLookupFamily = value.dnsLookupFamily;
      this._dnsQueryTimeout = value.dnsQueryTimeout;
      this._dnsRefreshRate = value.dnsRefreshRate;
      this._hostTtl = value.hostTtl;
      this._maxHosts = value.maxHosts;
      this._preresolveHostnames.internalValue = value.preresolveHostnames;
    }
  }

  // apple_dns - computed: false, optional: true, required: false
  private _appleDns?: { [key: string]: string }; 
  public get appleDns() {
    return this.getStringMapAttribute('apple_dns');
  }
  public set appleDns(value: { [key: string]: string }) {
    this._appleDns = value;
  }
  public resetAppleDns() {
    this._appleDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appleDnsInput() {
    return this._appleDns;
  }

  // cares_dns - computed: false, optional: true, required: false
  private _caresDns = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsOutputReference(this, "cares_dns");
  public get caresDns() {
    return this._caresDns;
  }
  public putCaresDns(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns) {
    this._caresDns.internalValue = value;
  }
  public resetCaresDns() {
    this._caresDns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caresDnsInput() {
    return this._caresDns.internalValue;
  }

  // dns_cache_circuit_breaker - computed: false, optional: true, required: false
  private _dnsCacheCircuitBreaker = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerOutputReference(this, "dns_cache_circuit_breaker");
  public get dnsCacheCircuitBreaker() {
    return this._dnsCacheCircuitBreaker;
  }
  public putDnsCacheCircuitBreaker(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker) {
    this._dnsCacheCircuitBreaker.internalValue = value;
  }
  public resetDnsCacheCircuitBreaker() {
    this._dnsCacheCircuitBreaker.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsCacheCircuitBreakerInput() {
    return this._dnsCacheCircuitBreaker.internalValue;
  }

  // dns_failure_refresh_rate - computed: false, optional: true, required: false
  private _dnsFailureRefreshRate = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateOutputReference(this, "dns_failure_refresh_rate");
  public get dnsFailureRefreshRate() {
    return this._dnsFailureRefreshRate;
  }
  public putDnsFailureRefreshRate(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate) {
    this._dnsFailureRefreshRate.internalValue = value;
  }
  public resetDnsFailureRefreshRate() {
    this._dnsFailureRefreshRate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsFailureRefreshRateInput() {
    return this._dnsFailureRefreshRate.internalValue;
  }

  // dns_lookup_family - computed: false, optional: true, required: false
  private _dnsLookupFamily?: string; 
  public get dnsLookupFamily() {
    return this.getStringAttribute('dns_lookup_family');
  }
  public set dnsLookupFamily(value: string) {
    this._dnsLookupFamily = value;
  }
  public resetDnsLookupFamily() {
    this._dnsLookupFamily = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsLookupFamilyInput() {
    return this._dnsLookupFamily;
  }

  // dns_query_timeout - computed: false, optional: true, required: false
  private _dnsQueryTimeout?: string; 
  public get dnsQueryTimeout() {
    return this.getStringAttribute('dns_query_timeout');
  }
  public set dnsQueryTimeout(value: string) {
    this._dnsQueryTimeout = value;
  }
  public resetDnsQueryTimeout() {
    this._dnsQueryTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsQueryTimeoutInput() {
    return this._dnsQueryTimeout;
  }

  // dns_refresh_rate - computed: false, optional: true, required: false
  private _dnsRefreshRate?: string; 
  public get dnsRefreshRate() {
    return this.getStringAttribute('dns_refresh_rate');
  }
  public set dnsRefreshRate(value: string) {
    this._dnsRefreshRate = value;
  }
  public resetDnsRefreshRate() {
    this._dnsRefreshRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsRefreshRateInput() {
    return this._dnsRefreshRate;
  }

  // host_ttl - computed: false, optional: true, required: false
  private _hostTtl?: string; 
  public get hostTtl() {
    return this.getStringAttribute('host_ttl');
  }
  public set hostTtl(value: string) {
    this._hostTtl = value;
  }
  public resetHostTtl() {
    this._hostTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostTtlInput() {
    return this._hostTtl;
  }

  // max_hosts - computed: false, optional: true, required: false
  private _maxHosts?: number; 
  public get maxHosts() {
    return this.getNumberAttribute('max_hosts');
  }
  public set maxHosts(value: number) {
    this._maxHosts = value;
  }
  public resetMaxHosts() {
    this._maxHosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxHostsInput() {
    return this._maxHosts;
  }

  // preresolve_hostnames - computed: false, optional: true, required: false
  private _preresolveHostnames = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesList(this, "preresolve_hostnames", false);
  public get preresolveHostnames() {
    return this._preresolveHostnames;
  }
  public putPreresolveHostnames(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames[] | cdktf.IResolvable) {
    this._preresolveHostnames.internalValue = value;
  }
  public resetPreresolveHostnames() {
    this._preresolveHostnames.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preresolveHostnamesInput() {
    return this._preresolveHostnames.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cipher_suites DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ecdh_curves DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ecdh_curves}
  */
  readonly ecdhCurves?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#maximum_protocol_version DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#maximum_protocol_version}
  */
  readonly maximumProtocolVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#minimum_protocol_version DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#minimum_protocol_version}
  */
  readonly minimumProtocolVersion?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParametersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    ecdh_curves: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ecdhCurves),
    maximum_protocol_version: cdktf.stringToTerraform(struct!.maximumProtocolVersion),
    minimum_protocol_version: cdktf.stringToTerraform(struct!.minimumProtocolVersion),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParametersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ecdh_curves: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ecdhCurves),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    maximum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maximumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    minimum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minimumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._ecdhCurves !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecdhCurves = this._ecdhCurves;
    }
    if (this._maximumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumProtocolVersion = this._maximumProtocolVersion;
    }
    if (this._minimumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumProtocolVersion = this._minimumProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cipherSuites = undefined;
      this._ecdhCurves = undefined;
      this._maximumProtocolVersion = undefined;
      this._minimumProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cipherSuites = value.cipherSuites;
      this._ecdhCurves = value.ecdhCurves;
      this._maximumProtocolVersion = value.maximumProtocolVersion;
      this._minimumProtocolVersion = value.minimumProtocolVersion;
    }
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // ecdh_curves - computed: false, optional: true, required: false
  private _ecdhCurves?: string[]; 
  public get ecdhCurves() {
    return this.getListAttribute('ecdh_curves');
  }
  public set ecdhCurves(value: string[]) {
    this._ecdhCurves = value;
  }
  public resetEcdhCurves() {
    this._ecdhCurves = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecdhCurvesInput() {
    return this._ecdhCurves;
  }

  // maximum_protocol_version - computed: false, optional: true, required: false
  private _maximumProtocolVersion?: string; 
  public get maximumProtocolVersion() {
    return this.getStringAttribute('maximum_protocol_version');
  }
  public set maximumProtocolVersion(value: string) {
    this._maximumProtocolVersion = value;
  }
  public resetMaximumProtocolVersion() {
    this._maximumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumProtocolVersionInput() {
    return this._maximumProtocolVersion;
  }

  // minimum_protocol_version - computed: false, optional: true, required: false
  private _minimumProtocolVersion?: string; 
  public get minimumProtocolVersion() {
    return this.getStringAttribute('minimum_protocol_version');
  }
  public set minimumProtocolVersion(value: string) {
    this._minimumProtocolVersion = value;
  }
  public resetMinimumProtocolVersion() {
    this._minimumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumProtocolVersionInput() {
    return this._minimumProtocolVersion;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#header DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#token_file_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#token_file_name}
  */
  readonly tokenFileName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    token_file_name: cdktf.stringToTerraform(struct!.tokenFileName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_file_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._tokenFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenFileName = this._tokenFileName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._tokenFileName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._tokenFileName = value.tokenFileName;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // token_file_name - computed: false, optional: true, required: false
  private _tokenFileName?: string; 
  public get tokenFileName() {
    return this.getStringAttribute('token_file_name');
  }
  public set tokenFileName(value: string) {
    this._tokenFileName = value;
  }
  public resetTokenFileName() {
    this._tokenFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenFileNameInput() {
    return this._tokenFileName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#file_credential_source DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#file_credential_source}
  */
  readonly fileCredentialSource?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file_credential_source: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct!.fileCredentialSource),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file_credential_source: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct!.fileCredentialSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fileCredentialSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileCredentialSource = this._fileCredentialSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = value.fileCredentialSource;
    }
  }

  // file_credential_source - computed: false, optional: true, required: false
  private _fileCredentialSource = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceOutputReference(this, "file_credential_source");
  public get fileCredentialSource() {
    return this._fileCredentialSource;
  }
  public putFileCredentialSource(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource) {
    this._fileCredentialSource.internalValue = value;
  }
  public resetFileCredentialSource() {
    this._fileCredentialSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileCredentialSourceInput() {
    return this._fileCredentialSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#call_credentials DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#call_credentials}
  */
  readonly callCredentials?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#certificates_secret_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#certificates_secret_name}
  */
  readonly certificatesSecretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#target_uri DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#target_uri}
  */
  readonly targetUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#validation_context_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#validation_context_name}
  */
  readonly validationContextName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    call_credentials: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToTerraform(struct!.callCredentials),
    certificates_secret_name: cdktf.stringToTerraform(struct!.certificatesSecretName),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
    validation_context_name: cdktf.stringToTerraform(struct!.validationContextName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    call_credentials: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToHclTerraform(struct!.callCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials",
    },
    certificates_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.certificatesSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validation_context_name: {
      value: cdktf.stringToHclTerraform(struct!.validationContextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._callCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.callCredentials = this._callCredentials?.internalValue;
    }
    if (this._certificatesSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesSecretName = this._certificatesSecretName;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    if (this._validationContextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationContextName = this._validationContextName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = undefined;
      this._certificatesSecretName = undefined;
      this._clusterName = undefined;
      this._targetUri = undefined;
      this._validationContextName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = value.callCredentials;
      this._certificatesSecretName = value.certificatesSecretName;
      this._clusterName = value.clusterName;
      this._targetUri = value.targetUri;
      this._validationContextName = value.validationContextName;
    }
  }

  // call_credentials - computed: false, optional: true, required: false
  private _callCredentials = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsOutputReference(this, "call_credentials");
  public get callCredentials() {
    return this._callCredentials;
  }
  public putCallCredentials(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials) {
    this._callCredentials.internalValue = value;
  }
  public resetCallCredentials() {
    this._callCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callCredentialsInput() {
    return this._callCredentials.internalValue;
  }

  // certificates_secret_name - computed: false, optional: true, required: false
  private _certificatesSecretName?: string; 
  public get certificatesSecretName() {
    return this.getStringAttribute('certificates_secret_name');
  }
  public set certificatesSecretName(value: string) {
    this._certificatesSecretName = value;
  }
  public resetCertificatesSecretName() {
    this._certificatesSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesSecretNameInput() {
    return this._certificatesSecretName;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }

  // validation_context_name - computed: false, optional: true, required: false
  private _validationContextName?: string; 
  public get validationContextName() {
    return this.getStringAttribute('validation_context_name');
  }
  public set validationContextName(value: string) {
    this._validationContextName = value;
  }
  public resetValidationContextName() {
    this._validationContextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationContextNameInput() {
    return this._validationContextName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ocsp_staple DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#root_ca DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tls_cert DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tls_key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_renegotiation DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_renegotiation}
  */
  readonly allowRenegotiation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#alpn_protocols DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#one_way_tls DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#parameters DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sds DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sds}
  */
  readonly sds?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#secret_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sni DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ssl_files DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#verify_subject_alt_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_renegotiation: cdktf.booleanToTerraform(struct!.allowRenegotiation),
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToTerraform(struct!.secretRef),
    sni: cdktf.stringToTerraform(struct!.sni),
    ssl_files: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToTerraform(struct!.sslFiles),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_renegotiation: {
      value: cdktf.booleanToHclTerraform(struct!.allowRenegotiation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters",
    },
    sds: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_files: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowRenegotiation !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRenegotiation = this._allowRenegotiation;
    }
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowRenegotiation = undefined;
      this._alpnProtocols = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sni = undefined;
      this._sslFiles.internalValue = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowRenegotiation = value.allowRenegotiation;
      this._alpnProtocols = value.alpnProtocols;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sni = value.sni;
      this._sslFiles.internalValue = value.sslFiles;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // allow_renegotiation - computed: false, optional: true, required: false
  private _allowRenegotiation?: boolean | cdktf.IResolvable; 
  public get allowRenegotiation() {
    return this.getBooleanAttribute('allow_renegotiation');
  }
  public set allowRenegotiation(value: boolean | cdktf.IResolvable) {
    this._allowRenegotiation = value;
  }
  public resetAllowRenegotiation() {
    this._allowRenegotiation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRenegotiationInput() {
    return this._allowRenegotiation;
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns_cache_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns_cache_config}
  */
  readonly dnsCacheConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#save_upstream_address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#save_upstream_address}
  */
  readonly saveUpstreamAddress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ssl_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ssl_config}
  */
  readonly sslConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dns_cache_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToTerraform(struct!.dnsCacheConfig),
    save_upstream_address: cdktf.booleanToTerraform(struct!.saveUpstreamAddress),
    ssl_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigToTerraform(struct!.sslConfig),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dns_cache_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToHclTerraform(struct!.dnsCacheConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig",
    },
    save_upstream_address: {
      value: cdktf.booleanToHclTerraform(struct!.saveUpstreamAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ssl_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigToHclTerraform(struct!.sslConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dnsCacheConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsCacheConfig = this._dnsCacheConfig?.internalValue;
    }
    if (this._saveUpstreamAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.saveUpstreamAddress = this._saveUpstreamAddress;
    }
    if (this._sslConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslConfig = this._sslConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dnsCacheConfig.internalValue = undefined;
      this._saveUpstreamAddress = undefined;
      this._sslConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dnsCacheConfig.internalValue = value.dnsCacheConfig;
      this._saveUpstreamAddress = value.saveUpstreamAddress;
      this._sslConfig.internalValue = value.sslConfig;
    }
  }

  // dns_cache_config - computed: false, optional: true, required: false
  private _dnsCacheConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigOutputReference(this, "dns_cache_config");
  public get dnsCacheConfig() {
    return this._dnsCacheConfig;
  }
  public putDnsCacheConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig) {
    this._dnsCacheConfig.internalValue = value;
  }
  public resetDnsCacheConfig() {
    this._dnsCacheConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsCacheConfigInput() {
    return this._dnsCacheConfig.internalValue;
  }

  // save_upstream_address - computed: false, optional: true, required: false
  private _saveUpstreamAddress?: boolean | cdktf.IResolvable; 
  public get saveUpstreamAddress() {
    return this.getBooleanAttribute('save_upstream_address');
  }
  public set saveUpstreamAddress(value: boolean | cdktf.IResolvable) {
    this._saveUpstreamAddress = value;
  }
  public resetSaveUpstreamAddress() {
    this._saveUpstreamAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saveUpstreamAddressInput() {
    return this._saveUpstreamAddress;
  }

  // ssl_config - computed: false, optional: true, required: false
  private _sslConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfigOutputReference(this, "ssl_config");
  public get sslConfig() {
    return this._sslConfig;
  }
  public putSslConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxySslConfig) {
    this._sslConfig.internalValue = value;
  }
  public resetSslConfig() {
    this._sslConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslConfigInput() {
    return this._sslConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#predicate DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#predicate}
  */
  readonly predicate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stage}
  */
  readonly stage?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStageToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    predicate: cdktf.stringToTerraform(struct!.predicate),
    stage: cdktf.stringToTerraform(struct!.stage),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStageToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    predicate: {
      value: cdktf.stringToHclTerraform(struct!.predicate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage: {
      value: cdktf.stringToHclTerraform(struct!.stage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._predicate !== undefined) {
      hasAnyValues = true;
      internalValueResult.predicate = this._predicate;
    }
    if (this._stage !== undefined) {
      hasAnyValues = true;
      internalValueResult.stage = this._stage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._predicate = undefined;
      this._stage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._predicate = value.predicate;
      this._stage = value.stage;
    }
  }

  // predicate - computed: false, optional: true, required: false
  private _predicate?: string; 
  public get predicate() {
    return this.getStringAttribute('predicate');
  }
  public set predicate(value: string) {
    this._predicate = value;
  }
  public resetPredicate() {
    this._predicate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get predicateInput() {
    return this._predicate;
  }

  // stage - computed: false, optional: true, required: false
  private _stage?: string; 
  public get stage() {
    return this.getStringAttribute('stage');
  }
  public set stage(value: string) {
    this._stage = value;
  }
  public resetStage() {
    this._stage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stageInput() {
    return this._stage;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#exact DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#suffix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#patterns DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#patterns}
  */
  readonly patterns?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    patterns: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToTerraform, false)(struct!.patterns),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    patterns: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToHclTerraform, false)(struct!.patterns),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._patterns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patterns = this._patterns?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._patterns.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._patterns.internalValue = value.patterns;
    }
  }

  // patterns - computed: false, optional: true, required: false
  private _patterns = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsList(this, "patterns", false);
  public get patterns() {
    return this._patterns;
  }
  public putPatterns(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns[] | cdktf.IResolvable) {
    this._patterns.internalValue = value;
  }
  public resetPatterns() {
    this._patterns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternsInput() {
    return this._patterns.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#exact DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#suffix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#patterns DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#patterns}
  */
  readonly patterns?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    patterns: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToTerraform, false)(struct!.patterns),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    patterns: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToHclTerraform, false)(struct!.patterns),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._patterns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patterns = this._patterns?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._patterns.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._patterns.internalValue = value.patterns;
    }
  }

  // patterns - computed: false, optional: true, required: false
  private _patterns = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsList(this, "patterns", false);
  public get patterns() {
    return this._patterns;
  }
  public putPatterns(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns[] | cdktf.IResolvable) {
    this._patterns.internalValue = value;
  }
  public resetPatterns() {
    this._patterns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternsInput() {
    return this._patterns.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_headers}
  */
  readonly allowedHeaders?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disallowed_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disallowed_headers}
  */
  readonly disallowedHeaders?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_headers: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToTerraform(struct!.allowedHeaders),
    disallowed_headers: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToTerraform(struct!.disallowedHeaders),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_headers: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToHclTerraform(struct!.allowedHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders",
    },
    disallowed_headers: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToHclTerraform(struct!.disallowedHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedHeaders = this._allowedHeaders?.internalValue;
    }
    if (this._disallowedHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowedHeaders = this._disallowedHeaders?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedHeaders.internalValue = undefined;
      this._disallowedHeaders.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedHeaders.internalValue = value.allowedHeaders;
      this._disallowedHeaders.internalValue = value.disallowedHeaders;
    }
  }

  // allowed_headers - computed: false, optional: true, required: false
  private _allowedHeaders = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeadersOutputReference(this, "allowed_headers");
  public get allowedHeaders() {
    return this._allowedHeaders;
  }
  public putAllowedHeaders(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesAllowedHeaders) {
    this._allowedHeaders.internalValue = value;
  }
  public resetAllowedHeaders() {
    this._allowedHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedHeadersInput() {
    return this._allowedHeaders.internalValue;
  }

  // disallowed_headers - computed: false, optional: true, required: false
  private _disallowedHeaders = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersOutputReference(this, "disallowed_headers");
  public get disallowedHeaders() {
    return this._disallowedHeaders;
  }
  public putDisallowedHeaders(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders) {
    this._disallowedHeaders.internalValue = value;
  }
  public resetDisallowedHeaders() {
    this._disallowedHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowedHeadersInput() {
    return this._disallowedHeaders.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#base_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#base_interval}
  */
  readonly baseInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_interval}
  */
  readonly maxInterval?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_interval: cdktf.stringToTerraform(struct!.baseInterval),
    max_interval: cdktf.stringToTerraform(struct!.maxInterval),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_interval: {
      value: cdktf.stringToHclTerraform(struct!.baseInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_interval: {
      value: cdktf.stringToHclTerraform(struct!.maxInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseInterval = this._baseInterval;
    }
    if (this._maxInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInterval = this._maxInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseInterval = undefined;
      this._maxInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseInterval = value.baseInterval;
      this._maxInterval = value.maxInterval;
    }
  }

  // base_interval - computed: false, optional: true, required: false
  private _baseInterval?: string; 
  public get baseInterval() {
    return this.getStringAttribute('base_interval');
  }
  public set baseInterval(value: string) {
    this._baseInterval = value;
  }
  public resetBaseInterval() {
    this._baseInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseIntervalInput() {
    return this._baseInterval;
  }

  // max_interval - computed: false, optional: true, required: false
  private _maxInterval?: string; 
  public get maxInterval() {
    return this.getStringAttribute('max_interval');
  }
  public set maxInterval(value: string) {
    this._maxInterval = value;
  }
  public resetMaxInterval() {
    this._maxInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIntervalInput() {
    return this._maxInterval;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#num_retries DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#num_retries}
  */
  readonly numRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#retry_back_off DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#retry_back_off}
  */
  readonly retryBackOff?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    num_retries: cdktf.numberToTerraform(struct!.numRetries),
    retry_back_off: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToTerraform(struct!.retryBackOff),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    num_retries: {
      value: cdktf.numberToHclTerraform(struct!.numRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_back_off: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct!.retryBackOff),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._numRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.numRetries = this._numRetries;
    }
    if (this._retryBackOff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryBackOff = this._retryBackOff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._numRetries = undefined;
      this._retryBackOff.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._numRetries = value.numRetries;
      this._retryBackOff.internalValue = value.retryBackOff;
    }
  }

  // num_retries - computed: false, optional: true, required: false
  private _numRetries?: number; 
  public get numRetries() {
    return this.getNumberAttribute('num_retries');
  }
  public set numRetries(value: number) {
    this._numRetries = value;
  }
  public resetNumRetries() {
    this._numRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numRetriesInput() {
    return this._numRetries;
  }

  // retry_back_off - computed: false, optional: true, required: false
  private _retryBackOff = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffOutputReference(this, "retry_back_off");
  public get retryBackOff() {
    return this._retryBackOff;
  }
  public putRetryBackOff(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff) {
    this._retryBackOff.internalValue = value;
  }
  public resetRetryBackOff() {
    this._retryBackOff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryBackOffInput() {
    return this._retryBackOff.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#authority DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#authority}
  */
  readonly authority?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ext_proc_server_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ext_proc_server_ref}
  */
  readonly extProcServerRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#initial_metadata DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#initial_metadata}
  */
  readonly initialMetadata?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#retry_policy DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#retry_policy}
  */
  readonly retryPolicy?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
    ext_proc_server_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToTerraform(struct!.extProcServerRef),
    initial_metadata: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToTerraform, false)(struct!.initialMetadata),
    retry_policy: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToTerraform(struct!.retryPolicy),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ext_proc_server_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToHclTerraform(struct!.extProcServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef",
    },
    initial_metadata: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToHclTerraform, false)(struct!.initialMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataList",
    },
    retry_policy: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToHclTerraform(struct!.retryPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    if (this._extProcServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extProcServerRef = this._extProcServerRef?.internalValue;
    }
    if (this._initialMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialMetadata = this._initialMetadata?.internalValue;
    }
    if (this._retryPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryPolicy = this._retryPolicy?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
      this._extProcServerRef.internalValue = undefined;
      this._initialMetadata.internalValue = undefined;
      this._retryPolicy.internalValue = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
      this._extProcServerRef.internalValue = value.extProcServerRef;
      this._initialMetadata.internalValue = value.initialMetadata;
      this._retryPolicy.internalValue = value.retryPolicy;
      this._timeout = value.timeout;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }

  // ext_proc_server_ref - computed: false, optional: true, required: false
  private _extProcServerRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefOutputReference(this, "ext_proc_server_ref");
  public get extProcServerRef() {
    return this._extProcServerRef;
  }
  public putExtProcServerRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef) {
    this._extProcServerRef.internalValue = value;
  }
  public resetExtProcServerRef() {
    this._extProcServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extProcServerRefInput() {
    return this._extProcServerRef.internalValue;
  }

  // initial_metadata - computed: false, optional: true, required: false
  private _initialMetadata = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadataList(this, "initial_metadata", false);
  public get initialMetadata() {
    return this._initialMetadata;
  }
  public putInitialMetadata(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceInitialMetadata[] | cdktf.IResolvable) {
    this._initialMetadata.internalValue = value;
  }
  public resetInitialMetadata() {
    this._initialMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialMetadataInput() {
    return this._initialMetadata.internalValue;
  }

  // retry_policy - computed: false, optional: true, required: false
  private _retryPolicy = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicyOutputReference(this, "retry_policy");
  public get retryPolicy() {
    return this._retryPolicy;
  }
  public putRetryPolicy(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceRetryPolicy) {
    this._retryPolicy.internalValue = value;
  }
  public resetRetryPolicy() {
    this._retryPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryPolicyInput() {
    return this._retryPolicy.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_all_routing DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_all_routing}
  */
  readonly allowAllRouting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_envoy DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_envoy}
  */
  readonly allowEnvoy?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_expression DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_expression}
  */
  readonly allowExpression?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disallow_all DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disallow_all}
  */
  readonly disallowAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disallow_expression DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disallow_expression}
  */
  readonly disallowExpression?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disallow_is_error DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disallow_is_error}
  */
  readonly disallowIsError?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disallow_system DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disallow_system}
  */
  readonly disallowSystem?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_all_routing: cdktf.booleanToTerraform(struct!.allowAllRouting),
    allow_envoy: cdktf.booleanToTerraform(struct!.allowEnvoy),
    allow_expression: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionToTerraform(struct!.allowExpression),
    disallow_all: cdktf.booleanToTerraform(struct!.disallowAll),
    disallow_expression: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToTerraform(struct!.disallowExpression),
    disallow_is_error: cdktf.booleanToTerraform(struct!.disallowIsError),
    disallow_system: cdktf.booleanToTerraform(struct!.disallowSystem),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_all_routing: {
      value: cdktf.booleanToHclTerraform(struct!.allowAllRouting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_envoy: {
      value: cdktf.booleanToHclTerraform(struct!.allowEnvoy),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_expression: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionToHclTerraform(struct!.allowExpression),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression",
    },
    disallow_all: {
      value: cdktf.booleanToHclTerraform(struct!.disallowAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disallow_expression: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToHclTerraform(struct!.disallowExpression),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression",
    },
    disallow_is_error: {
      value: cdktf.booleanToHclTerraform(struct!.disallowIsError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disallow_system: {
      value: cdktf.booleanToHclTerraform(struct!.disallowSystem),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowAllRouting !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowAllRouting = this._allowAllRouting;
    }
    if (this._allowEnvoy !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowEnvoy = this._allowEnvoy;
    }
    if (this._allowExpression?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowExpression = this._allowExpression?.internalValue;
    }
    if (this._disallowAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowAll = this._disallowAll;
    }
    if (this._disallowExpression?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowExpression = this._disallowExpression?.internalValue;
    }
    if (this._disallowIsError !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowIsError = this._disallowIsError;
    }
    if (this._disallowSystem !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowSystem = this._disallowSystem;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowAllRouting = undefined;
      this._allowEnvoy = undefined;
      this._allowExpression.internalValue = undefined;
      this._disallowAll = undefined;
      this._disallowExpression.internalValue = undefined;
      this._disallowIsError = undefined;
      this._disallowSystem = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowAllRouting = value.allowAllRouting;
      this._allowEnvoy = value.allowEnvoy;
      this._allowExpression.internalValue = value.allowExpression;
      this._disallowAll = value.disallowAll;
      this._disallowExpression.internalValue = value.disallowExpression;
      this._disallowIsError = value.disallowIsError;
      this._disallowSystem = value.disallowSystem;
    }
  }

  // allow_all_routing - computed: false, optional: true, required: false
  private _allowAllRouting?: boolean | cdktf.IResolvable; 
  public get allowAllRouting() {
    return this.getBooleanAttribute('allow_all_routing');
  }
  public set allowAllRouting(value: boolean | cdktf.IResolvable) {
    this._allowAllRouting = value;
  }
  public resetAllowAllRouting() {
    this._allowAllRouting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowAllRoutingInput() {
    return this._allowAllRouting;
  }

  // allow_envoy - computed: false, optional: true, required: false
  private _allowEnvoy?: boolean | cdktf.IResolvable; 
  public get allowEnvoy() {
    return this.getBooleanAttribute('allow_envoy');
  }
  public set allowEnvoy(value: boolean | cdktf.IResolvable) {
    this._allowEnvoy = value;
  }
  public resetAllowEnvoy() {
    this._allowEnvoy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowEnvoyInput() {
    return this._allowEnvoy;
  }

  // allow_expression - computed: false, optional: true, required: false
  private _allowExpression = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpressionOutputReference(this, "allow_expression");
  public get allowExpression() {
    return this._allowExpression;
  }
  public putAllowExpression(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesAllowExpression) {
    this._allowExpression.internalValue = value;
  }
  public resetAllowExpression() {
    this._allowExpression.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowExpressionInput() {
    return this._allowExpression.internalValue;
  }

  // disallow_all - computed: false, optional: true, required: false
  private _disallowAll?: boolean | cdktf.IResolvable; 
  public get disallowAll() {
    return this.getBooleanAttribute('disallow_all');
  }
  public set disallowAll(value: boolean | cdktf.IResolvable) {
    this._disallowAll = value;
  }
  public resetDisallowAll() {
    this._disallowAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowAllInput() {
    return this._disallowAll;
  }

  // disallow_expression - computed: false, optional: true, required: false
  private _disallowExpression = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpressionOutputReference(this, "disallow_expression");
  public get disallowExpression() {
    return this._disallowExpression;
  }
  public putDisallowExpression(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesDisallowExpression) {
    this._disallowExpression.internalValue = value;
  }
  public resetDisallowExpression() {
    this._disallowExpression.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowExpressionInput() {
    return this._disallowExpression.internalValue;
  }

  // disallow_is_error - computed: false, optional: true, required: false
  private _disallowIsError?: boolean | cdktf.IResolvable; 
  public get disallowIsError() {
    return this.getBooleanAttribute('disallow_is_error');
  }
  public set disallowIsError(value: boolean | cdktf.IResolvable) {
    this._disallowIsError = value;
  }
  public resetDisallowIsError() {
    this._disallowIsError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowIsErrorInput() {
    return this._disallowIsError;
  }

  // disallow_system - computed: false, optional: true, required: false
  private _disallowSystem?: boolean | cdktf.IResolvable; 
  public get disallowSystem() {
    return this.getBooleanAttribute('disallow_system');
  }
  public set disallowSystem(value: boolean | cdktf.IResolvable) {
    this._disallowSystem = value;
  }
  public resetDisallowSystem() {
    this._disallowSystem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowSystemInput() {
    return this._disallowSystem;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_body_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_body_mode}
  */
  readonly requestBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_header_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_header_mode}
  */
  readonly requestHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_trailer_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_trailer_mode}
  */
  readonly requestTrailerMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response_body_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response_body_mode}
  */
  readonly responseBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response_header_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response_header_mode}
  */
  readonly responseHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response_trailer_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response_trailer_mode}
  */
  readonly responseTrailerMode?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingModeToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_body_mode: cdktf.stringToTerraform(struct!.requestBodyMode),
    request_header_mode: cdktf.stringToTerraform(struct!.requestHeaderMode),
    request_trailer_mode: cdktf.stringToTerraform(struct!.requestTrailerMode),
    response_body_mode: cdktf.stringToTerraform(struct!.responseBodyMode),
    response_header_mode: cdktf.stringToTerraform(struct!.responseHeaderMode),
    response_trailer_mode: cdktf.stringToTerraform(struct!.responseTrailerMode),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingModeToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestBodyMode = this._requestBodyMode;
    }
    if (this._requestHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaderMode = this._requestHeaderMode;
    }
    if (this._requestTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTrailerMode = this._requestTrailerMode;
    }
    if (this._responseBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseBodyMode = this._responseBodyMode;
    }
    if (this._responseHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeaderMode = this._responseHeaderMode;
    }
    if (this._responseTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTrailerMode = this._responseTrailerMode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestBodyMode = undefined;
      this._requestHeaderMode = undefined;
      this._requestTrailerMode = undefined;
      this._responseBodyMode = undefined;
      this._responseHeaderMode = undefined;
      this._responseTrailerMode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestBodyMode = value.requestBodyMode;
      this._requestHeaderMode = value.requestHeaderMode;
      this._requestTrailerMode = value.requestTrailerMode;
      this._responseBodyMode = value.responseBodyMode;
      this._responseHeaderMode = value.responseHeaderMode;
      this._responseTrailerMode = value.responseTrailerMode;
    }
  }

  // request_body_mode - computed: false, optional: true, required: false
  private _requestBodyMode?: string; 
  public get requestBodyMode() {
    return this.getStringAttribute('request_body_mode');
  }
  public set requestBodyMode(value: string) {
    this._requestBodyMode = value;
  }
  public resetRequestBodyMode() {
    this._requestBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestBodyModeInput() {
    return this._requestBodyMode;
  }

  // request_header_mode - computed: false, optional: true, required: false
  private _requestHeaderMode?: string; 
  public get requestHeaderMode() {
    return this.getStringAttribute('request_header_mode');
  }
  public set requestHeaderMode(value: string) {
    this._requestHeaderMode = value;
  }
  public resetRequestHeaderMode() {
    this._requestHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeaderModeInput() {
    return this._requestHeaderMode;
  }

  // request_trailer_mode - computed: false, optional: true, required: false
  private _requestTrailerMode?: string; 
  public get requestTrailerMode() {
    return this.getStringAttribute('request_trailer_mode');
  }
  public set requestTrailerMode(value: string) {
    this._requestTrailerMode = value;
  }
  public resetRequestTrailerMode() {
    this._requestTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTrailerModeInput() {
    return this._requestTrailerMode;
  }

  // response_body_mode - computed: false, optional: true, required: false
  private _responseBodyMode?: string; 
  public get responseBodyMode() {
    return this.getStringAttribute('response_body_mode');
  }
  public set responseBodyMode(value: string) {
    this._responseBodyMode = value;
  }
  public resetResponseBodyMode() {
    this._responseBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseBodyModeInput() {
    return this._responseBodyMode;
  }

  // response_header_mode - computed: false, optional: true, required: false
  private _responseHeaderMode?: string; 
  public get responseHeaderMode() {
    return this.getStringAttribute('response_header_mode');
  }
  public set responseHeaderMode(value: string) {
    this._responseHeaderMode = value;
  }
  public resetResponseHeaderMode() {
    this._responseHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeaderModeInput() {
    return this._responseHeaderMode;
  }

  // response_trailer_mode - computed: false, optional: true, required: false
  private _responseTrailerMode?: string; 
  public get responseTrailerMode() {
    return this.getStringAttribute('response_trailer_mode');
  }
  public set responseTrailerMode(value: string) {
    this._responseTrailerMode = value;
  }
  public resetResponseTrailerMode() {
    this._responseTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTrailerModeInput() {
    return this._responseTrailerMode;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_mode_override DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_mode_override}
  */
  readonly allowModeOverride?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#async_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#async_mode}
  */
  readonly asyncMode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disable_clear_route_cache DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disable_clear_route_cache}
  */
  readonly disableClearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#failure_mode_allow DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#failure_mode_allow}
  */
  readonly failureModeAllow?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#filter_metadata DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#filter_metadata}
  */
  readonly filterMetadata?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#filter_stage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#filter_stage}
  */
  readonly filterStage?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#forward_rules DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#forward_rules}
  */
  readonly forwardRules?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_message_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_message_timeout}
  */
  readonly maxMessageTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#message_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#message_timeout}
  */
  readonly messageTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#metadata_context_namespaces DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#metadata_context_namespaces}
  */
  readonly metadataContextNamespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#mutation_rules DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#mutation_rules}
  */
  readonly mutationRules?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#processing_mode DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#processing_mode}
  */
  readonly processingMode?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_attributes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_attributes}
  */
  readonly requestAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response_attributes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response_attributes}
  */
  readonly responseAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stat_prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stat_prefix}
  */
  readonly statPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#typed_metadata_context_namespaces DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#typed_metadata_context_namespaces}
  */
  readonly typedMetadataContextNamespaces?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_mode_override: cdktf.booleanToTerraform(struct!.allowModeOverride),
    async_mode: cdktf.booleanToTerraform(struct!.asyncMode),
    disable_clear_route_cache: cdktf.booleanToTerraform(struct!.disableClearRouteCache),
    failure_mode_allow: cdktf.booleanToTerraform(struct!.failureModeAllow),
    filter_metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.filterMetadata),
    filter_stage: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStageToTerraform(struct!.filterStage),
    forward_rules: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesToTerraform(struct!.forwardRules),
    grpc_service: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceToTerraform(struct!.grpcService),
    max_message_timeout: cdktf.stringToTerraform(struct!.maxMessageTimeout),
    message_timeout: cdktf.stringToTerraform(struct!.messageTimeout),
    metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metadataContextNamespaces),
    mutation_rules: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesToTerraform(struct!.mutationRules),
    processing_mode: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingModeToTerraform(struct!.processingMode),
    request_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestAttributes),
    response_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseAttributes),
    stat_prefix: cdktf.stringToTerraform(struct!.statPrefix),
    typed_metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.typedMetadataContextNamespaces),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_mode_override: {
      value: cdktf.booleanToHclTerraform(struct!.allowModeOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    async_mode: {
      value: cdktf.booleanToHclTerraform(struct!.asyncMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.disableClearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    failure_mode_allow: {
      value: cdktf.booleanToHclTerraform(struct!.failureModeAllow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    filter_metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.filterMetadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    filter_stage: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStageToHclTerraform(struct!.filterStage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage",
    },
    forward_rules: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesToHclTerraform(struct!.forwardRules),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService",
    },
    max_message_timeout: {
      value: cdktf.stringToHclTerraform(struct!.maxMessageTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_timeout: {
      value: cdktf.stringToHclTerraform(struct!.messageTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mutation_rules: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesToHclTerraform(struct!.mutationRules),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules",
    },
    processing_mode: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingModeToHclTerraform(struct!.processingMode),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode",
    },
    request_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    stat_prefix: {
      value: cdktf.stringToHclTerraform(struct!.statPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    typed_metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.typedMetadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowModeOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowModeOverride = this._allowModeOverride;
    }
    if (this._asyncMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncMode = this._asyncMode;
    }
    if (this._disableClearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableClearRouteCache = this._disableClearRouteCache;
    }
    if (this._failureModeAllow !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureModeAllow = this._failureModeAllow;
    }
    if (this._filterMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterMetadata = this._filterMetadata;
    }
    if (this._filterStage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterStage = this._filterStage?.internalValue;
    }
    if (this._forwardRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardRules = this._forwardRules?.internalValue;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._maxMessageTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessageTimeout = this._maxMessageTimeout;
    }
    if (this._messageTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageTimeout = this._messageTimeout;
    }
    if (this._metadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataContextNamespaces = this._metadataContextNamespaces;
    }
    if (this._mutationRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mutationRules = this._mutationRules?.internalValue;
    }
    if (this._processingMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processingMode = this._processingMode?.internalValue;
    }
    if (this._requestAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestAttributes = this._requestAttributes;
    }
    if (this._responseAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseAttributes = this._responseAttributes;
    }
    if (this._statPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.statPrefix = this._statPrefix;
    }
    if (this._typedMetadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.typedMetadataContextNamespaces = this._typedMetadataContextNamespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowModeOverride = undefined;
      this._asyncMode = undefined;
      this._disableClearRouteCache = undefined;
      this._failureModeAllow = undefined;
      this._filterMetadata = undefined;
      this._filterStage.internalValue = undefined;
      this._forwardRules.internalValue = undefined;
      this._grpcService.internalValue = undefined;
      this._maxMessageTimeout = undefined;
      this._messageTimeout = undefined;
      this._metadataContextNamespaces = undefined;
      this._mutationRules.internalValue = undefined;
      this._processingMode.internalValue = undefined;
      this._requestAttributes = undefined;
      this._responseAttributes = undefined;
      this._statPrefix = undefined;
      this._typedMetadataContextNamespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowModeOverride = value.allowModeOverride;
      this._asyncMode = value.asyncMode;
      this._disableClearRouteCache = value.disableClearRouteCache;
      this._failureModeAllow = value.failureModeAllow;
      this._filterMetadata = value.filterMetadata;
      this._filterStage.internalValue = value.filterStage;
      this._forwardRules.internalValue = value.forwardRules;
      this._grpcService.internalValue = value.grpcService;
      this._maxMessageTimeout = value.maxMessageTimeout;
      this._messageTimeout = value.messageTimeout;
      this._metadataContextNamespaces = value.metadataContextNamespaces;
      this._mutationRules.internalValue = value.mutationRules;
      this._processingMode.internalValue = value.processingMode;
      this._requestAttributes = value.requestAttributes;
      this._responseAttributes = value.responseAttributes;
      this._statPrefix = value.statPrefix;
      this._typedMetadataContextNamespaces = value.typedMetadataContextNamespaces;
    }
  }

  // allow_mode_override - computed: false, optional: true, required: false
  private _allowModeOverride?: boolean | cdktf.IResolvable; 
  public get allowModeOverride() {
    return this.getBooleanAttribute('allow_mode_override');
  }
  public set allowModeOverride(value: boolean | cdktf.IResolvable) {
    this._allowModeOverride = value;
  }
  public resetAllowModeOverride() {
    this._allowModeOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowModeOverrideInput() {
    return this._allowModeOverride;
  }

  // async_mode - computed: false, optional: true, required: false
  private _asyncMode?: boolean | cdktf.IResolvable; 
  public get asyncMode() {
    return this.getBooleanAttribute('async_mode');
  }
  public set asyncMode(value: boolean | cdktf.IResolvable) {
    this._asyncMode = value;
  }
  public resetAsyncMode() {
    this._asyncMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncModeInput() {
    return this._asyncMode;
  }

  // disable_clear_route_cache - computed: false, optional: true, required: false
  private _disableClearRouteCache?: boolean | cdktf.IResolvable; 
  public get disableClearRouteCache() {
    return this.getBooleanAttribute('disable_clear_route_cache');
  }
  public set disableClearRouteCache(value: boolean | cdktf.IResolvable) {
    this._disableClearRouteCache = value;
  }
  public resetDisableClearRouteCache() {
    this._disableClearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableClearRouteCacheInput() {
    return this._disableClearRouteCache;
  }

  // failure_mode_allow - computed: false, optional: true, required: false
  private _failureModeAllow?: boolean | cdktf.IResolvable; 
  public get failureModeAllow() {
    return this.getBooleanAttribute('failure_mode_allow');
  }
  public set failureModeAllow(value: boolean | cdktf.IResolvable) {
    this._failureModeAllow = value;
  }
  public resetFailureModeAllow() {
    this._failureModeAllow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureModeAllowInput() {
    return this._failureModeAllow;
  }

  // filter_metadata - computed: false, optional: true, required: false
  private _filterMetadata?: { [key: string]: string }; 
  public get filterMetadata() {
    return this.getStringMapAttribute('filter_metadata');
  }
  public set filterMetadata(value: { [key: string]: string }) {
    this._filterMetadata = value;
  }
  public resetFilterMetadata() {
    this._filterMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterMetadataInput() {
    return this._filterMetadata;
  }

  // filter_stage - computed: false, optional: true, required: false
  private _filterStage = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStageOutputReference(this, "filter_stage");
  public get filterStage() {
    return this._filterStage;
  }
  public putFilterStage(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcFilterStage) {
    this._filterStage.internalValue = value;
  }
  public resetFilterStage() {
    this._filterStage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterStageInput() {
    return this._filterStage.internalValue;
  }

  // forward_rules - computed: false, optional: true, required: false
  private _forwardRules = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRulesOutputReference(this, "forward_rules");
  public get forwardRules() {
    return this._forwardRules;
  }
  public putForwardRules(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcForwardRules) {
    this._forwardRules.internalValue = value;
  }
  public resetForwardRules() {
    this._forwardRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardRulesInput() {
    return this._forwardRules.internalValue;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // max_message_timeout - computed: false, optional: true, required: false
  private _maxMessageTimeout?: string; 
  public get maxMessageTimeout() {
    return this.getStringAttribute('max_message_timeout');
  }
  public set maxMessageTimeout(value: string) {
    this._maxMessageTimeout = value;
  }
  public resetMaxMessageTimeout() {
    this._maxMessageTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessageTimeoutInput() {
    return this._maxMessageTimeout;
  }

  // message_timeout - computed: false, optional: true, required: false
  private _messageTimeout?: string; 
  public get messageTimeout() {
    return this.getStringAttribute('message_timeout');
  }
  public set messageTimeout(value: string) {
    this._messageTimeout = value;
  }
  public resetMessageTimeout() {
    this._messageTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTimeoutInput() {
    return this._messageTimeout;
  }

  // metadata_context_namespaces - computed: false, optional: true, required: false
  private _metadataContextNamespaces?: string[]; 
  public get metadataContextNamespaces() {
    return this.getListAttribute('metadata_context_namespaces');
  }
  public set metadataContextNamespaces(value: string[]) {
    this._metadataContextNamespaces = value;
  }
  public resetMetadataContextNamespaces() {
    this._metadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataContextNamespacesInput() {
    return this._metadataContextNamespaces;
  }

  // mutation_rules - computed: false, optional: true, required: false
  private _mutationRules = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRulesOutputReference(this, "mutation_rules");
  public get mutationRules() {
    return this._mutationRules;
  }
  public putMutationRules(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcMutationRules) {
    this._mutationRules.internalValue = value;
  }
  public resetMutationRules() {
    this._mutationRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mutationRulesInput() {
    return this._mutationRules.internalValue;
  }

  // processing_mode - computed: false, optional: true, required: false
  private _processingMode = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingModeOutputReference(this, "processing_mode");
  public get processingMode() {
    return this._processingMode;
  }
  public putProcessingMode(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcProcessingMode) {
    this._processingMode.internalValue = value;
  }
  public resetProcessingMode() {
    this._processingMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processingModeInput() {
    return this._processingMode.internalValue;
  }

  // request_attributes - computed: false, optional: true, required: false
  private _requestAttributes?: string[]; 
  public get requestAttributes() {
    return this.getListAttribute('request_attributes');
  }
  public set requestAttributes(value: string[]) {
    this._requestAttributes = value;
  }
  public resetRequestAttributes() {
    this._requestAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestAttributesInput() {
    return this._requestAttributes;
  }

  // response_attributes - computed: false, optional: true, required: false
  private _responseAttributes?: string[]; 
  public get responseAttributes() {
    return this.getListAttribute('response_attributes');
  }
  public set responseAttributes(value: string[]) {
    this._responseAttributes = value;
  }
  public resetResponseAttributes() {
    this._responseAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseAttributesInput() {
    return this._responseAttributes;
  }

  // stat_prefix - computed: false, optional: true, required: false
  private _statPrefix?: string; 
  public get statPrefix() {
    return this.getStringAttribute('stat_prefix');
  }
  public set statPrefix(value: string) {
    this._statPrefix = value;
  }
  public resetStatPrefix() {
    this._statPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statPrefixInput() {
    return this._statPrefix;
  }

  // typed_metadata_context_namespaces - computed: false, optional: true, required: false
  private _typedMetadataContextNamespaces?: string[]; 
  public get typedMetadataContextNamespaces() {
    return this.getListAttribute('typed_metadata_context_namespaces');
  }
  public set typedMetadataContextNamespaces(value: string[]) {
    this._typedMetadataContextNamespaces = value;
  }
  public resetTypedMetadataContextNamespaces() {
    this._typedMetadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typedMetadataContextNamespacesInput() {
    return this._typedMetadataContextNamespaces;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#authority DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#authority}
  */
  readonly authority?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_headers}
  */
  readonly allowedHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_headers_regex DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_headers_regex}
  */
  readonly allowedHeadersRegex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#headers_to_add DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#headers_to_add}
  */
  readonly headersToAdd?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequestToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedHeaders),
    allowed_headers_regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedHeadersRegex),
    headers_to_add: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headersToAdd),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequestToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_headers_regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedHeadersRegex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    headers_to_add: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headersToAdd),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedHeaders = this._allowedHeaders;
    }
    if (this._allowedHeadersRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedHeadersRegex = this._allowedHeadersRegex;
    }
    if (this._headersToAdd !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAdd = this._headersToAdd;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedHeaders = undefined;
      this._allowedHeadersRegex = undefined;
      this._headersToAdd = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedHeaders = value.allowedHeaders;
      this._allowedHeadersRegex = value.allowedHeadersRegex;
      this._headersToAdd = value.headersToAdd;
    }
  }

  // allowed_headers - computed: false, optional: true, required: false
  private _allowedHeaders?: string[]; 
  public get allowedHeaders() {
    return this.getListAttribute('allowed_headers');
  }
  public set allowedHeaders(value: string[]) {
    this._allowedHeaders = value;
  }
  public resetAllowedHeaders() {
    this._allowedHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedHeadersInput() {
    return this._allowedHeaders;
  }

  // allowed_headers_regex - computed: false, optional: true, required: false
  private _allowedHeadersRegex?: string[]; 
  public get allowedHeadersRegex() {
    return this.getListAttribute('allowed_headers_regex');
  }
  public set allowedHeadersRegex(value: string[]) {
    this._allowedHeadersRegex = value;
  }
  public resetAllowedHeadersRegex() {
    this._allowedHeadersRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedHeadersRegexInput() {
    return this._allowedHeadersRegex;
  }

  // headers_to_add - computed: false, optional: true, required: false
  private _headersToAdd?: { [key: string]: string }; 
  public get headersToAdd() {
    return this.getStringMapAttribute('headers_to_add');
  }
  public set headersToAdd(value: { [key: string]: string }) {
    this._headersToAdd = value;
  }
  public resetHeadersToAdd() {
    this._headersToAdd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAddInput() {
    return this._headersToAdd;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_client_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_client_headers}
  */
  readonly allowedClientHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_upstream_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_upstream_headers}
  */
  readonly allowedUpstreamHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allowed_upstream_headers_to_append DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allowed_upstream_headers_to_append}
  */
  readonly allowedUpstreamHeadersToAppend?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponseToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_client_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedClientHeaders),
    allowed_upstream_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedUpstreamHeaders),
    allowed_upstream_headers_to_append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedUpstreamHeadersToAppend),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponseToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_client_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedClientHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_upstream_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedUpstreamHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_upstream_headers_to_append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedUpstreamHeadersToAppend),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedClientHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedClientHeaders = this._allowedClientHeaders;
    }
    if (this._allowedUpstreamHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedUpstreamHeaders = this._allowedUpstreamHeaders;
    }
    if (this._allowedUpstreamHeadersToAppend !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedUpstreamHeadersToAppend = this._allowedUpstreamHeadersToAppend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedClientHeaders = undefined;
      this._allowedUpstreamHeaders = undefined;
      this._allowedUpstreamHeadersToAppend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedClientHeaders = value.allowedClientHeaders;
      this._allowedUpstreamHeaders = value.allowedUpstreamHeaders;
      this._allowedUpstreamHeadersToAppend = value.allowedUpstreamHeadersToAppend;
    }
  }

  // allowed_client_headers - computed: false, optional: true, required: false
  private _allowedClientHeaders?: string[]; 
  public get allowedClientHeaders() {
    return this.getListAttribute('allowed_client_headers');
  }
  public set allowedClientHeaders(value: string[]) {
    this._allowedClientHeaders = value;
  }
  public resetAllowedClientHeaders() {
    this._allowedClientHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedClientHeadersInput() {
    return this._allowedClientHeaders;
  }

  // allowed_upstream_headers - computed: false, optional: true, required: false
  private _allowedUpstreamHeaders?: string[]; 
  public get allowedUpstreamHeaders() {
    return this.getListAttribute('allowed_upstream_headers');
  }
  public set allowedUpstreamHeaders(value: string[]) {
    this._allowedUpstreamHeaders = value;
  }
  public resetAllowedUpstreamHeaders() {
    this._allowedUpstreamHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedUpstreamHeadersInput() {
    return this._allowedUpstreamHeaders;
  }

  // allowed_upstream_headers_to_append - computed: false, optional: true, required: false
  private _allowedUpstreamHeadersToAppend?: string[]; 
  public get allowedUpstreamHeadersToAppend() {
    return this.getListAttribute('allowed_upstream_headers_to_append');
  }
  public set allowedUpstreamHeadersToAppend(value: string[]) {
    this._allowedUpstreamHeadersToAppend = value;
  }
  public resetAllowedUpstreamHeadersToAppend() {
    this._allowedUpstreamHeadersToAppend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedUpstreamHeadersToAppendInput() {
    return this._allowedUpstreamHeadersToAppend;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#path_prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#path_prefix}
  */
  readonly pathPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request}
  */
  readonly request?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response}
  */
  readonly response?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path_prefix: cdktf.stringToTerraform(struct!.pathPrefix),
    request: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequestToTerraform(struct!.request),
    response: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponseToTerraform(struct!.response),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path_prefix: {
      value: cdktf.stringToHclTerraform(struct!.pathPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest",
    },
    response: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponseToHclTerraform(struct!.response),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pathPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPrefix = this._pathPrefix;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    if (this._response?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.response = this._response?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pathPrefix = undefined;
      this._request.internalValue = undefined;
      this._response.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pathPrefix = value.pathPrefix;
      this._request.internalValue = value.request;
      this._response.internalValue = value.response;
    }
  }

  // path_prefix - computed: false, optional: true, required: false
  private _pathPrefix?: string; 
  public get pathPrefix() {
    return this.getStringAttribute('path_prefix');
  }
  public set pathPrefix(value: string) {
    this._pathPrefix = value;
  }
  public resetPathPrefix() {
    this._pathPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPrefixInput() {
    return this._pathPrefix;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }

  // response - computed: false, optional: true, required: false
  private _response = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponseOutputReference(this, "response");
  public get response() {
    return this._response;
  }
  public putResponse(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceResponse) {
    this._response.internalValue = value;
  }
  public resetResponse() {
    this._response.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseInput() {
    return this._response.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_partial_message DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_partial_message}
  */
  readonly allowPartialMessage?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_request_bytes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#pack_as_bytes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#pack_as_bytes}
  */
  readonly packAsBytes?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBodyToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_partial_message: cdktf.booleanToTerraform(struct!.allowPartialMessage),
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
    pack_as_bytes: cdktf.booleanToTerraform(struct!.packAsBytes),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBodyToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_partial_message: {
      value: cdktf.booleanToHclTerraform(struct!.allowPartialMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pack_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.packAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPartialMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPartialMessage = this._allowPartialMessage;
    }
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    if (this._packAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.packAsBytes = this._packAsBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowPartialMessage = undefined;
      this._maxRequestBytes = undefined;
      this._packAsBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowPartialMessage = value.allowPartialMessage;
      this._maxRequestBytes = value.maxRequestBytes;
      this._packAsBytes = value.packAsBytes;
    }
  }

  // allow_partial_message - computed: false, optional: true, required: false
  private _allowPartialMessage?: boolean | cdktf.IResolvable; 
  public get allowPartialMessage() {
    return this.getBooleanAttribute('allow_partial_message');
  }
  public set allowPartialMessage(value: boolean | cdktf.IResolvable) {
    this._allowPartialMessage = value;
  }
  public resetAllowPartialMessage() {
    this._allowPartialMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPartialMessageInput() {
    return this._allowPartialMessage;
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }

  // pack_as_bytes - computed: false, optional: true, required: false
  private _packAsBytes?: boolean | cdktf.IResolvable; 
  public get packAsBytes() {
    return this.getBooleanAttribute('pack_as_bytes');
  }
  public set packAsBytes(value: boolean | cdktf.IResolvable) {
    this._packAsBytes = value;
  }
  public resetPackAsBytes() {
    this._packAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packAsBytesInput() {
    return this._packAsBytes;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#clear_route_cache DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#clear_route_cache}
  */
  readonly clearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#extauthz_server_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#extauthz_server_ref}
  */
  readonly extauthzServerRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#failure_mode_allow DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#failure_mode_allow}
  */
  readonly failureModeAllow?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http_service DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http_service}
  */
  readonly httpService?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_body DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_body}
  */
  readonly requestBody?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stat_prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stat_prefix}
  */
  readonly statPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#status_on_error DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#status_on_error}
  */
  readonly statusOnError?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#transport_api_version DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#transport_api_version}
  */
  readonly transportApiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#user_id_header DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#user_id_header}
  */
  readonly userIdHeader?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clear_route_cache: cdktf.booleanToTerraform(struct!.clearRouteCache),
    extauthz_server_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRefToTerraform(struct!.extauthzServerRef),
    failure_mode_allow: cdktf.booleanToTerraform(struct!.failureModeAllow),
    grpc_service: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcServiceToTerraform(struct!.grpcService),
    http_service: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceToTerraform(struct!.httpService),
    request_body: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBodyToTerraform(struct!.requestBody),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
    stat_prefix: cdktf.stringToTerraform(struct!.statPrefix),
    status_on_error: cdktf.numberToTerraform(struct!.statusOnError),
    transport_api_version: cdktf.stringToTerraform(struct!.transportApiVersion),
    user_id_header: cdktf.stringToTerraform(struct!.userIdHeader),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.clearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extauthz_server_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRefToHclTerraform(struct!.extauthzServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef",
    },
    failure_mode_allow: {
      value: cdktf.booleanToHclTerraform(struct!.failureModeAllow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService",
    },
    http_service: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceToHclTerraform(struct!.httpService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService",
    },
    request_body: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBodyToHclTerraform(struct!.requestBody),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stat_prefix: {
      value: cdktf.stringToHclTerraform(struct!.statPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_on_error: {
      value: cdktf.numberToHclTerraform(struct!.statusOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    transport_api_version: {
      value: cdktf.stringToHclTerraform(struct!.transportApiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_id_header: {
      value: cdktf.stringToHclTerraform(struct!.userIdHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.clearRouteCache = this._clearRouteCache;
    }
    if (this._extauthzServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extauthzServerRef = this._extauthzServerRef?.internalValue;
    }
    if (this._failureModeAllow !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureModeAllow = this._failureModeAllow;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._httpService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpService = this._httpService?.internalValue;
    }
    if (this._requestBody?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestBody = this._requestBody?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._statPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.statPrefix = this._statPrefix;
    }
    if (this._statusOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusOnError = this._statusOnError;
    }
    if (this._transportApiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.transportApiVersion = this._transportApiVersion;
    }
    if (this._userIdHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.userIdHeader = this._userIdHeader;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clearRouteCache = undefined;
      this._extauthzServerRef.internalValue = undefined;
      this._failureModeAllow = undefined;
      this._grpcService.internalValue = undefined;
      this._httpService.internalValue = undefined;
      this._requestBody.internalValue = undefined;
      this._requestTimeout = undefined;
      this._statPrefix = undefined;
      this._statusOnError = undefined;
      this._transportApiVersion = undefined;
      this._userIdHeader = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clearRouteCache = value.clearRouteCache;
      this._extauthzServerRef.internalValue = value.extauthzServerRef;
      this._failureModeAllow = value.failureModeAllow;
      this._grpcService.internalValue = value.grpcService;
      this._httpService.internalValue = value.httpService;
      this._requestBody.internalValue = value.requestBody;
      this._requestTimeout = value.requestTimeout;
      this._statPrefix = value.statPrefix;
      this._statusOnError = value.statusOnError;
      this._transportApiVersion = value.transportApiVersion;
      this._userIdHeader = value.userIdHeader;
    }
  }

  // clear_route_cache - computed: false, optional: true, required: false
  private _clearRouteCache?: boolean | cdktf.IResolvable; 
  public get clearRouteCache() {
    return this.getBooleanAttribute('clear_route_cache');
  }
  public set clearRouteCache(value: boolean | cdktf.IResolvable) {
    this._clearRouteCache = value;
  }
  public resetClearRouteCache() {
    this._clearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clearRouteCacheInput() {
    return this._clearRouteCache;
  }

  // extauthz_server_ref - computed: false, optional: true, required: false
  private _extauthzServerRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRefOutputReference(this, "extauthz_server_ref");
  public get extauthzServerRef() {
    return this._extauthzServerRef;
  }
  public putExtauthzServerRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthExtauthzServerRef) {
    this._extauthzServerRef.internalValue = value;
  }
  public resetExtauthzServerRef() {
    this._extauthzServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extauthzServerRefInput() {
    return this._extauthzServerRef.internalValue;
  }

  // failure_mode_allow - computed: false, optional: true, required: false
  private _failureModeAllow?: boolean | cdktf.IResolvable; 
  public get failureModeAllow() {
    return this.getBooleanAttribute('failure_mode_allow');
  }
  public set failureModeAllow(value: boolean | cdktf.IResolvable) {
    this._failureModeAllow = value;
  }
  public resetFailureModeAllow() {
    this._failureModeAllow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureModeAllowInput() {
    return this._failureModeAllow;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // http_service - computed: false, optional: true, required: false
  private _httpService = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpServiceOutputReference(this, "http_service");
  public get httpService() {
    return this._httpService;
  }
  public putHttpService(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthHttpService) {
    this._httpService.internalValue = value;
  }
  public resetHttpService() {
    this._httpService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpServiceInput() {
    return this._httpService.internalValue;
  }

  // request_body - computed: false, optional: true, required: false
  private _requestBody = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBodyOutputReference(this, "request_body");
  public get requestBody() {
    return this._requestBody;
  }
  public putRequestBody(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthRequestBody) {
    this._requestBody.internalValue = value;
  }
  public resetRequestBody() {
    this._requestBody.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestBodyInput() {
    return this._requestBody.internalValue;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // stat_prefix - computed: false, optional: true, required: false
  private _statPrefix?: string; 
  public get statPrefix() {
    return this.getStringAttribute('stat_prefix');
  }
  public set statPrefix(value: string) {
    this._statPrefix = value;
  }
  public resetStatPrefix() {
    this._statPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statPrefixInput() {
    return this._statPrefix;
  }

  // status_on_error - computed: false, optional: true, required: false
  private _statusOnError?: number; 
  public get statusOnError() {
    return this.getNumberAttribute('status_on_error');
  }
  public set statusOnError(value: number) {
    this._statusOnError = value;
  }
  public resetStatusOnError() {
    this._statusOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusOnErrorInput() {
    return this._statusOnError;
  }

  // transport_api_version - computed: false, optional: true, required: false
  private _transportApiVersion?: string; 
  public get transportApiVersion() {
    return this.getStringAttribute('transport_api_version');
  }
  public set transportApiVersion(value: string) {
    this._transportApiVersion = value;
  }
  public resetTransportApiVersion() {
    this._transportApiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportApiVersionInput() {
    return this._transportApiVersion;
  }

  // user_id_header - computed: false, optional: true, required: false
  private _userIdHeader?: string; 
  public get userIdHeader() {
    return this.getStringAttribute('user_id_header');
  }
  public set userIdHeader(value: string) {
    this._userIdHeader = value;
  }
  public resetUserIdHeader() {
    this._userIdHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userIdHeaderInput() {
    return this._userIdHeader;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#configs DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#configs}
  */
  readonly configs?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configs: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.configs),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configs: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.configs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configs !== undefined) {
      hasAnyValues = true;
      internalValueResult.configs = this._configs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configs = value.configs;
    }
  }

  // configs - computed: false, optional: true, required: false
  private _configs?: { [key: string]: string }; 
  public get configs() {
    return this.getStringMapAttribute('configs');
  }
  public set configs(value: { [key: string]: string }) {
    this._configs = value;
  }
  public resetConfigs() {
    this._configs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configsInput() {
    return this._configs;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#add_whitespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#add_whitespace}
  */
  readonly addWhitespace?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#always_print_enums_as_ints DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#always_print_enums_as_ints}
  */
  readonly alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#always_print_primitive_fields DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#always_print_primitive_fields}
  */
  readonly alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#preserve_proto_field_names DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#preserve_proto_field_names}
  */
  readonly preserveProtoFieldNames?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_whitespace: cdktf.booleanToTerraform(struct!.addWhitespace),
    always_print_enums_as_ints: cdktf.booleanToTerraform(struct!.alwaysPrintEnumsAsInts),
    always_print_primitive_fields: cdktf.booleanToTerraform(struct!.alwaysPrintPrimitiveFields),
    preserve_proto_field_names: cdktf.booleanToTerraform(struct!.preserveProtoFieldNames),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_whitespace: {
      value: cdktf.booleanToHclTerraform(struct!.addWhitespace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_enums_as_ints: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintEnumsAsInts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_primitive_fields: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintPrimitiveFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_proto_field_names: {
      value: cdktf.booleanToHclTerraform(struct!.preserveProtoFieldNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addWhitespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.addWhitespace = this._addWhitespace;
    }
    if (this._alwaysPrintEnumsAsInts !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintEnumsAsInts = this._alwaysPrintEnumsAsInts;
    }
    if (this._alwaysPrintPrimitiveFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintPrimitiveFields = this._alwaysPrintPrimitiveFields;
    }
    if (this._preserveProtoFieldNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveProtoFieldNames = this._preserveProtoFieldNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addWhitespace = undefined;
      this._alwaysPrintEnumsAsInts = undefined;
      this._alwaysPrintPrimitiveFields = undefined;
      this._preserveProtoFieldNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addWhitespace = value.addWhitespace;
      this._alwaysPrintEnumsAsInts = value.alwaysPrintEnumsAsInts;
      this._alwaysPrintPrimitiveFields = value.alwaysPrintPrimitiveFields;
      this._preserveProtoFieldNames = value.preserveProtoFieldNames;
    }
  }

  // add_whitespace - computed: false, optional: true, required: false
  private _addWhitespace?: boolean | cdktf.IResolvable; 
  public get addWhitespace() {
    return this.getBooleanAttribute('add_whitespace');
  }
  public set addWhitespace(value: boolean | cdktf.IResolvable) {
    this._addWhitespace = value;
  }
  public resetAddWhitespace() {
    this._addWhitespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addWhitespaceInput() {
    return this._addWhitespace;
  }

  // always_print_enums_as_ints - computed: false, optional: true, required: false
  private _alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable; 
  public get alwaysPrintEnumsAsInts() {
    return this.getBooleanAttribute('always_print_enums_as_ints');
  }
  public set alwaysPrintEnumsAsInts(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintEnumsAsInts = value;
  }
  public resetAlwaysPrintEnumsAsInts() {
    this._alwaysPrintEnumsAsInts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintEnumsAsIntsInput() {
    return this._alwaysPrintEnumsAsInts;
  }

  // always_print_primitive_fields - computed: false, optional: true, required: false
  private _alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable; 
  public get alwaysPrintPrimitiveFields() {
    return this.getBooleanAttribute('always_print_primitive_fields');
  }
  public set alwaysPrintPrimitiveFields(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintPrimitiveFields = value;
  }
  public resetAlwaysPrintPrimitiveFields() {
    this._alwaysPrintPrimitiveFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintPrimitiveFieldsInput() {
    return this._alwaysPrintPrimitiveFields;
  }

  // preserve_proto_field_names - computed: false, optional: true, required: false
  private _preserveProtoFieldNames?: boolean | cdktf.IResolvable; 
  public get preserveProtoFieldNames() {
    return this.getBooleanAttribute('preserve_proto_field_names');
  }
  public set preserveProtoFieldNames(value: boolean | cdktf.IResolvable) {
    this._preserveProtoFieldNames = value;
  }
  public resetPreserveProtoFieldNames() {
    this._preserveProtoFieldNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveProtoFieldNamesInput() {
    return this._preserveProtoFieldNames;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#config_map_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct!.configMapRef),
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._key = value.key;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#auto_mapping DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#auto_mapping}
  */
  readonly autoMapping?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#convert_grpc_status DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#convert_grpc_status}
  */
  readonly convertGrpcStatus?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ignore_unknown_query_parameters DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ignore_unknown_query_parameters}
  */
  readonly ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ignored_query_parameters DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ignored_query_parameters}
  */
  readonly ignoredQueryParameters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#match_incoming_request_route DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#match_incoming_request_route}
  */
  readonly matchIncomingRequestRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#print_options DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#print_options}
  */
  readonly printOptions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#proto_descriptor DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#proto_descriptor}
  */
  readonly protoDescriptor?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#proto_descriptor_bin DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#proto_descriptor_bin}
  */
  readonly protoDescriptorBin?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#proto_descriptor_config_map DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#proto_descriptor_config_map}
  */
  readonly protoDescriptorConfigMap?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#services DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#services}
  */
  readonly services?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_mapping: cdktf.booleanToTerraform(struct!.autoMapping),
    convert_grpc_status: cdktf.booleanToTerraform(struct!.convertGrpcStatus),
    ignore_unknown_query_parameters: cdktf.booleanToTerraform(struct!.ignoreUnknownQueryParameters),
    ignored_query_parameters: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ignoredQueryParameters),
    match_incoming_request_route: cdktf.booleanToTerraform(struct!.matchIncomingRequestRoute),
    print_options: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToTerraform(struct!.printOptions),
    proto_descriptor: cdktf.stringToTerraform(struct!.protoDescriptor),
    proto_descriptor_bin: cdktf.stringToTerraform(struct!.protoDescriptorBin),
    proto_descriptor_config_map: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct!.protoDescriptorConfigMap),
    services: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.services),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_mapping: {
      value: cdktf.booleanToHclTerraform(struct!.autoMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    convert_grpc_status: {
      value: cdktf.booleanToHclTerraform(struct!.convertGrpcStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_unknown_query_parameters: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreUnknownQueryParameters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignored_query_parameters: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ignoredQueryParameters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    match_incoming_request_route: {
      value: cdktf.booleanToHclTerraform(struct!.matchIncomingRequestRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    print_options: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToHclTerraform(struct!.printOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions",
    },
    proto_descriptor: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_bin: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptorBin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_config_map: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct!.protoDescriptorConfigMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap",
    },
    services: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.services),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoMapping = this._autoMapping;
    }
    if (this._convertGrpcStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.convertGrpcStatus = this._convertGrpcStatus;
    }
    if (this._ignoreUnknownQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreUnknownQueryParameters = this._ignoreUnknownQueryParameters;
    }
    if (this._ignoredQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoredQueryParameters = this._ignoredQueryParameters;
    }
    if (this._matchIncomingRequestRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchIncomingRequestRoute = this._matchIncomingRequestRoute;
    }
    if (this._printOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.printOptions = this._printOptions?.internalValue;
    }
    if (this._protoDescriptor !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptor = this._protoDescriptor;
    }
    if (this._protoDescriptorBin !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorBin = this._protoDescriptorBin;
    }
    if (this._protoDescriptorConfigMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorConfigMap = this._protoDescriptorConfigMap?.internalValue;
    }
    if (this._services !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoMapping = undefined;
      this._convertGrpcStatus = undefined;
      this._ignoreUnknownQueryParameters = undefined;
      this._ignoredQueryParameters = undefined;
      this._matchIncomingRequestRoute = undefined;
      this._printOptions.internalValue = undefined;
      this._protoDescriptor = undefined;
      this._protoDescriptorBin = undefined;
      this._protoDescriptorConfigMap.internalValue = undefined;
      this._services = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoMapping = value.autoMapping;
      this._convertGrpcStatus = value.convertGrpcStatus;
      this._ignoreUnknownQueryParameters = value.ignoreUnknownQueryParameters;
      this._ignoredQueryParameters = value.ignoredQueryParameters;
      this._matchIncomingRequestRoute = value.matchIncomingRequestRoute;
      this._printOptions.internalValue = value.printOptions;
      this._protoDescriptor = value.protoDescriptor;
      this._protoDescriptorBin = value.protoDescriptorBin;
      this._protoDescriptorConfigMap.internalValue = value.protoDescriptorConfigMap;
      this._services = value.services;
    }
  }

  // auto_mapping - computed: false, optional: true, required: false
  private _autoMapping?: boolean | cdktf.IResolvable; 
  public get autoMapping() {
    return this.getBooleanAttribute('auto_mapping');
  }
  public set autoMapping(value: boolean | cdktf.IResolvable) {
    this._autoMapping = value;
  }
  public resetAutoMapping() {
    this._autoMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoMappingInput() {
    return this._autoMapping;
  }

  // convert_grpc_status - computed: false, optional: true, required: false
  private _convertGrpcStatus?: boolean | cdktf.IResolvable; 
  public get convertGrpcStatus() {
    return this.getBooleanAttribute('convert_grpc_status');
  }
  public set convertGrpcStatus(value: boolean | cdktf.IResolvable) {
    this._convertGrpcStatus = value;
  }
  public resetConvertGrpcStatus() {
    this._convertGrpcStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get convertGrpcStatusInput() {
    return this._convertGrpcStatus;
  }

  // ignore_unknown_query_parameters - computed: false, optional: true, required: false
  private _ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable; 
  public get ignoreUnknownQueryParameters() {
    return this.getBooleanAttribute('ignore_unknown_query_parameters');
  }
  public set ignoreUnknownQueryParameters(value: boolean | cdktf.IResolvable) {
    this._ignoreUnknownQueryParameters = value;
  }
  public resetIgnoreUnknownQueryParameters() {
    this._ignoreUnknownQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreUnknownQueryParametersInput() {
    return this._ignoreUnknownQueryParameters;
  }

  // ignored_query_parameters - computed: false, optional: true, required: false
  private _ignoredQueryParameters?: string[]; 
  public get ignoredQueryParameters() {
    return this.getListAttribute('ignored_query_parameters');
  }
  public set ignoredQueryParameters(value: string[]) {
    this._ignoredQueryParameters = value;
  }
  public resetIgnoredQueryParameters() {
    this._ignoredQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoredQueryParametersInput() {
    return this._ignoredQueryParameters;
  }

  // match_incoming_request_route - computed: false, optional: true, required: false
  private _matchIncomingRequestRoute?: boolean | cdktf.IResolvable; 
  public get matchIncomingRequestRoute() {
    return this.getBooleanAttribute('match_incoming_request_route');
  }
  public set matchIncomingRequestRoute(value: boolean | cdktf.IResolvable) {
    this._matchIncomingRequestRoute = value;
  }
  public resetMatchIncomingRequestRoute() {
    this._matchIncomingRequestRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchIncomingRequestRouteInput() {
    return this._matchIncomingRequestRoute;
  }

  // print_options - computed: false, optional: true, required: false
  private _printOptions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsOutputReference(this, "print_options");
  public get printOptions() {
    return this._printOptions;
  }
  public putPrintOptions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderPrintOptions) {
    this._printOptions.internalValue = value;
  }
  public resetPrintOptions() {
    this._printOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get printOptionsInput() {
    return this._printOptions.internalValue;
  }

  // proto_descriptor - computed: false, optional: true, required: false
  private _protoDescriptor?: string; 
  public get protoDescriptor() {
    return this.getStringAttribute('proto_descriptor');
  }
  public set protoDescriptor(value: string) {
    this._protoDescriptor = value;
  }
  public resetProtoDescriptor() {
    this._protoDescriptor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorInput() {
    return this._protoDescriptor;
  }

  // proto_descriptor_bin - computed: false, optional: true, required: false
  private _protoDescriptorBin?: string; 
  public get protoDescriptorBin() {
    return this.getStringAttribute('proto_descriptor_bin');
  }
  public set protoDescriptorBin(value: string) {
    this._protoDescriptorBin = value;
  }
  public resetProtoDescriptorBin() {
    this._protoDescriptorBin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorBinInput() {
    return this._protoDescriptorBin;
  }

  // proto_descriptor_config_map - computed: false, optional: true, required: false
  private _protoDescriptorConfigMap = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference(this, "proto_descriptor_config_map");
  public get protoDescriptorConfigMap() {
    return this._protoDescriptorConfigMap;
  }
  public putProtoDescriptorConfigMap(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap) {
    this._protoDescriptorConfigMap.internalValue = value;
  }
  public resetProtoDescriptorConfigMap() {
    this._protoDescriptorConfigMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorConfigMapInput() {
    return this._protoDescriptorConfigMap.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services?: string[]; 
  public get services() {
    return this.getListAttribute('services');
  }
  public set services(value: string[]) {
    this._services = value;
  }
  public resetServices() {
    this._services = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disable DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWebToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWebToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWebOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#compression_level DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#compression_strategy DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#compression_strategy}
  */
  readonly compressionStrategy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#content_length DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#content_length}
  */
  readonly contentLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#content_type DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#content_type}
  */
  readonly contentType?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disable_on_etag_header DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disable_on_etag_header}
  */
  readonly disableOnEtagHeader?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#memory_level DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#memory_level}
  */
  readonly memoryLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#remove_accept_encoding_header DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#remove_accept_encoding_header}
  */
  readonly removeAcceptEncodingHeader?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#window_bits DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#window_bits}
  */
  readonly windowBits?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzipToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    compression_strategy: cdktf.stringToTerraform(struct!.compressionStrategy),
    content_length: cdktf.numberToTerraform(struct!.contentLength),
    content_type: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.contentType),
    disable_on_etag_header: cdktf.booleanToTerraform(struct!.disableOnEtagHeader),
    memory_level: cdktf.numberToTerraform(struct!.memoryLevel),
    remove_accept_encoding_header: cdktf.booleanToTerraform(struct!.removeAcceptEncodingHeader),
    window_bits: cdktf.numberToTerraform(struct!.windowBits),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzipToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_strategy: {
      value: cdktf.stringToHclTerraform(struct!.compressionStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    content_length: {
      value: cdktf.numberToHclTerraform(struct!.contentLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    content_type: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.contentType),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_on_etag_header: {
      value: cdktf.booleanToHclTerraform(struct!.disableOnEtagHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    memory_level: {
      value: cdktf.numberToHclTerraform(struct!.memoryLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove_accept_encoding_header: {
      value: cdktf.booleanToHclTerraform(struct!.removeAcceptEncodingHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    window_bits: {
      value: cdktf.numberToHclTerraform(struct!.windowBits),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._compressionStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionStrategy = this._compressionStrategy;
    }
    if (this._contentLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentLength = this._contentLength;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._disableOnEtagHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableOnEtagHeader = this._disableOnEtagHeader;
    }
    if (this._memoryLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLevel = this._memoryLevel;
    }
    if (this._removeAcceptEncodingHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAcceptEncodingHeader = this._removeAcceptEncodingHeader;
    }
    if (this._windowBits !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowBits = this._windowBits;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compressionLevel = undefined;
      this._compressionStrategy = undefined;
      this._contentLength = undefined;
      this._contentType = undefined;
      this._disableOnEtagHeader = undefined;
      this._memoryLevel = undefined;
      this._removeAcceptEncodingHeader = undefined;
      this._windowBits = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compressionLevel = value.compressionLevel;
      this._compressionStrategy = value.compressionStrategy;
      this._contentLength = value.contentLength;
      this._contentType = value.contentType;
      this._disableOnEtagHeader = value.disableOnEtagHeader;
      this._memoryLevel = value.memoryLevel;
      this._removeAcceptEncodingHeader = value.removeAcceptEncodingHeader;
      this._windowBits = value.windowBits;
    }
  }

  // compression_level - computed: false, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // compression_strategy - computed: false, optional: true, required: false
  private _compressionStrategy?: string; 
  public get compressionStrategy() {
    return this.getStringAttribute('compression_strategy');
  }
  public set compressionStrategy(value: string) {
    this._compressionStrategy = value;
  }
  public resetCompressionStrategy() {
    this._compressionStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionStrategyInput() {
    return this._compressionStrategy;
  }

  // content_length - computed: false, optional: true, required: false
  private _contentLength?: number; 
  public get contentLength() {
    return this.getNumberAttribute('content_length');
  }
  public set contentLength(value: number) {
    this._contentLength = value;
  }
  public resetContentLength() {
    this._contentLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentLengthInput() {
    return this._contentLength;
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string[]; 
  public get contentType() {
    return this.getListAttribute('content_type');
  }
  public set contentType(value: string[]) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // disable_on_etag_header - computed: false, optional: true, required: false
  private _disableOnEtagHeader?: boolean | cdktf.IResolvable; 
  public get disableOnEtagHeader() {
    return this.getBooleanAttribute('disable_on_etag_header');
  }
  public set disableOnEtagHeader(value: boolean | cdktf.IResolvable) {
    this._disableOnEtagHeader = value;
  }
  public resetDisableOnEtagHeader() {
    this._disableOnEtagHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableOnEtagHeaderInput() {
    return this._disableOnEtagHeader;
  }

  // memory_level - computed: false, optional: true, required: false
  private _memoryLevel?: number; 
  public get memoryLevel() {
    return this.getNumberAttribute('memory_level');
  }
  public set memoryLevel(value: number) {
    this._memoryLevel = value;
  }
  public resetMemoryLevel() {
    this._memoryLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLevelInput() {
    return this._memoryLevel;
  }

  // remove_accept_encoding_header - computed: false, optional: true, required: false
  private _removeAcceptEncodingHeader?: boolean | cdktf.IResolvable; 
  public get removeAcceptEncodingHeader() {
    return this.getBooleanAttribute('remove_accept_encoding_header');
  }
  public set removeAcceptEncodingHeader(value: boolean | cdktf.IResolvable) {
    this._removeAcceptEncodingHeader = value;
  }
  public resetRemoveAcceptEncodingHeader() {
    this._removeAcceptEncodingHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAcceptEncodingHeaderInput() {
    return this._removeAcceptEncodingHeader;
  }

  // window_bits - computed: false, optional: true, required: false
  private _windowBits?: number; 
  public get windowBits() {
    return this.getNumberAttribute('window_bits');
  }
  public set windowBits(value: number) {
    this._windowBits = value;
  }
  public resetWindowBits() {
    this._windowBits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowBitsInput() {
    return this._windowBits;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disable_http1_method_validation DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disable_http1_method_validation}
  */
  readonly disableHttp1MethodValidation?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettingsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable_http1_method_validation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.disableHttp1MethodValidation),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettingsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable_http1_method_validation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.disableHttp1MethodValidation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disableHttp1MethodValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableHttp1MethodValidation = this._disableHttp1MethodValidation;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disableHttp1MethodValidation = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disableHttp1MethodValidation = value.disableHttp1MethodValidation;
    }
  }

  // disable_http1_method_validation - computed: false, optional: true, required: false
  private _disableHttp1MethodValidation?: { [key: string]: string }; 
  public get disableHttp1MethodValidation() {
    return this.getStringMapAttribute('disable_http1_method_validation');
  }
  public set disableHttp1MethodValidation(value: { [key: string]: string }) {
    this._disableHttp1MethodValidation = value;
  }
  public resetDisableHttp1MethodValidation() {
    this._disableHttp1MethodValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableHttp1MethodValidationInput() {
    return this._disableHttp1MethodValidation;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#path DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheckToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheckToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#initial_connection_window_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#initial_connection_window_size}
  */
  readonly initialConnectionWindowSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#initial_stream_window_size DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#initial_stream_window_size}
  */
  readonly initialStreamWindowSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_concurrent_streams DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_concurrent_streams}
  */
  readonly maxConcurrentStreams?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#override_stream_error_on_invalid_http_message DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#override_stream_error_on_invalid_http_message}
  */
  readonly overrideStreamErrorOnInvalidHttpMessage?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    initial_connection_window_size: cdktf.numberToTerraform(struct!.initialConnectionWindowSize),
    initial_stream_window_size: cdktf.numberToTerraform(struct!.initialStreamWindowSize),
    max_concurrent_streams: cdktf.numberToTerraform(struct!.maxConcurrentStreams),
    override_stream_error_on_invalid_http_message: cdktf.booleanToTerraform(struct!.overrideStreamErrorOnInvalidHttpMessage),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    initial_connection_window_size: {
      value: cdktf.numberToHclTerraform(struct!.initialConnectionWindowSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_stream_window_size: {
      value: cdktf.numberToHclTerraform(struct!.initialStreamWindowSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_streams: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentStreams),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    override_stream_error_on_invalid_http_message: {
      value: cdktf.booleanToHclTerraform(struct!.overrideStreamErrorOnInvalidHttpMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._initialConnectionWindowSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialConnectionWindowSize = this._initialConnectionWindowSize;
    }
    if (this._initialStreamWindowSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialStreamWindowSize = this._initialStreamWindowSize;
    }
    if (this._maxConcurrentStreams !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentStreams = this._maxConcurrentStreams;
    }
    if (this._overrideStreamErrorOnInvalidHttpMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideStreamErrorOnInvalidHttpMessage = this._overrideStreamErrorOnInvalidHttpMessage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._initialConnectionWindowSize = undefined;
      this._initialStreamWindowSize = undefined;
      this._maxConcurrentStreams = undefined;
      this._overrideStreamErrorOnInvalidHttpMessage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._initialConnectionWindowSize = value.initialConnectionWindowSize;
      this._initialStreamWindowSize = value.initialStreamWindowSize;
      this._maxConcurrentStreams = value.maxConcurrentStreams;
      this._overrideStreamErrorOnInvalidHttpMessage = value.overrideStreamErrorOnInvalidHttpMessage;
    }
  }

  // initial_connection_window_size - computed: false, optional: true, required: false
  private _initialConnectionWindowSize?: number; 
  public get initialConnectionWindowSize() {
    return this.getNumberAttribute('initial_connection_window_size');
  }
  public set initialConnectionWindowSize(value: number) {
    this._initialConnectionWindowSize = value;
  }
  public resetInitialConnectionWindowSize() {
    this._initialConnectionWindowSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialConnectionWindowSizeInput() {
    return this._initialConnectionWindowSize;
  }

  // initial_stream_window_size - computed: false, optional: true, required: false
  private _initialStreamWindowSize?: number; 
  public get initialStreamWindowSize() {
    return this.getNumberAttribute('initial_stream_window_size');
  }
  public set initialStreamWindowSize(value: number) {
    this._initialStreamWindowSize = value;
  }
  public resetInitialStreamWindowSize() {
    this._initialStreamWindowSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialStreamWindowSizeInput() {
    return this._initialStreamWindowSize;
  }

  // max_concurrent_streams - computed: false, optional: true, required: false
  private _maxConcurrentStreams?: number; 
  public get maxConcurrentStreams() {
    return this.getNumberAttribute('max_concurrent_streams');
  }
  public set maxConcurrentStreams(value: number) {
    this._maxConcurrentStreams = value;
  }
  public resetMaxConcurrentStreams() {
    this._maxConcurrentStreams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentStreamsInput() {
    return this._maxConcurrentStreams;
  }

  // override_stream_error_on_invalid_http_message - computed: false, optional: true, required: false
  private _overrideStreamErrorOnInvalidHttpMessage?: boolean | cdktf.IResolvable; 
  public get overrideStreamErrorOnInvalidHttpMessage() {
    return this.getBooleanAttribute('override_stream_error_on_invalid_http_message');
  }
  public set overrideStreamErrorOnInvalidHttpMessage(value: boolean | cdktf.IResolvable) {
    this._overrideStreamErrorOnInvalidHttpMessage = value;
  }
  public resetOverrideStreamErrorOnInvalidHttpMessage() {
    this._overrideStreamErrorOnInvalidHttpMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideStreamErrorOnInvalidHttpMessageInput() {
    return this._overrideStreamErrorOnInvalidHttpMessage;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#address_prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#address_prefix}
  */
  readonly addressPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix_len DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix_len}
  */
  readonly prefixLen?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.stringToTerraform(struct!.addressPrefix),
    prefix_len: cdktf.numberToTerraform(struct!.prefixLen),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.stringToHclTerraform(struct!.addressPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_len: {
      value: cdktf.numberToHclTerraform(struct!.prefixLen),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix;
    }
    if (this._prefixLen !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixLen = this._prefixLen;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix = undefined;
      this._prefixLen = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix = value.addressPrefix;
      this._prefixLen = value.prefixLen;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix?: string; 
  public get addressPrefix() {
    return this.getStringAttribute('address_prefix');
  }
  public set addressPrefix(value: string) {
    this._addressPrefix = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix;
  }

  // prefix_len - computed: false, optional: true, required: false
  private _prefixLen?: number; 
  public get prefixLen() {
    return this.getNumberAttribute('prefix_len');
  }
  public set prefixLen(value: number) {
    this._prefixLen = value;
  }
  public resetPrefixLen() {
    this._prefixLen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixLenInput() {
    return this._prefixLen;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cidr_ranges DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cidr_ranges}
  */
  readonly cidrRanges?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#unix_sockets DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#unix_sockets}
  */
  readonly unixSockets?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr_ranges: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToTerraform, false)(struct!.cidrRanges),
    unix_sockets: cdktf.booleanToTerraform(struct!.unixSockets),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr_ranges: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToHclTerraform, false)(struct!.cidrRanges),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesList",
    },
    unix_sockets: {
      value: cdktf.booleanToHclTerraform(struct!.unixSockets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidrRanges?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrRanges = this._cidrRanges?.internalValue;
    }
    if (this._unixSockets !== undefined) {
      hasAnyValues = true;
      internalValueResult.unixSockets = this._unixSockets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidrRanges.internalValue = undefined;
      this._unixSockets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidrRanges.internalValue = value.cidrRanges;
      this._unixSockets = value.unixSockets;
    }
  }

  // cidr_ranges - computed: false, optional: true, required: false
  private _cidrRanges = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesList(this, "cidr_ranges", false);
  public get cidrRanges() {
    return this._cidrRanges;
  }
  public putCidrRanges(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges[] | cdktf.IResolvable) {
    this._cidrRanges.internalValue = value;
  }
  public resetCidrRanges() {
    this._cidrRanges.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrRangesInput() {
    return this._cidrRanges.internalValue;
  }

  // unix_sockets - computed: false, optional: true, required: false
  private _unixSockets?: boolean | cdktf.IResolvable; 
  public get unixSockets() {
    return this.getBooleanAttribute('unix_sockets');
  }
  public set unixSockets(value: boolean | cdktf.IResolvable) {
    this._unixSockets = value;
  }
  public resetUnixSockets() {
    this._unixSockets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixSocketsInput() {
    return this._unixSockets;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cert DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cert}
  */
  readonly cert?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#chain DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#chain}
  */
  readonly chain?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dns DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dns}
  */
  readonly dns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#subject DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#subject}
  */
  readonly subject?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#uri DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#uri}
  */
  readonly uri?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert: cdktf.booleanToTerraform(struct!.cert),
    chain: cdktf.booleanToTerraform(struct!.chain),
    dns: cdktf.booleanToTerraform(struct!.dns),
    subject: cdktf.booleanToTerraform(struct!.subject),
    uri: cdktf.booleanToTerraform(struct!.uri),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert: {
      value: cdktf.booleanToHclTerraform(struct!.cert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    chain: {
      value: cdktf.booleanToHclTerraform(struct!.chain),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns: {
      value: cdktf.booleanToHclTerraform(struct!.dns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    subject: {
      value: cdktf.booleanToHclTerraform(struct!.subject),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    uri: {
      value: cdktf.booleanToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cert !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert;
    }
    if (this._chain !== undefined) {
      hasAnyValues = true;
      internalValueResult.chain = this._chain;
    }
    if (this._dns !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns;
    }
    if (this._subject !== undefined) {
      hasAnyValues = true;
      internalValueResult.subject = this._subject;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cert = undefined;
      this._chain = undefined;
      this._dns = undefined;
      this._subject = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cert = value.cert;
      this._chain = value.chain;
      this._dns = value.dns;
      this._subject = value.subject;
      this._uri = value.uri;
    }
  }

  // cert - computed: false, optional: true, required: false
  private _cert?: boolean | cdktf.IResolvable; 
  public get cert() {
    return this.getBooleanAttribute('cert');
  }
  public set cert(value: boolean | cdktf.IResolvable) {
    this._cert = value;
  }
  public resetCert() {
    this._cert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert;
  }

  // chain - computed: false, optional: true, required: false
  private _chain?: boolean | cdktf.IResolvable; 
  public get chain() {
    return this.getBooleanAttribute('chain');
  }
  public set chain(value: boolean | cdktf.IResolvable) {
    this._chain = value;
  }
  public resetChain() {
    this._chain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chainInput() {
    return this._chain;
  }

  // dns - computed: false, optional: true, required: false
  private _dns?: boolean | cdktf.IResolvable; 
  public get dns() {
    return this.getBooleanAttribute('dns');
  }
  public set dns(value: boolean | cdktf.IResolvable) {
    this._dns = value;
  }
  public resetDns() {
    this._dns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns;
  }

  // subject - computed: false, optional: true, required: false
  private _subject?: boolean | cdktf.IResolvable; 
  public get subject() {
    return this.getBooleanAttribute('subject');
  }
  public set subject(value: boolean | cdktf.IResolvable) {
    this._subject = value;
  }
  public resetSubject() {
    this._subject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectInput() {
    return this._subject;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: boolean | cdktf.IResolvable; 
  public get uri() {
    return this.getBooleanAttribute('uri');
  }
  public set uri(value: boolean | cdktf.IResolvable) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#polling_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#polling_interval}
  */
  readonly pollingInterval?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    polling_interval: cdktf.stringToTerraform(struct!.pollingInterval),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    polling_interval: {
      value: cdktf.stringToHclTerraform(struct!.pollingInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._pollingInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollingInterval = this._pollingInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._pollingInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._pollingInterval = value.pollingInterval;
    }
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // polling_interval - computed: false, optional: true, required: false
  private _pollingInterval?: string; 
  public get pollingInterval() {
    return this.getStringAttribute('polling_interval');
  }
  public set pollingInterval(value: string) {
    this._pollingInterval = value;
  }
  public resetPollingInterval() {
    this._pollingInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollingIntervalInput() {
    return this._pollingInterval;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#collector_hostname DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#collector_hostname}
  */
  readonly collectorHostname?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#collector_upstream_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#collector_upstream_ref}
  */
  readonly collectorUpstreamRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#remote_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#remote_config}
  */
  readonly remoteConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#service_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#service_name}
  */
  readonly serviceName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    collector_hostname: cdktf.stringToTerraform(struct!.collectorHostname),
    collector_upstream_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToTerraform(struct!.collectorUpstreamRef),
    remote_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToTerraform(struct!.remoteConfig),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_hostname: {
      value: cdktf.stringToHclTerraform(struct!.collectorHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_upstream_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToHclTerraform(struct!.collectorUpstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef",
    },
    remote_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToHclTerraform(struct!.remoteConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._collectorHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorHostname = this._collectorHostname;
    }
    if (this._collectorUpstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorUpstreamRef = this._collectorUpstreamRef?.internalValue;
    }
    if (this._remoteConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteConfig = this._remoteConfig?.internalValue;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterName = undefined;
      this._collectorHostname = undefined;
      this._collectorUpstreamRef.internalValue = undefined;
      this._remoteConfig.internalValue = undefined;
      this._serviceName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterName = value.clusterName;
      this._collectorHostname = value.collectorHostname;
      this._collectorUpstreamRef.internalValue = value.collectorUpstreamRef;
      this._remoteConfig.internalValue = value.remoteConfig;
      this._serviceName = value.serviceName;
    }
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // collector_hostname - computed: false, optional: true, required: false
  private _collectorHostname?: string; 
  public get collectorHostname() {
    return this.getStringAttribute('collector_hostname');
  }
  public set collectorHostname(value: string) {
    this._collectorHostname = value;
  }
  public resetCollectorHostname() {
    this._collectorHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorHostnameInput() {
    return this._collectorHostname;
  }

  // collector_upstream_ref - computed: false, optional: true, required: false
  private _collectorUpstreamRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefOutputReference(this, "collector_upstream_ref");
  public get collectorUpstreamRef() {
    return this._collectorUpstreamRef;
  }
  public putCollectorUpstreamRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef) {
    this._collectorUpstreamRef.internalValue = value;
  }
  public resetCollectorUpstreamRef() {
    this._collectorUpstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorUpstreamRefInput() {
    return this._collectorUpstreamRef.internalValue;
  }

  // remote_config - computed: false, optional: true, required: false
  private _remoteConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigOutputReference(this, "remote_config");
  public get remoteConfig() {
    return this._remoteConfig;
  }
  public putRemoteConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig) {
    this._remoteConfig.internalValue = value;
  }
  public resetRemoteConfig() {
    this._remoteConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteConfigInput() {
    return this._remoteConfig.internalValue;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#default_value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tag DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tag}
  */
  readonly tag?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    name: cdktf.stringToTerraform(struct!.name),
    tag: cdktf.stringToTerraform(struct!.tag),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.stringToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._name = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._name = value.name;
      this._tag = value.tag;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: string; 
  public get tag() {
    return this.getStringAttribute('tag');
  }
  public set tag(value: string) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tag DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tag}
  */
  readonly tag?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#value DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tag: cdktf.stringToTerraform(struct!.tag),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tag: {
      value: cdktf.stringToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tag = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tag = value.tag;
      this._value = value.value;
    }
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: string; 
  public get tag() {
    return this.getStringAttribute('tag');
  }
  public set tag(value: string) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stat_prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stat_prefix}
  */
  readonly statPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#target_uri DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#target_uri}
  */
  readonly targetUri?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    stat_prefix: cdktf.stringToTerraform(struct!.statPrefix),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    stat_prefix: {
      value: cdktf.stringToHclTerraform(struct!.statPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._statPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.statPrefix = this._statPrefix;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._statPrefix = undefined;
      this._targetUri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._statPrefix = value.statPrefix;
      this._targetUri = value.targetUri;
    }
  }

  // stat_prefix - computed: false, optional: true, required: false
  private _statPrefix?: string; 
  public get statPrefix() {
    return this.getStringAttribute('stat_prefix');
  }
  public set statPrefix(value: string) {
    this._statPrefix = value;
  }
  public resetStatPrefix() {
    this._statPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statPrefixInput() {
    return this._statPrefix;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#decision DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#decision}
  */
  readonly decision?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    decision: cdktf.stringToTerraform(struct!.decision),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    decision: {
      value: cdktf.stringToHclTerraform(struct!.decision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._decision !== undefined) {
      hasAnyValues = true;
      internalValueResult.decision = this._decision;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._decision = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._decision = value.decision;
    }
  }

  // decision - computed: false, optional: true, required: false
  private _decision?: string; 
  public get decision() {
    return this.getStringAttribute('decision');
  }
  public set decision(value: string) {
    this._decision = value;
  }
  public resetDecision() {
    this._decision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decisionInput() {
    return this._decision;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sampling_probability DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sampling_probability}
  */
  readonly samplingProbability?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sampling_probability: cdktf.numberToTerraform(struct!.samplingProbability),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sampling_probability: {
      value: cdktf.numberToHclTerraform(struct!.samplingProbability),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._samplingProbability !== undefined) {
      hasAnyValues = true;
      internalValueResult.samplingProbability = this._samplingProbability;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._samplingProbability = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._samplingProbability = value.samplingProbability;
    }
  }

  // sampling_probability - computed: false, optional: true, required: false
  private _samplingProbability?: number; 
  public get samplingProbability() {
    return this.getNumberAttribute('sampling_probability');
  }
  public set samplingProbability(value: number) {
    this._samplingProbability = value;
  }
  public resetSamplingProbability() {
    this._samplingProbability = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get samplingProbabilityInput() {
    return this._samplingProbability;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#qps DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#qps}
  */
  readonly qps?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    qps: cdktf.numberToTerraform(struct!.qps),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    qps: {
      value: cdktf.numberToHclTerraform(struct!.qps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._qps !== undefined) {
      hasAnyValues = true;
      internalValueResult.qps = this._qps;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._qps = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._qps = value.qps;
    }
  }

  // qps - computed: false, optional: true, required: false
  private _qps?: number; 
  public get qps() {
    return this.getNumberAttribute('qps');
  }
  public set qps(value: number) {
    this._qps = value;
  }
  public resetQps() {
    this._qps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qpsInput() {
    return this._qps;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#constant_sampler DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#constant_sampler}
  */
  readonly constantSampler?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_number_of_annotations DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_number_of_annotations}
  */
  readonly maxNumberOfAnnotations?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_number_of_attributes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_number_of_attributes}
  */
  readonly maxNumberOfAttributes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_number_of_links DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_number_of_links}
  */
  readonly maxNumberOfLinks?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_number_of_message_events DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_number_of_message_events}
  */
  readonly maxNumberOfMessageEvents?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#probability_sampler DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#probability_sampler}
  */
  readonly probabilitySampler?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#rate_limiting_sampler DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#rate_limiting_sampler}
  */
  readonly rateLimitingSampler?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    constant_sampler: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToTerraform(struct!.constantSampler),
    max_number_of_annotations: cdktf.numberToTerraform(struct!.maxNumberOfAnnotations),
    max_number_of_attributes: cdktf.numberToTerraform(struct!.maxNumberOfAttributes),
    max_number_of_links: cdktf.numberToTerraform(struct!.maxNumberOfLinks),
    max_number_of_message_events: cdktf.numberToTerraform(struct!.maxNumberOfMessageEvents),
    probability_sampler: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToTerraform(struct!.probabilitySampler),
    rate_limiting_sampler: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToTerraform(struct!.rateLimitingSampler),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    constant_sampler: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToHclTerraform(struct!.constantSampler),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler",
    },
    max_number_of_annotations: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_attributes: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAttributes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_links: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfLinks),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_message_events: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfMessageEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    probability_sampler: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToHclTerraform(struct!.probabilitySampler),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler",
    },
    rate_limiting_sampler: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToHclTerraform(struct!.rateLimitingSampler),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._constantSampler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.constantSampler = this._constantSampler?.internalValue;
    }
    if (this._maxNumberOfAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAnnotations = this._maxNumberOfAnnotations;
    }
    if (this._maxNumberOfAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAttributes = this._maxNumberOfAttributes;
    }
    if (this._maxNumberOfLinks !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfLinks = this._maxNumberOfLinks;
    }
    if (this._maxNumberOfMessageEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfMessageEvents = this._maxNumberOfMessageEvents;
    }
    if (this._probabilitySampler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.probabilitySampler = this._probabilitySampler?.internalValue;
    }
    if (this._rateLimitingSampler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rateLimitingSampler = this._rateLimitingSampler?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._constantSampler.internalValue = undefined;
      this._maxNumberOfAnnotations = undefined;
      this._maxNumberOfAttributes = undefined;
      this._maxNumberOfLinks = undefined;
      this._maxNumberOfMessageEvents = undefined;
      this._probabilitySampler.internalValue = undefined;
      this._rateLimitingSampler.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._constantSampler.internalValue = value.constantSampler;
      this._maxNumberOfAnnotations = value.maxNumberOfAnnotations;
      this._maxNumberOfAttributes = value.maxNumberOfAttributes;
      this._maxNumberOfLinks = value.maxNumberOfLinks;
      this._maxNumberOfMessageEvents = value.maxNumberOfMessageEvents;
      this._probabilitySampler.internalValue = value.probabilitySampler;
      this._rateLimitingSampler.internalValue = value.rateLimitingSampler;
    }
  }

  // constant_sampler - computed: false, optional: true, required: false
  private _constantSampler = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerOutputReference(this, "constant_sampler");
  public get constantSampler() {
    return this._constantSampler;
  }
  public putConstantSampler(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler) {
    this._constantSampler.internalValue = value;
  }
  public resetConstantSampler() {
    this._constantSampler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get constantSamplerInput() {
    return this._constantSampler.internalValue;
  }

  // max_number_of_annotations - computed: false, optional: true, required: false
  private _maxNumberOfAnnotations?: number; 
  public get maxNumberOfAnnotations() {
    return this.getNumberAttribute('max_number_of_annotations');
  }
  public set maxNumberOfAnnotations(value: number) {
    this._maxNumberOfAnnotations = value;
  }
  public resetMaxNumberOfAnnotations() {
    this._maxNumberOfAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAnnotationsInput() {
    return this._maxNumberOfAnnotations;
  }

  // max_number_of_attributes - computed: false, optional: true, required: false
  private _maxNumberOfAttributes?: number; 
  public get maxNumberOfAttributes() {
    return this.getNumberAttribute('max_number_of_attributes');
  }
  public set maxNumberOfAttributes(value: number) {
    this._maxNumberOfAttributes = value;
  }
  public resetMaxNumberOfAttributes() {
    this._maxNumberOfAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAttributesInput() {
    return this._maxNumberOfAttributes;
  }

  // max_number_of_links - computed: false, optional: true, required: false
  private _maxNumberOfLinks?: number; 
  public get maxNumberOfLinks() {
    return this.getNumberAttribute('max_number_of_links');
  }
  public set maxNumberOfLinks(value: number) {
    this._maxNumberOfLinks = value;
  }
  public resetMaxNumberOfLinks() {
    this._maxNumberOfLinks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfLinksInput() {
    return this._maxNumberOfLinks;
  }

  // max_number_of_message_events - computed: false, optional: true, required: false
  private _maxNumberOfMessageEvents?: number; 
  public get maxNumberOfMessageEvents() {
    return this.getNumberAttribute('max_number_of_message_events');
  }
  public set maxNumberOfMessageEvents(value: number) {
    this._maxNumberOfMessageEvents = value;
  }
  public resetMaxNumberOfMessageEvents() {
    this._maxNumberOfMessageEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfMessageEventsInput() {
    return this._maxNumberOfMessageEvents;
  }

  // probability_sampler - computed: false, optional: true, required: false
  private _probabilitySampler = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerOutputReference(this, "probability_sampler");
  public get probabilitySampler() {
    return this._probabilitySampler;
  }
  public putProbabilitySampler(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler) {
    this._probabilitySampler.internalValue = value;
  }
  public resetProbabilitySampler() {
    this._probabilitySampler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get probabilitySamplerInput() {
    return this._probabilitySampler.internalValue;
  }

  // rate_limiting_sampler - computed: false, optional: true, required: false
  private _rateLimitingSampler = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerOutputReference(this, "rate_limiting_sampler");
  public get rateLimitingSampler() {
    return this._rateLimitingSampler;
  }
  public putRateLimitingSampler(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler) {
    this._rateLimitingSampler.internalValue = value;
  }
  public resetRateLimitingSampler() {
    this._rateLimitingSampler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rateLimitingSamplerInput() {
    return this._rateLimitingSampler.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_address}
  */
  readonly grpcAddress?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http_address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http_address}
  */
  readonly httpAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#incoming_trace_context DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#incoming_trace_context}
  */
  readonly incomingTraceContext?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ocagent_exporter_enabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ocagent_exporter_enabled}
  */
  readonly ocagentExporterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#outgoing_trace_context DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#outgoing_trace_context}
  */
  readonly outgoingTraceContext?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#trace_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#trace_config}
  */
  readonly traceConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_address: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToTerraform(struct!.grpcAddress),
    http_address: cdktf.stringToTerraform(struct!.httpAddress),
    incoming_trace_context: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.incomingTraceContext),
    ocagent_exporter_enabled: cdktf.booleanToTerraform(struct!.ocagentExporterEnabled),
    outgoing_trace_context: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.outgoingTraceContext),
    trace_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToTerraform(struct!.traceConfig),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_address: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToHclTerraform(struct!.grpcAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress",
    },
    http_address: {
      value: cdktf.stringToHclTerraform(struct!.httpAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    incoming_trace_context: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.incomingTraceContext),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ocagent_exporter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.ocagentExporterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    outgoing_trace_context: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.outgoingTraceContext),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    trace_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToHclTerraform(struct!.traceConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcAddress = this._grpcAddress?.internalValue;
    }
    if (this._httpAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpAddress = this._httpAddress;
    }
    if (this._incomingTraceContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.incomingTraceContext = this._incomingTraceContext;
    }
    if (this._ocagentExporterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocagentExporterEnabled = this._ocagentExporterEnabled;
    }
    if (this._outgoingTraceContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.outgoingTraceContext = this._outgoingTraceContext;
    }
    if (this._traceConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceConfig = this._traceConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcAddress.internalValue = undefined;
      this._httpAddress = undefined;
      this._incomingTraceContext = undefined;
      this._ocagentExporterEnabled = undefined;
      this._outgoingTraceContext = undefined;
      this._traceConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcAddress.internalValue = value.grpcAddress;
      this._httpAddress = value.httpAddress;
      this._incomingTraceContext = value.incomingTraceContext;
      this._ocagentExporterEnabled = value.ocagentExporterEnabled;
      this._outgoingTraceContext = value.outgoingTraceContext;
      this._traceConfig.internalValue = value.traceConfig;
    }
  }

  // grpc_address - computed: false, optional: true, required: false
  private _grpcAddress = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressOutputReference(this, "grpc_address");
  public get grpcAddress() {
    return this._grpcAddress;
  }
  public putGrpcAddress(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress) {
    this._grpcAddress.internalValue = value;
  }
  public resetGrpcAddress() {
    this._grpcAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcAddressInput() {
    return this._grpcAddress.internalValue;
  }

  // http_address - computed: false, optional: true, required: false
  private _httpAddress?: string; 
  public get httpAddress() {
    return this.getStringAttribute('http_address');
  }
  public set httpAddress(value: string) {
    this._httpAddress = value;
  }
  public resetHttpAddress() {
    this._httpAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpAddressInput() {
    return this._httpAddress;
  }

  // incoming_trace_context - computed: false, optional: true, required: false
  private _incomingTraceContext?: string[]; 
  public get incomingTraceContext() {
    return this.getListAttribute('incoming_trace_context');
  }
  public set incomingTraceContext(value: string[]) {
    this._incomingTraceContext = value;
  }
  public resetIncomingTraceContext() {
    this._incomingTraceContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get incomingTraceContextInput() {
    return this._incomingTraceContext;
  }

  // ocagent_exporter_enabled - computed: false, optional: true, required: false
  private _ocagentExporterEnabled?: boolean | cdktf.IResolvable; 
  public get ocagentExporterEnabled() {
    return this.getBooleanAttribute('ocagent_exporter_enabled');
  }
  public set ocagentExporterEnabled(value: boolean | cdktf.IResolvable) {
    this._ocagentExporterEnabled = value;
  }
  public resetOcagentExporterEnabled() {
    this._ocagentExporterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocagentExporterEnabledInput() {
    return this._ocagentExporterEnabled;
  }

  // outgoing_trace_context - computed: false, optional: true, required: false
  private _outgoingTraceContext?: string[]; 
  public get outgoingTraceContext() {
    return this.getListAttribute('outgoing_trace_context');
  }
  public set outgoingTraceContext(value: string[]) {
    this._outgoingTraceContext = value;
  }
  public resetOutgoingTraceContext() {
    this._outgoingTraceContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outgoingTraceContextInput() {
    return this._outgoingTraceContext;
  }

  // trace_config - computed: false, optional: true, required: false
  private _traceConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigOutputReference(this, "trace_config");
  public get traceConfig() {
    return this._traceConfig;
  }
  public putTraceConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig) {
    this._traceConfig.internalValue = value;
  }
  public resetTraceConfig() {
    this._traceConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceConfigInput() {
    return this._traceConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#collector_upstream_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#collector_upstream_ref}
  */
  readonly collectorUpstreamRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    collector_upstream_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToTerraform(struct!.collectorUpstreamRef),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_upstream_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToHclTerraform(struct!.collectorUpstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._collectorUpstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorUpstreamRef = this._collectorUpstreamRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterName = undefined;
      this._collectorUpstreamRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterName = value.clusterName;
      this._collectorUpstreamRef.internalValue = value.collectorUpstreamRef;
    }
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // collector_upstream_ref - computed: false, optional: true, required: false
  private _collectorUpstreamRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefOutputReference(this, "collector_upstream_ref");
  public get collectorUpstreamRef() {
    return this._collectorUpstreamRef;
  }
  public putCollectorUpstreamRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef) {
    this._collectorUpstreamRef.internalValue = value;
  }
  public resetCollectorUpstreamRef() {
    this._collectorUpstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorUpstreamRefInput() {
    return this._collectorUpstreamRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#client_sample_percentage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#client_sample_percentage}
  */
  readonly clientSamplePercentage?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#overall_sample_percentage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#overall_sample_percentage}
  */
  readonly overallSamplePercentage?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#random_sample_percentage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#random_sample_percentage}
  */
  readonly randomSamplePercentage?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_sample_percentage: cdktf.numberToTerraform(struct!.clientSamplePercentage),
    overall_sample_percentage: cdktf.numberToTerraform(struct!.overallSamplePercentage),
    random_sample_percentage: cdktf.numberToTerraform(struct!.randomSamplePercentage),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_sample_percentage: {
      value: cdktf.numberToHclTerraform(struct!.clientSamplePercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overall_sample_percentage: {
      value: cdktf.numberToHclTerraform(struct!.overallSamplePercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    random_sample_percentage: {
      value: cdktf.numberToHclTerraform(struct!.randomSamplePercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientSamplePercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSamplePercentage = this._clientSamplePercentage;
    }
    if (this._overallSamplePercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.overallSamplePercentage = this._overallSamplePercentage;
    }
    if (this._randomSamplePercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.randomSamplePercentage = this._randomSamplePercentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientSamplePercentage = undefined;
      this._overallSamplePercentage = undefined;
      this._randomSamplePercentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientSamplePercentage = value.clientSamplePercentage;
      this._overallSamplePercentage = value.overallSamplePercentage;
      this._randomSamplePercentage = value.randomSamplePercentage;
    }
  }

  // client_sample_percentage - computed: false, optional: true, required: false
  private _clientSamplePercentage?: number; 
  public get clientSamplePercentage() {
    return this.getNumberAttribute('client_sample_percentage');
  }
  public set clientSamplePercentage(value: number) {
    this._clientSamplePercentage = value;
  }
  public resetClientSamplePercentage() {
    this._clientSamplePercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSamplePercentageInput() {
    return this._clientSamplePercentage;
  }

  // overall_sample_percentage - computed: false, optional: true, required: false
  private _overallSamplePercentage?: number; 
  public get overallSamplePercentage() {
    return this.getNumberAttribute('overall_sample_percentage');
  }
  public set overallSamplePercentage(value: number) {
    this._overallSamplePercentage = value;
  }
  public resetOverallSamplePercentage() {
    this._overallSamplePercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overallSamplePercentageInput() {
    return this._overallSamplePercentage;
  }

  // random_sample_percentage - computed: false, optional: true, required: false
  private _randomSamplePercentage?: number; 
  public get randomSamplePercentage() {
    return this.getNumberAttribute('random_sample_percentage');
  }
  public set randomSamplePercentage(value: number) {
    this._randomSamplePercentage = value;
  }
  public resetRandomSamplePercentage() {
    this._randomSamplePercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get randomSamplePercentageInput() {
    return this._randomSamplePercentage;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#collector_endpoint DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#collector_endpoint}
  */
  readonly collectorEndpoint?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#collector_endpoint_version DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#collector_endpoint_version}
  */
  readonly collectorEndpointVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#collector_upstream_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#collector_upstream_ref}
  */
  readonly collectorUpstreamRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#shared_span_context DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#shared_span_context}
  */
  readonly sharedSpanContext?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#trace_id128bit DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#trace_id128bit}
  */
  readonly traceId128Bit?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    collector_endpoint: cdktf.stringToTerraform(struct!.collectorEndpoint),
    collector_endpoint_version: cdktf.stringToTerraform(struct!.collectorEndpointVersion),
    collector_upstream_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToTerraform(struct!.collectorUpstreamRef),
    shared_span_context: cdktf.booleanToTerraform(struct!.sharedSpanContext),
    trace_id128bit: cdktf.booleanToTerraform(struct!.traceId128Bit),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.collectorEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_endpoint_version: {
      value: cdktf.stringToHclTerraform(struct!.collectorEndpointVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_upstream_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToHclTerraform(struct!.collectorUpstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef",
    },
    shared_span_context: {
      value: cdktf.booleanToHclTerraform(struct!.sharedSpanContext),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    trace_id128bit: {
      value: cdktf.booleanToHclTerraform(struct!.traceId128Bit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._collectorEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorEndpoint = this._collectorEndpoint;
    }
    if (this._collectorEndpointVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorEndpointVersion = this._collectorEndpointVersion;
    }
    if (this._collectorUpstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorUpstreamRef = this._collectorUpstreamRef?.internalValue;
    }
    if (this._sharedSpanContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedSpanContext = this._sharedSpanContext;
    }
    if (this._traceId128Bit !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceId128Bit = this._traceId128Bit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterName = undefined;
      this._collectorEndpoint = undefined;
      this._collectorEndpointVersion = undefined;
      this._collectorUpstreamRef.internalValue = undefined;
      this._sharedSpanContext = undefined;
      this._traceId128Bit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterName = value.clusterName;
      this._collectorEndpoint = value.collectorEndpoint;
      this._collectorEndpointVersion = value.collectorEndpointVersion;
      this._collectorUpstreamRef.internalValue = value.collectorUpstreamRef;
      this._sharedSpanContext = value.sharedSpanContext;
      this._traceId128Bit = value.traceId128Bit;
    }
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // collector_endpoint - computed: false, optional: true, required: false
  private _collectorEndpoint?: string; 
  public get collectorEndpoint() {
    return this.getStringAttribute('collector_endpoint');
  }
  public set collectorEndpoint(value: string) {
    this._collectorEndpoint = value;
  }
  public resetCollectorEndpoint() {
    this._collectorEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorEndpointInput() {
    return this._collectorEndpoint;
  }

  // collector_endpoint_version - computed: false, optional: true, required: false
  private _collectorEndpointVersion?: string; 
  public get collectorEndpointVersion() {
    return this.getStringAttribute('collector_endpoint_version');
  }
  public set collectorEndpointVersion(value: string) {
    this._collectorEndpointVersion = value;
  }
  public resetCollectorEndpointVersion() {
    this._collectorEndpointVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorEndpointVersionInput() {
    return this._collectorEndpointVersion;
  }

  // collector_upstream_ref - computed: false, optional: true, required: false
  private _collectorUpstreamRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefOutputReference(this, "collector_upstream_ref");
  public get collectorUpstreamRef() {
    return this._collectorUpstreamRef;
  }
  public putCollectorUpstreamRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef) {
    this._collectorUpstreamRef.internalValue = value;
  }
  public resetCollectorUpstreamRef() {
    this._collectorUpstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorUpstreamRefInput() {
    return this._collectorUpstreamRef.internalValue;
  }

  // shared_span_context - computed: false, optional: true, required: false
  private _sharedSpanContext?: boolean | cdktf.IResolvable; 
  public get sharedSpanContext() {
    return this.getBooleanAttribute('shared_span_context');
  }
  public set sharedSpanContext(value: boolean | cdktf.IResolvable) {
    this._sharedSpanContext = value;
  }
  public resetSharedSpanContext() {
    this._sharedSpanContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedSpanContextInput() {
    return this._sharedSpanContext;
  }

  // trace_id128bit - computed: false, optional: true, required: false
  private _traceId128Bit?: boolean | cdktf.IResolvable; 
  public get traceId128Bit() {
    return this.getBooleanAttribute('trace_id128bit');
  }
  public set traceId128Bit(value: boolean | cdktf.IResolvable) {
    this._traceId128Bit = value;
  }
  public resetTraceId128Bit() {
    this._traceId128Bit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceId128BitInput() {
    return this._traceId128Bit;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#datadog_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#datadog_config}
  */
  readonly datadogConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#environment_variables_for_tags DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#environment_variables_for_tags}
  */
  readonly environmentVariablesForTags?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#literals_for_tags DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#literals_for_tags}
  */
  readonly literalsForTags?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#open_census_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#open_census_config}
  */
  readonly openCensusConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#open_telemetry_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#open_telemetry_config}
  */
  readonly openTelemetryConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_headers_for_tags DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_headers_for_tags}
  */
  readonly requestHeadersForTags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#trace_percentages DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#trace_percentages}
  */
  readonly tracePercentages?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#verbose DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#verbose}
  */
  readonly verbose?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#zipkin_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#zipkin_config}
  */
  readonly zipkinConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datadog_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToTerraform(struct!.datadogConfig),
    environment_variables_for_tags: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToTerraform, false)(struct!.environmentVariablesForTags),
    literals_for_tags: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToTerraform, false)(struct!.literalsForTags),
    open_census_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToTerraform(struct!.openCensusConfig),
    open_telemetry_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToTerraform(struct!.openTelemetryConfig),
    request_headers_for_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestHeadersForTags),
    trace_percentages: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToTerraform(struct!.tracePercentages),
    verbose: cdktf.booleanToTerraform(struct!.verbose),
    zipkin_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToTerraform(struct!.zipkinConfig),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datadog_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToHclTerraform(struct!.datadogConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig",
    },
    environment_variables_for_tags: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToHclTerraform, false)(struct!.environmentVariablesForTags),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsList",
    },
    literals_for_tags: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToHclTerraform, false)(struct!.literalsForTags),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsList",
    },
    open_census_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToHclTerraform(struct!.openCensusConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig",
    },
    open_telemetry_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToHclTerraform(struct!.openTelemetryConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig",
    },
    request_headers_for_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestHeadersForTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    trace_percentages: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToHclTerraform(struct!.tracePercentages),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages",
    },
    verbose: {
      value: cdktf.booleanToHclTerraform(struct!.verbose),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    zipkin_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToHclTerraform(struct!.zipkinConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datadogConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datadogConfig = this._datadogConfig?.internalValue;
    }
    if (this._environmentVariablesForTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentVariablesForTags = this._environmentVariablesForTags?.internalValue;
    }
    if (this._literalsForTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.literalsForTags = this._literalsForTags?.internalValue;
    }
    if (this._openCensusConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openCensusConfig = this._openCensusConfig?.internalValue;
    }
    if (this._openTelemetryConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openTelemetryConfig = this._openTelemetryConfig?.internalValue;
    }
    if (this._requestHeadersForTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersForTags = this._requestHeadersForTags;
    }
    if (this._tracePercentages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracePercentages = this._tracePercentages?.internalValue;
    }
    if (this._verbose !== undefined) {
      hasAnyValues = true;
      internalValueResult.verbose = this._verbose;
    }
    if (this._zipkinConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zipkinConfig = this._zipkinConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datadogConfig.internalValue = undefined;
      this._environmentVariablesForTags.internalValue = undefined;
      this._literalsForTags.internalValue = undefined;
      this._openCensusConfig.internalValue = undefined;
      this._openTelemetryConfig.internalValue = undefined;
      this._requestHeadersForTags = undefined;
      this._tracePercentages.internalValue = undefined;
      this._verbose = undefined;
      this._zipkinConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datadogConfig.internalValue = value.datadogConfig;
      this._environmentVariablesForTags.internalValue = value.environmentVariablesForTags;
      this._literalsForTags.internalValue = value.literalsForTags;
      this._openCensusConfig.internalValue = value.openCensusConfig;
      this._openTelemetryConfig.internalValue = value.openTelemetryConfig;
      this._requestHeadersForTags = value.requestHeadersForTags;
      this._tracePercentages.internalValue = value.tracePercentages;
      this._verbose = value.verbose;
      this._zipkinConfig.internalValue = value.zipkinConfig;
    }
  }

  // datadog_config - computed: false, optional: true, required: false
  private _datadogConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigOutputReference(this, "datadog_config");
  public get datadogConfig() {
    return this._datadogConfig;
  }
  public putDatadogConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig) {
    this._datadogConfig.internalValue = value;
  }
  public resetDatadogConfig() {
    this._datadogConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datadogConfigInput() {
    return this._datadogConfig.internalValue;
  }

  // environment_variables_for_tags - computed: false, optional: true, required: false
  private _environmentVariablesForTags = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsList(this, "environment_variables_for_tags", false);
  public get environmentVariablesForTags() {
    return this._environmentVariablesForTags;
  }
  public putEnvironmentVariablesForTags(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags[] | cdktf.IResolvable) {
    this._environmentVariablesForTags.internalValue = value;
  }
  public resetEnvironmentVariablesForTags() {
    this._environmentVariablesForTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentVariablesForTagsInput() {
    return this._environmentVariablesForTags.internalValue;
  }

  // literals_for_tags - computed: false, optional: true, required: false
  private _literalsForTags = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsList(this, "literals_for_tags", false);
  public get literalsForTags() {
    return this._literalsForTags;
  }
  public putLiteralsForTags(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags[] | cdktf.IResolvable) {
    this._literalsForTags.internalValue = value;
  }
  public resetLiteralsForTags() {
    this._literalsForTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get literalsForTagsInput() {
    return this._literalsForTags.internalValue;
  }

  // open_census_config - computed: false, optional: true, required: false
  private _openCensusConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigOutputReference(this, "open_census_config");
  public get openCensusConfig() {
    return this._openCensusConfig;
  }
  public putOpenCensusConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig) {
    this._openCensusConfig.internalValue = value;
  }
  public resetOpenCensusConfig() {
    this._openCensusConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openCensusConfigInput() {
    return this._openCensusConfig.internalValue;
  }

  // open_telemetry_config - computed: false, optional: true, required: false
  private _openTelemetryConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigOutputReference(this, "open_telemetry_config");
  public get openTelemetryConfig() {
    return this._openTelemetryConfig;
  }
  public putOpenTelemetryConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig) {
    this._openTelemetryConfig.internalValue = value;
  }
  public resetOpenTelemetryConfig() {
    this._openTelemetryConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openTelemetryConfigInput() {
    return this._openTelemetryConfig.internalValue;
  }

  // request_headers_for_tags - computed: false, optional: true, required: false
  private _requestHeadersForTags?: string[]; 
  public get requestHeadersForTags() {
    return this.getListAttribute('request_headers_for_tags');
  }
  public set requestHeadersForTags(value: string[]) {
    this._requestHeadersForTags = value;
  }
  public resetRequestHeadersForTags() {
    this._requestHeadersForTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersForTagsInput() {
    return this._requestHeadersForTags;
  }

  // trace_percentages - computed: false, optional: true, required: false
  private _tracePercentages = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesOutputReference(this, "trace_percentages");
  public get tracePercentages() {
    return this._tracePercentages;
  }
  public putTracePercentages(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages) {
    this._tracePercentages.internalValue = value;
  }
  public resetTracePercentages() {
    this._tracePercentages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracePercentagesInput() {
    return this._tracePercentages.internalValue;
  }

  // verbose - computed: false, optional: true, required: false
  private _verbose?: boolean | cdktf.IResolvable; 
  public get verbose() {
    return this.getBooleanAttribute('verbose');
  }
  public set verbose(value: boolean | cdktf.IResolvable) {
    this._verbose = value;
  }
  public resetVerbose() {
    this._verbose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verboseInput() {
    return this._verbose;
  }

  // zipkin_config - computed: false, optional: true, required: false
  private _zipkinConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigOutputReference(this, "zipkin_config");
  public get zipkinConfig() {
    return this._zipkinConfig;
  }
  public putZipkinConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig) {
    this._zipkinConfig.internalValue = value;
  }
  public resetZipkinConfig() {
    this._zipkinConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zipkinConfigInput() {
    return this._zipkinConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#enabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#enabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#connect DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#connect}
  */
  readonly connect?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#websocket DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#websocket}
  */
  readonly websocket?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToTerraform(struct!.connect),
    websocket: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToTerraform(struct!.websocket),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToHclTerraform(struct!.connect),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect",
    },
    websocket: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToHclTerraform(struct!.websocket),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connect = this._connect?.internalValue;
    }
    if (this._websocket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.websocket = this._websocket?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connect.internalValue = undefined;
      this._websocket.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connect.internalValue = value.connect;
      this._websocket.internalValue = value.websocket;
    }
  }

  // connect - computed: false, optional: true, required: false
  private _connect = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectOutputReference(this, "connect");
  public get connect() {
    return this._connect;
  }
  public putConnect(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect) {
    this._connect.internalValue = value;
  }
  public resetConnect() {
    this._connect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectInput() {
    return this._connect.internalValue;
  }

  // websocket - computed: false, optional: true, required: false
  private _websocket = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketOutputReference(this, "websocket");
  public get websocket() {
    return this._websocket;
  }
  public putWebsocket(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket) {
    this._websocket.internalValue = value;
  }
  public resetWebsocket() {
    this._websocket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get websocketInput() {
    return this._websocket.internalValue;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#pack_trace_reason DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#pack_trace_reason}
  */
  readonly packTraceReason?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#use_request_id_for_trace_sampling DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#use_request_id_for_trace_sampling}
  */
  readonly useRequestIdForTraceSampling?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pack_trace_reason: cdktf.booleanToTerraform(struct!.packTraceReason),
    use_request_id_for_trace_sampling: cdktf.booleanToTerraform(struct!.useRequestIdForTraceSampling),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pack_trace_reason: {
      value: cdktf.booleanToHclTerraform(struct!.packTraceReason),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_request_id_for_trace_sampling: {
      value: cdktf.booleanToHclTerraform(struct!.useRequestIdForTraceSampling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._packTraceReason !== undefined) {
      hasAnyValues = true;
      internalValueResult.packTraceReason = this._packTraceReason;
    }
    if (this._useRequestIdForTraceSampling !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRequestIdForTraceSampling = this._useRequestIdForTraceSampling;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._packTraceReason = undefined;
      this._useRequestIdForTraceSampling = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._packTraceReason = value.packTraceReason;
      this._useRequestIdForTraceSampling = value.useRequestIdForTraceSampling;
    }
  }

  // pack_trace_reason - computed: false, optional: true, required: false
  private _packTraceReason?: boolean | cdktf.IResolvable; 
  public get packTraceReason() {
    return this.getBooleanAttribute('pack_trace_reason');
  }
  public set packTraceReason(value: boolean | cdktf.IResolvable) {
    this._packTraceReason = value;
  }
  public resetPackTraceReason() {
    this._packTraceReason = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packTraceReasonInput() {
    return this._packTraceReason;
  }

  // use_request_id_for_trace_sampling - computed: false, optional: true, required: false
  private _useRequestIdForTraceSampling?: boolean | cdktf.IResolvable; 
  public get useRequestIdForTraceSampling() {
    return this.getBooleanAttribute('use_request_id_for_trace_sampling');
  }
  public set useRequestIdForTraceSampling(value: boolean | cdktf.IResolvable) {
    this._useRequestIdForTraceSampling = value;
  }
  public resetUseRequestIdForTraceSampling() {
    this._useRequestIdForTraceSampling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRequestIdForTraceSamplingInput() {
    return this._useRequestIdForTraceSampling;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#accept_http10 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#accept_http10}
  */
  readonly acceptHttp10?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#allow_chunked_length DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#allow_chunked_length}
  */
  readonly allowChunkedLength?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#append_x_forwarded_port DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#append_x_forwarded_port}
  */
  readonly appendXForwardedPort?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#codec_type DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#codec_type}
  */
  readonly codecType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#default_host_for_http10 DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#default_host_for_http10}
  */
  readonly defaultHostForHttp10?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#delayed_close_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#delayed_close_timeout}
  */
  readonly delayedCloseTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#drain_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#drain_timeout}
  */
  readonly drainTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#enable_trailers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#enable_trailers}
  */
  readonly enableTrailers?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#forward_client_cert_details DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#forward_client_cert_details}
  */
  readonly forwardClientCertDetails?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#generate_request_id DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#generate_request_id}
  */
  readonly generateRequestId?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#headers_with_underscores_action DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#headers_with_underscores_action}
  */
  readonly headersWithUnderscoresAction?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http2_protocol_options DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http2_protocol_options}
  */
  readonly http2ProtocolOptions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#idle_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#idle_timeout}
  */
  readonly idleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#internal_address_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#internal_address_config}
  */
  readonly internalAddressConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_connection_duration DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_connection_duration}
  */
  readonly maxConnectionDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_headers_count DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_headers_count}
  */
  readonly maxHeadersCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_request_headers_kb DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_request_headers_kb}
  */
  readonly maxRequestHeadersKb?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_requests_per_connection DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_requests_per_connection}
  */
  readonly maxRequestsPerConnection?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_stream_duration DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_stream_duration}
  */
  readonly maxStreamDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#merge_slashes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#merge_slashes}
  */
  readonly mergeSlashes?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#normalize_path DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#normalize_path}
  */
  readonly normalizePath?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#path_with_escaped_slashes_action DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#path_with_escaped_slashes_action}
  */
  readonly pathWithEscapedSlashesAction?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#preserve_case_header_key_format DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#preserve_case_header_key_format}
  */
  readonly preserveCaseHeaderKeyFormat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#preserve_external_request_id DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#preserve_external_request_id}
  */
  readonly preserveExternalRequestId?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#proper_case_header_key_format DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#proper_case_header_key_format}
  */
  readonly properCaseHeaderKeyFormat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#proxy100_continue DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#proxy100_continue}
  */
  readonly proxy100Continue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_headers_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_headers_timeout}
  */
  readonly requestHeadersTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#server_header_transformation DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#server_header_transformation}
  */
  readonly serverHeaderTransformation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#server_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#server_name}
  */
  readonly serverName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#set_current_client_cert_details DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#set_current_client_cert_details}
  */
  readonly setCurrentClientCertDetails?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#skip_xff_append DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#skip_xff_append}
  */
  readonly skipXffAppend?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stream_idle_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stream_idle_timeout}
  */
  readonly streamIdleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#strip_any_host_port DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#strip_any_host_port}
  */
  readonly stripAnyHostPort?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tracing DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tracing}
  */
  readonly tracing?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#upgrades DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#upgrades}
  */
  readonly upgrades?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#use_remote_address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#use_remote_address}
  */
  readonly useRemoteAddress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#uuid_request_id_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#uuid_request_id_config}
  */
  readonly uuidRequestIdConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#via DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#via}
  */
  readonly via?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#xff_num_trusted_hops DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#xff_num_trusted_hops}
  */
  readonly xffNumTrustedHops?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    accept_http10: cdktf.booleanToTerraform(struct!.acceptHttp10),
    allow_chunked_length: cdktf.booleanToTerraform(struct!.allowChunkedLength),
    append_x_forwarded_port: cdktf.booleanToTerraform(struct!.appendXForwardedPort),
    codec_type: cdktf.stringToTerraform(struct!.codecType),
    default_host_for_http10: cdktf.stringToTerraform(struct!.defaultHostForHttp10),
    delayed_close_timeout: cdktf.stringToTerraform(struct!.delayedCloseTimeout),
    drain_timeout: cdktf.stringToTerraform(struct!.drainTimeout),
    enable_trailers: cdktf.booleanToTerraform(struct!.enableTrailers),
    forward_client_cert_details: cdktf.stringToTerraform(struct!.forwardClientCertDetails),
    generate_request_id: cdktf.booleanToTerraform(struct!.generateRequestId),
    headers_with_underscores_action: cdktf.stringToTerraform(struct!.headersWithUnderscoresAction),
    http2_protocol_options: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToTerraform(struct!.http2ProtocolOptions),
    idle_timeout: cdktf.stringToTerraform(struct!.idleTimeout),
    internal_address_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToTerraform(struct!.internalAddressConfig),
    max_connection_duration: cdktf.stringToTerraform(struct!.maxConnectionDuration),
    max_headers_count: cdktf.numberToTerraform(struct!.maxHeadersCount),
    max_request_headers_kb: cdktf.numberToTerraform(struct!.maxRequestHeadersKb),
    max_requests_per_connection: cdktf.numberToTerraform(struct!.maxRequestsPerConnection),
    max_stream_duration: cdktf.stringToTerraform(struct!.maxStreamDuration),
    merge_slashes: cdktf.booleanToTerraform(struct!.mergeSlashes),
    normalize_path: cdktf.booleanToTerraform(struct!.normalizePath),
    path_with_escaped_slashes_action: cdktf.stringToTerraform(struct!.pathWithEscapedSlashesAction),
    preserve_case_header_key_format: cdktf.booleanToTerraform(struct!.preserveCaseHeaderKeyFormat),
    preserve_external_request_id: cdktf.booleanToTerraform(struct!.preserveExternalRequestId),
    proper_case_header_key_format: cdktf.booleanToTerraform(struct!.properCaseHeaderKeyFormat),
    proxy100_continue: cdktf.booleanToTerraform(struct!.proxy100Continue),
    request_headers_timeout: cdktf.stringToTerraform(struct!.requestHeadersTimeout),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
    server_header_transformation: cdktf.stringToTerraform(struct!.serverHeaderTransformation),
    server_name: cdktf.stringToTerraform(struct!.serverName),
    set_current_client_cert_details: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToTerraform(struct!.setCurrentClientCertDetails),
    skip_xff_append: cdktf.booleanToTerraform(struct!.skipXffAppend),
    stream_idle_timeout: cdktf.stringToTerraform(struct!.streamIdleTimeout),
    strip_any_host_port: cdktf.booleanToTerraform(struct!.stripAnyHostPort),
    tracing: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingToTerraform(struct!.tracing),
    upgrades: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToTerraform, false)(struct!.upgrades),
    use_remote_address: cdktf.booleanToTerraform(struct!.useRemoteAddress),
    uuid_request_id_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToTerraform(struct!.uuidRequestIdConfig),
    via: cdktf.stringToTerraform(struct!.via),
    xff_num_trusted_hops: cdktf.numberToTerraform(struct!.xffNumTrustedHops),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    accept_http10: {
      value: cdktf.booleanToHclTerraform(struct!.acceptHttp10),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_chunked_length: {
      value: cdktf.booleanToHclTerraform(struct!.allowChunkedLength),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    append_x_forwarded_port: {
      value: cdktf.booleanToHclTerraform(struct!.appendXForwardedPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    codec_type: {
      value: cdktf.stringToHclTerraform(struct!.codecType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_host_for_http10: {
      value: cdktf.stringToHclTerraform(struct!.defaultHostForHttp10),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delayed_close_timeout: {
      value: cdktf.stringToHclTerraform(struct!.delayedCloseTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    drain_timeout: {
      value: cdktf.stringToHclTerraform(struct!.drainTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_trailers: {
      value: cdktf.booleanToHclTerraform(struct!.enableTrailers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    forward_client_cert_details: {
      value: cdktf.stringToHclTerraform(struct!.forwardClientCertDetails),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    generate_request_id: {
      value: cdktf.booleanToHclTerraform(struct!.generateRequestId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers_with_underscores_action: {
      value: cdktf.stringToHclTerraform(struct!.headersWithUnderscoresAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http2_protocol_options: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToHclTerraform(struct!.http2ProtocolOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions",
    },
    idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.idleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    internal_address_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToHclTerraform(struct!.internalAddressConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig",
    },
    max_connection_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxConnectionDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_headers_count: {
      value: cdktf.numberToHclTerraform(struct!.maxHeadersCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_request_headers_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestHeadersKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_connection: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_stream_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxStreamDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    merge_slashes: {
      value: cdktf.booleanToHclTerraform(struct!.mergeSlashes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normalize_path: {
      value: cdktf.booleanToHclTerraform(struct!.normalizePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    path_with_escaped_slashes_action: {
      value: cdktf.stringToHclTerraform(struct!.pathWithEscapedSlashesAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preserve_case_header_key_format: {
      value: cdktf.booleanToHclTerraform(struct!.preserveCaseHeaderKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_external_request_id: {
      value: cdktf.booleanToHclTerraform(struct!.preserveExternalRequestId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proper_case_header_key_format: {
      value: cdktf.booleanToHclTerraform(struct!.properCaseHeaderKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy100_continue: {
      value: cdktf.booleanToHclTerraform(struct!.proxy100Continue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_headers_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestHeadersTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_header_transformation: {
      value: cdktf.stringToHclTerraform(struct!.serverHeaderTransformation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set_current_client_cert_details: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToHclTerraform(struct!.setCurrentClientCertDetails),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails",
    },
    skip_xff_append: {
      value: cdktf.booleanToHclTerraform(struct!.skipXffAppend),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stream_idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.streamIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    strip_any_host_port: {
      value: cdktf.booleanToHclTerraform(struct!.stripAnyHostPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tracing: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingToHclTerraform(struct!.tracing),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing",
    },
    upgrades: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToHclTerraform, false)(struct!.upgrades),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesList",
    },
    use_remote_address: {
      value: cdktf.booleanToHclTerraform(struct!.useRemoteAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    uuid_request_id_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToHclTerraform(struct!.uuidRequestIdConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig",
    },
    via: {
      value: cdktf.stringToHclTerraform(struct!.via),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xff_num_trusted_hops: {
      value: cdktf.numberToHclTerraform(struct!.xffNumTrustedHops),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acceptHttp10 !== undefined) {
      hasAnyValues = true;
      internalValueResult.acceptHttp10 = this._acceptHttp10;
    }
    if (this._allowChunkedLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowChunkedLength = this._allowChunkedLength;
    }
    if (this._appendXForwardedPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.appendXForwardedPort = this._appendXForwardedPort;
    }
    if (this._codecType !== undefined) {
      hasAnyValues = true;
      internalValueResult.codecType = this._codecType;
    }
    if (this._defaultHostForHttp10 !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultHostForHttp10 = this._defaultHostForHttp10;
    }
    if (this._delayedCloseTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.delayedCloseTimeout = this._delayedCloseTimeout;
    }
    if (this._drainTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainTimeout = this._drainTimeout;
    }
    if (this._enableTrailers !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableTrailers = this._enableTrailers;
    }
    if (this._forwardClientCertDetails !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardClientCertDetails = this._forwardClientCertDetails;
    }
    if (this._generateRequestId !== undefined) {
      hasAnyValues = true;
      internalValueResult.generateRequestId = this._generateRequestId;
    }
    if (this._headersWithUnderscoresAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersWithUnderscoresAction = this._headersWithUnderscoresAction;
    }
    if (this._http2ProtocolOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http2ProtocolOptions = this._http2ProtocolOptions?.internalValue;
    }
    if (this._idleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleTimeout = this._idleTimeout;
    }
    if (this._internalAddressConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalAddressConfig = this._internalAddressConfig?.internalValue;
    }
    if (this._maxConnectionDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnectionDuration = this._maxConnectionDuration;
    }
    if (this._maxHeadersCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxHeadersCount = this._maxHeadersCount;
    }
    if (this._maxRequestHeadersKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestHeadersKb = this._maxRequestHeadersKb;
    }
    if (this._maxRequestsPerConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerConnection = this._maxRequestsPerConnection;
    }
    if (this._maxStreamDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxStreamDuration = this._maxStreamDuration;
    }
    if (this._mergeSlashes !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeSlashes = this._mergeSlashes;
    }
    if (this._normalizePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalizePath = this._normalizePath;
    }
    if (this._pathWithEscapedSlashesAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathWithEscapedSlashesAction = this._pathWithEscapedSlashesAction;
    }
    if (this._preserveCaseHeaderKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveCaseHeaderKeyFormat = this._preserveCaseHeaderKeyFormat;
    }
    if (this._preserveExternalRequestId !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveExternalRequestId = this._preserveExternalRequestId;
    }
    if (this._properCaseHeaderKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.properCaseHeaderKeyFormat = this._properCaseHeaderKeyFormat;
    }
    if (this._proxy100Continue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy100Continue = this._proxy100Continue;
    }
    if (this._requestHeadersTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersTimeout = this._requestHeadersTimeout;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._serverHeaderTransformation !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverHeaderTransformation = this._serverHeaderTransformation;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    if (this._setCurrentClientCertDetails?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setCurrentClientCertDetails = this._setCurrentClientCertDetails?.internalValue;
    }
    if (this._skipXffAppend !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipXffAppend = this._skipXffAppend;
    }
    if (this._streamIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamIdleTimeout = this._streamIdleTimeout;
    }
    if (this._stripAnyHostPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.stripAnyHostPort = this._stripAnyHostPort;
    }
    if (this._tracing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracing = this._tracing?.internalValue;
    }
    if (this._upgrades?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upgrades = this._upgrades?.internalValue;
    }
    if (this._useRemoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRemoteAddress = this._useRemoteAddress;
    }
    if (this._uuidRequestIdConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.uuidRequestIdConfig = this._uuidRequestIdConfig?.internalValue;
    }
    if (this._via !== undefined) {
      hasAnyValues = true;
      internalValueResult.via = this._via;
    }
    if (this._xffNumTrustedHops !== undefined) {
      hasAnyValues = true;
      internalValueResult.xffNumTrustedHops = this._xffNumTrustedHops;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acceptHttp10 = undefined;
      this._allowChunkedLength = undefined;
      this._appendXForwardedPort = undefined;
      this._codecType = undefined;
      this._defaultHostForHttp10 = undefined;
      this._delayedCloseTimeout = undefined;
      this._drainTimeout = undefined;
      this._enableTrailers = undefined;
      this._forwardClientCertDetails = undefined;
      this._generateRequestId = undefined;
      this._headersWithUnderscoresAction = undefined;
      this._http2ProtocolOptions.internalValue = undefined;
      this._idleTimeout = undefined;
      this._internalAddressConfig.internalValue = undefined;
      this._maxConnectionDuration = undefined;
      this._maxHeadersCount = undefined;
      this._maxRequestHeadersKb = undefined;
      this._maxRequestsPerConnection = undefined;
      this._maxStreamDuration = undefined;
      this._mergeSlashes = undefined;
      this._normalizePath = undefined;
      this._pathWithEscapedSlashesAction = undefined;
      this._preserveCaseHeaderKeyFormat = undefined;
      this._preserveExternalRequestId = undefined;
      this._properCaseHeaderKeyFormat = undefined;
      this._proxy100Continue = undefined;
      this._requestHeadersTimeout = undefined;
      this._requestTimeout = undefined;
      this._serverHeaderTransformation = undefined;
      this._serverName = undefined;
      this._setCurrentClientCertDetails.internalValue = undefined;
      this._skipXffAppend = undefined;
      this._streamIdleTimeout = undefined;
      this._stripAnyHostPort = undefined;
      this._tracing.internalValue = undefined;
      this._upgrades.internalValue = undefined;
      this._useRemoteAddress = undefined;
      this._uuidRequestIdConfig.internalValue = undefined;
      this._via = undefined;
      this._xffNumTrustedHops = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acceptHttp10 = value.acceptHttp10;
      this._allowChunkedLength = value.allowChunkedLength;
      this._appendXForwardedPort = value.appendXForwardedPort;
      this._codecType = value.codecType;
      this._defaultHostForHttp10 = value.defaultHostForHttp10;
      this._delayedCloseTimeout = value.delayedCloseTimeout;
      this._drainTimeout = value.drainTimeout;
      this._enableTrailers = value.enableTrailers;
      this._forwardClientCertDetails = value.forwardClientCertDetails;
      this._generateRequestId = value.generateRequestId;
      this._headersWithUnderscoresAction = value.headersWithUnderscoresAction;
      this._http2ProtocolOptions.internalValue = value.http2ProtocolOptions;
      this._idleTimeout = value.idleTimeout;
      this._internalAddressConfig.internalValue = value.internalAddressConfig;
      this._maxConnectionDuration = value.maxConnectionDuration;
      this._maxHeadersCount = value.maxHeadersCount;
      this._maxRequestHeadersKb = value.maxRequestHeadersKb;
      this._maxRequestsPerConnection = value.maxRequestsPerConnection;
      this._maxStreamDuration = value.maxStreamDuration;
      this._mergeSlashes = value.mergeSlashes;
      this._normalizePath = value.normalizePath;
      this._pathWithEscapedSlashesAction = value.pathWithEscapedSlashesAction;
      this._preserveCaseHeaderKeyFormat = value.preserveCaseHeaderKeyFormat;
      this._preserveExternalRequestId = value.preserveExternalRequestId;
      this._properCaseHeaderKeyFormat = value.properCaseHeaderKeyFormat;
      this._proxy100Continue = value.proxy100Continue;
      this._requestHeadersTimeout = value.requestHeadersTimeout;
      this._requestTimeout = value.requestTimeout;
      this._serverHeaderTransformation = value.serverHeaderTransformation;
      this._serverName = value.serverName;
      this._setCurrentClientCertDetails.internalValue = value.setCurrentClientCertDetails;
      this._skipXffAppend = value.skipXffAppend;
      this._streamIdleTimeout = value.streamIdleTimeout;
      this._stripAnyHostPort = value.stripAnyHostPort;
      this._tracing.internalValue = value.tracing;
      this._upgrades.internalValue = value.upgrades;
      this._useRemoteAddress = value.useRemoteAddress;
      this._uuidRequestIdConfig.internalValue = value.uuidRequestIdConfig;
      this._via = value.via;
      this._xffNumTrustedHops = value.xffNumTrustedHops;
    }
  }

  // accept_http10 - computed: false, optional: true, required: false
  private _acceptHttp10?: boolean | cdktf.IResolvable; 
  public get acceptHttp10() {
    return this.getBooleanAttribute('accept_http10');
  }
  public set acceptHttp10(value: boolean | cdktf.IResolvable) {
    this._acceptHttp10 = value;
  }
  public resetAcceptHttp10() {
    this._acceptHttp10 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acceptHttp10Input() {
    return this._acceptHttp10;
  }

  // allow_chunked_length - computed: false, optional: true, required: false
  private _allowChunkedLength?: boolean | cdktf.IResolvable; 
  public get allowChunkedLength() {
    return this.getBooleanAttribute('allow_chunked_length');
  }
  public set allowChunkedLength(value: boolean | cdktf.IResolvable) {
    this._allowChunkedLength = value;
  }
  public resetAllowChunkedLength() {
    this._allowChunkedLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowChunkedLengthInput() {
    return this._allowChunkedLength;
  }

  // append_x_forwarded_port - computed: false, optional: true, required: false
  private _appendXForwardedPort?: boolean | cdktf.IResolvable; 
  public get appendXForwardedPort() {
    return this.getBooleanAttribute('append_x_forwarded_port');
  }
  public set appendXForwardedPort(value: boolean | cdktf.IResolvable) {
    this._appendXForwardedPort = value;
  }
  public resetAppendXForwardedPort() {
    this._appendXForwardedPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendXForwardedPortInput() {
    return this._appendXForwardedPort;
  }

  // codec_type - computed: false, optional: true, required: false
  private _codecType?: string; 
  public get codecType() {
    return this.getStringAttribute('codec_type');
  }
  public set codecType(value: string) {
    this._codecType = value;
  }
  public resetCodecType() {
    this._codecType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codecTypeInput() {
    return this._codecType;
  }

  // default_host_for_http10 - computed: false, optional: true, required: false
  private _defaultHostForHttp10?: string; 
  public get defaultHostForHttp10() {
    return this.getStringAttribute('default_host_for_http10');
  }
  public set defaultHostForHttp10(value: string) {
    this._defaultHostForHttp10 = value;
  }
  public resetDefaultHostForHttp10() {
    this._defaultHostForHttp10 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultHostForHttp10Input() {
    return this._defaultHostForHttp10;
  }

  // delayed_close_timeout - computed: false, optional: true, required: false
  private _delayedCloseTimeout?: string; 
  public get delayedCloseTimeout() {
    return this.getStringAttribute('delayed_close_timeout');
  }
  public set delayedCloseTimeout(value: string) {
    this._delayedCloseTimeout = value;
  }
  public resetDelayedCloseTimeout() {
    this._delayedCloseTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayedCloseTimeoutInput() {
    return this._delayedCloseTimeout;
  }

  // drain_timeout - computed: false, optional: true, required: false
  private _drainTimeout?: string; 
  public get drainTimeout() {
    return this.getStringAttribute('drain_timeout');
  }
  public set drainTimeout(value: string) {
    this._drainTimeout = value;
  }
  public resetDrainTimeout() {
    this._drainTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainTimeoutInput() {
    return this._drainTimeout;
  }

  // enable_trailers - computed: false, optional: true, required: false
  private _enableTrailers?: boolean | cdktf.IResolvable; 
  public get enableTrailers() {
    return this.getBooleanAttribute('enable_trailers');
  }
  public set enableTrailers(value: boolean | cdktf.IResolvable) {
    this._enableTrailers = value;
  }
  public resetEnableTrailers() {
    this._enableTrailers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableTrailersInput() {
    return this._enableTrailers;
  }

  // forward_client_cert_details - computed: false, optional: true, required: false
  private _forwardClientCertDetails?: string; 
  public get forwardClientCertDetails() {
    return this.getStringAttribute('forward_client_cert_details');
  }
  public set forwardClientCertDetails(value: string) {
    this._forwardClientCertDetails = value;
  }
  public resetForwardClientCertDetails() {
    this._forwardClientCertDetails = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardClientCertDetailsInput() {
    return this._forwardClientCertDetails;
  }

  // generate_request_id - computed: false, optional: true, required: false
  private _generateRequestId?: boolean | cdktf.IResolvable; 
  public get generateRequestId() {
    return this.getBooleanAttribute('generate_request_id');
  }
  public set generateRequestId(value: boolean | cdktf.IResolvable) {
    this._generateRequestId = value;
  }
  public resetGenerateRequestId() {
    this._generateRequestId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get generateRequestIdInput() {
    return this._generateRequestId;
  }

  // headers_with_underscores_action - computed: false, optional: true, required: false
  private _headersWithUnderscoresAction?: string; 
  public get headersWithUnderscoresAction() {
    return this.getStringAttribute('headers_with_underscores_action');
  }
  public set headersWithUnderscoresAction(value: string) {
    this._headersWithUnderscoresAction = value;
  }
  public resetHeadersWithUnderscoresAction() {
    this._headersWithUnderscoresAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersWithUnderscoresActionInput() {
    return this._headersWithUnderscoresAction;
  }

  // http2_protocol_options - computed: false, optional: true, required: false
  private _http2ProtocolOptions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsOutputReference(this, "http2_protocol_options");
  public get http2ProtocolOptions() {
    return this._http2ProtocolOptions;
  }
  public putHttp2ProtocolOptions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions) {
    this._http2ProtocolOptions.internalValue = value;
  }
  public resetHttp2ProtocolOptions() {
    this._http2ProtocolOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get http2ProtocolOptionsInput() {
    return this._http2ProtocolOptions.internalValue;
  }

  // idle_timeout - computed: false, optional: true, required: false
  private _idleTimeout?: string; 
  public get idleTimeout() {
    return this.getStringAttribute('idle_timeout');
  }
  public set idleTimeout(value: string) {
    this._idleTimeout = value;
  }
  public resetIdleTimeout() {
    this._idleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleTimeoutInput() {
    return this._idleTimeout;
  }

  // internal_address_config - computed: false, optional: true, required: false
  private _internalAddressConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigOutputReference(this, "internal_address_config");
  public get internalAddressConfig() {
    return this._internalAddressConfig;
  }
  public putInternalAddressConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig) {
    this._internalAddressConfig.internalValue = value;
  }
  public resetInternalAddressConfig() {
    this._internalAddressConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalAddressConfigInput() {
    return this._internalAddressConfig.internalValue;
  }

  // max_connection_duration - computed: false, optional: true, required: false
  private _maxConnectionDuration?: string; 
  public get maxConnectionDuration() {
    return this.getStringAttribute('max_connection_duration');
  }
  public set maxConnectionDuration(value: string) {
    this._maxConnectionDuration = value;
  }
  public resetMaxConnectionDuration() {
    this._maxConnectionDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnectionDurationInput() {
    return this._maxConnectionDuration;
  }

  // max_headers_count - computed: false, optional: true, required: false
  private _maxHeadersCount?: number; 
  public get maxHeadersCount() {
    return this.getNumberAttribute('max_headers_count');
  }
  public set maxHeadersCount(value: number) {
    this._maxHeadersCount = value;
  }
  public resetMaxHeadersCount() {
    this._maxHeadersCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxHeadersCountInput() {
    return this._maxHeadersCount;
  }

  // max_request_headers_kb - computed: false, optional: true, required: false
  private _maxRequestHeadersKb?: number; 
  public get maxRequestHeadersKb() {
    return this.getNumberAttribute('max_request_headers_kb');
  }
  public set maxRequestHeadersKb(value: number) {
    this._maxRequestHeadersKb = value;
  }
  public resetMaxRequestHeadersKb() {
    this._maxRequestHeadersKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestHeadersKbInput() {
    return this._maxRequestHeadersKb;
  }

  // max_requests_per_connection - computed: false, optional: true, required: false
  private _maxRequestsPerConnection?: number; 
  public get maxRequestsPerConnection() {
    return this.getNumberAttribute('max_requests_per_connection');
  }
  public set maxRequestsPerConnection(value: number) {
    this._maxRequestsPerConnection = value;
  }
  public resetMaxRequestsPerConnection() {
    this._maxRequestsPerConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerConnectionInput() {
    return this._maxRequestsPerConnection;
  }

  // max_stream_duration - computed: false, optional: true, required: false
  private _maxStreamDuration?: string; 
  public get maxStreamDuration() {
    return this.getStringAttribute('max_stream_duration');
  }
  public set maxStreamDuration(value: string) {
    this._maxStreamDuration = value;
  }
  public resetMaxStreamDuration() {
    this._maxStreamDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxStreamDurationInput() {
    return this._maxStreamDuration;
  }

  // merge_slashes - computed: false, optional: true, required: false
  private _mergeSlashes?: boolean | cdktf.IResolvable; 
  public get mergeSlashes() {
    return this.getBooleanAttribute('merge_slashes');
  }
  public set mergeSlashes(value: boolean | cdktf.IResolvable) {
    this._mergeSlashes = value;
  }
  public resetMergeSlashes() {
    this._mergeSlashes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeSlashesInput() {
    return this._mergeSlashes;
  }

  // normalize_path - computed: false, optional: true, required: false
  private _normalizePath?: boolean | cdktf.IResolvable; 
  public get normalizePath() {
    return this.getBooleanAttribute('normalize_path');
  }
  public set normalizePath(value: boolean | cdktf.IResolvable) {
    this._normalizePath = value;
  }
  public resetNormalizePath() {
    this._normalizePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalizePathInput() {
    return this._normalizePath;
  }

  // path_with_escaped_slashes_action - computed: false, optional: true, required: false
  private _pathWithEscapedSlashesAction?: string; 
  public get pathWithEscapedSlashesAction() {
    return this.getStringAttribute('path_with_escaped_slashes_action');
  }
  public set pathWithEscapedSlashesAction(value: string) {
    this._pathWithEscapedSlashesAction = value;
  }
  public resetPathWithEscapedSlashesAction() {
    this._pathWithEscapedSlashesAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathWithEscapedSlashesActionInput() {
    return this._pathWithEscapedSlashesAction;
  }

  // preserve_case_header_key_format - computed: false, optional: true, required: false
  private _preserveCaseHeaderKeyFormat?: boolean | cdktf.IResolvable; 
  public get preserveCaseHeaderKeyFormat() {
    return this.getBooleanAttribute('preserve_case_header_key_format');
  }
  public set preserveCaseHeaderKeyFormat(value: boolean | cdktf.IResolvable) {
    this._preserveCaseHeaderKeyFormat = value;
  }
  public resetPreserveCaseHeaderKeyFormat() {
    this._preserveCaseHeaderKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveCaseHeaderKeyFormatInput() {
    return this._preserveCaseHeaderKeyFormat;
  }

  // preserve_external_request_id - computed: false, optional: true, required: false
  private _preserveExternalRequestId?: boolean | cdktf.IResolvable; 
  public get preserveExternalRequestId() {
    return this.getBooleanAttribute('preserve_external_request_id');
  }
  public set preserveExternalRequestId(value: boolean | cdktf.IResolvable) {
    this._preserveExternalRequestId = value;
  }
  public resetPreserveExternalRequestId() {
    this._preserveExternalRequestId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveExternalRequestIdInput() {
    return this._preserveExternalRequestId;
  }

  // proper_case_header_key_format - computed: false, optional: true, required: false
  private _properCaseHeaderKeyFormat?: boolean | cdktf.IResolvable; 
  public get properCaseHeaderKeyFormat() {
    return this.getBooleanAttribute('proper_case_header_key_format');
  }
  public set properCaseHeaderKeyFormat(value: boolean | cdktf.IResolvable) {
    this._properCaseHeaderKeyFormat = value;
  }
  public resetProperCaseHeaderKeyFormat() {
    this._properCaseHeaderKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get properCaseHeaderKeyFormatInput() {
    return this._properCaseHeaderKeyFormat;
  }

  // proxy100_continue - computed: false, optional: true, required: false
  private _proxy100Continue?: boolean | cdktf.IResolvable; 
  public get proxy100Continue() {
    return this.getBooleanAttribute('proxy100_continue');
  }
  public set proxy100Continue(value: boolean | cdktf.IResolvable) {
    this._proxy100Continue = value;
  }
  public resetProxy100Continue() {
    this._proxy100Continue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxy100ContinueInput() {
    return this._proxy100Continue;
  }

  // request_headers_timeout - computed: false, optional: true, required: false
  private _requestHeadersTimeout?: string; 
  public get requestHeadersTimeout() {
    return this.getStringAttribute('request_headers_timeout');
  }
  public set requestHeadersTimeout(value: string) {
    this._requestHeadersTimeout = value;
  }
  public resetRequestHeadersTimeout() {
    this._requestHeadersTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersTimeoutInput() {
    return this._requestHeadersTimeout;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // server_header_transformation - computed: false, optional: true, required: false
  private _serverHeaderTransformation?: string; 
  public get serverHeaderTransformation() {
    return this.getStringAttribute('server_header_transformation');
  }
  public set serverHeaderTransformation(value: string) {
    this._serverHeaderTransformation = value;
  }
  public resetServerHeaderTransformation() {
    this._serverHeaderTransformation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverHeaderTransformationInput() {
    return this._serverHeaderTransformation;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }

  // set_current_client_cert_details - computed: false, optional: true, required: false
  private _setCurrentClientCertDetails = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsOutputReference(this, "set_current_client_cert_details");
  public get setCurrentClientCertDetails() {
    return this._setCurrentClientCertDetails;
  }
  public putSetCurrentClientCertDetails(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails) {
    this._setCurrentClientCertDetails.internalValue = value;
  }
  public resetSetCurrentClientCertDetails() {
    this._setCurrentClientCertDetails.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setCurrentClientCertDetailsInput() {
    return this._setCurrentClientCertDetails.internalValue;
  }

  // skip_xff_append - computed: false, optional: true, required: false
  private _skipXffAppend?: boolean | cdktf.IResolvable; 
  public get skipXffAppend() {
    return this.getBooleanAttribute('skip_xff_append');
  }
  public set skipXffAppend(value: boolean | cdktf.IResolvable) {
    this._skipXffAppend = value;
  }
  public resetSkipXffAppend() {
    this._skipXffAppend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipXffAppendInput() {
    return this._skipXffAppend;
  }

  // stream_idle_timeout - computed: false, optional: true, required: false
  private _streamIdleTimeout?: string; 
  public get streamIdleTimeout() {
    return this.getStringAttribute('stream_idle_timeout');
  }
  public set streamIdleTimeout(value: string) {
    this._streamIdleTimeout = value;
  }
  public resetStreamIdleTimeout() {
    this._streamIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamIdleTimeoutInput() {
    return this._streamIdleTimeout;
  }

  // strip_any_host_port - computed: false, optional: true, required: false
  private _stripAnyHostPort?: boolean | cdktf.IResolvable; 
  public get stripAnyHostPort() {
    return this.getBooleanAttribute('strip_any_host_port');
  }
  public set stripAnyHostPort(value: boolean | cdktf.IResolvable) {
    this._stripAnyHostPort = value;
  }
  public resetStripAnyHostPort() {
    this._stripAnyHostPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stripAnyHostPortInput() {
    return this._stripAnyHostPort;
  }

  // tracing - computed: false, optional: true, required: false
  private _tracing = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracingOutputReference(this, "tracing");
  public get tracing() {
    return this._tracing;
  }
  public putTracing(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsTracing) {
    this._tracing.internalValue = value;
  }
  public resetTracing() {
    this._tracing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracingInput() {
    return this._tracing.internalValue;
  }

  // upgrades - computed: false, optional: true, required: false
  private _upgrades = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesList(this, "upgrades", false);
  public get upgrades() {
    return this._upgrades;
  }
  public putUpgrades(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades[] | cdktf.IResolvable) {
    this._upgrades.internalValue = value;
  }
  public resetUpgrades() {
    this._upgrades.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upgradesInput() {
    return this._upgrades.internalValue;
  }

  // use_remote_address - computed: false, optional: true, required: false
  private _useRemoteAddress?: boolean | cdktf.IResolvable; 
  public get useRemoteAddress() {
    return this.getBooleanAttribute('use_remote_address');
  }
  public set useRemoteAddress(value: boolean | cdktf.IResolvable) {
    this._useRemoteAddress = value;
  }
  public resetUseRemoteAddress() {
    this._useRemoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRemoteAddressInput() {
    return this._useRemoteAddress;
  }

  // uuid_request_id_config - computed: false, optional: true, required: false
  private _uuidRequestIdConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigOutputReference(this, "uuid_request_id_config");
  public get uuidRequestIdConfig() {
    return this._uuidRequestIdConfig;
  }
  public putUuidRequestIdConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig) {
    this._uuidRequestIdConfig.internalValue = value;
  }
  public resetUuidRequestIdConfig() {
    this._uuidRequestIdConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uuidRequestIdConfigInput() {
    return this._uuidRequestIdConfig.internalValue;
  }

  // via - computed: false, optional: true, required: false
  private _via?: string; 
  public get via() {
    return this.getStringAttribute('via');
  }
  public set via(value: string) {
    this._via = value;
  }
  public resetVia() {
    this._via = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get viaInput() {
    return this._via;
  }

  // xff_num_trusted_hops - computed: false, optional: true, required: false
  private _xffNumTrustedHops?: number; 
  public get xffNumTrustedHops() {
    return this.getNumberAttribute('xff_num_trusted_hops');
  }
  public set xffNumTrustedHops(value: number) {
    this._xffNumTrustedHops = value;
  }
  public resetXffNumTrustedHops() {
    this._xffNumTrustedHops = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xffNumTrustedHopsInput() {
    return this._xffNumTrustedHops;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#fill_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_tokens DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#default_limit DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#default_limit}
  */
  readonly defaultLimit?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#enable_x_ratelimit_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#enable_x_ratelimit_headers}
  */
  readonly enableXRatelimitHeaders?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#local_rate_limit_per_downstream_connection DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#local_rate_limit_per_downstream_connection}
  */
  readonly localRateLimitPerDownstreamConnection?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_limit: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToTerraform(struct!.defaultLimit),
    enable_x_ratelimit_headers: cdktf.booleanToTerraform(struct!.enableXRatelimitHeaders),
    local_rate_limit_per_downstream_connection: cdktf.booleanToTerraform(struct!.localRateLimitPerDownstreamConnection),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_limit: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToHclTerraform(struct!.defaultLimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit",
    },
    enable_x_ratelimit_headers: {
      value: cdktf.booleanToHclTerraform(struct!.enableXRatelimitHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_rate_limit_per_downstream_connection: {
      value: cdktf.booleanToHclTerraform(struct!.localRateLimitPerDownstreamConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultLimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultLimit = this._defaultLimit?.internalValue;
    }
    if (this._enableXRatelimitHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableXRatelimitHeaders = this._enableXRatelimitHeaders;
    }
    if (this._localRateLimitPerDownstreamConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRateLimitPerDownstreamConnection = this._localRateLimitPerDownstreamConnection;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultLimit.internalValue = undefined;
      this._enableXRatelimitHeaders = undefined;
      this._localRateLimitPerDownstreamConnection = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultLimit.internalValue = value.defaultLimit;
      this._enableXRatelimitHeaders = value.enableXRatelimitHeaders;
      this._localRateLimitPerDownstreamConnection = value.localRateLimitPerDownstreamConnection;
    }
  }

  // default_limit - computed: false, optional: true, required: false
  private _defaultLimit = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimitOutputReference(this, "default_limit");
  public get defaultLimit() {
    return this._defaultLimit;
  }
  public putDefaultLimit(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitDefaultLimit) {
    this._defaultLimit.internalValue = value;
  }
  public resetDefaultLimit() {
    this._defaultLimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultLimitInput() {
    return this._defaultLimit.internalValue;
  }

  // enable_x_ratelimit_headers - computed: false, optional: true, required: false
  private _enableXRatelimitHeaders?: boolean | cdktf.IResolvable; 
  public get enableXRatelimitHeaders() {
    return this.getBooleanAttribute('enable_x_ratelimit_headers');
  }
  public set enableXRatelimitHeaders(value: boolean | cdktf.IResolvable) {
    this._enableXRatelimitHeaders = value;
  }
  public resetEnableXRatelimitHeaders() {
    this._enableXRatelimitHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableXRatelimitHeadersInput() {
    return this._enableXRatelimitHeaders;
  }

  // local_rate_limit_per_downstream_connection - computed: false, optional: true, required: false
  private _localRateLimitPerDownstreamConnection?: boolean | cdktf.IResolvable; 
  public get localRateLimitPerDownstreamConnection() {
    return this.getBooleanAttribute('local_rate_limit_per_downstream_connection');
  }
  public set localRateLimitPerDownstreamConnection(value: boolean | cdktf.IResolvable) {
    this._localRateLimitPerDownstreamConnection = value;
  }
  public resetLocalRateLimitPerDownstreamConnection() {
    this._localRateLimitPerDownstreamConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRateLimitPerDownstreamConnectionInput() {
    return this._localRateLimitPerDownstreamConnection;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#fill_interval DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_tokens DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#charge_cluster_stat DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#charge_cluster_stat}
  */
  readonly chargeClusterStat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#charge_listener_stat DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#charge_listener_stat}
  */
  readonly chargeListenerStat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#emit_dynamic_metadata DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#emit_dynamic_metadata}
  */
  readonly emitDynamicMetadata?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#measure_request_internally DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#measure_request_internally}
  */
  readonly measureRequestInternally?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request}
  */
  readonly request?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response}
  */
  readonly response?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatencyToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    charge_cluster_stat: cdktf.booleanToTerraform(struct!.chargeClusterStat),
    charge_listener_stat: cdktf.booleanToTerraform(struct!.chargeListenerStat),
    emit_dynamic_metadata: cdktf.booleanToTerraform(struct!.emitDynamicMetadata),
    measure_request_internally: cdktf.booleanToTerraform(struct!.measureRequestInternally),
    request: cdktf.stringToTerraform(struct!.request),
    response: cdktf.stringToTerraform(struct!.response),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatencyToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    charge_cluster_stat: {
      value: cdktf.booleanToHclTerraform(struct!.chargeClusterStat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    charge_listener_stat: {
      value: cdktf.booleanToHclTerraform(struct!.chargeListenerStat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    emit_dynamic_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.emitDynamicMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    measure_request_internally: {
      value: cdktf.booleanToHclTerraform(struct!.measureRequestInternally),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response: {
      value: cdktf.stringToHclTerraform(struct!.response),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chargeClusterStat !== undefined) {
      hasAnyValues = true;
      internalValueResult.chargeClusterStat = this._chargeClusterStat;
    }
    if (this._chargeListenerStat !== undefined) {
      hasAnyValues = true;
      internalValueResult.chargeListenerStat = this._chargeListenerStat;
    }
    if (this._emitDynamicMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.emitDynamicMetadata = this._emitDynamicMetadata;
    }
    if (this._measureRequestInternally !== undefined) {
      hasAnyValues = true;
      internalValueResult.measureRequestInternally = this._measureRequestInternally;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    if (this._response !== undefined) {
      hasAnyValues = true;
      internalValueResult.response = this._response;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chargeClusterStat = undefined;
      this._chargeListenerStat = undefined;
      this._emitDynamicMetadata = undefined;
      this._measureRequestInternally = undefined;
      this._request = undefined;
      this._response = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chargeClusterStat = value.chargeClusterStat;
      this._chargeListenerStat = value.chargeListenerStat;
      this._emitDynamicMetadata = value.emitDynamicMetadata;
      this._measureRequestInternally = value.measureRequestInternally;
      this._request = value.request;
      this._response = value.response;
    }
  }

  // charge_cluster_stat - computed: false, optional: true, required: false
  private _chargeClusterStat?: boolean | cdktf.IResolvable; 
  public get chargeClusterStat() {
    return this.getBooleanAttribute('charge_cluster_stat');
  }
  public set chargeClusterStat(value: boolean | cdktf.IResolvable) {
    this._chargeClusterStat = value;
  }
  public resetChargeClusterStat() {
    this._chargeClusterStat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chargeClusterStatInput() {
    return this._chargeClusterStat;
  }

  // charge_listener_stat - computed: false, optional: true, required: false
  private _chargeListenerStat?: boolean | cdktf.IResolvable; 
  public get chargeListenerStat() {
    return this.getBooleanAttribute('charge_listener_stat');
  }
  public set chargeListenerStat(value: boolean | cdktf.IResolvable) {
    this._chargeListenerStat = value;
  }
  public resetChargeListenerStat() {
    this._chargeListenerStat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chargeListenerStatInput() {
    return this._chargeListenerStat;
  }

  // emit_dynamic_metadata - computed: false, optional: true, required: false
  private _emitDynamicMetadata?: boolean | cdktf.IResolvable; 
  public get emitDynamicMetadata() {
    return this.getBooleanAttribute('emit_dynamic_metadata');
  }
  public set emitDynamicMetadata(value: boolean | cdktf.IResolvable) {
    this._emitDynamicMetadata = value;
  }
  public resetEmitDynamicMetadata() {
    this._emitDynamicMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emitDynamicMetadataInput() {
    return this._emitDynamicMetadata;
  }

  // measure_request_internally - computed: false, optional: true, required: false
  private _measureRequestInternally?: boolean | cdktf.IResolvable; 
  public get measureRequestInternally() {
    return this.getBooleanAttribute('measure_request_internally');
  }
  public set measureRequestInternally(value: boolean | cdktf.IResolvable) {
    this._measureRequestInternally = value;
  }
  public resetMeasureRequestInternally() {
    this._measureRequestInternally = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get measureRequestInternallyInput() {
    return this._measureRequestInternally;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }

  // response - computed: false, optional: true, required: false
  private _response?: string; 
  public get response() {
    return this.getStringAttribute('response');
  }
  public set response(value: string) {
    this._response = value;
  }
  public resetResponse() {
    this._response = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseInput() {
    return this._response;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#authority DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#authority}
  */
  readonly authority?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#deny_on_fail DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#deny_on_fail}
  */
  readonly denyOnFail?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#enable_x_ratelimit_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#enable_x_ratelimit_headers}
  */
  readonly enableXRatelimitHeaders?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#rate_limit_before_auth DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#rate_limit_before_auth}
  */
  readonly rateLimitBeforeAuth?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ratelimit_server_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ratelimit_server_ref}
  */
  readonly ratelimitServerRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deny_on_fail: cdktf.booleanToTerraform(struct!.denyOnFail),
    enable_x_ratelimit_headers: cdktf.booleanToTerraform(struct!.enableXRatelimitHeaders),
    grpc_service: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcServiceToTerraform(struct!.grpcService),
    rate_limit_before_auth: cdktf.booleanToTerraform(struct!.rateLimitBeforeAuth),
    ratelimit_server_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRefToTerraform(struct!.ratelimitServerRef),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deny_on_fail: {
      value: cdktf.booleanToHclTerraform(struct!.denyOnFail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_x_ratelimit_headers: {
      value: cdktf.booleanToHclTerraform(struct!.enableXRatelimitHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService",
    },
    rate_limit_before_auth: {
      value: cdktf.booleanToHclTerraform(struct!.rateLimitBeforeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ratelimit_server_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRefToHclTerraform(struct!.ratelimitServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denyOnFail !== undefined) {
      hasAnyValues = true;
      internalValueResult.denyOnFail = this._denyOnFail;
    }
    if (this._enableXRatelimitHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableXRatelimitHeaders = this._enableXRatelimitHeaders;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._rateLimitBeforeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.rateLimitBeforeAuth = this._rateLimitBeforeAuth;
    }
    if (this._ratelimitServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ratelimitServerRef = this._ratelimitServerRef?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denyOnFail = undefined;
      this._enableXRatelimitHeaders = undefined;
      this._grpcService.internalValue = undefined;
      this._rateLimitBeforeAuth = undefined;
      this._ratelimitServerRef.internalValue = undefined;
      this._requestTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denyOnFail = value.denyOnFail;
      this._enableXRatelimitHeaders = value.enableXRatelimitHeaders;
      this._grpcService.internalValue = value.grpcService;
      this._rateLimitBeforeAuth = value.rateLimitBeforeAuth;
      this._ratelimitServerRef.internalValue = value.ratelimitServerRef;
      this._requestTimeout = value.requestTimeout;
    }
  }

  // deny_on_fail - computed: false, optional: true, required: false
  private _denyOnFail?: boolean | cdktf.IResolvable; 
  public get denyOnFail() {
    return this.getBooleanAttribute('deny_on_fail');
  }
  public set denyOnFail(value: boolean | cdktf.IResolvable) {
    this._denyOnFail = value;
  }
  public resetDenyOnFail() {
    this._denyOnFail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyOnFailInput() {
    return this._denyOnFail;
  }

  // enable_x_ratelimit_headers - computed: false, optional: true, required: false
  private _enableXRatelimitHeaders?: boolean | cdktf.IResolvable; 
  public get enableXRatelimitHeaders() {
    return this.getBooleanAttribute('enable_x_ratelimit_headers');
  }
  public set enableXRatelimitHeaders(value: boolean | cdktf.IResolvable) {
    this._enableXRatelimitHeaders = value;
  }
  public resetEnableXRatelimitHeaders() {
    this._enableXRatelimitHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableXRatelimitHeadersInput() {
    return this._enableXRatelimitHeaders;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // rate_limit_before_auth - computed: false, optional: true, required: false
  private _rateLimitBeforeAuth?: boolean | cdktf.IResolvable; 
  public get rateLimitBeforeAuth() {
    return this.getBooleanAttribute('rate_limit_before_auth');
  }
  public set rateLimitBeforeAuth(value: boolean | cdktf.IResolvable) {
    this._rateLimitBeforeAuth = value;
  }
  public resetRateLimitBeforeAuth() {
    this._rateLimitBeforeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rateLimitBeforeAuthInput() {
    return this._rateLimitBeforeAuth;
  }

  // ratelimit_server_ref - computed: false, optional: true, required: false
  private _ratelimitServerRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRefOutputReference(this, "ratelimit_server_ref");
  public get ratelimitServerRef() {
    return this._ratelimitServerRef;
  }
  public putRatelimitServerRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerRatelimitServerRef) {
    this._ratelimitServerRef.internalValue = value;
  }
  public resetRatelimitServerRef() {
    this._ratelimitServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ratelimitServerRefInput() {
    return this._ratelimitServerRef.internalValue;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dynamic_stats DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dynamic_stats}
  */
  readonly dynamicStats?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#suppress_envoy_headers DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#suppress_envoy_headers}
  */
  readonly suppressEnvoyHeaders?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouterToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic_stats: cdktf.booleanToTerraform(struct!.dynamicStats),
    suppress_envoy_headers: cdktf.booleanToTerraform(struct!.suppressEnvoyHeaders),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouterToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic_stats: {
      value: cdktf.booleanToHclTerraform(struct!.dynamicStats),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    suppress_envoy_headers: {
      value: cdktf.booleanToHclTerraform(struct!.suppressEnvoyHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamicStats !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicStats = this._dynamicStats;
    }
    if (this._suppressEnvoyHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressEnvoyHeaders = this._suppressEnvoyHeaders;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamicStats = undefined;
      this._suppressEnvoyHeaders = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamicStats = value.dynamicStats;
      this._suppressEnvoyHeaders = value.suppressEnvoyHeaders;
    }
  }

  // dynamic_stats - computed: false, optional: true, required: false
  private _dynamicStats?: boolean | cdktf.IResolvable; 
  public get dynamicStats() {
    return this.getBooleanAttribute('dynamic_stats');
  }
  public set dynamicStats(value: boolean | cdktf.IResolvable) {
    this._dynamicStats = value;
  }
  public resetDynamicStats() {
    this._dynamicStats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicStatsInput() {
    return this._dynamicStats;
  }

  // suppress_envoy_headers - computed: false, optional: true, required: false
  private _suppressEnvoyHeaders?: boolean | cdktf.IResolvable; 
  public get suppressEnvoyHeaders() {
    return this.getBooleanAttribute('suppress_envoy_headers');
  }
  public set suppressEnvoyHeaders(value: boolean | cdktf.IResolvable) {
    this._suppressEnvoyHeaders = value;
  }
  public resetSuppressEnvoyHeaders() {
    this._suppressEnvoyHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressEnvoyHeadersInput() {
    return this._suppressEnvoyHeaders;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#path DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ttl DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ttl}
  */
  readonly ttl?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookieToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    ttl: cdktf.stringToTerraform(struct!.ttl),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookieToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
      this._ttl = value.ttl;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cookie DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cookie}
  */
  readonly cookie?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookie: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookieToTerraform(struct!.cookie),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookie: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookie.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookie.internalValue = value.cookie;
    }
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#header_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBasedToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBasedToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBasedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerName = value.headerName;
    }
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cookie_based DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cookie_based}
  */
  readonly cookieBased?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#header_based DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#header_based}
  */
  readonly headerBased?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#strict DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#strict}
  */
  readonly strict?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookie_based: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedToTerraform(struct!.cookieBased),
    header_based: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBasedToTerraform(struct!.headerBased),
    strict: cdktf.booleanToTerraform(struct!.strict),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookie_based: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedToHclTerraform(struct!.cookieBased),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased",
    },
    header_based: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBasedToHclTerraform(struct!.headerBased),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased",
    },
    strict: {
      value: cdktf.booleanToHclTerraform(struct!.strict),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookieBased?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookieBased = this._cookieBased?.internalValue;
    }
    if (this._headerBased?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBased = this._headerBased?.internalValue;
    }
    if (this._strict !== undefined) {
      hasAnyValues = true;
      internalValueResult.strict = this._strict;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookieBased.internalValue = undefined;
      this._headerBased.internalValue = undefined;
      this._strict = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookieBased.internalValue = value.cookieBased;
      this._headerBased.internalValue = value.headerBased;
      this._strict = value.strict;
    }
  }

  // cookie_based - computed: false, optional: true, required: false
  private _cookieBased = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBasedOutputReference(this, "cookie_based");
  public get cookieBased() {
    return this._cookieBased;
  }
  public putCookieBased(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionCookieBased) {
    this._cookieBased.internalValue = value;
  }
  public resetCookieBased() {
    this._cookieBased.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieBasedInput() {
    return this._cookieBased.internalValue;
  }

  // header_based - computed: false, optional: true, required: false
  private _headerBased = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBasedOutputReference(this, "header_based");
  public get headerBased() {
    return this._headerBased;
  }
  public putHeaderBased(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionHeaderBased) {
    this._headerBased.internalValue = value;
  }
  public resetHeaderBased() {
    this._headerBased.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBasedInput() {
    return this._headerBased.internalValue;
  }

  // strict - computed: false, optional: true, required: false
  private _strict?: boolean | cdktf.IResolvable; 
  public get strict() {
    return this.getBooleanAttribute('strict');
  }
  public set strict(value: boolean | cdktf.IResolvable) {
    this._strict = value;
  }
  public resetStrict() {
    this._strict = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictInput() {
    return this._strict;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tap_server DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tap_server}
  */
  readonly tapServer?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tap_server: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServerToTerraform(struct!.tapServer),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tap_server: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServerToHclTerraform(struct!.tapServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tapServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tapServer = this._tapServer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = value.tapServer;
    }
  }

  // tap_server - computed: false, optional: true, required: false
  private _tapServer = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServerOutputReference(this, "tap_server");
  public get tapServer() {
    return this._tapServer;
  }
  public putTapServer(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceTapServer) {
    this._tapServer.internalValue = value;
  }
  public resetTapServer() {
    this._tapServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapServerInput() {
    return this._tapServer.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServerToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServerToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tap_server DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tap_server}
  */
  readonly tapServer?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tap_server: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServerToTerraform(struct!.tapServer),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tap_server: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServerToHclTerraform(struct!.tapServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tapServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tapServer = this._tapServer?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = value.tapServer;
      this._timeout = value.timeout;
    }
  }

  // tap_server - computed: false, optional: true, required: false
  private _tapServer = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServerOutputReference(this, "tap_server");
  public get tapServer() {
    return this._tapServer;
  }
  public putTapServer(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceTapServer) {
    this._tapServer.internalValue = value;
  }
  public resetTapServer() {
    this._tapServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapServerInput() {
    return this._tapServer.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http_service DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http_service}
  */
  readonly httpService?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_service: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceToTerraform(struct!.grpcService),
    http_service: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceToTerraform(struct!.httpService),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_service: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService",
    },
    http_service: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceToHclTerraform(struct!.httpService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._httpService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpService = this._httpService?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcService.internalValue = undefined;
      this._httpService.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcService.internalValue = value.grpcService;
      this._httpService.internalValue = value.httpService;
    }
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // http_service - computed: false, optional: true, required: false
  private _httpService = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpServiceOutputReference(this, "http_service");
  public get httpService() {
    return this._httpService;
  }
  public putHttpService(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksHttpService) {
    this._httpService.internalValue = value;
  }
  public resetHttpService() {
    this._httpService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpServiceInput() {
    return this._httpService.internalValue;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_buffered_rx_bytes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_buffered_rx_bytes}
  */
  readonly maxBufferedRxBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#max_buffered_tx_bytes DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#max_buffered_tx_bytes}
  */
  readonly maxBufferedTxBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#record_downstream_connection DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#record_downstream_connection}
  */
  readonly recordDownstreamConnection?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#record_headers_received_time DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#record_headers_received_time}
  */
  readonly recordHeadersReceivedTime?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sinks DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sinks}
  */
  readonly sinks?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_buffered_rx_bytes: cdktf.numberToTerraform(struct!.maxBufferedRxBytes),
    max_buffered_tx_bytes: cdktf.numberToTerraform(struct!.maxBufferedTxBytes),
    record_downstream_connection: cdktf.booleanToTerraform(struct!.recordDownstreamConnection),
    record_headers_received_time: cdktf.booleanToTerraform(struct!.recordHeadersReceivedTime),
    sinks: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksToTerraform, false)(struct!.sinks),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_buffered_rx_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferedRxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_buffered_tx_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferedTxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    record_downstream_connection: {
      value: cdktf.booleanToHclTerraform(struct!.recordDownstreamConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    record_headers_received_time: {
      value: cdktf.booleanToHclTerraform(struct!.recordHeadersReceivedTime),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sinks: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksToHclTerraform, false)(struct!.sinks),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxBufferedRxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferedRxBytes = this._maxBufferedRxBytes;
    }
    if (this._maxBufferedTxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferedTxBytes = this._maxBufferedTxBytes;
    }
    if (this._recordDownstreamConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordDownstreamConnection = this._recordDownstreamConnection;
    }
    if (this._recordHeadersReceivedTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordHeadersReceivedTime = this._recordHeadersReceivedTime;
    }
    if (this._sinks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sinks = this._sinks?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxBufferedRxBytes = undefined;
      this._maxBufferedTxBytes = undefined;
      this._recordDownstreamConnection = undefined;
      this._recordHeadersReceivedTime = undefined;
      this._sinks.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxBufferedRxBytes = value.maxBufferedRxBytes;
      this._maxBufferedTxBytes = value.maxBufferedTxBytes;
      this._recordDownstreamConnection = value.recordDownstreamConnection;
      this._recordHeadersReceivedTime = value.recordHeadersReceivedTime;
      this._sinks.internalValue = value.sinks;
    }
  }

  // max_buffered_rx_bytes - computed: false, optional: true, required: false
  private _maxBufferedRxBytes?: number; 
  public get maxBufferedRxBytes() {
    return this.getNumberAttribute('max_buffered_rx_bytes');
  }
  public set maxBufferedRxBytes(value: number) {
    this._maxBufferedRxBytes = value;
  }
  public resetMaxBufferedRxBytes() {
    this._maxBufferedRxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferedRxBytesInput() {
    return this._maxBufferedRxBytes;
  }

  // max_buffered_tx_bytes - computed: false, optional: true, required: false
  private _maxBufferedTxBytes?: number; 
  public get maxBufferedTxBytes() {
    return this.getNumberAttribute('max_buffered_tx_bytes');
  }
  public set maxBufferedTxBytes(value: number) {
    this._maxBufferedTxBytes = value;
  }
  public resetMaxBufferedTxBytes() {
    this._maxBufferedTxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferedTxBytesInput() {
    return this._maxBufferedTxBytes;
  }

  // record_downstream_connection - computed: false, optional: true, required: false
  private _recordDownstreamConnection?: boolean | cdktf.IResolvable; 
  public get recordDownstreamConnection() {
    return this.getBooleanAttribute('record_downstream_connection');
  }
  public set recordDownstreamConnection(value: boolean | cdktf.IResolvable) {
    this._recordDownstreamConnection = value;
  }
  public resetRecordDownstreamConnection() {
    this._recordDownstreamConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordDownstreamConnectionInput() {
    return this._recordDownstreamConnection;
  }

  // record_headers_received_time - computed: false, optional: true, required: false
  private _recordHeadersReceivedTime?: boolean | cdktf.IResolvable; 
  public get recordHeadersReceivedTime() {
    return this.getBooleanAttribute('record_headers_received_time');
  }
  public set recordHeadersReceivedTime(value: boolean | cdktf.IResolvable) {
    this._recordHeadersReceivedTime = value;
  }
  public resetRecordHeadersReceivedTime() {
    this._recordHeadersReceivedTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordHeadersReceivedTimeInput() {
    return this._recordHeadersReceivedTime;
  }

  // sinks - computed: false, optional: true, required: false
  private _sinks = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinksList(this, "sinks", false);
  public get sinks() {
    return this._sinks;
  }
  public putSinks(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapSinks[] | cdktf.IResolvable) {
    this._sinks.internalValue = value;
  }
  public resetSinks() {
    this._sinks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sinksInput() {
    return this._sinks.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#action DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#action}
  */
  readonly action?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#location DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#location}
  */
  readonly location?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLoggingToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    location: cdktf.stringToTerraform(struct!.location),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLoggingToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLoggingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._location = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._location = value.location;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // location - computed: false, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#config_map_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#data_map_keys DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#data_map_keys}
  */
  readonly dataMapKeys?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToTerraform(struct!.configMapRef),
    data_map_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dataMapKeys),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef",
    },
    data_map_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dataMapKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._dataMapKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataMapKeys = this._dataMapKeys;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._dataMapKeys = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._dataMapKeys = value.dataMapKeys;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // data_map_keys - computed: false, optional: true, required: false
  private _dataMapKeys?: string[]; 
  public get dataMapKeys() {
    return this.getListAttribute('data_map_keys');
  }
  public set dataMapKeys(value: string[]) {
    this._dataMapKeys = value;
  }
  public resetDataMapKeys() {
    this._dataMapKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataMapKeysInput() {
    return this._dataMapKeys;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#custom_settings_file DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#custom_settings_file}
  */
  readonly customSettingsFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#custom_settings_string DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#custom_settings_string}
  */
  readonly customSettingsString?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSetToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_settings_file: cdktf.stringToTerraform(struct!.customSettingsFile),
    custom_settings_string: cdktf.stringToTerraform(struct!.customSettingsString),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSetToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_settings_file: {
      value: cdktf.stringToHclTerraform(struct!.customSettingsFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_settings_string: {
      value: cdktf.stringToHclTerraform(struct!.customSettingsString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customSettingsFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSettingsFile = this._customSettingsFile;
    }
    if (this._customSettingsString !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSettingsString = this._customSettingsString;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customSettingsFile = undefined;
      this._customSettingsString = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customSettingsFile = value.customSettingsFile;
      this._customSettingsString = value.customSettingsString;
    }
  }

  // custom_settings_file - computed: false, optional: true, required: false
  private _customSettingsFile?: string; 
  public get customSettingsFile() {
    return this.getStringAttribute('custom_settings_file');
  }
  public set customSettingsFile(value: string) {
    this._customSettingsFile = value;
  }
  public resetCustomSettingsFile() {
    this._customSettingsFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSettingsFileInput() {
    return this._customSettingsFile;
  }

  // custom_settings_string - computed: false, optional: true, required: false
  private _customSettingsString?: string; 
  public get customSettingsString() {
    return this.getStringAttribute('custom_settings_string');
  }
  public set customSettingsString(value: string) {
    this._customSettingsString = value;
  }
  public resetCustomSettingsString() {
    this._customSettingsString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSettingsStringInput() {
    return this._customSettingsString;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#directory DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#directory}
  */
  readonly directory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#files DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#files}
  */
  readonly files?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#rule_str DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#rule_str}
  */
  readonly ruleStr?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    directory: cdktf.stringToTerraform(struct!.directory),
    files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.files),
    rule_str: cdktf.stringToTerraform(struct!.ruleStr),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    directory: {
      value: cdktf.stringToHclTerraform(struct!.directory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.files),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    rule_str: {
      value: cdktf.stringToHclTerraform(struct!.ruleStr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._directory !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory;
    }
    if (this._files !== undefined) {
      hasAnyValues = true;
      internalValueResult.files = this._files;
    }
    if (this._ruleStr !== undefined) {
      hasAnyValues = true;
      internalValueResult.ruleStr = this._ruleStr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._directory = undefined;
      this._files = undefined;
      this._ruleStr = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._directory = value.directory;
      this._files = value.files;
      this._ruleStr = value.ruleStr;
    }
  }

  // directory - computed: false, optional: true, required: false
  private _directory?: string; 
  public get directory() {
    return this.getStringAttribute('directory');
  }
  public set directory(value: string) {
    this._directory = value;
  }
  public resetDirectory() {
    this._directory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory;
  }

  // files - computed: false, optional: true, required: false
  private _files?: string[]; 
  public get files() {
    return this.getListAttribute('files');
  }
  public set files(value: string[]) {
    this._files = value;
  }
  public resetFiles() {
    this._files = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filesInput() {
    return this._files;
  }

  // rule_str - computed: false, optional: true, required: false
  private _ruleStr?: string; 
  public get ruleStr() {
    return this.getStringAttribute('rule_str');
  }
  public set ruleStr(value: string) {
    this._ruleStr = value;
  }
  public resetRuleStr() {
    this._ruleStr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleStrInput() {
    return this._ruleStr;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#audit_logging DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#audit_logging}
  */
  readonly auditLogging?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#config_map_rule_sets DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#config_map_rule_sets}
  */
  readonly configMapRuleSets?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#core_rule_set DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#core_rule_set}
  */
  readonly coreRuleSet?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#custom_intervention_message DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#custom_intervention_message}
  */
  readonly customInterventionMessage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disabled DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#request_headers_only DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#request_headers_only}
  */
  readonly requestHeadersOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#response_headers_only DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#response_headers_only}
  */
  readonly responseHeadersOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#rule_sets DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#rule_sets}
  */
  readonly ruleSets?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audit_logging: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLoggingToTerraform(struct!.auditLogging),
    config_map_rule_sets: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsToTerraform, false)(struct!.configMapRuleSets),
    core_rule_set: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSetToTerraform(struct!.coreRuleSet),
    custom_intervention_message: cdktf.stringToTerraform(struct!.customInterventionMessage),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    request_headers_only: cdktf.booleanToTerraform(struct!.requestHeadersOnly),
    response_headers_only: cdktf.booleanToTerraform(struct!.responseHeadersOnly),
    rule_sets: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsToTerraform, false)(struct!.ruleSets),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audit_logging: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLoggingToHclTerraform(struct!.auditLogging),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging",
    },
    config_map_rule_sets: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsToHclTerraform, false)(struct!.configMapRuleSets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsList",
    },
    core_rule_set: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSetToHclTerraform(struct!.coreRuleSet),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet",
    },
    custom_intervention_message: {
      value: cdktf.stringToHclTerraform(struct!.customInterventionMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_headers_only: {
      value: cdktf.booleanToHclTerraform(struct!.requestHeadersOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_headers_only: {
      value: cdktf.booleanToHclTerraform(struct!.responseHeadersOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rule_sets: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsToHclTerraform, false)(struct!.ruleSets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auditLogging?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogging = this._auditLogging?.internalValue;
    }
    if (this._configMapRuleSets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRuleSets = this._configMapRuleSets?.internalValue;
    }
    if (this._coreRuleSet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.coreRuleSet = this._coreRuleSet?.internalValue;
    }
    if (this._customInterventionMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.customInterventionMessage = this._customInterventionMessage;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._requestHeadersOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersOnly = this._requestHeadersOnly;
    }
    if (this._responseHeadersOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersOnly = this._responseHeadersOnly;
    }
    if (this._ruleSets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ruleSets = this._ruleSets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auditLogging.internalValue = undefined;
      this._configMapRuleSets.internalValue = undefined;
      this._coreRuleSet.internalValue = undefined;
      this._customInterventionMessage = undefined;
      this._disabled = undefined;
      this._requestHeadersOnly = undefined;
      this._responseHeadersOnly = undefined;
      this._ruleSets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auditLogging.internalValue = value.auditLogging;
      this._configMapRuleSets.internalValue = value.configMapRuleSets;
      this._coreRuleSet.internalValue = value.coreRuleSet;
      this._customInterventionMessage = value.customInterventionMessage;
      this._disabled = value.disabled;
      this._requestHeadersOnly = value.requestHeadersOnly;
      this._responseHeadersOnly = value.responseHeadersOnly;
      this._ruleSets.internalValue = value.ruleSets;
    }
  }

  // audit_logging - computed: false, optional: true, required: false
  private _auditLogging = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLoggingOutputReference(this, "audit_logging");
  public get auditLogging() {
    return this._auditLogging;
  }
  public putAuditLogging(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafAuditLogging) {
    this._auditLogging.internalValue = value;
  }
  public resetAuditLogging() {
    this._auditLogging.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLoggingInput() {
    return this._auditLogging.internalValue;
  }

  // config_map_rule_sets - computed: false, optional: true, required: false
  private _configMapRuleSets = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSetsList(this, "config_map_rule_sets", false);
  public get configMapRuleSets() {
    return this._configMapRuleSets;
  }
  public putConfigMapRuleSets(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafConfigMapRuleSets[] | cdktf.IResolvable) {
    this._configMapRuleSets.internalValue = value;
  }
  public resetConfigMapRuleSets() {
    this._configMapRuleSets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRuleSetsInput() {
    return this._configMapRuleSets.internalValue;
  }

  // core_rule_set - computed: false, optional: true, required: false
  private _coreRuleSet = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSetOutputReference(this, "core_rule_set");
  public get coreRuleSet() {
    return this._coreRuleSet;
  }
  public putCoreRuleSet(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafCoreRuleSet) {
    this._coreRuleSet.internalValue = value;
  }
  public resetCoreRuleSet() {
    this._coreRuleSet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get coreRuleSetInput() {
    return this._coreRuleSet.internalValue;
  }

  // custom_intervention_message - computed: false, optional: true, required: false
  private _customInterventionMessage?: string; 
  public get customInterventionMessage() {
    return this.getStringAttribute('custom_intervention_message');
  }
  public set customInterventionMessage(value: string) {
    this._customInterventionMessage = value;
  }
  public resetCustomInterventionMessage() {
    this._customInterventionMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInterventionMessageInput() {
    return this._customInterventionMessage;
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // request_headers_only - computed: false, optional: true, required: false
  private _requestHeadersOnly?: boolean | cdktf.IResolvable; 
  public get requestHeadersOnly() {
    return this.getBooleanAttribute('request_headers_only');
  }
  public set requestHeadersOnly(value: boolean | cdktf.IResolvable) {
    this._requestHeadersOnly = value;
  }
  public resetRequestHeadersOnly() {
    this._requestHeadersOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersOnlyInput() {
    return this._requestHeadersOnly;
  }

  // response_headers_only - computed: false, optional: true, required: false
  private _responseHeadersOnly?: boolean | cdktf.IResolvable; 
  public get responseHeadersOnly() {
    return this.getBooleanAttribute('response_headers_only');
  }
  public set responseHeadersOnly(value: boolean | cdktf.IResolvable) {
    this._responseHeadersOnly = value;
  }
  public resetResponseHeadersOnly() {
    this._responseHeadersOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersOnlyInput() {
    return this._responseHeadersOnly;
  }

  // rule_sets - computed: false, optional: true, required: false
  private _ruleSets = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSetsList(this, "rule_sets", false);
  public get ruleSets() {
    return this._ruleSets;
  }
  public putRuleSets(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafRuleSets[] | cdktf.IResolvable) {
    this._ruleSets.internalValue = value;
  }
  public resetRuleSets() {
    this._ruleSets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleSetsInput() {
    return this._ruleSets.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#predicate DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#predicate}
  */
  readonly predicate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stage}
  */
  readonly stage?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStageToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    predicate: cdktf.stringToTerraform(struct!.predicate),
    stage: cdktf.stringToTerraform(struct!.stage),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStageToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    predicate: {
      value: cdktf.stringToHclTerraform(struct!.predicate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage: {
      value: cdktf.stringToHclTerraform(struct!.stage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._predicate !== undefined) {
      hasAnyValues = true;
      internalValueResult.predicate = this._predicate;
    }
    if (this._stage !== undefined) {
      hasAnyValues = true;
      internalValueResult.stage = this._stage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._predicate = undefined;
      this._stage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._predicate = value.predicate;
      this._stage = value.stage;
    }
  }

  // predicate - computed: false, optional: true, required: false
  private _predicate?: string; 
  public get predicate() {
    return this.getStringAttribute('predicate');
  }
  public set predicate(value: string) {
    this._predicate = value;
  }
  public resetPredicate() {
    this._predicate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get predicateInput() {
    return this._predicate;
  }

  // stage - computed: false, optional: true, required: false
  private _stage?: string; 
  public get stage() {
    return this.getStringAttribute('stage');
  }
  public set stage(value: string) {
    this._stage = value;
  }
  public resetStage() {
    this._stage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stageInput() {
    return this._stage;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#config}
  */
  readonly config?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#fail_open DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#fail_open}
  */
  readonly failOpen?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#file_path DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#file_path}
  */
  readonly filePath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#filter_stage DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#filter_stage}
  */
  readonly filterStage?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#image DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#root_id DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#root_id}
  */
  readonly rootId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#vm_type DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#vm_type}
  */
  readonly vmType?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.config),
    fail_open: cdktf.booleanToTerraform(struct!.failOpen),
    file_path: cdktf.stringToTerraform(struct!.filePath),
    filter_stage: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStageToTerraform(struct!.filterStage),
    image: cdktf.stringToTerraform(struct!.image),
    name: cdktf.stringToTerraform(struct!.name),
    root_id: cdktf.stringToTerraform(struct!.rootId),
    vm_type: cdktf.stringToTerraform(struct!.vmType),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.config),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    fail_open: {
      value: cdktf.booleanToHclTerraform(struct!.failOpen),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    file_path: {
      value: cdktf.stringToHclTerraform(struct!.filePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter_stage: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStageToHclTerraform(struct!.filterStage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_id: {
      value: cdktf.stringToHclTerraform(struct!.rootId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vm_type: {
      value: cdktf.stringToHclTerraform(struct!.vmType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._failOpen !== undefined) {
      hasAnyValues = true;
      internalValueResult.failOpen = this._failOpen;
    }
    if (this._filePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.filePath = this._filePath;
    }
    if (this._filterStage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterStage = this._filterStage?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._rootId !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootId = this._rootId;
    }
    if (this._vmType !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmType = this._vmType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._config = undefined;
      this._failOpen = undefined;
      this._filePath = undefined;
      this._filterStage.internalValue = undefined;
      this._image = undefined;
      this._name = undefined;
      this._rootId = undefined;
      this._vmType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._config = value.config;
      this._failOpen = value.failOpen;
      this._filePath = value.filePath;
      this._filterStage.internalValue = value.filterStage;
      this._image = value.image;
      this._name = value.name;
      this._rootId = value.rootId;
      this._vmType = value.vmType;
    }
  }

  // config - computed: false, optional: true, required: false
  private _config?: { [key: string]: string }; 
  public get config() {
    return this.getStringMapAttribute('config');
  }
  public set config(value: { [key: string]: string }) {
    this._config = value;
  }
  public resetConfig() {
    this._config = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // fail_open - computed: false, optional: true, required: false
  private _failOpen?: boolean | cdktf.IResolvable; 
  public get failOpen() {
    return this.getBooleanAttribute('fail_open');
  }
  public set failOpen(value: boolean | cdktf.IResolvable) {
    this._failOpen = value;
  }
  public resetFailOpen() {
    this._failOpen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failOpenInput() {
    return this._failOpen;
  }

  // file_path - computed: false, optional: true, required: false
  private _filePath?: string; 
  public get filePath() {
    return this.getStringAttribute('file_path');
  }
  public set filePath(value: string) {
    this._filePath = value;
  }
  public resetFilePath() {
    this._filePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filePathInput() {
    return this._filePath;
  }

  // filter_stage - computed: false, optional: true, required: false
  private _filterStage = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStageOutputReference(this, "filter_stage");
  public get filterStage() {
    return this._filterStage;
  }
  public putFilterStage(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersFilterStage) {
    this._filterStage.internalValue = value;
  }
  public resetFilterStage() {
    this._filterStage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterStageInput() {
    return this._filterStage.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // root_id - computed: false, optional: true, required: false
  private _rootId?: string; 
  public get rootId() {
    return this.getStringAttribute('root_id');
  }
  public set rootId(value: string) {
    this._rootId = value;
  }
  public resetRootId() {
    this._rootId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootIdInput() {
    return this._rootId;
  }

  // vm_type - computed: false, optional: true, required: false
  private _vmType?: string; 
  public get vmType() {
    return this.getStringAttribute('vm_type');
  }
  public set vmType(value: string) {
    this._vmType = value;
  }
  public resetVmType() {
    this._vmType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmTypeInput() {
    return this._vmType;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#filters DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#filters}
  */
  readonly filters?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersToTerraform, false)(struct!.filters),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#buffer DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#buffer}
  */
  readonly buffer?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#caching DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#caching}
  */
  readonly caching?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#connection_limit DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#connection_limit}
  */
  readonly connectionLimit?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#csrf DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#csrf}
  */
  readonly csrf?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disable_ext_proc DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disable_ext_proc}
  */
  readonly disableExtProc?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dlp DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dlp}
  */
  readonly dlp?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#dynamic_forward_proxy DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#dynamic_forward_proxy}
  */
  readonly dynamicForwardProxy?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ext_proc DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ext_proc}
  */
  readonly extProc?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#extauth DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#extauth}
  */
  readonly extauth?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#extensions DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#extensions}
  */
  readonly extensions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_json_transcoder DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_json_transcoder}
  */
  readonly grpcJsonTranscoder?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#grpc_web DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#grpc_web}
  */
  readonly grpcWeb?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#gzip DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#gzip}
  */
  readonly gzip?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#header_validation_settings DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#header_validation_settings}
  */
  readonly headerValidationSettings?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#health_check DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#health_check}
  */
  readonly healthCheck?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http_connection_manager_settings DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http_connection_manager_settings}
  */
  readonly httpConnectionManagerSettings?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http_local_ratelimit DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http_local_ratelimit}
  */
  readonly httpLocalRatelimit?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#leftmost_xff_address DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#leftmost_xff_address}
  */
  readonly leftmostXffAddress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#network_local_ratelimit DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#network_local_ratelimit}
  */
  readonly networkLocalRatelimit?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#proxy_latency DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#proxy_latency}
  */
  readonly proxyLatency?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ratelimit_server DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ratelimit_server}
  */
  readonly ratelimitServer?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#router DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#router}
  */
  readonly router?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sanitize_cluster_header DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sanitize_cluster_header}
  */
  readonly sanitizeClusterHeader?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#stateful_session DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#stateful_session}
  */
  readonly statefulSession?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tap DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tap}
  */
  readonly tap?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#waf DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#waf}
  */
  readonly waf?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#wasm DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#wasm}
  */
  readonly wasm?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBufferToTerraform(struct!.buffer),
    caching: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingToTerraform(struct!.caching),
    connection_limit: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimitToTerraform(struct!.connectionLimit),
    csrf: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfToTerraform(struct!.csrf),
    disable_ext_proc: cdktf.booleanToTerraform(struct!.disableExtProc),
    dlp: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpToTerraform(struct!.dlp),
    dynamic_forward_proxy: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyToTerraform(struct!.dynamicForwardProxy),
    ext_proc: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcToTerraform(struct!.extProc),
    extauth: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthToTerraform(struct!.extauth),
    extensions: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensionsToTerraform(struct!.extensions),
    grpc_json_transcoder: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderToTerraform(struct!.grpcJsonTranscoder),
    grpc_web: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWebToTerraform(struct!.grpcWeb),
    gzip: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzipToTerraform(struct!.gzip),
    header_validation_settings: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettingsToTerraform(struct!.headerValidationSettings),
    health_check: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheckToTerraform(struct!.healthCheck),
    http_connection_manager_settings: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsToTerraform(struct!.httpConnectionManagerSettings),
    http_local_ratelimit: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitToTerraform(struct!.httpLocalRatelimit),
    leftmost_xff_address: cdktf.booleanToTerraform(struct!.leftmostXffAddress),
    network_local_ratelimit: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimitToTerraform(struct!.networkLocalRatelimit),
    proxy_latency: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatencyToTerraform(struct!.proxyLatency),
    ratelimit_server: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerToTerraform(struct!.ratelimitServer),
    router: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouterToTerraform(struct!.router),
    sanitize_cluster_header: cdktf.booleanToTerraform(struct!.sanitizeClusterHeader),
    stateful_session: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionToTerraform(struct!.statefulSession),
    tap: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapToTerraform(struct!.tap),
    waf: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafToTerraform(struct!.waf),
    wasm: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmToTerraform(struct!.wasm),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBufferToHclTerraform(struct!.buffer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer",
    },
    caching: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingToHclTerraform(struct!.caching),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching",
    },
    connection_limit: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimitToHclTerraform(struct!.connectionLimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit",
    },
    csrf: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfToHclTerraform(struct!.csrf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf",
    },
    disable_ext_proc: {
      value: cdktf.booleanToHclTerraform(struct!.disableExtProc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dlp: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpToHclTerraform(struct!.dlp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp",
    },
    dynamic_forward_proxy: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyToHclTerraform(struct!.dynamicForwardProxy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy",
    },
    ext_proc: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcToHclTerraform(struct!.extProc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc",
    },
    extauth: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthToHclTerraform(struct!.extauth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth",
    },
    extensions: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensionsToHclTerraform(struct!.extensions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions",
    },
    grpc_json_transcoder: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderToHclTerraform(struct!.grpcJsonTranscoder),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder",
    },
    grpc_web: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWebToHclTerraform(struct!.grpcWeb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb",
    },
    gzip: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzipToHclTerraform(struct!.gzip),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip",
    },
    header_validation_settings: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettingsToHclTerraform(struct!.headerValidationSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings",
    },
    health_check: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheckToHclTerraform(struct!.healthCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck",
    },
    http_connection_manager_settings: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsToHclTerraform(struct!.httpConnectionManagerSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings",
    },
    http_local_ratelimit: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitToHclTerraform(struct!.httpLocalRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit",
    },
    leftmost_xff_address: {
      value: cdktf.booleanToHclTerraform(struct!.leftmostXffAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    network_local_ratelimit: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimitToHclTerraform(struct!.networkLocalRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit",
    },
    proxy_latency: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatencyToHclTerraform(struct!.proxyLatency),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency",
    },
    ratelimit_server: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerToHclTerraform(struct!.ratelimitServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer",
    },
    router: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouterToHclTerraform(struct!.router),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter",
    },
    sanitize_cluster_header: {
      value: cdktf.booleanToHclTerraform(struct!.sanitizeClusterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stateful_session: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionToHclTerraform(struct!.statefulSession),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession",
    },
    tap: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapToHclTerraform(struct!.tap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap",
    },
    waf: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafToHclTerraform(struct!.waf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf",
    },
    wasm: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmToHclTerraform(struct!.wasm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._buffer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.buffer = this._buffer?.internalValue;
    }
    if (this._caching?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caching = this._caching?.internalValue;
    }
    if (this._connectionLimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionLimit = this._connectionLimit?.internalValue;
    }
    if (this._csrf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.csrf = this._csrf?.internalValue;
    }
    if (this._disableExtProc !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableExtProc = this._disableExtProc;
    }
    if (this._dlp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dlp = this._dlp?.internalValue;
    }
    if (this._dynamicForwardProxy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicForwardProxy = this._dynamicForwardProxy?.internalValue;
    }
    if (this._extProc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extProc = this._extProc?.internalValue;
    }
    if (this._extauth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extauth = this._extauth?.internalValue;
    }
    if (this._extensions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extensions = this._extensions?.internalValue;
    }
    if (this._grpcJsonTranscoder?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcJsonTranscoder = this._grpcJsonTranscoder?.internalValue;
    }
    if (this._grpcWeb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcWeb = this._grpcWeb?.internalValue;
    }
    if (this._gzip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gzip = this._gzip?.internalValue;
    }
    if (this._headerValidationSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValidationSettings = this._headerValidationSettings?.internalValue;
    }
    if (this._healthCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheck = this._healthCheck?.internalValue;
    }
    if (this._httpConnectionManagerSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConnectionManagerSettings = this._httpConnectionManagerSettings?.internalValue;
    }
    if (this._httpLocalRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLocalRatelimit = this._httpLocalRatelimit?.internalValue;
    }
    if (this._leftmostXffAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.leftmostXffAddress = this._leftmostXffAddress;
    }
    if (this._networkLocalRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkLocalRatelimit = this._networkLocalRatelimit?.internalValue;
    }
    if (this._proxyLatency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyLatency = this._proxyLatency?.internalValue;
    }
    if (this._ratelimitServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ratelimitServer = this._ratelimitServer?.internalValue;
    }
    if (this._router?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.router = this._router?.internalValue;
    }
    if (this._sanitizeClusterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.sanitizeClusterHeader = this._sanitizeClusterHeader;
    }
    if (this._statefulSession?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.statefulSession = this._statefulSession?.internalValue;
    }
    if (this._tap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tap = this._tap?.internalValue;
    }
    if (this._waf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.waf = this._waf?.internalValue;
    }
    if (this._wasm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wasm = this._wasm?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._buffer.internalValue = undefined;
      this._caching.internalValue = undefined;
      this._connectionLimit.internalValue = undefined;
      this._csrf.internalValue = undefined;
      this._disableExtProc = undefined;
      this._dlp.internalValue = undefined;
      this._dynamicForwardProxy.internalValue = undefined;
      this._extProc.internalValue = undefined;
      this._extauth.internalValue = undefined;
      this._extensions.internalValue = undefined;
      this._grpcJsonTranscoder.internalValue = undefined;
      this._grpcWeb.internalValue = undefined;
      this._gzip.internalValue = undefined;
      this._headerValidationSettings.internalValue = undefined;
      this._healthCheck.internalValue = undefined;
      this._httpConnectionManagerSettings.internalValue = undefined;
      this._httpLocalRatelimit.internalValue = undefined;
      this._leftmostXffAddress = undefined;
      this._networkLocalRatelimit.internalValue = undefined;
      this._proxyLatency.internalValue = undefined;
      this._ratelimitServer.internalValue = undefined;
      this._router.internalValue = undefined;
      this._sanitizeClusterHeader = undefined;
      this._statefulSession.internalValue = undefined;
      this._tap.internalValue = undefined;
      this._waf.internalValue = undefined;
      this._wasm.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._buffer.internalValue = value.buffer;
      this._caching.internalValue = value.caching;
      this._connectionLimit.internalValue = value.connectionLimit;
      this._csrf.internalValue = value.csrf;
      this._disableExtProc = value.disableExtProc;
      this._dlp.internalValue = value.dlp;
      this._dynamicForwardProxy.internalValue = value.dynamicForwardProxy;
      this._extProc.internalValue = value.extProc;
      this._extauth.internalValue = value.extauth;
      this._extensions.internalValue = value.extensions;
      this._grpcJsonTranscoder.internalValue = value.grpcJsonTranscoder;
      this._grpcWeb.internalValue = value.grpcWeb;
      this._gzip.internalValue = value.gzip;
      this._headerValidationSettings.internalValue = value.headerValidationSettings;
      this._healthCheck.internalValue = value.healthCheck;
      this._httpConnectionManagerSettings.internalValue = value.httpConnectionManagerSettings;
      this._httpLocalRatelimit.internalValue = value.httpLocalRatelimit;
      this._leftmostXffAddress = value.leftmostXffAddress;
      this._networkLocalRatelimit.internalValue = value.networkLocalRatelimit;
      this._proxyLatency.internalValue = value.proxyLatency;
      this._ratelimitServer.internalValue = value.ratelimitServer;
      this._router.internalValue = value.router;
      this._sanitizeClusterHeader = value.sanitizeClusterHeader;
      this._statefulSession.internalValue = value.statefulSession;
      this._tap.internalValue = value.tap;
      this._waf.internalValue = value.waf;
      this._wasm.internalValue = value.wasm;
    }
  }

  // buffer - computed: false, optional: true, required: false
  private _buffer = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBufferOutputReference(this, "buffer");
  public get buffer() {
    return this._buffer;
  }
  public putBuffer(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsBuffer) {
    this._buffer.internalValue = value;
  }
  public resetBuffer() {
    this._buffer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferInput() {
    return this._buffer.internalValue;
  }

  // caching - computed: false, optional: true, required: false
  private _caching = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCachingOutputReference(this, "caching");
  public get caching() {
    return this._caching;
  }
  public putCaching(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCaching) {
    this._caching.internalValue = value;
  }
  public resetCaching() {
    this._caching.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingInput() {
    return this._caching.internalValue;
  }

  // connection_limit - computed: false, optional: true, required: false
  private _connectionLimit = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimitOutputReference(this, "connection_limit");
  public get connectionLimit() {
    return this._connectionLimit;
  }
  public putConnectionLimit(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsConnectionLimit) {
    this._connectionLimit.internalValue = value;
  }
  public resetConnectionLimit() {
    this._connectionLimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionLimitInput() {
    return this._connectionLimit.internalValue;
  }

  // csrf - computed: false, optional: true, required: false
  private _csrf = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrfOutputReference(this, "csrf");
  public get csrf() {
    return this._csrf;
  }
  public putCsrf(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsCsrf) {
    this._csrf.internalValue = value;
  }
  public resetCsrf() {
    this._csrf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csrfInput() {
    return this._csrf.internalValue;
  }

  // disable_ext_proc - computed: false, optional: true, required: false
  private _disableExtProc?: boolean | cdktf.IResolvable; 
  public get disableExtProc() {
    return this.getBooleanAttribute('disable_ext_proc');
  }
  public set disableExtProc(value: boolean | cdktf.IResolvable) {
    this._disableExtProc = value;
  }
  public resetDisableExtProc() {
    this._disableExtProc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableExtProcInput() {
    return this._disableExtProc;
  }

  // dlp - computed: false, optional: true, required: false
  private _dlp = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlpOutputReference(this, "dlp");
  public get dlp() {
    return this._dlp;
  }
  public putDlp(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDlp) {
    this._dlp.internalValue = value;
  }
  public resetDlp() {
    this._dlp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dlpInput() {
    return this._dlp.internalValue;
  }

  // dynamic_forward_proxy - computed: false, optional: true, required: false
  private _dynamicForwardProxy = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxyOutputReference(this, "dynamic_forward_proxy");
  public get dynamicForwardProxy() {
    return this._dynamicForwardProxy;
  }
  public putDynamicForwardProxy(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsDynamicForwardProxy) {
    this._dynamicForwardProxy.internalValue = value;
  }
  public resetDynamicForwardProxy() {
    this._dynamicForwardProxy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicForwardProxyInput() {
    return this._dynamicForwardProxy.internalValue;
  }

  // ext_proc - computed: false, optional: true, required: false
  private _extProc = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProcOutputReference(this, "ext_proc");
  public get extProc() {
    return this._extProc;
  }
  public putExtProc(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtProc) {
    this._extProc.internalValue = value;
  }
  public resetExtProc() {
    this._extProc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extProcInput() {
    return this._extProc.internalValue;
  }

  // extauth - computed: false, optional: true, required: false
  private _extauth = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauthOutputReference(this, "extauth");
  public get extauth() {
    return this._extauth;
  }
  public putExtauth(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtauth) {
    this._extauth.internalValue = value;
  }
  public resetExtauth() {
    this._extauth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extauthInput() {
    return this._extauth.internalValue;
  }

  // extensions - computed: false, optional: true, required: false
  private _extensions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensionsOutputReference(this, "extensions");
  public get extensions() {
    return this._extensions;
  }
  public putExtensions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsExtensions) {
    this._extensions.internalValue = value;
  }
  public resetExtensions() {
    this._extensions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extensionsInput() {
    return this._extensions.internalValue;
  }

  // grpc_json_transcoder - computed: false, optional: true, required: false
  private _grpcJsonTranscoder = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoderOutputReference(this, "grpc_json_transcoder");
  public get grpcJsonTranscoder() {
    return this._grpcJsonTranscoder;
  }
  public putGrpcJsonTranscoder(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcJsonTranscoder) {
    this._grpcJsonTranscoder.internalValue = value;
  }
  public resetGrpcJsonTranscoder() {
    this._grpcJsonTranscoder.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcJsonTranscoderInput() {
    return this._grpcJsonTranscoder.internalValue;
  }

  // grpc_web - computed: false, optional: true, required: false
  private _grpcWeb = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWebOutputReference(this, "grpc_web");
  public get grpcWeb() {
    return this._grpcWeb;
  }
  public putGrpcWeb(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGrpcWeb) {
    this._grpcWeb.internalValue = value;
  }
  public resetGrpcWeb() {
    this._grpcWeb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcWebInput() {
    return this._grpcWeb.internalValue;
  }

  // gzip - computed: false, optional: true, required: false
  private _gzip = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzipOutputReference(this, "gzip");
  public get gzip() {
    return this._gzip;
  }
  public putGzip(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsGzip) {
    this._gzip.internalValue = value;
  }
  public resetGzip() {
    this._gzip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gzipInput() {
    return this._gzip.internalValue;
  }

  // header_validation_settings - computed: false, optional: true, required: false
  private _headerValidationSettings = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettingsOutputReference(this, "header_validation_settings");
  public get headerValidationSettings() {
    return this._headerValidationSettings;
  }
  public putHeaderValidationSettings(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHeaderValidationSettings) {
    this._headerValidationSettings.internalValue = value;
  }
  public resetHeaderValidationSettings() {
    this._headerValidationSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValidationSettingsInput() {
    return this._headerValidationSettings.internalValue;
  }

  // health_check - computed: false, optional: true, required: false
  private _healthCheck = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheckOutputReference(this, "health_check");
  public get healthCheck() {
    return this._healthCheck;
  }
  public putHealthCheck(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHealthCheck) {
    this._healthCheck.internalValue = value;
  }
  public resetHealthCheck() {
    this._healthCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckInput() {
    return this._healthCheck.internalValue;
  }

  // http_connection_manager_settings - computed: false, optional: true, required: false
  private _httpConnectionManagerSettings = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettingsOutputReference(this, "http_connection_manager_settings");
  public get httpConnectionManagerSettings() {
    return this._httpConnectionManagerSettings;
  }
  public putHttpConnectionManagerSettings(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpConnectionManagerSettings) {
    this._httpConnectionManagerSettings.internalValue = value;
  }
  public resetHttpConnectionManagerSettings() {
    this._httpConnectionManagerSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConnectionManagerSettingsInput() {
    return this._httpConnectionManagerSettings.internalValue;
  }

  // http_local_ratelimit - computed: false, optional: true, required: false
  private _httpLocalRatelimit = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimitOutputReference(this, "http_local_ratelimit");
  public get httpLocalRatelimit() {
    return this._httpLocalRatelimit;
  }
  public putHttpLocalRatelimit(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsHttpLocalRatelimit) {
    this._httpLocalRatelimit.internalValue = value;
  }
  public resetHttpLocalRatelimit() {
    this._httpLocalRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLocalRatelimitInput() {
    return this._httpLocalRatelimit.internalValue;
  }

  // leftmost_xff_address - computed: false, optional: true, required: false
  private _leftmostXffAddress?: boolean | cdktf.IResolvable; 
  public get leftmostXffAddress() {
    return this.getBooleanAttribute('leftmost_xff_address');
  }
  public set leftmostXffAddress(value: boolean | cdktf.IResolvable) {
    this._leftmostXffAddress = value;
  }
  public resetLeftmostXffAddress() {
    this._leftmostXffAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leftmostXffAddressInput() {
    return this._leftmostXffAddress;
  }

  // network_local_ratelimit - computed: false, optional: true, required: false
  private _networkLocalRatelimit = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimitOutputReference(this, "network_local_ratelimit");
  public get networkLocalRatelimit() {
    return this._networkLocalRatelimit;
  }
  public putNetworkLocalRatelimit(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsNetworkLocalRatelimit) {
    this._networkLocalRatelimit.internalValue = value;
  }
  public resetNetworkLocalRatelimit() {
    this._networkLocalRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkLocalRatelimitInput() {
    return this._networkLocalRatelimit.internalValue;
  }

  // proxy_latency - computed: false, optional: true, required: false
  private _proxyLatency = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatencyOutputReference(this, "proxy_latency");
  public get proxyLatency() {
    return this._proxyLatency;
  }
  public putProxyLatency(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsProxyLatency) {
    this._proxyLatency.internalValue = value;
  }
  public resetProxyLatency() {
    this._proxyLatency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyLatencyInput() {
    return this._proxyLatency.internalValue;
  }

  // ratelimit_server - computed: false, optional: true, required: false
  private _ratelimitServer = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServerOutputReference(this, "ratelimit_server");
  public get ratelimitServer() {
    return this._ratelimitServer;
  }
  public putRatelimitServer(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRatelimitServer) {
    this._ratelimitServer.internalValue = value;
  }
  public resetRatelimitServer() {
    this._ratelimitServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ratelimitServerInput() {
    return this._ratelimitServer.internalValue;
  }

  // router - computed: false, optional: true, required: false
  private _router = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouterOutputReference(this, "router");
  public get router() {
    return this._router;
  }
  public putRouter(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsRouter) {
    this._router.internalValue = value;
  }
  public resetRouter() {
    this._router.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerInput() {
    return this._router.internalValue;
  }

  // sanitize_cluster_header - computed: false, optional: true, required: false
  private _sanitizeClusterHeader?: boolean | cdktf.IResolvable; 
  public get sanitizeClusterHeader() {
    return this.getBooleanAttribute('sanitize_cluster_header');
  }
  public set sanitizeClusterHeader(value: boolean | cdktf.IResolvable) {
    this._sanitizeClusterHeader = value;
  }
  public resetSanitizeClusterHeader() {
    this._sanitizeClusterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sanitizeClusterHeaderInput() {
    return this._sanitizeClusterHeader;
  }

  // stateful_session - computed: false, optional: true, required: false
  private _statefulSession = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSessionOutputReference(this, "stateful_session");
  public get statefulSession() {
    return this._statefulSession;
  }
  public putStatefulSession(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsStatefulSession) {
    this._statefulSession.internalValue = value;
  }
  public resetStatefulSession() {
    this._statefulSession.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statefulSessionInput() {
    return this._statefulSession.internalValue;
  }

  // tap - computed: false, optional: true, required: false
  private _tap = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTapOutputReference(this, "tap");
  public get tap() {
    return this._tap;
  }
  public putTap(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsTap) {
    this._tap.internalValue = value;
  }
  public resetTap() {
    this._tap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapInput() {
    return this._tap.internalValue;
  }

  // waf - computed: false, optional: true, required: false
  private _waf = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWafOutputReference(this, "waf");
  public get waf() {
    return this._waf;
  }
  public putWaf(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWaf) {
    this._waf.internalValue = value;
  }
  public resetWaf() {
    this._waf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wafInput() {
    return this._waf.internalValue;
  }

  // wasm - computed: false, optional: true, required: false
  private _wasm = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasmOutputReference(this, "wasm");
  public get wasm() {
    return this._wasm;
  }
  public putWasm(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsWasm) {
    this._wasm.internalValue = value;
  }
  public resetWasm() {
    this._wasm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wasmInput() {
    return this._wasm.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#operator DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#values DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#expressions DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#expressions}
  */
  readonly expressions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expressions: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsToTerraform, false)(struct!.expressions),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expressions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsToHclTerraform, false)(struct!.expressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressions = this._expressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expressions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expressions.internalValue = value.expressions;
    }
  }

  // expressions - computed: false, optional: true, required: false
  private _expressions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressionsList(this, "expressions", false);
  public get expressions() {
    return this._expressions;
  }
  public putExpressions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsExpressions[] | cdktf.IResolvable) {
    this._expressions.internalValue = value;
  }
  public resetExpressions() {
    this._expressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionsInput() {
    return this._expressions.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#options DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#options}
  */
  readonly options?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#virtual_service_expressions DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#virtual_service_expressions}
  */
  readonly virtualServiceExpressions?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#virtual_service_namespaces DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#virtual_service_namespaces}
  */
  readonly virtualServiceNamespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#virtual_service_selector DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#virtual_service_selector}
  */
  readonly virtualServiceSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#virtual_services DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#virtual_services}
  */
  readonly virtualServices?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    options: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsToTerraform(struct!.options),
    virtual_service_expressions: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsToTerraform(struct!.virtualServiceExpressions),
    virtual_service_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.virtualServiceNamespaces),
    virtual_service_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.virtualServiceSelector),
    virtual_services: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesToTerraform, false)(struct!.virtualServices),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    options: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsToHclTerraform(struct!.options),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions",
    },
    virtual_service_expressions: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsToHclTerraform(struct!.virtualServiceExpressions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions",
    },
    virtual_service_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.virtualServiceNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    virtual_service_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.virtualServiceSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    virtual_services: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesToHclTerraform, false)(struct!.virtualServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._options?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options?.internalValue;
    }
    if (this._virtualServiceExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceExpressions = this._virtualServiceExpressions?.internalValue;
    }
    if (this._virtualServiceNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceNamespaces = this._virtualServiceNamespaces;
    }
    if (this._virtualServiceSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceSelector = this._virtualServiceSelector;
    }
    if (this._virtualServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServices = this._virtualServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._options.internalValue = undefined;
      this._virtualServiceExpressions.internalValue = undefined;
      this._virtualServiceNamespaces = undefined;
      this._virtualServiceSelector = undefined;
      this._virtualServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._options.internalValue = value.options;
      this._virtualServiceExpressions.internalValue = value.virtualServiceExpressions;
      this._virtualServiceNamespaces = value.virtualServiceNamespaces;
      this._virtualServiceSelector = value.virtualServiceSelector;
      this._virtualServices.internalValue = value.virtualServices;
    }
  }

  // options - computed: false, optional: true, required: false
  private _options = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptionsOutputReference(this, "options");
  public get options() {
    return this._options;
  }
  public putOptions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOptions) {
    this._options.internalValue = value;
  }
  public resetOptions() {
    this._options.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options.internalValue;
  }

  // virtual_service_expressions - computed: false, optional: true, required: false
  private _virtualServiceExpressions = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressionsOutputReference(this, "virtual_service_expressions");
  public get virtualServiceExpressions() {
    return this._virtualServiceExpressions;
  }
  public putVirtualServiceExpressions(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServiceExpressions) {
    this._virtualServiceExpressions.internalValue = value;
  }
  public resetVirtualServiceExpressions() {
    this._virtualServiceExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceExpressionsInput() {
    return this._virtualServiceExpressions.internalValue;
  }

  // virtual_service_namespaces - computed: false, optional: true, required: false
  private _virtualServiceNamespaces?: string[]; 
  public get virtualServiceNamespaces() {
    return this.getListAttribute('virtual_service_namespaces');
  }
  public set virtualServiceNamespaces(value: string[]) {
    this._virtualServiceNamespaces = value;
  }
  public resetVirtualServiceNamespaces() {
    this._virtualServiceNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceNamespacesInput() {
    return this._virtualServiceNamespaces;
  }

  // virtual_service_selector - computed: false, optional: true, required: false
  private _virtualServiceSelector?: { [key: string]: string }; 
  public get virtualServiceSelector() {
    return this.getStringMapAttribute('virtual_service_selector');
  }
  public set virtualServiceSelector(value: { [key: string]: string }) {
    this._virtualServiceSelector = value;
  }
  public resetVirtualServiceSelector() {
    this._virtualServiceSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceSelectorInput() {
    return this._virtualServiceSelector;
  }

  // virtual_services - computed: false, optional: true, required: false
  private _virtualServices = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServicesList(this, "virtual_services", false);
  public get virtualServices() {
    return this._virtualServices;
  }
  public putVirtualServices(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayVirtualServices[] | cdktf.IResolvable) {
    this._virtualServices.internalValue = value;
  }
  public resetVirtualServices() {
    this._virtualServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServicesInput() {
    return this._virtualServices.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#address_prefix DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#address_prefix}
  */
  readonly addressPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#prefix_len DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#prefix_len}
  */
  readonly prefixLen?: number;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.stringToTerraform(struct!.addressPrefix),
    prefix_len: cdktf.numberToTerraform(struct!.prefixLen),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.stringToHclTerraform(struct!.addressPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_len: {
      value: cdktf.numberToHclTerraform(struct!.prefixLen),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix;
    }
    if (this._prefixLen !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixLen = this._prefixLen;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix = undefined;
      this._prefixLen = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix = value.addressPrefix;
      this._prefixLen = value.prefixLen;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix?: string; 
  public get addressPrefix() {
    return this.getStringAttribute('address_prefix');
  }
  public set addressPrefix(value: string) {
    this._addressPrefix = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix;
  }

  // prefix_len - computed: false, optional: true, required: false
  private _prefixLen?: number; 
  public get prefixLen() {
    return this.getNumberAttribute('prefix_len');
  }
  public set prefixLen(value: number) {
    this._prefixLen = value;
  }
  public resetPrefixLen() {
    this._prefixLen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixLenInput() {
    return this._prefixLen;
  }
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesOutputReference {
    return new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cipher_suites DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ecdh_curves DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ecdh_curves}
  */
  readonly ecdhCurves?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#maximum_protocol_version DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#maximum_protocol_version}
  */
  readonly maximumProtocolVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#minimum_protocol_version DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#minimum_protocol_version}
  */
  readonly minimumProtocolVersion?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParametersToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    ecdh_curves: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ecdhCurves),
    maximum_protocol_version: cdktf.stringToTerraform(struct!.maximumProtocolVersion),
    minimum_protocol_version: cdktf.stringToTerraform(struct!.minimumProtocolVersion),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParametersToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ecdh_curves: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ecdhCurves),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    maximum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maximumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    minimum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minimumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._ecdhCurves !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecdhCurves = this._ecdhCurves;
    }
    if (this._maximumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumProtocolVersion = this._maximumProtocolVersion;
    }
    if (this._minimumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumProtocolVersion = this._minimumProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cipherSuites = undefined;
      this._ecdhCurves = undefined;
      this._maximumProtocolVersion = undefined;
      this._minimumProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cipherSuites = value.cipherSuites;
      this._ecdhCurves = value.ecdhCurves;
      this._maximumProtocolVersion = value.maximumProtocolVersion;
      this._minimumProtocolVersion = value.minimumProtocolVersion;
    }
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // ecdh_curves - computed: false, optional: true, required: false
  private _ecdhCurves?: string[]; 
  public get ecdhCurves() {
    return this.getListAttribute('ecdh_curves');
  }
  public set ecdhCurves(value: string[]) {
    this._ecdhCurves = value;
  }
  public resetEcdhCurves() {
    this._ecdhCurves = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecdhCurvesInput() {
    return this._ecdhCurves;
  }

  // maximum_protocol_version - computed: false, optional: true, required: false
  private _maximumProtocolVersion?: string; 
  public get maximumProtocolVersion() {
    return this.getStringAttribute('maximum_protocol_version');
  }
  public set maximumProtocolVersion(value: string) {
    this._maximumProtocolVersion = value;
  }
  public resetMaximumProtocolVersion() {
    this._maximumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumProtocolVersionInput() {
    return this._maximumProtocolVersion;
  }

  // minimum_protocol_version - computed: false, optional: true, required: false
  private _minimumProtocolVersion?: string; 
  public get minimumProtocolVersion() {
    return this.getStringAttribute('minimum_protocol_version');
  }
  public set minimumProtocolVersion(value: string) {
    this._minimumProtocolVersion = value;
  }
  public resetMinimumProtocolVersion() {
    this._minimumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumProtocolVersionInput() {
    return this._minimumProtocolVersion;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#header DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#token_file_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#token_file_name}
  */
  readonly tokenFileName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    token_file_name: cdktf.stringToTerraform(struct!.tokenFileName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_file_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._tokenFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenFileName = this._tokenFileName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._tokenFileName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._tokenFileName = value.tokenFileName;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // token_file_name - computed: false, optional: true, required: false
  private _tokenFileName?: string; 
  public get tokenFileName() {
    return this.getStringAttribute('token_file_name');
  }
  public set tokenFileName(value: string) {
    this._tokenFileName = value;
  }
  public resetTokenFileName() {
    this._tokenFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenFileNameInput() {
    return this._tokenFileName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#file_credential_source DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#file_credential_source}
  */
  readonly fileCredentialSource?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file_credential_source: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct!.fileCredentialSource),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file_credential_source: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct!.fileCredentialSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fileCredentialSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileCredentialSource = this._fileCredentialSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = value.fileCredentialSource;
    }
  }

  // file_credential_source - computed: false, optional: true, required: false
  private _fileCredentialSource = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSourceOutputReference(this, "file_credential_source");
  public get fileCredentialSource() {
    return this._fileCredentialSource;
  }
  public putFileCredentialSource(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsFileCredentialSource) {
    this._fileCredentialSource.internalValue = value;
  }
  public resetFileCredentialSource() {
    this._fileCredentialSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileCredentialSourceInput() {
    return this._fileCredentialSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#call_credentials DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#call_credentials}
  */
  readonly callCredentials?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#certificates_secret_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#certificates_secret_name}
  */
  readonly certificatesSecretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#target_uri DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#target_uri}
  */
  readonly targetUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#validation_context_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#validation_context_name}
  */
  readonly validationContextName?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    call_credentials: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsToTerraform(struct!.callCredentials),
    certificates_secret_name: cdktf.stringToTerraform(struct!.certificatesSecretName),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
    validation_context_name: cdktf.stringToTerraform(struct!.validationContextName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    call_credentials: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsToHclTerraform(struct!.callCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials",
    },
    certificates_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.certificatesSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validation_context_name: {
      value: cdktf.stringToHclTerraform(struct!.validationContextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._callCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.callCredentials = this._callCredentials?.internalValue;
    }
    if (this._certificatesSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesSecretName = this._certificatesSecretName;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    if (this._validationContextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationContextName = this._validationContextName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = undefined;
      this._certificatesSecretName = undefined;
      this._clusterName = undefined;
      this._targetUri = undefined;
      this._validationContextName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = value.callCredentials;
      this._certificatesSecretName = value.certificatesSecretName;
      this._clusterName = value.clusterName;
      this._targetUri = value.targetUri;
      this._validationContextName = value.validationContextName;
    }
  }

  // call_credentials - computed: false, optional: true, required: false
  private _callCredentials = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentialsOutputReference(this, "call_credentials");
  public get callCredentials() {
    return this._callCredentials;
  }
  public putCallCredentials(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsCallCredentials) {
    this._callCredentials.internalValue = value;
  }
  public resetCallCredentials() {
    this._callCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callCredentialsInput() {
    return this._callCredentials.internalValue;
  }

  // certificates_secret_name - computed: false, optional: true, required: false
  private _certificatesSecretName?: string; 
  public get certificatesSecretName() {
    return this.getStringAttribute('certificates_secret_name');
  }
  public set certificatesSecretName(value: string) {
    this._certificatesSecretName = value;
  }
  public resetCertificatesSecretName() {
    this._certificatesSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesSecretNameInput() {
    return this._certificatesSecretName;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }

  // validation_context_name - computed: false, optional: true, required: false
  private _validationContextName?: string; 
  public get validationContextName() {
    return this.getStringAttribute('validation_context_name');
  }
  public set validationContextName(value: string) {
    this._validationContextName = value;
  }
  public resetValidationContextName() {
    this._validationContextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationContextNameInput() {
    return this._validationContextName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespace DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRefToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ocsp_staple DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#root_ca DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tls_cert DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#tls_key DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFilesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFilesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#alpn_protocols DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#disable_tls_session_resumption DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#disable_tls_session_resumption}
  */
  readonly disableTlsSessionResumption?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ocsp_staple_policy DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ocsp_staple_policy}
  */
  readonly ocspStaplePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#one_way_tls DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#parameters DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sds DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sds}
  */
  readonly sds?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#secret_ref DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#sni_domains DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#sni_domains}
  */
  readonly sniDomains?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ssl_files DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#transport_socket_connect_timeout DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#transport_socket_connect_timeout}
  */
  readonly transportSocketConnectTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#verify_subject_alt_name DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    disable_tls_session_resumption: cdktf.booleanToTerraform(struct!.disableTlsSessionResumption),
    ocsp_staple_policy: cdktf.stringToTerraform(struct!.ocspStaplePolicy),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRefToTerraform(struct!.secretRef),
    sni_domains: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sniDomains),
    ssl_files: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFilesToTerraform(struct!.sslFiles),
    transport_socket_connect_timeout: cdktf.stringToTerraform(struct!.transportSocketConnectTimeout),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_tls_session_resumption: {
      value: cdktf.booleanToHclTerraform(struct!.disableTlsSessionResumption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ocsp_staple_policy: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaplePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters",
    },
    sds: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef",
    },
    sni_domains: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sniDomains),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ssl_files: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles",
    },
    transport_socket_connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.transportSocketConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._disableTlsSessionResumption !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTlsSessionResumption = this._disableTlsSessionResumption;
    }
    if (this._ocspStaplePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaplePolicy = this._ocspStaplePolicy;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sniDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.sniDomains = this._sniDomains;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._transportSocketConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.transportSocketConnectTimeout = this._transportSocketConnectTimeout;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alpnProtocols = undefined;
      this._disableTlsSessionResumption = undefined;
      this._ocspStaplePolicy = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sniDomains = undefined;
      this._sslFiles.internalValue = undefined;
      this._transportSocketConnectTimeout = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alpnProtocols = value.alpnProtocols;
      this._disableTlsSessionResumption = value.disableTlsSessionResumption;
      this._ocspStaplePolicy = value.ocspStaplePolicy;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sniDomains = value.sniDomains;
      this._sslFiles.internalValue = value.sslFiles;
      this._transportSocketConnectTimeout = value.transportSocketConnectTimeout;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // disable_tls_session_resumption - computed: false, optional: true, required: false
  private _disableTlsSessionResumption?: boolean | cdktf.IResolvable; 
  public get disableTlsSessionResumption() {
    return this.getBooleanAttribute('disable_tls_session_resumption');
  }
  public set disableTlsSessionResumption(value: boolean | cdktf.IResolvable) {
    this._disableTlsSessionResumption = value;
  }
  public resetDisableTlsSessionResumption() {
    this._disableTlsSessionResumption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTlsSessionResumptionInput() {
    return this._disableTlsSessionResumption;
  }

  // ocsp_staple_policy - computed: false, optional: true, required: false
  private _ocspStaplePolicy?: string; 
  public get ocspStaplePolicy() {
    return this.getStringAttribute('ocsp_staple_policy');
  }
  public set ocspStaplePolicy(value: string) {
    this._ocspStaplePolicy = value;
  }
  public resetOcspStaplePolicy() {
    this._ocspStaplePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStaplePolicyInput() {
    return this._ocspStaplePolicy;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni_domains - computed: false, optional: true, required: false
  private _sniDomains?: string[]; 
  public get sniDomains() {
    return this.getListAttribute('sni_domains');
  }
  public set sniDomains(value: string[]) {
    this._sniDomains = value;
  }
  public resetSniDomains() {
    this._sniDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniDomainsInput() {
    return this._sniDomains;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // transport_socket_connect_timeout - computed: false, optional: true, required: false
  private _transportSocketConnectTimeout?: string; 
  public get transportSocketConnectTimeout() {
    return this.getStringAttribute('transport_socket_connect_timeout');
  }
  public set transportSocketConnectTimeout(value: string) {
    this._transportSocketConnectTimeout = value;
  }
  public resetTransportSocketConnectTimeout() {
    this._transportSocketConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportSocketConnectTimeoutInput() {
    return this._transportSocketConnectTimeout;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#source_prefix_ranges DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#source_prefix_ranges}
  */
  readonly sourcePrefixRanges?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#ssl_config DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#ssl_config}
  */
  readonly sslConfig?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source_prefix_ranges: cdktf.listMapper(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesToTerraform, false)(struct!.sourcePrefixRanges),
    ssl_config: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigToTerraform(struct!.sslConfig),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source_prefix_ranges: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesToHclTerraform, false)(struct!.sourcePrefixRanges),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesList",
    },
    ssl_config: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigToHclTerraform(struct!.sslConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sourcePrefixRanges?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourcePrefixRanges = this._sourcePrefixRanges?.internalValue;
    }
    if (this._sslConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslConfig = this._sslConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sourcePrefixRanges.internalValue = undefined;
      this._sslConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sourcePrefixRanges.internalValue = value.sourcePrefixRanges;
      this._sslConfig.internalValue = value.sslConfig;
    }
  }

  // source_prefix_ranges - computed: false, optional: true, required: false
  private _sourcePrefixRanges = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRangesList(this, "source_prefix_ranges", false);
  public get sourcePrefixRanges() {
    return this._sourcePrefixRanges;
  }
  public putSourcePrefixRanges(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSourcePrefixRanges[] | cdktf.IResolvable) {
    this._sourcePrefixRanges.internalValue = value;
  }
  public resetSourcePrefixRanges() {
    this._sourcePrefixRanges.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcePrefixRangesInput() {
    return this._sourcePrefixRanges.internalValue;
  }

  // ssl_config - computed: false, optional: true, required: false
  private _sslConfig = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfigOutputReference(this, "ssl_config");
  public get sslConfig() {
    return this._sslConfig;
  }
  public putSslConfig(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherSslConfig) {
    this._sslConfig.internalValue = value;
  }
  public resetSslConfig() {
    this._sslConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslConfigInput() {
    return this._sslConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#statuses DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#statuses}
  */
  readonly statuses?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatusesToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    statuses: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.statuses),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatusesToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    statuses: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.statuses),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatusesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._statuses !== undefined) {
      hasAnyValues = true;
      internalValueResult.statuses = this._statuses;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._statuses = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._statuses = value.statuses;
    }
  }

  // statuses - computed: false, optional: true, required: false
  private _statuses?: { [key: string]: string }; 
  public get statuses() {
    return this.getStringMapAttribute('statuses');
  }
  public set statuses(value: { [key: string]: string }) {
    this._statuses = value;
  }
  public resetStatuses() {
    this._statuses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusesInput() {
    return this._statuses;
  }
}
export interface DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#http_gateway DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#http_gateway}
  */
  readonly httpGateway?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#matcher DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#matcher}
  */
  readonly matcher?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#namespaced_statuses DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest#namespaced_statuses}
  */
  readonly namespacedStatuses?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses;
}

export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecToTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_gateway: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayToTerraform(struct!.httpGateway),
    matcher: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherToTerraform(struct!.matcher),
    namespaced_statuses: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatusesToTerraform(struct!.namespacedStatuses),
  }
}


export function dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecToHclTerraform(struct?: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_gateway: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayToHclTerraform(struct!.httpGateway),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway",
    },
    matcher: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherToHclTerraform(struct!.matcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher",
    },
    namespaced_statuses: {
      value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatusesToHclTerraform(struct!.namespacedStatuses),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpGateway?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpGateway = this._httpGateway?.internalValue;
    }
    if (this._matcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matcher = this._matcher?.internalValue;
    }
    if (this._namespacedStatuses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespacedStatuses = this._namespacedStatuses?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpGateway.internalValue = undefined;
      this._matcher.internalValue = undefined;
      this._namespacedStatuses.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpGateway.internalValue = value.httpGateway;
      this._matcher.internalValue = value.matcher;
      this._namespacedStatuses.internalValue = value.namespacedStatuses;
    }
  }

  // http_gateway - computed: false, optional: true, required: false
  private _httpGateway = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGatewayOutputReference(this, "http_gateway");
  public get httpGateway() {
    return this._httpGateway;
  }
  public putHttpGateway(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecHttpGateway) {
    this._httpGateway.internalValue = value;
  }
  public resetHttpGateway() {
    this._httpGateway.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpGatewayInput() {
    return this._httpGateway.internalValue;
  }

  // matcher - computed: false, optional: true, required: false
  private _matcher = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcherOutputReference(this, "matcher");
  public get matcher() {
    return this._matcher;
  }
  public putMatcher(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecMatcher) {
    this._matcher.internalValue = value;
  }
  public resetMatcher() {
    this._matcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matcherInput() {
    return this._matcher.internalValue;
  }

  // namespaced_statuses - computed: false, optional: true, required: false
  private _namespacedStatuses = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatusesOutputReference(this, "namespaced_statuses");
  public get namespacedStatuses() {
    return this._namespacedStatuses;
  }
  public putNamespacedStatuses(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecNamespacedStatuses) {
    this._namespacedStatuses.internalValue = value;
  }
  public resetNamespacedStatuses() {
    this._namespacedStatuses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacedStatusesInput() {
    return this._namespacedStatuses.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest k8s_gateway_solo_io_matchable_http_gateway_v1_manifest}
*/
export class DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_gateway_solo_io_matchable_http_gateway_v1_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest to import
  * @param importFromId The id of the existing DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8SGatewaySoloIoMatchableHttpGatewayV1Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_gateway_solo_io_matchable_http_gateway_v1_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_matchable_http_gateway_v1_manifest k8s_gateway_solo_io_matchable_http_gateway_v1_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_gateway_solo_io_matchable_http_gateway_v1_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.10.20'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestMetadata",
      },
      spec: {
        value: dataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SGatewaySoloIoMatchableHttpGatewayV1ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
