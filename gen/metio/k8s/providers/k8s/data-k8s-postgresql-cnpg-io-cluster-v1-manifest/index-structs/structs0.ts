import * as cdktf from 'cdktf';
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#annotations DataK8SPostgresqlCnpgIoClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#labels DataK8SPostgresqlCnpgIoClusterV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespace DataK8SPostgresqlCnpgIoClusterV1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestMetadataToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestMetadataToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#label_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key in (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key notin (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#mismatch_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#mismatch_label_keys}
  */
  readonly mismatchLabelKeys?: string[];
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespace_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespaces DataK8SPostgresqlCnpgIoClusterV1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#topology_key DataK8SPostgresqlCnpgIoClusterV1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    mismatch_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mismatchLabelKeys),
    namespace_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mismatch_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mismatchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._mismatchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.mismatchLabelKeys = this._mismatchLabelKeys;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._mismatchLabelKeys = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._mismatchLabelKeys = value.mismatchLabelKeys;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // mismatch_label_keys - computed: false, optional: true, required: false
  private _mismatchLabelKeys?: string[]; 
  public get mismatchLabelKeys() {
    return this.getListAttribute('mismatch_label_keys');
  }
  public set mismatchLabelKeys(value: string[]) {
    this._mismatchLabelKeys = value;
  }
  public resetMismatchLabelKeys() {
    this._mismatchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mismatchLabelKeysInput() {
    return this._mismatchLabelKeys;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A pod affinity term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pod_affinity_term DataK8SPostgresqlCnpgIoClusterV1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#weight DataK8SPostgresqlCnpgIoClusterV1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#label_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key in (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key notin (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#mismatch_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#mismatch_label_keys}
  */
  readonly mismatchLabelKeys?: string[];
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespace_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespaces DataK8SPostgresqlCnpgIoClusterV1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#topology_key DataK8SPostgresqlCnpgIoClusterV1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    mismatch_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mismatchLabelKeys),
    namespace_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mismatch_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mismatchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._mismatchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.mismatchLabelKeys = this._mismatchLabelKeys;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._mismatchLabelKeys = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._mismatchLabelKeys = value.mismatchLabelKeys;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // mismatch_label_keys - computed: false, optional: true, required: false
  private _mismatchLabelKeys?: string[]; 
  public get mismatchLabelKeys() {
    return this.getListAttribute('mismatch_label_keys');
  }
  public set mismatchLabelKeys(value: string[]) {
    this._mismatchLabelKeys = value;
  }
  public resetMismatchLabelKeys() {
    this._mismatchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mismatchLabelKeysInput() {
    return this._mismatchLabelKeys;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SPostgresqlCnpgIoClusterV1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#required_during_scheduling_ignored_during_execution DataK8SPostgresqlCnpgIoClusterV1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#label_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key in (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key notin (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#mismatch_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#mismatch_label_keys}
  */
  readonly mismatchLabelKeys?: string[];
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespace_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespaces DataK8SPostgresqlCnpgIoClusterV1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#topology_key DataK8SPostgresqlCnpgIoClusterV1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    mismatch_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mismatchLabelKeys),
    namespace_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mismatch_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mismatchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._mismatchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.mismatchLabelKeys = this._mismatchLabelKeys;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._mismatchLabelKeys = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._mismatchLabelKeys = value.mismatchLabelKeys;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // mismatch_label_keys - computed: false, optional: true, required: false
  private _mismatchLabelKeys?: string[]; 
  public get mismatchLabelKeys() {
    return this.getListAttribute('mismatch_label_keys');
  }
  public set mismatchLabelKeys(value: string[]) {
    this._mismatchLabelKeys = value;
  }
  public resetMismatchLabelKeys() {
    this._mismatchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mismatchLabelKeysInput() {
    return this._mismatchLabelKeys;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A pod affinity term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pod_affinity_term DataK8SPostgresqlCnpgIoClusterV1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#weight DataK8SPostgresqlCnpgIoClusterV1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches with no Pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#label_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key in (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with 'labelSelector' as 'key notin (value)' to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#mismatch_label_keys DataK8SPostgresqlCnpgIoClusterV1Manifest#mismatch_label_keys}
  */
  readonly mismatchLabelKeys?: string[];
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespace_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespaces DataK8SPostgresqlCnpgIoClusterV1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#topology_key DataK8SPostgresqlCnpgIoClusterV1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    mismatch_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mismatchLabelKeys),
    namespace_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mismatch_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mismatchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._mismatchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.mismatchLabelKeys = this._mismatchLabelKeys;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._mismatchLabelKeys = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._mismatchLabelKeys = value.mismatchLabelKeys;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // mismatch_label_keys - computed: false, optional: true, required: false
  private _mismatchLabelKeys?: string[]; 
  public get mismatchLabelKeys() {
    return this.getListAttribute('mismatch_label_keys');
  }
  public set mismatchLabelKeys(value: string[]) {
    this._mismatchLabelKeys = value;
  }
  public resetMismatchLabelKeys() {
    this._mismatchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mismatchLabelKeysInput() {
    return this._mismatchLabelKeys;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SPostgresqlCnpgIoClusterV1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#required_during_scheduling_ignored_during_execution DataK8SPostgresqlCnpgIoClusterV1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * A list of node selector requirements by node's labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * A list of node selector requirements by node's fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_fields DataK8SPostgresqlCnpgIoClusterV1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * A node selector term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#preference DataK8SPostgresqlCnpgIoClusterV1Manifest#preference}
  */
  readonly preference: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
  /**
  * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#weight DataK8SPostgresqlCnpgIoClusterV1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preference: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preference: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preference.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preference.internalValue = value.preference;
      this._weight = value.weight;
    }
  }

  // preference - computed: false, optional: false, required: true
  private _preference = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * A list of node selector requirements by node's labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * A list of node selector requirements by node's fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_fields DataK8SPostgresqlCnpgIoClusterV1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A list of node selector terms. The terms are ORed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#node_selector_terms DataK8SPostgresqlCnpgIoClusterV1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: false, required: true
  private _nodeSelectorTerms = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SPostgresqlCnpgIoClusterV1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#required_during_scheduling_ignored_during_execution DataK8SPostgresqlCnpgIoClusterV1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#effect DataK8SPostgresqlCnpgIoClusterV1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#toleration_seconds DataK8SPostgresqlCnpgIoClusterV1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#value DataK8SPostgresqlCnpgIoClusterV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinity {
  /**
  * AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#additional_pod_affinity DataK8SPostgresqlCnpgIoClusterV1Manifest#additional_pod_affinity}
  */
  readonly additionalPodAffinity?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity;
  /**
  * AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#additional_pod_anti_affinity DataK8SPostgresqlCnpgIoClusterV1Manifest#additional_pod_anti_affinity}
  */
  readonly additionalPodAntiAffinity?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity;
  /**
  * Activates anti-affinity for the pods. The operator will define pods anti-affinity unless this field is explicitly set to false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#enable_pod_anti_affinity DataK8SPostgresqlCnpgIoClusterV1Manifest#enable_pod_anti_affinity}
  */
  readonly enablePodAntiAffinity?: boolean | cdktf.IResolvable;
  /**
  * NodeAffinity describes node affinity scheduling rules for the pod. More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#node_affinity DataK8SPostgresqlCnpgIoClusterV1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity;
  /**
  * NodeSelector is map of key-value pairs used to define the nodes on which the pods can run. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#node_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * PodAntiAffinityType allows the user to decide whether pod anti-affinity between cluster instance has to be considered a strong requirement during scheduling or not. Allowed values are: 'preferred' (default if empty) or 'required'. Setting it to 'required', could lead to instances remaining pending until new kubernetes nodes are added if all the existing nodes don't match the required pod anti-affinity rule. More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pod_anti_affinity_type DataK8SPostgresqlCnpgIoClusterV1Manifest#pod_anti_affinity_type}
  */
  readonly podAntiAffinityType?: string;
  /**
  * Tolerations is a list of Tolerations that should be set for all the pods, in order to allow them to run on tainted nodes. More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tolerations DataK8SPostgresqlCnpgIoClusterV1Manifest#tolerations}
  */
  readonly tolerations?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations[] | cdktf.IResolvable;
  /**
  * TopologyKey to use for anti-affinity configuration. See k8s documentation for more info on that
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#topology_key DataK8SPostgresqlCnpgIoClusterV1Manifest#topology_key}
  */
  readonly topologyKey?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_pod_affinity: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityToTerraform(struct!.additionalPodAffinity),
    additional_pod_anti_affinity: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityToTerraform(struct!.additionalPodAntiAffinity),
    enable_pod_anti_affinity: cdktf.booleanToTerraform(struct!.enablePodAntiAffinity),
    node_affinity: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    pod_anti_affinity_type: cdktf.stringToTerraform(struct!.podAntiAffinityType),
    tolerations: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsToTerraform, false)(struct!.tolerations),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_pod_affinity: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityToHclTerraform(struct!.additionalPodAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity",
    },
    additional_pod_anti_affinity: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityToHclTerraform(struct!.additionalPodAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity",
    },
    enable_pod_anti_affinity: {
      value: cdktf.booleanToHclTerraform(struct!.enablePodAntiAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    node_affinity: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    pod_anti_affinity_type: {
      value: cdktf.stringToHclTerraform(struct!.podAntiAffinityType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalPodAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalPodAffinity = this._additionalPodAffinity?.internalValue;
    }
    if (this._additionalPodAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalPodAntiAffinity = this._additionalPodAntiAffinity?.internalValue;
    }
    if (this._enablePodAntiAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePodAntiAffinity = this._enablePodAntiAffinity;
    }
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._podAntiAffinityType !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinityType = this._podAntiAffinityType;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalPodAffinity.internalValue = undefined;
      this._additionalPodAntiAffinity.internalValue = undefined;
      this._enablePodAntiAffinity = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._nodeSelector = undefined;
      this._podAntiAffinityType = undefined;
      this._tolerations.internalValue = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalPodAffinity.internalValue = value.additionalPodAffinity;
      this._additionalPodAntiAffinity.internalValue = value.additionalPodAntiAffinity;
      this._enablePodAntiAffinity = value.enablePodAntiAffinity;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._nodeSelector = value.nodeSelector;
      this._podAntiAffinityType = value.podAntiAffinityType;
      this._tolerations.internalValue = value.tolerations;
      this._topologyKey = value.topologyKey;
    }
  }

  // additional_pod_affinity - computed: false, optional: true, required: false
  private _additionalPodAffinity = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinityOutputReference(this, "additional_pod_affinity");
  public get additionalPodAffinity() {
    return this._additionalPodAffinity;
  }
  public putAdditionalPodAffinity(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAffinity) {
    this._additionalPodAffinity.internalValue = value;
  }
  public resetAdditionalPodAffinity() {
    this._additionalPodAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalPodAffinityInput() {
    return this._additionalPodAffinity.internalValue;
  }

  // additional_pod_anti_affinity - computed: false, optional: true, required: false
  private _additionalPodAntiAffinity = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinityOutputReference(this, "additional_pod_anti_affinity");
  public get additionalPodAntiAffinity() {
    return this._additionalPodAntiAffinity;
  }
  public putAdditionalPodAntiAffinity(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityAdditionalPodAntiAffinity) {
    this._additionalPodAntiAffinity.internalValue = value;
  }
  public resetAdditionalPodAntiAffinity() {
    this._additionalPodAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalPodAntiAffinityInput() {
    return this._additionalPodAntiAffinity.internalValue;
  }

  // enable_pod_anti_affinity - computed: false, optional: true, required: false
  private _enablePodAntiAffinity?: boolean | cdktf.IResolvable; 
  public get enablePodAntiAffinity() {
    return this.getBooleanAttribute('enable_pod_anti_affinity');
  }
  public set enablePodAntiAffinity(value: boolean | cdktf.IResolvable) {
    this._enablePodAntiAffinity = value;
  }
  public resetEnablePodAntiAffinity() {
    this._enablePodAntiAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePodAntiAffinityInput() {
    return this._enablePodAntiAffinity;
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // pod_anti_affinity_type - computed: false, optional: true, required: false
  private _podAntiAffinityType?: string; 
  public get podAntiAffinityType() {
    return this.getStringAttribute('pod_anti_affinity_type');
  }
  public set podAntiAffinityType(value: string) {
    this._podAntiAffinityType = value;
  }
  public resetPodAntiAffinityType() {
    this._podAntiAffinityType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityTypeInput() {
    return this._podAntiAffinityType;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecAffinityTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // topology_key - computed: false, optional: true, required: false
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  public resetTopologyKey() {
    this._topologyKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionStringToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionStringToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionStringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccountToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccountToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKeyToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKeyToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasTokenToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasTokenToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials {
  /**
  * The connection string to be used
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#connection_string DataK8SPostgresqlCnpgIoClusterV1Manifest#connection_string}
  */
  readonly connectionString?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString;
  /**
  * Use the Azure AD based authentication without providing explicitly the keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#inherit_from_azure_ad DataK8SPostgresqlCnpgIoClusterV1Manifest#inherit_from_azure_ad}
  */
  readonly inheritFromAzureAd?: boolean | cdktf.IResolvable;
  /**
  * The storage account where to upload data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_account DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_account}
  */
  readonly storageAccount?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount;
  /**
  * The storage account key to be used in conjunction with the storage account name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_key DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_key}
  */
  readonly storageKey?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey;
  /**
  * A shared-access-signature to be used in conjunction with the storage account name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_sas_token DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_sas_token}
  */
  readonly storageSasToken?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_string: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionStringToTerraform(struct!.connectionString),
    inherit_from_azure_ad: cdktf.booleanToTerraform(struct!.inheritFromAzureAd),
    storage_account: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccountToTerraform(struct!.storageAccount),
    storage_key: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKeyToTerraform(struct!.storageKey),
    storage_sas_token: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasTokenToTerraform(struct!.storageSasToken),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_string: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionStringToHclTerraform(struct!.connectionString),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString",
    },
    inherit_from_azure_ad: {
      value: cdktf.booleanToHclTerraform(struct!.inheritFromAzureAd),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    storage_account: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccountToHclTerraform(struct!.storageAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount",
    },
    storage_key: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKeyToHclTerraform(struct!.storageKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey",
    },
    storage_sas_token: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasTokenToHclTerraform(struct!.storageSasToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionString?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString?.internalValue;
    }
    if (this._inheritFromAzureAd !== undefined) {
      hasAnyValues = true;
      internalValueResult.inheritFromAzureAd = this._inheritFromAzureAd;
    }
    if (this._storageAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageAccount = this._storageAccount?.internalValue;
    }
    if (this._storageKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageKey = this._storageKey?.internalValue;
    }
    if (this._storageSasToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageSasToken = this._storageSasToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionString.internalValue = undefined;
      this._inheritFromAzureAd = undefined;
      this._storageAccount.internalValue = undefined;
      this._storageKey.internalValue = undefined;
      this._storageSasToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionString.internalValue = value.connectionString;
      this._inheritFromAzureAd = value.inheritFromAzureAd;
      this._storageAccount.internalValue = value.storageAccount;
      this._storageKey.internalValue = value.storageKey;
      this._storageSasToken.internalValue = value.storageSasToken;
    }
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionStringOutputReference(this, "connection_string");
  public get connectionString() {
    return this._connectionString;
  }
  public putConnectionString(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsConnectionString) {
    this._connectionString.internalValue = value;
  }
  public resetConnectionString() {
    this._connectionString.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString.internalValue;
  }

  // inherit_from_azure_ad - computed: false, optional: true, required: false
  private _inheritFromAzureAd?: boolean | cdktf.IResolvable; 
  public get inheritFromAzureAd() {
    return this.getBooleanAttribute('inherit_from_azure_ad');
  }
  public set inheritFromAzureAd(value: boolean | cdktf.IResolvable) {
    this._inheritFromAzureAd = value;
  }
  public resetInheritFromAzureAd() {
    this._inheritFromAzureAd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritFromAzureAdInput() {
    return this._inheritFromAzureAd;
  }

  // storage_account - computed: false, optional: true, required: false
  private _storageAccount = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccountOutputReference(this, "storage_account");
  public get storageAccount() {
    return this._storageAccount;
  }
  public putStorageAccount(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageAccount) {
    this._storageAccount.internalValue = value;
  }
  public resetStorageAccount() {
    this._storageAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageAccountInput() {
    return this._storageAccount.internalValue;
  }

  // storage_key - computed: false, optional: true, required: false
  private _storageKey = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKeyOutputReference(this, "storage_key");
  public get storageKey() {
    return this._storageKey;
  }
  public putStorageKey(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageKey) {
    this._storageKey.internalValue = value;
  }
  public resetStorageKey() {
    this._storageKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageKeyInput() {
    return this._storageKey.internalValue;
  }

  // storage_sas_token - computed: false, optional: true, required: false
  private _storageSasToken = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasTokenOutputReference(this, "storage_sas_token");
  public get storageSasToken() {
    return this._storageSasToken;
  }
  public putStorageSasToken(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsStorageSasToken) {
    this._storageSasToken.internalValue = value;
  }
  public resetStorageSasToken() {
    this._storageSasToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageSasTokenInput() {
    return this._storageSasToken.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData {
  /**
  * AdditionalCommandArgs represents additional arguments that can be appended to the 'barman-cloud-backup' command-line invocation. These arguments provide flexibility to customize the backup process further according to specific requirements or configurations. Example: In a scenario where specialized backup options are required, such as setting a specific timeout or defining custom behavior, users can use this field to specify additional command arguments. Note: It's essential to ensure that the provided arguments are valid and supported by the 'barman-cloud-backup' command, to avoid potential errors or unintended behavior during execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#additional_command_args DataK8SPostgresqlCnpgIoClusterV1Manifest#additional_command_args}
  */
  readonly additionalCommandArgs?: string[];
  /**
  * Compress a backup file (a tar file per tablespace) while streaming it to the object store. Available options are empty string (no compression, default), 'gzip', 'bzip2' or 'snappy'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#compression DataK8SPostgresqlCnpgIoClusterV1Manifest#compression}
  */
  readonly compression?: string;
  /**
  * Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), 'AES256' and 'aws:kms'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#encryption DataK8SPostgresqlCnpgIoClusterV1Manifest#encryption}
  */
  readonly encryption?: string;
  /**
  * Control whether the I/O workload for the backup initial checkpoint will be limited, according to the 'checkpoint_completion_target' setting on the PostgreSQL server. If set to true, an immediate checkpoint will be used, meaning PostgreSQL will complete the checkpoint as soon as possible. 'false' by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#immediate_checkpoint DataK8SPostgresqlCnpgIoClusterV1Manifest#immediate_checkpoint}
  */
  readonly immediateCheckpoint?: boolean | cdktf.IResolvable;
  /**
  * The number of parallel jobs to be used to upload the backup, defaults to 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#jobs DataK8SPostgresqlCnpgIoClusterV1Manifest#jobs}
  */
  readonly jobs?: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreDataToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_command_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalCommandArgs),
    compression: cdktf.stringToTerraform(struct!.compression),
    encryption: cdktf.stringToTerraform(struct!.encryption),
    immediate_checkpoint: cdktf.booleanToTerraform(struct!.immediateCheckpoint),
    jobs: cdktf.numberToTerraform(struct!.jobs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreDataToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_command_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalCommandArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encryption: {
      value: cdktf.stringToHclTerraform(struct!.encryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    immediate_checkpoint: {
      value: cdktf.booleanToHclTerraform(struct!.immediateCheckpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jobs: {
      value: cdktf.numberToHclTerraform(struct!.jobs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalCommandArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalCommandArgs = this._additionalCommandArgs;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._encryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption;
    }
    if (this._immediateCheckpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.immediateCheckpoint = this._immediateCheckpoint;
    }
    if (this._jobs !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobs = this._jobs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalCommandArgs = undefined;
      this._compression = undefined;
      this._encryption = undefined;
      this._immediateCheckpoint = undefined;
      this._jobs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalCommandArgs = value.additionalCommandArgs;
      this._compression = value.compression;
      this._encryption = value.encryption;
      this._immediateCheckpoint = value.immediateCheckpoint;
      this._jobs = value.jobs;
    }
  }

  // additional_command_args - computed: false, optional: true, required: false
  private _additionalCommandArgs?: string[]; 
  public get additionalCommandArgs() {
    return this.getListAttribute('additional_command_args');
  }
  public set additionalCommandArgs(value: string[]) {
    this._additionalCommandArgs = value;
  }
  public resetAdditionalCommandArgs() {
    this._additionalCommandArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalCommandArgsInput() {
    return this._additionalCommandArgs;
  }

  // compression - computed: false, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption?: string; 
  public get encryption() {
    return this.getStringAttribute('encryption');
  }
  public set encryption(value: string) {
    this._encryption = value;
  }
  public resetEncryption() {
    this._encryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption;
  }

  // immediate_checkpoint - computed: false, optional: true, required: false
  private _immediateCheckpoint?: boolean | cdktf.IResolvable; 
  public get immediateCheckpoint() {
    return this.getBooleanAttribute('immediate_checkpoint');
  }
  public set immediateCheckpoint(value: boolean | cdktf.IResolvable) {
    this._immediateCheckpoint = value;
  }
  public resetImmediateCheckpoint() {
    this._immediateCheckpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get immediateCheckpointInput() {
    return this._immediateCheckpoint;
  }

  // jobs - computed: false, optional: true, required: false
  private _jobs?: number; 
  public get jobs() {
    return this.getNumberAttribute('jobs');
  }
  public set jobs(value: number) {
    this._jobs = value;
  }
  public resetJobs() {
    this._jobs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobsInput() {
    return this._jobs;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCaToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCaToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials {
  /**
  * The secret containing the Google Cloud Storage JSON file with the credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#application_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#application_credentials}
  */
  readonly applicationCredentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials;
  /**
  * If set to true, will presume that it's running inside a GKE environment, default to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#gke_environment DataK8SPostgresqlCnpgIoClusterV1Manifest#gke_environment}
  */
  readonly gkeEnvironment?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    application_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentialsToTerraform(struct!.applicationCredentials),
    gke_environment: cdktf.booleanToTerraform(struct!.gkeEnvironment),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    application_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentialsToHclTerraform(struct!.applicationCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials",
    },
    gke_environment: {
      value: cdktf.booleanToHclTerraform(struct!.gkeEnvironment),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applicationCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.applicationCredentials = this._applicationCredentials?.internalValue;
    }
    if (this._gkeEnvironment !== undefined) {
      hasAnyValues = true;
      internalValueResult.gkeEnvironment = this._gkeEnvironment;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._applicationCredentials.internalValue = undefined;
      this._gkeEnvironment = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._applicationCredentials.internalValue = value.applicationCredentials;
      this._gkeEnvironment = value.gkeEnvironment;
    }
  }

  // application_credentials - computed: false, optional: true, required: false
  private _applicationCredentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentialsOutputReference(this, "application_credentials");
  public get applicationCredentials() {
    return this._applicationCredentials;
  }
  public putApplicationCredentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsApplicationCredentials) {
    this._applicationCredentials.internalValue = value;
  }
  public resetApplicationCredentials() {
    this._applicationCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationCredentialsInput() {
    return this._applicationCredentials.internalValue;
  }

  // gke_environment - computed: false, optional: true, required: false
  private _gkeEnvironment?: boolean | cdktf.IResolvable; 
  public get gkeEnvironment() {
    return this.getBooleanAttribute('gke_environment');
  }
  public set gkeEnvironment(value: boolean | cdktf.IResolvable) {
    this._gkeEnvironment = value;
  }
  public resetGkeEnvironment() {
    this._gkeEnvironment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gkeEnvironmentInput() {
    return this._gkeEnvironment;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyIdToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyIdToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKeyToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKeyToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionTokenToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionTokenToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials {
  /**
  * The reference to the access key id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#access_key_id DataK8SPostgresqlCnpgIoClusterV1Manifest#access_key_id}
  */
  readonly accessKeyId?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId;
  /**
  * Use the role based authentication without providing explicitly the keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#inherit_from_iam_role DataK8SPostgresqlCnpgIoClusterV1Manifest#inherit_from_iam_role}
  */
  readonly inheritFromIamRole?: boolean | cdktf.IResolvable;
  /**
  * The reference to the secret containing the region name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#region DataK8SPostgresqlCnpgIoClusterV1Manifest#region}
  */
  readonly region?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion;
  /**
  * The reference to the secret access key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_access_key DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_access_key}
  */
  readonly secretAccessKey?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey;
  /**
  * The references to the session key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#session_token DataK8SPostgresqlCnpgIoClusterV1Manifest#session_token}
  */
  readonly sessionToken?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyIdToTerraform(struct!.accessKeyId),
    inherit_from_iam_role: cdktf.booleanToTerraform(struct!.inheritFromIamRole),
    region: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegionToTerraform(struct!.region),
    secret_access_key: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKeyToTerraform(struct!.secretAccessKey),
    session_token: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionTokenToTerraform(struct!.sessionToken),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyIdToHclTerraform(struct!.accessKeyId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId",
    },
    inherit_from_iam_role: {
      value: cdktf.booleanToHclTerraform(struct!.inheritFromIamRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegionToHclTerraform(struct!.region),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion",
    },
    secret_access_key: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKeyToHclTerraform(struct!.secretAccessKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey",
    },
    session_token: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionTokenToHclTerraform(struct!.sessionToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyId = this._accessKeyId?.internalValue;
    }
    if (this._inheritFromIamRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.inheritFromIamRole = this._inheritFromIamRole;
    }
    if (this._region?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region?.internalValue;
    }
    if (this._secretAccessKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey?.internalValue;
    }
    if (this._sessionToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionToken = this._sessionToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyId.internalValue = undefined;
      this._inheritFromIamRole = undefined;
      this._region.internalValue = undefined;
      this._secretAccessKey.internalValue = undefined;
      this._sessionToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyId.internalValue = value.accessKeyId;
      this._inheritFromIamRole = value.inheritFromIamRole;
      this._region.internalValue = value.region;
      this._secretAccessKey.internalValue = value.secretAccessKey;
      this._sessionToken.internalValue = value.sessionToken;
    }
  }

  // access_key_id - computed: false, optional: true, required: false
  private _accessKeyId = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyIdOutputReference(this, "access_key_id");
  public get accessKeyId() {
    return this._accessKeyId;
  }
  public putAccessKeyId(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsAccessKeyId) {
    this._accessKeyId.internalValue = value;
  }
  public resetAccessKeyId() {
    this._accessKeyId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdInput() {
    return this._accessKeyId.internalValue;
  }

  // inherit_from_iam_role - computed: false, optional: true, required: false
  private _inheritFromIamRole?: boolean | cdktf.IResolvable; 
  public get inheritFromIamRole() {
    return this.getBooleanAttribute('inherit_from_iam_role');
  }
  public set inheritFromIamRole(value: boolean | cdktf.IResolvable) {
    this._inheritFromIamRole = value;
  }
  public resetInheritFromIamRole() {
    this._inheritFromIamRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritFromIamRoleInput() {
    return this._inheritFromIamRole;
  }

  // region - computed: false, optional: true, required: false
  private _region = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegionOutputReference(this, "region");
  public get region() {
    return this._region;
  }
  public putRegion(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsRegion) {
    this._region.internalValue = value;
  }
  public resetRegion() {
    this._region.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region.internalValue;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKeyOutputReference(this, "secret_access_key");
  public get secretAccessKey() {
    return this._secretAccessKey;
  }
  public putSecretAccessKey(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSecretAccessKey) {
    this._secretAccessKey.internalValue = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey.internalValue;
  }

  // session_token - computed: false, optional: true, required: false
  private _sessionToken = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionTokenOutputReference(this, "session_token");
  public get sessionToken() {
    return this._sessionToken;
  }
  public putSessionToken(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsSessionToken) {
    this._sessionToken.internalValue = value;
  }
  public resetSessionToken() {
    this._sessionToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTokenInput() {
    return this._sessionToken.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal {
  /**
  * Additional arguments that can be appended to the 'barman-cloud-wal-archive' command-line invocation. These arguments provide flexibility to customize the WAL archive process further, according to specific requirements or configurations. Example: In a scenario where specialized backup options are required, such as setting a specific timeout or defining custom behavior, users can use this field to specify additional command arguments. Note: It's essential to ensure that the provided arguments are valid and supported by the 'barman-cloud-wal-archive' command, to avoid potential errors or unintended behavior during execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#archive_additional_command_args DataK8SPostgresqlCnpgIoClusterV1Manifest#archive_additional_command_args}
  */
  readonly archiveAdditionalCommandArgs?: string[];
  /**
  * Compress a WAL file before sending it to the object store. Available options are empty string (no compression, default), 'gzip', 'bzip2' or 'snappy'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#compression DataK8SPostgresqlCnpgIoClusterV1Manifest#compression}
  */
  readonly compression?: string;
  /**
  * Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), 'AES256' and 'aws:kms'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#encryption DataK8SPostgresqlCnpgIoClusterV1Manifest#encryption}
  */
  readonly encryption?: string;
  /**
  * Number of WAL files to be either archived in parallel (when the PostgreSQL instance is archiving to a backup object store) or restored in parallel (when a PostgreSQL standby is fetching WAL files from a recovery object store). If not specified, WAL files will be processed one at a time. It accepts a positive integer as a value - with 1 being the minimum accepted value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#max_parallel DataK8SPostgresqlCnpgIoClusterV1Manifest#max_parallel}
  */
  readonly maxParallel?: number;
  /**
  * Additional arguments that can be appended to the 'barman-cloud-wal-restore' command-line invocation. These arguments provide flexibility to customize the WAL restore process further, according to specific requirements or configurations. Example: In a scenario where specialized backup options are required, such as setting a specific timeout or defining custom behavior, users can use this field to specify additional command arguments. Note: It's essential to ensure that the provided arguments are valid and supported by the 'barman-cloud-wal-restore' command, to avoid potential errors or unintended behavior during execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#restore_additional_command_args DataK8SPostgresqlCnpgIoClusterV1Manifest#restore_additional_command_args}
  */
  readonly restoreAdditionalCommandArgs?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWalToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    archive_additional_command_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.archiveAdditionalCommandArgs),
    compression: cdktf.stringToTerraform(struct!.compression),
    encryption: cdktf.stringToTerraform(struct!.encryption),
    max_parallel: cdktf.numberToTerraform(struct!.maxParallel),
    restore_additional_command_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.restoreAdditionalCommandArgs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWalToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    archive_additional_command_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.archiveAdditionalCommandArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encryption: {
      value: cdktf.stringToHclTerraform(struct!.encryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_parallel: {
      value: cdktf.numberToHclTerraform(struct!.maxParallel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    restore_additional_command_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.restoreAdditionalCommandArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._archiveAdditionalCommandArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.archiveAdditionalCommandArgs = this._archiveAdditionalCommandArgs;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._encryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption;
    }
    if (this._maxParallel !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxParallel = this._maxParallel;
    }
    if (this._restoreAdditionalCommandArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.restoreAdditionalCommandArgs = this._restoreAdditionalCommandArgs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._archiveAdditionalCommandArgs = undefined;
      this._compression = undefined;
      this._encryption = undefined;
      this._maxParallel = undefined;
      this._restoreAdditionalCommandArgs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._archiveAdditionalCommandArgs = value.archiveAdditionalCommandArgs;
      this._compression = value.compression;
      this._encryption = value.encryption;
      this._maxParallel = value.maxParallel;
      this._restoreAdditionalCommandArgs = value.restoreAdditionalCommandArgs;
    }
  }

  // archive_additional_command_args - computed: false, optional: true, required: false
  private _archiveAdditionalCommandArgs?: string[]; 
  public get archiveAdditionalCommandArgs() {
    return this.getListAttribute('archive_additional_command_args');
  }
  public set archiveAdditionalCommandArgs(value: string[]) {
    this._archiveAdditionalCommandArgs = value;
  }
  public resetArchiveAdditionalCommandArgs() {
    this._archiveAdditionalCommandArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get archiveAdditionalCommandArgsInput() {
    return this._archiveAdditionalCommandArgs;
  }

  // compression - computed: false, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption?: string; 
  public get encryption() {
    return this.getStringAttribute('encryption');
  }
  public set encryption(value: string) {
    this._encryption = value;
  }
  public resetEncryption() {
    this._encryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption;
  }

  // max_parallel - computed: false, optional: true, required: false
  private _maxParallel?: number; 
  public get maxParallel() {
    return this.getNumberAttribute('max_parallel');
  }
  public set maxParallel(value: number) {
    this._maxParallel = value;
  }
  public resetMaxParallel() {
    this._maxParallel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxParallelInput() {
    return this._maxParallel;
  }

  // restore_additional_command_args - computed: false, optional: true, required: false
  private _restoreAdditionalCommandArgs?: string[]; 
  public get restoreAdditionalCommandArgs() {
    return this.getListAttribute('restore_additional_command_args');
  }
  public set restoreAdditionalCommandArgs(value: string[]) {
    this._restoreAdditionalCommandArgs = value;
  }
  public resetRestoreAdditionalCommandArgs() {
    this._restoreAdditionalCommandArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restoreAdditionalCommandArgsInput() {
    return this._restoreAdditionalCommandArgs;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore {
  /**
  * The credentials to use to upload data to Azure Blob Storage
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#azure_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#azure_credentials}
  */
  readonly azureCredentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials;
  /**
  * The configuration to be used to backup the data files When not defined, base backups files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#data DataK8SPostgresqlCnpgIoClusterV1Manifest#data}
  */
  readonly data?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData;
  /**
  * The path where to store the backup (i.e. s3://bucket/path/to/folder) this path, with different destination folders, will be used for WALs and for data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#destination_path DataK8SPostgresqlCnpgIoClusterV1Manifest#destination_path}
  */
  readonly destinationPath: string;
  /**
  * EndpointCA store the CA bundle of the barman endpoint. Useful when using self-signed certificates to avoid errors with certificate issuer and barman-cloud-wal-archive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#endpoint_ca DataK8SPostgresqlCnpgIoClusterV1Manifest#endpoint_ca}
  */
  readonly endpointCa?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa;
  /**
  * Endpoint to be used to upload data to the cloud, overriding the automatic endpoint discovery
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#endpoint_url DataK8SPostgresqlCnpgIoClusterV1Manifest#endpoint_url}
  */
  readonly endpointUrl?: string;
  /**
  * The credentials to use to upload data to Google Cloud Storage
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#google_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#google_credentials}
  */
  readonly googleCredentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials;
  /**
  * HistoryTags is a list of key value pairs that will be passed to the Barman --history-tags option.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#history_tags DataK8SPostgresqlCnpgIoClusterV1Manifest#history_tags}
  */
  readonly historyTags?: { [key: string]: string };
  /**
  * The credentials to use to upload data to S3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#s3_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#s3_credentials}
  */
  readonly s3Credentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials;
  /**
  * The server name on S3, the cluster name is used if this parameter is omitted
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#server_name DataK8SPostgresqlCnpgIoClusterV1Manifest#server_name}
  */
  readonly serverName?: string;
  /**
  * Tags is a list of key value pairs that will be passed to the Barman --tags option.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tags DataK8SPostgresqlCnpgIoClusterV1Manifest#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The configuration for the backup of the WAL stream. When not defined, WAL files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#wal DataK8SPostgresqlCnpgIoClusterV1Manifest#wal}
  */
  readonly wal?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsToTerraform(struct!.azureCredentials),
    data: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreDataToTerraform(struct!.data),
    destination_path: cdktf.stringToTerraform(struct!.destinationPath),
    endpoint_ca: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCaToTerraform(struct!.endpointCa),
    endpoint_url: cdktf.stringToTerraform(struct!.endpointUrl),
    google_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsToTerraform(struct!.googleCredentials),
    history_tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.historyTags),
    s3_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsToTerraform(struct!.s3Credentials),
    server_name: cdktf.stringToTerraform(struct!.serverName),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    wal: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWalToTerraform(struct!.wal),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsToHclTerraform(struct!.azureCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials",
    },
    data: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreDataToHclTerraform(struct!.data),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData",
    },
    destination_path: {
      value: cdktf.stringToHclTerraform(struct!.destinationPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_ca: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCaToHclTerraform(struct!.endpointCa),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa",
    },
    endpoint_url: {
      value: cdktf.stringToHclTerraform(struct!.endpointUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    google_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsToHclTerraform(struct!.googleCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials",
    },
    history_tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.historyTags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    s3_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsToHclTerraform(struct!.s3Credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    wal: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWalToHclTerraform(struct!.wal),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azureCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureCredentials = this._azureCredentials?.internalValue;
    }
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._destinationPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationPath = this._destinationPath;
    }
    if (this._endpointCa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointCa = this._endpointCa?.internalValue;
    }
    if (this._endpointUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointUrl = this._endpointUrl;
    }
    if (this._googleCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleCredentials = this._googleCredentials?.internalValue;
    }
    if (this._historyTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.historyTags = this._historyTags;
    }
    if (this._s3Credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3Credentials = this._s3Credentials?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._wal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wal = this._wal?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azureCredentials.internalValue = undefined;
      this._data.internalValue = undefined;
      this._destinationPath = undefined;
      this._endpointCa.internalValue = undefined;
      this._endpointUrl = undefined;
      this._googleCredentials.internalValue = undefined;
      this._historyTags = undefined;
      this._s3Credentials.internalValue = undefined;
      this._serverName = undefined;
      this._tags = undefined;
      this._wal.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azureCredentials.internalValue = value.azureCredentials;
      this._data.internalValue = value.data;
      this._destinationPath = value.destinationPath;
      this._endpointCa.internalValue = value.endpointCa;
      this._endpointUrl = value.endpointUrl;
      this._googleCredentials.internalValue = value.googleCredentials;
      this._historyTags = value.historyTags;
      this._s3Credentials.internalValue = value.s3Credentials;
      this._serverName = value.serverName;
      this._tags = value.tags;
      this._wal.internalValue = value.wal;
    }
  }

  // azure_credentials - computed: false, optional: true, required: false
  private _azureCredentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentialsOutputReference(this, "azure_credentials");
  public get azureCredentials() {
    return this._azureCredentials;
  }
  public putAzureCredentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreAzureCredentials) {
    this._azureCredentials.internalValue = value;
  }
  public resetAzureCredentials() {
    this._azureCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCredentialsInput() {
    return this._azureCredentials.internalValue;
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreDataOutputReference(this, "data");
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreData) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // destination_path - computed: false, optional: false, required: true
  private _destinationPath?: string; 
  public get destinationPath() {
    return this.getStringAttribute('destination_path');
  }
  public set destinationPath(value: string) {
    this._destinationPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationPathInput() {
    return this._destinationPath;
  }

  // endpoint_ca - computed: false, optional: true, required: false
  private _endpointCa = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCaOutputReference(this, "endpoint_ca");
  public get endpointCa() {
    return this._endpointCa;
  }
  public putEndpointCa(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreEndpointCa) {
    this._endpointCa.internalValue = value;
  }
  public resetEndpointCa() {
    this._endpointCa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointCaInput() {
    return this._endpointCa.internalValue;
  }

  // endpoint_url - computed: false, optional: true, required: false
  private _endpointUrl?: string; 
  public get endpointUrl() {
    return this.getStringAttribute('endpoint_url');
  }
  public set endpointUrl(value: string) {
    this._endpointUrl = value;
  }
  public resetEndpointUrl() {
    this._endpointUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointUrlInput() {
    return this._endpointUrl;
  }

  // google_credentials - computed: false, optional: true, required: false
  private _googleCredentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentialsOutputReference(this, "google_credentials");
  public get googleCredentials() {
    return this._googleCredentials;
  }
  public putGoogleCredentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreGoogleCredentials) {
    this._googleCredentials.internalValue = value;
  }
  public resetGoogleCredentials() {
    this._googleCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleCredentialsInput() {
    return this._googleCredentials.internalValue;
  }

  // history_tags - computed: false, optional: true, required: false
  private _historyTags?: { [key: string]: string }; 
  public get historyTags() {
    return this.getStringMapAttribute('history_tags');
  }
  public set historyTags(value: { [key: string]: string }) {
    this._historyTags = value;
  }
  public resetHistoryTags() {
    this._historyTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get historyTagsInput() {
    return this._historyTags;
  }

  // s3_credentials - computed: false, optional: true, required: false
  private _s3Credentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3CredentialsOutputReference(this, "s3_credentials");
  public get s3Credentials() {
    return this._s3Credentials;
  }
  public putS3Credentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreS3Credentials) {
    this._s3Credentials.internalValue = value;
  }
  public resetS3Credentials() {
    this._s3Credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3CredentialsInput() {
    return this._s3Credentials.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // wal - computed: false, optional: true, required: false
  private _wal = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWalOutputReference(this, "wal");
  public get wal() {
    return this._wal;
  }
  public putWal(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreWal) {
    this._wal.internalValue = value;
  }
  public resetWal() {
    this._wal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get walInput() {
    return this._wal.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration {
  /**
  * Control whether the I/O workload for the backup initial checkpoint will be limited, according to the 'checkpoint_completion_target' setting on the PostgreSQL server. If set to true, an immediate checkpoint will be used, meaning PostgreSQL will complete the checkpoint as soon as possible. 'false' by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#immediate_checkpoint DataK8SPostgresqlCnpgIoClusterV1Manifest#immediate_checkpoint}
  */
  readonly immediateCheckpoint?: boolean | cdktf.IResolvable;
  /**
  * If false, the function will return immediately after the backup is completed, without waiting for WAL to be archived. This behavior is only useful with backup software that independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is enabled. On a standby, this means that it will wait only when archive_mode = always. If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger an immediate segment switch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#wait_for_archive DataK8SPostgresqlCnpgIoClusterV1Manifest#wait_for_archive}
  */
  readonly waitForArchive?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfigurationToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    immediate_checkpoint: cdktf.booleanToTerraform(struct!.immediateCheckpoint),
    wait_for_archive: cdktf.booleanToTerraform(struct!.waitForArchive),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfigurationToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    immediate_checkpoint: {
      value: cdktf.booleanToHclTerraform(struct!.immediateCheckpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    wait_for_archive: {
      value: cdktf.booleanToHclTerraform(struct!.waitForArchive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._immediateCheckpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.immediateCheckpoint = this._immediateCheckpoint;
    }
    if (this._waitForArchive !== undefined) {
      hasAnyValues = true;
      internalValueResult.waitForArchive = this._waitForArchive;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._immediateCheckpoint = undefined;
      this._waitForArchive = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._immediateCheckpoint = value.immediateCheckpoint;
      this._waitForArchive = value.waitForArchive;
    }
  }

  // immediate_checkpoint - computed: false, optional: true, required: false
  private _immediateCheckpoint?: boolean | cdktf.IResolvable; 
  public get immediateCheckpoint() {
    return this.getBooleanAttribute('immediate_checkpoint');
  }
  public set immediateCheckpoint(value: boolean | cdktf.IResolvable) {
    this._immediateCheckpoint = value;
  }
  public resetImmediateCheckpoint() {
    this._immediateCheckpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get immediateCheckpointInput() {
    return this._immediateCheckpoint;
  }

  // wait_for_archive - computed: false, optional: true, required: false
  private _waitForArchive?: boolean | cdktf.IResolvable; 
  public get waitForArchive() {
    return this.getBooleanAttribute('wait_for_archive');
  }
  public set waitForArchive(value: boolean | cdktf.IResolvable) {
    this._waitForArchive = value;
  }
  public resetWaitForArchive() {
    this._waitForArchive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitForArchiveInput() {
    return this._waitForArchive;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot {
  /**
  * Annotations key-value pairs that will be added to .metadata.annotations snapshot resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#annotations DataK8SPostgresqlCnpgIoClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * ClassName specifies the Snapshot Class to be used for PG_DATA PersistentVolumeClaim. It is the default class for the other types if no specific class is present
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#class_name DataK8SPostgresqlCnpgIoClusterV1Manifest#class_name}
  */
  readonly className?: string;
  /**
  * Labels are key-value pairs that will be added to .metadata.labels snapshot resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#labels DataK8SPostgresqlCnpgIoClusterV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Whether the default type of backup with volume snapshots is online/hot ('true', default) or offline/cold ('false')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#online DataK8SPostgresqlCnpgIoClusterV1Manifest#online}
  */
  readonly online?: boolean | cdktf.IResolvable;
  /**
  * Configuration parameters to control the online/hot backup with volume snapshots
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#online_configuration DataK8SPostgresqlCnpgIoClusterV1Manifest#online_configuration}
  */
  readonly onlineConfiguration?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration;
  /**
  * SnapshotOwnerReference indicates the type of owner reference the snapshot should have
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#snapshot_owner_reference DataK8SPostgresqlCnpgIoClusterV1Manifest#snapshot_owner_reference}
  */
  readonly snapshotOwnerReference?: string;
  /**
  * TablespaceClassName specifies the Snapshot Class to be used for the tablespaces. defaults to the PGDATA Snapshot Class, if set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tablespace_class_name DataK8SPostgresqlCnpgIoClusterV1Manifest#tablespace_class_name}
  */
  readonly tablespaceClassName?: { [key: string]: string };
  /**
  * WalClassName specifies the Snapshot Class to be used for the PG_WAL PersistentVolumeClaim.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#wal_class_name DataK8SPostgresqlCnpgIoClusterV1Manifest#wal_class_name}
  */
  readonly walClassName?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    class_name: cdktf.stringToTerraform(struct!.className),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    online: cdktf.booleanToTerraform(struct!.online),
    online_configuration: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfigurationToTerraform(struct!.onlineConfiguration),
    snapshot_owner_reference: cdktf.stringToTerraform(struct!.snapshotOwnerReference),
    tablespace_class_name: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tablespaceClassName),
    wal_class_name: cdktf.stringToTerraform(struct!.walClassName),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    class_name: {
      value: cdktf.stringToHclTerraform(struct!.className),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    online: {
      value: cdktf.booleanToHclTerraform(struct!.online),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    online_configuration: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfigurationToHclTerraform(struct!.onlineConfiguration),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration",
    },
    snapshot_owner_reference: {
      value: cdktf.stringToHclTerraform(struct!.snapshotOwnerReference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tablespace_class_name: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tablespaceClassName),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    wal_class_name: {
      value: cdktf.stringToHclTerraform(struct!.walClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._className !== undefined) {
      hasAnyValues = true;
      internalValueResult.className = this._className;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._online !== undefined) {
      hasAnyValues = true;
      internalValueResult.online = this._online;
    }
    if (this._onlineConfiguration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.onlineConfiguration = this._onlineConfiguration?.internalValue;
    }
    if (this._snapshotOwnerReference !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshotOwnerReference = this._snapshotOwnerReference;
    }
    if (this._tablespaceClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tablespaceClassName = this._tablespaceClassName;
    }
    if (this._walClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.walClassName = this._walClassName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._className = undefined;
      this._labels = undefined;
      this._online = undefined;
      this._onlineConfiguration.internalValue = undefined;
      this._snapshotOwnerReference = undefined;
      this._tablespaceClassName = undefined;
      this._walClassName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._className = value.className;
      this._labels = value.labels;
      this._online = value.online;
      this._onlineConfiguration.internalValue = value.onlineConfiguration;
      this._snapshotOwnerReference = value.snapshotOwnerReference;
      this._tablespaceClassName = value.tablespaceClassName;
      this._walClassName = value.walClassName;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // class_name - computed: false, optional: true, required: false
  private _className?: string; 
  public get className() {
    return this.getStringAttribute('class_name');
  }
  public set className(value: string) {
    this._className = value;
  }
  public resetClassName() {
    this._className = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get classNameInput() {
    return this._className;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // online - computed: false, optional: true, required: false
  private _online?: boolean | cdktf.IResolvable; 
  public get online() {
    return this.getBooleanAttribute('online');
  }
  public set online(value: boolean | cdktf.IResolvable) {
    this._online = value;
  }
  public resetOnline() {
    this._online = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onlineInput() {
    return this._online;
  }

  // online_configuration - computed: false, optional: true, required: false
  private _onlineConfiguration = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfigurationOutputReference(this, "online_configuration");
  public get onlineConfiguration() {
    return this._onlineConfiguration;
  }
  public putOnlineConfiguration(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOnlineConfiguration) {
    this._onlineConfiguration.internalValue = value;
  }
  public resetOnlineConfiguration() {
    this._onlineConfiguration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onlineConfigurationInput() {
    return this._onlineConfiguration.internalValue;
  }

  // snapshot_owner_reference - computed: false, optional: true, required: false
  private _snapshotOwnerReference?: string; 
  public get snapshotOwnerReference() {
    return this.getStringAttribute('snapshot_owner_reference');
  }
  public set snapshotOwnerReference(value: string) {
    this._snapshotOwnerReference = value;
  }
  public resetSnapshotOwnerReference() {
    this._snapshotOwnerReference = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotOwnerReferenceInput() {
    return this._snapshotOwnerReference;
  }

  // tablespace_class_name - computed: false, optional: true, required: false
  private _tablespaceClassName?: { [key: string]: string }; 
  public get tablespaceClassName() {
    return this.getStringMapAttribute('tablespace_class_name');
  }
  public set tablespaceClassName(value: { [key: string]: string }) {
    this._tablespaceClassName = value;
  }
  public resetTablespaceClassName() {
    this._tablespaceClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tablespaceClassNameInput() {
    return this._tablespaceClassName;
  }

  // wal_class_name - computed: false, optional: true, required: false
  private _walClassName?: string; 
  public get walClassName() {
    return this.getStringAttribute('wal_class_name');
  }
  public set walClassName(value: string) {
    this._walClassName = value;
  }
  public resetWalClassName() {
    this._walClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get walClassNameInput() {
    return this._walClassName;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackup {
  /**
  * The configuration for the barman-cloud tool suite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#barman_object_store DataK8SPostgresqlCnpgIoClusterV1Manifest#barman_object_store}
  */
  readonly barmanObjectStore?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore;
  /**
  * RetentionPolicy is the retention policy to be used for backups and WALs (i.e. '60d'). The retention policy is expressed in the form of 'XXu' where 'XX' is a positive integer and 'u' is in '[dwm]' - days, weeks, months. It's currently only applicable when using the BarmanObjectStore method.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#retention_policy DataK8SPostgresqlCnpgIoClusterV1Manifest#retention_policy}
  */
  readonly retentionPolicy?: string;
  /**
  * The policy to decide which instance should perform backups. Available options are empty string, which will default to 'prefer-standby' policy, 'primary' to have backups run always on primary instances, 'prefer-standby' to have backups run preferably on the most updated standby, if available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target DataK8SPostgresqlCnpgIoClusterV1Manifest#target}
  */
  readonly target?: string;
  /**
  * VolumeSnapshot provides the configuration for the execution of volume snapshot backups.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#volume_snapshot DataK8SPostgresqlCnpgIoClusterV1Manifest#volume_snapshot}
  */
  readonly volumeSnapshot?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    barman_object_store: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreToTerraform(struct!.barmanObjectStore),
    retention_policy: cdktf.stringToTerraform(struct!.retentionPolicy),
    target: cdktf.stringToTerraform(struct!.target),
    volume_snapshot: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotToTerraform(struct!.volumeSnapshot),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    barman_object_store: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreToHclTerraform(struct!.barmanObjectStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore",
    },
    retention_policy: {
      value: cdktf.stringToHclTerraform(struct!.retentionPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target: {
      value: cdktf.stringToHclTerraform(struct!.target),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_snapshot: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotToHclTerraform(struct!.volumeSnapshot),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._barmanObjectStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.barmanObjectStore = this._barmanObjectStore?.internalValue;
    }
    if (this._retentionPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.retentionPolicy = this._retentionPolicy;
    }
    if (this._target !== undefined) {
      hasAnyValues = true;
      internalValueResult.target = this._target;
    }
    if (this._volumeSnapshot?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeSnapshot = this._volumeSnapshot?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._barmanObjectStore.internalValue = undefined;
      this._retentionPolicy = undefined;
      this._target = undefined;
      this._volumeSnapshot.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._barmanObjectStore.internalValue = value.barmanObjectStore;
      this._retentionPolicy = value.retentionPolicy;
      this._target = value.target;
      this._volumeSnapshot.internalValue = value.volumeSnapshot;
    }
  }

  // barman_object_store - computed: false, optional: true, required: false
  private _barmanObjectStore = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStoreOutputReference(this, "barman_object_store");
  public get barmanObjectStore() {
    return this._barmanObjectStore;
  }
  public putBarmanObjectStore(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupBarmanObjectStore) {
    this._barmanObjectStore.internalValue = value;
  }
  public resetBarmanObjectStore() {
    this._barmanObjectStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get barmanObjectStoreInput() {
    return this._barmanObjectStore.internalValue;
  }

  // retention_policy - computed: false, optional: true, required: false
  private _retentionPolicy?: string; 
  public get retentionPolicy() {
    return this.getStringAttribute('retention_policy');
  }
  public set retentionPolicy(value: string) {
    this._retentionPolicy = value;
  }
  public resetRetentionPolicy() {
    this._retentionPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retentionPolicyInput() {
    return this._retentionPolicy;
  }

  // target - computed: false, optional: true, required: false
  private _target?: string; 
  public get target() {
    return this.getStringAttribute('target');
  }
  public set target(value: string) {
    this._target = value;
  }
  public resetTarget() {
    this._target = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetInput() {
    return this._target;
  }

  // volume_snapshot - computed: false, optional: true, required: false
  private _volumeSnapshot = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshotOutputReference(this, "volume_snapshot");
  public get volumeSnapshot() {
    return this._volumeSnapshot;
  }
  public putVolumeSnapshot(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBackupVolumeSnapshot) {
    this._volumeSnapshot.internalValue = value;
  }
  public resetVolumeSnapshot() {
    this._volumeSnapshot.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeSnapshotInput() {
    return this._volumeSnapshot.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource {
  /**
  * The name of the externalCluster used for import
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#external_cluster DataK8SPostgresqlCnpgIoClusterV1Manifest#external_cluster}
  */
  readonly externalCluster: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSourceToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_cluster: cdktf.stringToTerraform(struct!.externalCluster),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSourceToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_cluster: {
      value: cdktf.stringToHclTerraform(struct!.externalCluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalCluster = this._externalCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalCluster = value.externalCluster;
    }
  }

  // external_cluster - computed: false, optional: false, required: true
  private _externalCluster?: string; 
  public get externalCluster() {
    return this.getStringAttribute('external_cluster');
  }
  public set externalCluster(value: string) {
    this._externalCluster = value;
  }
  // Temporarily expose input value. Use with caution.
  public get externalClusterInput() {
    return this._externalCluster;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport {
  /**
  * The databases to import
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#databases DataK8SPostgresqlCnpgIoClusterV1Manifest#databases}
  */
  readonly databases: string[];
  /**
  * List of SQL queries to be executed as a superuser in the application database right after is imported - to be used with extreme care (by default empty). Only available in microservice type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_import_application_sql DataK8SPostgresqlCnpgIoClusterV1Manifest#post_import_application_sql}
  */
  readonly postImportApplicationSql?: string[];
  /**
  * The roles to import
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#roles DataK8SPostgresqlCnpgIoClusterV1Manifest#roles}
  */
  readonly roles?: string[];
  /**
  * When set to true, only the 'pre-data' and 'post-data' sections of 'pg_restore' are invoked, avoiding data import. Default: 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#schema_only DataK8SPostgresqlCnpgIoClusterV1Manifest#schema_only}
  */
  readonly schemaOnly?: boolean | cdktf.IResolvable;
  /**
  * The source of the import
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#source DataK8SPostgresqlCnpgIoClusterV1Manifest#source}
  */
  readonly source: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource;
  /**
  * The import type. Can be 'microservice' or 'monolith'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#type DataK8SPostgresqlCnpgIoClusterV1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    databases: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.databases),
    post_import_application_sql: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.postImportApplicationSql),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
    schema_only: cdktf.booleanToTerraform(struct!.schemaOnly),
    source: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSourceToTerraform(struct!.source),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    databases: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.databases),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    post_import_application_sql: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.postImportApplicationSql),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    schema_only: {
      value: cdktf.booleanToHclTerraform(struct!.schemaOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._databases !== undefined) {
      hasAnyValues = true;
      internalValueResult.databases = this._databases;
    }
    if (this._postImportApplicationSql !== undefined) {
      hasAnyValues = true;
      internalValueResult.postImportApplicationSql = this._postImportApplicationSql;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    if (this._schemaOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaOnly = this._schemaOnly;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._databases = undefined;
      this._postImportApplicationSql = undefined;
      this._roles = undefined;
      this._schemaOnly = undefined;
      this._source.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._databases = value.databases;
      this._postImportApplicationSql = value.postImportApplicationSql;
      this._roles = value.roles;
      this._schemaOnly = value.schemaOnly;
      this._source.internalValue = value.source;
      this._type = value.type;
    }
  }

  // databases - computed: false, optional: false, required: true
  private _databases?: string[]; 
  public get databases() {
    return this.getListAttribute('databases');
  }
  public set databases(value: string[]) {
    this._databases = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databasesInput() {
    return this._databases;
  }

  // post_import_application_sql - computed: false, optional: true, required: false
  private _postImportApplicationSql?: string[]; 
  public get postImportApplicationSql() {
    return this.getListAttribute('post_import_application_sql');
  }
  public set postImportApplicationSql(value: string[]) {
    this._postImportApplicationSql = value;
  }
  public resetPostImportApplicationSql() {
    this._postImportApplicationSql = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postImportApplicationSqlInput() {
    return this._postImportApplicationSql;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }

  // schema_only - computed: false, optional: true, required: false
  private _schemaOnly?: boolean | cdktf.IResolvable; 
  public get schemaOnly() {
    return this.getBooleanAttribute('schema_only');
  }
  public set schemaOnly(value: boolean | cdktf.IResolvable) {
    this._schemaOnly = value;
  }
  public resetSchemaOnly() {
    this._schemaOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaOnlyInput() {
    return this._schemaOnly;
  }

  // source - computed: false, optional: false, required: true
  private _source = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs {
  /**
  * ConfigMapRefs holds a list of references to ConfigMaps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#config_map_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#config_map_refs}
  */
  readonly configMapRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs[] | cdktf.IResolvable;
  /**
  * SecretRefs holds a list of references to Secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_refs}
  */
  readonly secretRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_refs: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsToTerraform, false)(struct!.configMapRefs),
    secret_refs: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsToTerraform, false)(struct!.secretRefs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_refs: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsToHclTerraform, false)(struct!.configMapRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsList",
    },
    secret_refs: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsToHclTerraform, false)(struct!.secretRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRefs = this._configMapRefs?.internalValue;
    }
    if (this._secretRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRefs = this._secretRefs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRefs.internalValue = undefined;
      this._secretRefs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRefs.internalValue = value.configMapRefs;
      this._secretRefs.internalValue = value.secretRefs;
    }
  }

  // config_map_refs - computed: false, optional: true, required: false
  private _configMapRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefsList(this, "config_map_refs", false);
  public get configMapRefs() {
    return this._configMapRefs;
  }
  public putConfigMapRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsConfigMapRefs[] | cdktf.IResolvable) {
    this._configMapRefs.internalValue = value;
  }
  public resetConfigMapRefs() {
    this._configMapRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefsInput() {
    return this._configMapRefs.internalValue;
  }

  // secret_refs - computed: false, optional: true, required: false
  private _secretRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefsList(this, "secret_refs", false);
  public get secretRefs() {
    return this._secretRefs;
  }
  public putSecretRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsSecretRefs[] | cdktf.IResolvable) {
    this._secretRefs.internalValue = value;
  }
  public resetSecretRefs() {
    this._secretRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefsInput() {
    return this._secretRefs.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs {
  /**
  * ConfigMapRefs holds a list of references to ConfigMaps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#config_map_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#config_map_refs}
  */
  readonly configMapRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs[] | cdktf.IResolvable;
  /**
  * SecretRefs holds a list of references to Secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_refs}
  */
  readonly secretRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_refs: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsToTerraform, false)(struct!.configMapRefs),
    secret_refs: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsToTerraform, false)(struct!.secretRefs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_refs: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsToHclTerraform, false)(struct!.configMapRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsList",
    },
    secret_refs: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsToHclTerraform, false)(struct!.secretRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRefs = this._configMapRefs?.internalValue;
    }
    if (this._secretRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRefs = this._secretRefs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRefs.internalValue = undefined;
      this._secretRefs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRefs.internalValue = value.configMapRefs;
      this._secretRefs.internalValue = value.secretRefs;
    }
  }

  // config_map_refs - computed: false, optional: true, required: false
  private _configMapRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefsList(this, "config_map_refs", false);
  public get configMapRefs() {
    return this._configMapRefs;
  }
  public putConfigMapRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsConfigMapRefs[] | cdktf.IResolvable) {
    this._configMapRefs.internalValue = value;
  }
  public resetConfigMapRefs() {
    this._configMapRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefsInput() {
    return this._configMapRefs.internalValue;
  }

  // secret_refs - computed: false, optional: true, required: false
  private _secretRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefsList(this, "secret_refs", false);
  public get secretRefs() {
    return this._secretRefs;
  }
  public putSecretRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsSecretRefs[] | cdktf.IResolvable) {
    this._secretRefs.internalValue = value;
  }
  public resetSecretRefs() {
    this._secretRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefsInput() {
    return this._secretRefs.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs {
  /**
  * ConfigMapRefs holds a list of references to ConfigMaps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#config_map_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#config_map_refs}
  */
  readonly configMapRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs[] | cdktf.IResolvable;
  /**
  * SecretRefs holds a list of references to Secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_refs}
  */
  readonly secretRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_refs: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsToTerraform, false)(struct!.configMapRefs),
    secret_refs: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsToTerraform, false)(struct!.secretRefs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_refs: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsToHclTerraform, false)(struct!.configMapRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsList",
    },
    secret_refs: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsToHclTerraform, false)(struct!.secretRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRefs = this._configMapRefs?.internalValue;
    }
    if (this._secretRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRefs = this._secretRefs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRefs.internalValue = undefined;
      this._secretRefs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRefs.internalValue = value.configMapRefs;
      this._secretRefs.internalValue = value.secretRefs;
    }
  }

  // config_map_refs - computed: false, optional: true, required: false
  private _configMapRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefsList(this, "config_map_refs", false);
  public get configMapRefs() {
    return this._configMapRefs;
  }
  public putConfigMapRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsConfigMapRefs[] | cdktf.IResolvable) {
    this._configMapRefs.internalValue = value;
  }
  public resetConfigMapRefs() {
    this._configMapRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefsInput() {
    return this._configMapRefs.internalValue;
  }

  // secret_refs - computed: false, optional: true, required: false
  private _secretRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefsList(this, "secret_refs", false);
  public get secretRefs() {
    return this._secretRefs;
  }
  public putSecretRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsSecretRefs[] | cdktf.IResolvable) {
    this._secretRefs.internalValue = value;
  }
  public resetSecretRefs() {
    this._secretRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefsInput() {
    return this._secretRefs.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret {
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecretToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecretToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb {
  /**
  * Whether the '-k' option should be passed to initdb, enabling checksums on data pages (default: 'false')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#data_checksums DataK8SPostgresqlCnpgIoClusterV1Manifest#data_checksums}
  */
  readonly dataChecksums?: boolean | cdktf.IResolvable;
  /**
  * Name of the database used by the application. Default: 'app'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#database DataK8SPostgresqlCnpgIoClusterV1Manifest#database}
  */
  readonly database?: string;
  /**
  * The value to be passed as option '--encoding' for initdb (default:'UTF8')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#encoding DataK8SPostgresqlCnpgIoClusterV1Manifest#encoding}
  */
  readonly encoding?: string;
  /**
  * Bootstraps the new cluster by importing data from an existing PostgreSQL instance using logical backup ('pg_dump' and 'pg_restore')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#import DataK8SPostgresqlCnpgIoClusterV1Manifest#import}
  */
  readonly import?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport;
  /**
  * The value to be passed as option '--lc-ctype' for initdb (default:'C')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#locale_c_type DataK8SPostgresqlCnpgIoClusterV1Manifest#locale_c_type}
  */
  readonly localeCType?: string;
  /**
  * The value to be passed as option '--lc-collate' for initdb (default:'C')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#locale_collate DataK8SPostgresqlCnpgIoClusterV1Manifest#locale_collate}
  */
  readonly localeCollate?: string;
  /**
  * The list of options that must be passed to initdb when creating the cluster. Deprecated: This could lead to inconsistent configurations, please use the explicit provided parameters instead. If defined, explicit values will be ignored.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#options DataK8SPostgresqlCnpgIoClusterV1Manifest#options}
  */
  readonly options?: string[];
  /**
  * Name of the owner of the database in the instance to be used by applications. Defaults to the value of the 'database' key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#owner DataK8SPostgresqlCnpgIoClusterV1Manifest#owner}
  */
  readonly owner?: string;
  /**
  * List of SQL queries to be executed as a superuser in the application database right after the cluster has been created - to be used with extreme care (by default empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_init_application_sql DataK8SPostgresqlCnpgIoClusterV1Manifest#post_init_application_sql}
  */
  readonly postInitApplicationSql?: string[];
  /**
  * List of references to ConfigMaps or Secrets containing SQL files to be executed as a superuser in the application database right after the cluster has been created. The references are processed in a specific order: first, all Secrets are processed, followed by all ConfigMaps. Within each group, the processing order follows the sequence specified in their respective arrays. (by default empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_init_application_sql_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#post_init_application_sql_refs}
  */
  readonly postInitApplicationSqlRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs;
  /**
  * List of SQL queries to be executed as a superuser in the 'postgres' database right after the cluster has been created - to be used with extreme care (by default empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_init_sql DataK8SPostgresqlCnpgIoClusterV1Manifest#post_init_sql}
  */
  readonly postInitSql?: string[];
  /**
  * List of references to ConfigMaps or Secrets containing SQL files to be executed as a superuser in the 'postgres' database right after the cluster has been created. The references are processed in a specific order: first, all Secrets are processed, followed by all ConfigMaps. Within each group, the processing order follows the sequence specified in their respective arrays. (by default empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_init_sql_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#post_init_sql_refs}
  */
  readonly postInitSqlRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs;
  /**
  * List of SQL queries to be executed as a superuser in the 'template1' database right after the cluster has been created - to be used with extreme care (by default empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_init_template_sql DataK8SPostgresqlCnpgIoClusterV1Manifest#post_init_template_sql}
  */
  readonly postInitTemplateSql?: string[];
  /**
  * List of references to ConfigMaps or Secrets containing SQL files to be executed as a superuser in the 'template1' database right after the cluster has been created. The references are processed in a specific order: first, all Secrets are processed, followed by all ConfigMaps. Within each group, the processing order follows the sequence specified in their respective arrays. (by default empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#post_init_template_sql_refs DataK8SPostgresqlCnpgIoClusterV1Manifest#post_init_template_sql_refs}
  */
  readonly postInitTemplateSqlRefs?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs;
  /**
  * Name of the secret containing the initial credentials for the owner of the user database. If empty a new secret will be created from scratch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret DataK8SPostgresqlCnpgIoClusterV1Manifest#secret}
  */
  readonly secret?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret;
  /**
  * The value in megabytes (1 to 1024) to be passed to the '--wal-segsize' option for initdb (default: empty, resulting in PostgreSQL default: 16MB)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#wal_segment_size DataK8SPostgresqlCnpgIoClusterV1Manifest#wal_segment_size}
  */
  readonly walSegmentSize?: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_checksums: cdktf.booleanToTerraform(struct!.dataChecksums),
    database: cdktf.stringToTerraform(struct!.database),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    import: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportToTerraform(struct!.import),
    locale_c_type: cdktf.stringToTerraform(struct!.localeCType),
    locale_collate: cdktf.stringToTerraform(struct!.localeCollate),
    options: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.options),
    owner: cdktf.stringToTerraform(struct!.owner),
    post_init_application_sql: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.postInitApplicationSql),
    post_init_application_sql_refs: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsToTerraform(struct!.postInitApplicationSqlRefs),
    post_init_sql: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.postInitSql),
    post_init_sql_refs: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsToTerraform(struct!.postInitSqlRefs),
    post_init_template_sql: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.postInitTemplateSql),
    post_init_template_sql_refs: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsToTerraform(struct!.postInitTemplateSqlRefs),
    secret: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecretToTerraform(struct!.secret),
    wal_segment_size: cdktf.numberToTerraform(struct!.walSegmentSize),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_checksums: {
      value: cdktf.booleanToHclTerraform(struct!.dataChecksums),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    import: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportToHclTerraform(struct!.import),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport",
    },
    locale_c_type: {
      value: cdktf.stringToHclTerraform(struct!.localeCType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    locale_collate: {
      value: cdktf.stringToHclTerraform(struct!.localeCollate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    options: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.options),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    owner: {
      value: cdktf.stringToHclTerraform(struct!.owner),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    post_init_application_sql: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.postInitApplicationSql),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    post_init_application_sql_refs: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsToHclTerraform(struct!.postInitApplicationSqlRefs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs",
    },
    post_init_sql: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.postInitSql),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    post_init_sql_refs: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsToHclTerraform(struct!.postInitSqlRefs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs",
    },
    post_init_template_sql: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.postInitTemplateSql),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    post_init_template_sql_refs: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsToHclTerraform(struct!.postInitTemplateSqlRefs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs",
    },
    secret: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret",
    },
    wal_segment_size: {
      value: cdktf.numberToHclTerraform(struct!.walSegmentSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataChecksums !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataChecksums = this._dataChecksums;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._import?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.import = this._import?.internalValue;
    }
    if (this._localeCType !== undefined) {
      hasAnyValues = true;
      internalValueResult.localeCType = this._localeCType;
    }
    if (this._localeCollate !== undefined) {
      hasAnyValues = true;
      internalValueResult.localeCollate = this._localeCollate;
    }
    if (this._options !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options;
    }
    if (this._owner !== undefined) {
      hasAnyValues = true;
      internalValueResult.owner = this._owner;
    }
    if (this._postInitApplicationSql !== undefined) {
      hasAnyValues = true;
      internalValueResult.postInitApplicationSql = this._postInitApplicationSql;
    }
    if (this._postInitApplicationSqlRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postInitApplicationSqlRefs = this._postInitApplicationSqlRefs?.internalValue;
    }
    if (this._postInitSql !== undefined) {
      hasAnyValues = true;
      internalValueResult.postInitSql = this._postInitSql;
    }
    if (this._postInitSqlRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postInitSqlRefs = this._postInitSqlRefs?.internalValue;
    }
    if (this._postInitTemplateSql !== undefined) {
      hasAnyValues = true;
      internalValueResult.postInitTemplateSql = this._postInitTemplateSql;
    }
    if (this._postInitTemplateSqlRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postInitTemplateSqlRefs = this._postInitTemplateSqlRefs?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._walSegmentSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.walSegmentSize = this._walSegmentSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataChecksums = undefined;
      this._database = undefined;
      this._encoding = undefined;
      this._import.internalValue = undefined;
      this._localeCType = undefined;
      this._localeCollate = undefined;
      this._options = undefined;
      this._owner = undefined;
      this._postInitApplicationSql = undefined;
      this._postInitApplicationSqlRefs.internalValue = undefined;
      this._postInitSql = undefined;
      this._postInitSqlRefs.internalValue = undefined;
      this._postInitTemplateSql = undefined;
      this._postInitTemplateSqlRefs.internalValue = undefined;
      this._secret.internalValue = undefined;
      this._walSegmentSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataChecksums = value.dataChecksums;
      this._database = value.database;
      this._encoding = value.encoding;
      this._import.internalValue = value.import;
      this._localeCType = value.localeCType;
      this._localeCollate = value.localeCollate;
      this._options = value.options;
      this._owner = value.owner;
      this._postInitApplicationSql = value.postInitApplicationSql;
      this._postInitApplicationSqlRefs.internalValue = value.postInitApplicationSqlRefs;
      this._postInitSql = value.postInitSql;
      this._postInitSqlRefs.internalValue = value.postInitSqlRefs;
      this._postInitTemplateSql = value.postInitTemplateSql;
      this._postInitTemplateSqlRefs.internalValue = value.postInitTemplateSqlRefs;
      this._secret.internalValue = value.secret;
      this._walSegmentSize = value.walSegmentSize;
    }
  }

  // data_checksums - computed: false, optional: true, required: false
  private _dataChecksums?: boolean | cdktf.IResolvable; 
  public get dataChecksums() {
    return this.getBooleanAttribute('data_checksums');
  }
  public set dataChecksums(value: boolean | cdktf.IResolvable) {
    this._dataChecksums = value;
  }
  public resetDataChecksums() {
    this._dataChecksums = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataChecksumsInput() {
    return this._dataChecksums;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // import - computed: false, optional: true, required: false
  private _import = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImportOutputReference(this, "import");
  public get import() {
    return this._import;
  }
  public putImport(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbImport) {
    this._import.internalValue = value;
  }
  public resetImport() {
    this._import.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importInput() {
    return this._import.internalValue;
  }

  // locale_c_type - computed: false, optional: true, required: false
  private _localeCType?: string; 
  public get localeCType() {
    return this.getStringAttribute('locale_c_type');
  }
  public set localeCType(value: string) {
    this._localeCType = value;
  }
  public resetLocaleCType() {
    this._localeCType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localeCTypeInput() {
    return this._localeCType;
  }

  // locale_collate - computed: false, optional: true, required: false
  private _localeCollate?: string; 
  public get localeCollate() {
    return this.getStringAttribute('locale_collate');
  }
  public set localeCollate(value: string) {
    this._localeCollate = value;
  }
  public resetLocaleCollate() {
    this._localeCollate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localeCollateInput() {
    return this._localeCollate;
  }

  // options - computed: false, optional: true, required: false
  private _options?: string[]; 
  public get options() {
    return this.getListAttribute('options');
  }
  public set options(value: string[]) {
    this._options = value;
  }
  public resetOptions() {
    this._options = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options;
  }

  // owner - computed: false, optional: true, required: false
  private _owner?: string; 
  public get owner() {
    return this.getStringAttribute('owner');
  }
  public set owner(value: string) {
    this._owner = value;
  }
  public resetOwner() {
    this._owner = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerInput() {
    return this._owner;
  }

  // post_init_application_sql - computed: false, optional: true, required: false
  private _postInitApplicationSql?: string[]; 
  public get postInitApplicationSql() {
    return this.getListAttribute('post_init_application_sql');
  }
  public set postInitApplicationSql(value: string[]) {
    this._postInitApplicationSql = value;
  }
  public resetPostInitApplicationSql() {
    this._postInitApplicationSql = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postInitApplicationSqlInput() {
    return this._postInitApplicationSql;
  }

  // post_init_application_sql_refs - computed: false, optional: true, required: false
  private _postInitApplicationSqlRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefsOutputReference(this, "post_init_application_sql_refs");
  public get postInitApplicationSqlRefs() {
    return this._postInitApplicationSqlRefs;
  }
  public putPostInitApplicationSqlRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitApplicationSqlRefs) {
    this._postInitApplicationSqlRefs.internalValue = value;
  }
  public resetPostInitApplicationSqlRefs() {
    this._postInitApplicationSqlRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postInitApplicationSqlRefsInput() {
    return this._postInitApplicationSqlRefs.internalValue;
  }

  // post_init_sql - computed: false, optional: true, required: false
  private _postInitSql?: string[]; 
  public get postInitSql() {
    return this.getListAttribute('post_init_sql');
  }
  public set postInitSql(value: string[]) {
    this._postInitSql = value;
  }
  public resetPostInitSql() {
    this._postInitSql = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postInitSqlInput() {
    return this._postInitSql;
  }

  // post_init_sql_refs - computed: false, optional: true, required: false
  private _postInitSqlRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefsOutputReference(this, "post_init_sql_refs");
  public get postInitSqlRefs() {
    return this._postInitSqlRefs;
  }
  public putPostInitSqlRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitSqlRefs) {
    this._postInitSqlRefs.internalValue = value;
  }
  public resetPostInitSqlRefs() {
    this._postInitSqlRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postInitSqlRefsInput() {
    return this._postInitSqlRefs.internalValue;
  }

  // post_init_template_sql - computed: false, optional: true, required: false
  private _postInitTemplateSql?: string[]; 
  public get postInitTemplateSql() {
    return this.getListAttribute('post_init_template_sql');
  }
  public set postInitTemplateSql(value: string[]) {
    this._postInitTemplateSql = value;
  }
  public resetPostInitTemplateSql() {
    this._postInitTemplateSql = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postInitTemplateSqlInput() {
    return this._postInitTemplateSql;
  }

  // post_init_template_sql_refs - computed: false, optional: true, required: false
  private _postInitTemplateSqlRefs = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefsOutputReference(this, "post_init_template_sql_refs");
  public get postInitTemplateSqlRefs() {
    return this._postInitTemplateSqlRefs;
  }
  public putPostInitTemplateSqlRefs(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbPostInitTemplateSqlRefs) {
    this._postInitTemplateSqlRefs.internalValue = value;
  }
  public resetPostInitTemplateSqlRefs() {
    this._postInitTemplateSqlRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postInitTemplateSqlRefsInput() {
    return this._postInitTemplateSqlRefs.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // wal_segment_size - computed: false, optional: true, required: false
  private _walSegmentSize?: number; 
  public get walSegmentSize() {
    return this.getNumberAttribute('wal_segment_size');
  }
  public set walSegmentSize(value: number) {
    this._walSegmentSize = value;
  }
  public resetWalSegmentSize() {
    this._walSegmentSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get walSegmentSizeInput() {
    return this._walSegmentSize;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret {
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecretToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecretToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup {
  /**
  * Name of the database used by the application. Default: 'app'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#database DataK8SPostgresqlCnpgIoClusterV1Manifest#database}
  */
  readonly database?: string;
  /**
  * Name of the owner of the database in the instance to be used by applications. Defaults to the value of the 'database' key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#owner DataK8SPostgresqlCnpgIoClusterV1Manifest#owner}
  */
  readonly owner?: string;
  /**
  * Name of the secret containing the initial credentials for the owner of the user database. If empty a new secret will be created from scratch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret DataK8SPostgresqlCnpgIoClusterV1Manifest#secret}
  */
  readonly secret?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret;
  /**
  * The name of the server of which we need to take a physical backup
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#source DataK8SPostgresqlCnpgIoClusterV1Manifest#source}
  */
  readonly source: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    database: cdktf.stringToTerraform(struct!.database),
    owner: cdktf.stringToTerraform(struct!.owner),
    secret: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecretToTerraform(struct!.secret),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    owner: {
      value: cdktf.stringToHclTerraform(struct!.owner),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._owner !== undefined) {
      hasAnyValues = true;
      internalValueResult.owner = this._owner;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._database = undefined;
      this._owner = undefined;
      this._secret.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._database = value.database;
      this._owner = value.owner;
      this._secret.internalValue = value.secret;
      this._source = value.source;
    }
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // owner - computed: false, optional: true, required: false
  private _owner?: string; 
  public get owner() {
    return this.getStringAttribute('owner');
  }
  public set owner(value: string) {
    this._owner = value;
  }
  public resetOwner() {
    this._owner = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerInput() {
    return this._owner;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // source - computed: false, optional: false, required: true
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCaToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCaToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup {
  /**
  * EndpointCA store the CA bundle of the barman endpoint. Useful when using self-signed certificates to avoid errors with certificate issuer and barman-cloud-wal-archive.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#endpoint_ca DataK8SPostgresqlCnpgIoClusterV1Manifest#endpoint_ca}
  */
  readonly endpointCa?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint_ca: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCaToTerraform(struct!.endpointCa),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint_ca: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCaToHclTerraform(struct!.endpointCa),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpointCa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointCa = this._endpointCa?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpointCa.internalValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpointCa.internalValue = value.endpointCa;
      this._name = value.name;
    }
  }

  // endpoint_ca - computed: false, optional: true, required: false
  private _endpointCa = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCaOutputReference(this, "endpoint_ca");
  public get endpointCa() {
    return this._endpointCa;
  }
  public putEndpointCa(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupEndpointCa) {
    this._endpointCa.internalValue = value;
  }
  public resetEndpointCa() {
    this._endpointCa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointCaInput() {
    return this._endpointCa.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget {
  /**
  * The ID of the backup from which to start the recovery process. If empty (default) the operator will automatically detect the backup based on targetTime or targetLSN if specified. Otherwise use the latest available backup in chronological order.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#backup_id DataK8SPostgresqlCnpgIoClusterV1Manifest#backup_id}
  */
  readonly backupId?: string;
  /**
  * Set the target to be exclusive. If omitted, defaults to false, so that in Postgres, 'recovery_target_inclusive' will be true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#exclusive DataK8SPostgresqlCnpgIoClusterV1Manifest#exclusive}
  */
  readonly exclusive?: boolean | cdktf.IResolvable;
  /**
  * End recovery as soon as a consistent state is reached
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_immediate DataK8SPostgresqlCnpgIoClusterV1Manifest#target_immediate}
  */
  readonly targetImmediate?: boolean | cdktf.IResolvable;
  /**
  * The target LSN (Log Sequence Number)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_lsn DataK8SPostgresqlCnpgIoClusterV1Manifest#target_lsn}
  */
  readonly targetLsn?: string;
  /**
  * The target name (to be previously created with 'pg_create_restore_point')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_name DataK8SPostgresqlCnpgIoClusterV1Manifest#target_name}
  */
  readonly targetName?: string;
  /**
  * The target time as a timestamp in the RFC3339 standard
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_time DataK8SPostgresqlCnpgIoClusterV1Manifest#target_time}
  */
  readonly targetTime?: string;
  /**
  * The target timeline ('latest' or a positive integer)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_tli DataK8SPostgresqlCnpgIoClusterV1Manifest#target_tli}
  */
  readonly targetTli?: string;
  /**
  * The target transaction ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_xid DataK8SPostgresqlCnpgIoClusterV1Manifest#target_xid}
  */
  readonly targetXid?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTargetToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backup_id: cdktf.stringToTerraform(struct!.backupId),
    exclusive: cdktf.booleanToTerraform(struct!.exclusive),
    target_immediate: cdktf.booleanToTerraform(struct!.targetImmediate),
    target_lsn: cdktf.stringToTerraform(struct!.targetLsn),
    target_name: cdktf.stringToTerraform(struct!.targetName),
    target_time: cdktf.stringToTerraform(struct!.targetTime),
    target_tli: cdktf.stringToTerraform(struct!.targetTli),
    target_xid: cdktf.stringToTerraform(struct!.targetXid),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTargetToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backup_id: {
      value: cdktf.stringToHclTerraform(struct!.backupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclusive: {
      value: cdktf.booleanToHclTerraform(struct!.exclusive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_immediate: {
      value: cdktf.booleanToHclTerraform(struct!.targetImmediate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_lsn: {
      value: cdktf.stringToHclTerraform(struct!.targetLsn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_name: {
      value: cdktf.stringToHclTerraform(struct!.targetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_time: {
      value: cdktf.stringToHclTerraform(struct!.targetTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_tli: {
      value: cdktf.stringToHclTerraform(struct!.targetTli),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_xid: {
      value: cdktf.stringToHclTerraform(struct!.targetXid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTargetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.backupId = this._backupId;
    }
    if (this._exclusive !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclusive = this._exclusive;
    }
    if (this._targetImmediate !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetImmediate = this._targetImmediate;
    }
    if (this._targetLsn !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLsn = this._targetLsn;
    }
    if (this._targetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetName = this._targetName;
    }
    if (this._targetTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetTime = this._targetTime;
    }
    if (this._targetTli !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetTli = this._targetTli;
    }
    if (this._targetXid !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetXid = this._targetXid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backupId = undefined;
      this._exclusive = undefined;
      this._targetImmediate = undefined;
      this._targetLsn = undefined;
      this._targetName = undefined;
      this._targetTime = undefined;
      this._targetTli = undefined;
      this._targetXid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backupId = value.backupId;
      this._exclusive = value.exclusive;
      this._targetImmediate = value.targetImmediate;
      this._targetLsn = value.targetLsn;
      this._targetName = value.targetName;
      this._targetTime = value.targetTime;
      this._targetTli = value.targetTli;
      this._targetXid = value.targetXid;
    }
  }

  // backup_id - computed: false, optional: true, required: false
  private _backupId?: string; 
  public get backupId() {
    return this.getStringAttribute('backup_id');
  }
  public set backupId(value: string) {
    this._backupId = value;
  }
  public resetBackupId() {
    this._backupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backupIdInput() {
    return this._backupId;
  }

  // exclusive - computed: false, optional: true, required: false
  private _exclusive?: boolean | cdktf.IResolvable; 
  public get exclusive() {
    return this.getBooleanAttribute('exclusive');
  }
  public set exclusive(value: boolean | cdktf.IResolvable) {
    this._exclusive = value;
  }
  public resetExclusive() {
    this._exclusive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exclusiveInput() {
    return this._exclusive;
  }

  // target_immediate - computed: false, optional: true, required: false
  private _targetImmediate?: boolean | cdktf.IResolvable; 
  public get targetImmediate() {
    return this.getBooleanAttribute('target_immediate');
  }
  public set targetImmediate(value: boolean | cdktf.IResolvable) {
    this._targetImmediate = value;
  }
  public resetTargetImmediate() {
    this._targetImmediate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetImmediateInput() {
    return this._targetImmediate;
  }

  // target_lsn - computed: false, optional: true, required: false
  private _targetLsn?: string; 
  public get targetLsn() {
    return this.getStringAttribute('target_lsn');
  }
  public set targetLsn(value: string) {
    this._targetLsn = value;
  }
  public resetTargetLsn() {
    this._targetLsn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLsnInput() {
    return this._targetLsn;
  }

  // target_name - computed: false, optional: true, required: false
  private _targetName?: string; 
  public get targetName() {
    return this.getStringAttribute('target_name');
  }
  public set targetName(value: string) {
    this._targetName = value;
  }
  public resetTargetName() {
    this._targetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetNameInput() {
    return this._targetName;
  }

  // target_time - computed: false, optional: true, required: false
  private _targetTime?: string; 
  public get targetTime() {
    return this.getStringAttribute('target_time');
  }
  public set targetTime(value: string) {
    this._targetTime = value;
  }
  public resetTargetTime() {
    this._targetTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetTimeInput() {
    return this._targetTime;
  }

  // target_tli - computed: false, optional: true, required: false
  private _targetTli?: string; 
  public get targetTli() {
    return this.getStringAttribute('target_tli');
  }
  public set targetTli(value: string) {
    this._targetTli = value;
  }
  public resetTargetTli() {
    this._targetTli = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetTliInput() {
    return this._targetTli;
  }

  // target_xid - computed: false, optional: true, required: false
  private _targetXid?: string; 
  public get targetXid() {
    return this.getStringAttribute('target_xid');
  }
  public set targetXid(value: string) {
    this._targetXid = value;
  }
  public resetTargetXid() {
    this._targetXid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetXidInput() {
    return this._targetXid;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret {
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecretToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecretToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage {
  /**
  * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_group DataK8SPostgresqlCnpgIoClusterV1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind is the type of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#kind DataK8SPostgresqlCnpgIoClusterV1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name is the name of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorageToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorageToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage {
  /**
  * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_group DataK8SPostgresqlCnpgIoClusterV1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind is the type of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#kind DataK8SPostgresqlCnpgIoClusterV1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name is the name of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorageToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorageToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage {
  /**
  * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_group DataK8SPostgresqlCnpgIoClusterV1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind is the type of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#kind DataK8SPostgresqlCnpgIoClusterV1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name is the name of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorageToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorageToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots {
  /**
  * Configuration of the storage of the instances
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage DataK8SPostgresqlCnpgIoClusterV1Manifest#storage}
  */
  readonly storage: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage;
  /**
  * Configuration of the storage for PostgreSQL tablespaces
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tablespace_storage DataK8SPostgresqlCnpgIoClusterV1Manifest#tablespace_storage}
  */
  readonly tablespaceStorage?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage;
  /**
  * Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#wal_storage DataK8SPostgresqlCnpgIoClusterV1Manifest#wal_storage}
  */
  readonly walStorage?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    storage: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorageToTerraform(struct!.storage),
    tablespace_storage: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorageToTerraform(struct!.tablespaceStorage),
    wal_storage: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorageToTerraform(struct!.walStorage),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    storage: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorageToHclTerraform(struct!.storage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage",
    },
    tablespace_storage: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorageToHclTerraform(struct!.tablespaceStorage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage",
    },
    wal_storage: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorageToHclTerraform(struct!.walStorage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._storage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage?.internalValue;
    }
    if (this._tablespaceStorage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tablespaceStorage = this._tablespaceStorage?.internalValue;
    }
    if (this._walStorage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.walStorage = this._walStorage?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._storage.internalValue = undefined;
      this._tablespaceStorage.internalValue = undefined;
      this._walStorage.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._storage.internalValue = value.storage;
      this._tablespaceStorage.internalValue = value.tablespaceStorage;
      this._walStorage.internalValue = value.walStorage;
    }
  }

  // storage - computed: false, optional: false, required: true
  private _storage = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorageOutputReference(this, "storage");
  public get storage() {
    return this._storage;
  }
  public putStorage(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsStorage) {
    this._storage.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage.internalValue;
  }

  // tablespace_storage - computed: false, optional: true, required: false
  private _tablespaceStorage = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorageOutputReference(this, "tablespace_storage");
  public get tablespaceStorage() {
    return this._tablespaceStorage;
  }
  public putTablespaceStorage(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsTablespaceStorage) {
    this._tablespaceStorage.internalValue = value;
  }
  public resetTablespaceStorage() {
    this._tablespaceStorage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tablespaceStorageInput() {
    return this._tablespaceStorage.internalValue;
  }

  // wal_storage - computed: false, optional: true, required: false
  private _walStorage = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorageOutputReference(this, "wal_storage");
  public get walStorage() {
    return this._walStorage;
  }
  public putWalStorage(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsWalStorage) {
    this._walStorage.internalValue = value;
  }
  public resetWalStorage() {
    this._walStorage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get walStorageInput() {
    return this._walStorage.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery {
  /**
  * The backup object containing the physical base backup from which to initiate the recovery procedure. Mutually exclusive with 'source' and 'volumeSnapshots'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#backup DataK8SPostgresqlCnpgIoClusterV1Manifest#backup}
  */
  readonly backup?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup;
  /**
  * Name of the database used by the application. Default: 'app'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#database DataK8SPostgresqlCnpgIoClusterV1Manifest#database}
  */
  readonly database?: string;
  /**
  * Name of the owner of the database in the instance to be used by applications. Defaults to the value of the 'database' key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#owner DataK8SPostgresqlCnpgIoClusterV1Manifest#owner}
  */
  readonly owner?: string;
  /**
  * By default, the recovery process applies all the available WAL files in the archive (full recovery). However, you can also end the recovery as soon as a consistent state is reached or recover to a point-in-time (PITR) by specifying a 'RecoveryTarget' object, as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...). More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#recovery_target DataK8SPostgresqlCnpgIoClusterV1Manifest#recovery_target}
  */
  readonly recoveryTarget?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget;
  /**
  * Name of the secret containing the initial credentials for the owner of the user database. If empty a new secret will be created from scratch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret DataK8SPostgresqlCnpgIoClusterV1Manifest#secret}
  */
  readonly secret?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret;
  /**
  * The external cluster whose backup we will restore. This is also used as the name of the folder under which the backup is stored, so it must be set to the name of the source cluster Mutually exclusive with 'backup'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#source DataK8SPostgresqlCnpgIoClusterV1Manifest#source}
  */
  readonly source?: string;
  /**
  * The static PVC data source(s) from which to initiate the recovery procedure. Currently supporting 'VolumeSnapshot' and 'PersistentVolumeClaim' resources that map an existing PVC group, compatible with CloudNativePG, and taken with a cold backup copy on a fenced Postgres instance (limitation which will be removed in the future when online backup will be implemented). Mutually exclusive with 'backup'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#volume_snapshots DataK8SPostgresqlCnpgIoClusterV1Manifest#volume_snapshots}
  */
  readonly volumeSnapshots?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backup: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupToTerraform(struct!.backup),
    database: cdktf.stringToTerraform(struct!.database),
    owner: cdktf.stringToTerraform(struct!.owner),
    recovery_target: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTargetToTerraform(struct!.recoveryTarget),
    secret: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecretToTerraform(struct!.secret),
    source: cdktf.stringToTerraform(struct!.source),
    volume_snapshots: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsToTerraform(struct!.volumeSnapshots),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backup: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupToHclTerraform(struct!.backup),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    owner: {
      value: cdktf.stringToHclTerraform(struct!.owner),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recovery_target: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTargetToHclTerraform(struct!.recoveryTarget),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget",
    },
    secret: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_snapshots: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsToHclTerraform(struct!.volumeSnapshots),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backup?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backup = this._backup?.internalValue;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._owner !== undefined) {
      hasAnyValues = true;
      internalValueResult.owner = this._owner;
    }
    if (this._recoveryTarget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.recoveryTarget = this._recoveryTarget?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    if (this._volumeSnapshots?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeSnapshots = this._volumeSnapshots?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backup.internalValue = undefined;
      this._database = undefined;
      this._owner = undefined;
      this._recoveryTarget.internalValue = undefined;
      this._secret.internalValue = undefined;
      this._source = undefined;
      this._volumeSnapshots.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backup.internalValue = value.backup;
      this._database = value.database;
      this._owner = value.owner;
      this._recoveryTarget.internalValue = value.recoveryTarget;
      this._secret.internalValue = value.secret;
      this._source = value.source;
      this._volumeSnapshots.internalValue = value.volumeSnapshots;
    }
  }

  // backup - computed: false, optional: true, required: false
  private _backup = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackupOutputReference(this, "backup");
  public get backup() {
    return this._backup;
  }
  public putBackup(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryBackup) {
    this._backup.internalValue = value;
  }
  public resetBackup() {
    this._backup.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backupInput() {
    return this._backup.internalValue;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // owner - computed: false, optional: true, required: false
  private _owner?: string; 
  public get owner() {
    return this.getStringAttribute('owner');
  }
  public set owner(value: string) {
    this._owner = value;
  }
  public resetOwner() {
    this._owner = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerInput() {
    return this._owner;
  }

  // recovery_target - computed: false, optional: true, required: false
  private _recoveryTarget = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTargetOutputReference(this, "recovery_target");
  public get recoveryTarget() {
    return this._recoveryTarget;
  }
  public putRecoveryTarget(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryRecoveryTarget) {
    this._recoveryTarget.internalValue = value;
  }
  public resetRecoveryTarget() {
    this._recoveryTarget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recoveryTargetInput() {
    return this._recoveryTarget.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoverySecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }

  // volume_snapshots - computed: false, optional: true, required: false
  private _volumeSnapshots = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshotsOutputReference(this, "volume_snapshots");
  public get volumeSnapshots() {
    return this._volumeSnapshots;
  }
  public putVolumeSnapshots(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryVolumeSnapshots) {
    this._volumeSnapshots.internalValue = value;
  }
  public resetVolumeSnapshots() {
    this._volumeSnapshots.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeSnapshotsInput() {
    return this._volumeSnapshots.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrap {
  /**
  * Bootstrap the cluster via initdb
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#initdb DataK8SPostgresqlCnpgIoClusterV1Manifest#initdb}
  */
  readonly initdb?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb;
  /**
  * Bootstrap the cluster taking a physical backup of another compatible PostgreSQL instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pg_basebackup DataK8SPostgresqlCnpgIoClusterV1Manifest#pg_basebackup}
  */
  readonly pgBasebackup?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup;
  /**
  * Bootstrap the cluster from a backup
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#recovery DataK8SPostgresqlCnpgIoClusterV1Manifest#recovery}
  */
  readonly recovery?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    initdb: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbToTerraform(struct!.initdb),
    pg_basebackup: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupToTerraform(struct!.pgBasebackup),
    recovery: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryToTerraform(struct!.recovery),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    initdb: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbToHclTerraform(struct!.initdb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb",
    },
    pg_basebackup: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupToHclTerraform(struct!.pgBasebackup),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup",
    },
    recovery: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryToHclTerraform(struct!.recovery),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._initdb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initdb = this._initdb?.internalValue;
    }
    if (this._pgBasebackup?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pgBasebackup = this._pgBasebackup?.internalValue;
    }
    if (this._recovery?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.recovery = this._recovery?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._initdb.internalValue = undefined;
      this._pgBasebackup.internalValue = undefined;
      this._recovery.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._initdb.internalValue = value.initdb;
      this._pgBasebackup.internalValue = value.pgBasebackup;
      this._recovery.internalValue = value.recovery;
    }
  }

  // initdb - computed: false, optional: true, required: false
  private _initdb = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdbOutputReference(this, "initdb");
  public get initdb() {
    return this._initdb;
  }
  public putInitdb(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapInitdb) {
    this._initdb.internalValue = value;
  }
  public resetInitdb() {
    this._initdb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initdbInput() {
    return this._initdb.internalValue;
  }

  // pg_basebackup - computed: false, optional: true, required: false
  private _pgBasebackup = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackupOutputReference(this, "pg_basebackup");
  public get pgBasebackup() {
    return this._pgBasebackup;
  }
  public putPgBasebackup(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapPgBasebackup) {
    this._pgBasebackup.internalValue = value;
  }
  public resetPgBasebackup() {
    this._pgBasebackup.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pgBasebackupInput() {
    return this._pgBasebackup.internalValue;
  }

  // recovery - computed: false, optional: true, required: false
  private _recovery = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecoveryOutputReference(this, "recovery");
  public get recovery() {
    return this._recovery;
  }
  public putRecovery(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecBootstrapRecovery) {
    this._recovery.internalValue = value;
  }
  public resetRecovery() {
    this._recovery.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recoveryInput() {
    return this._recovery.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificates {
  /**
  * The secret containing the Client CA certificate. If not defined, a new secret will be created with a self-signed CA and will be used to generate all the client certificates.<br /> <br /> Contains:<br /> <br /> - 'ca.crt': CA that should be used to validate the client certificates, used as 'ssl_ca_file' of all the instances.<br /> - 'ca.key': key used to generate client certificates, if ReplicationTLSSecret is provided, this can be omitted.<br />
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#client_ca_secret DataK8SPostgresqlCnpgIoClusterV1Manifest#client_ca_secret}
  */
  readonly clientCaSecret?: string;
  /**
  * The secret of type kubernetes.io/tls containing the client certificate to authenticate as the 'streaming_replica' user. If not defined, ClientCASecret must provide also 'ca.key', and a new secret will be created using the provided CA.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#replication_tls_secret DataK8SPostgresqlCnpgIoClusterV1Manifest#replication_tls_secret}
  */
  readonly replicationTlsSecret?: string;
  /**
  * The list of the server alternative DNS names to be added to the generated server TLS certificates, when required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#server_alt_dns_names DataK8SPostgresqlCnpgIoClusterV1Manifest#server_alt_dns_names}
  */
  readonly serverAltDnsNames?: string[];
  /**
  * The secret containing the Server CA certificate. If not defined, a new secret will be created with a self-signed CA and will be used to generate the TLS certificate ServerTLSSecret.<br /> <br /> Contains:<br /> <br /> - 'ca.crt': CA that should be used to validate the server certificate, used as 'sslrootcert' in client connection strings.<br /> - 'ca.key': key used to generate Server SSL certs, if ServerTLSSecret is provided, this can be omitted.<br />
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#server_ca_secret DataK8SPostgresqlCnpgIoClusterV1Manifest#server_ca_secret}
  */
  readonly serverCaSecret?: string;
  /**
  * The secret of type kubernetes.io/tls containing the server TLS certificate and key that will be set as 'ssl_cert_file' and 'ssl_key_file' so that clients can connect to postgres securely. If not defined, ServerCASecret must provide also 'ca.key' and a new secret will be created using the provided CA.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#server_tls_secret DataK8SPostgresqlCnpgIoClusterV1Manifest#server_tls_secret}
  */
  readonly serverTlsSecret?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificatesToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_ca_secret: cdktf.stringToTerraform(struct!.clientCaSecret),
    replication_tls_secret: cdktf.stringToTerraform(struct!.replicationTlsSecret),
    server_alt_dns_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.serverAltDnsNames),
    server_ca_secret: cdktf.stringToTerraform(struct!.serverCaSecret),
    server_tls_secret: cdktf.stringToTerraform(struct!.serverTlsSecret),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificatesToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_ca_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientCaSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replication_tls_secret: {
      value: cdktf.stringToHclTerraform(struct!.replicationTlsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_alt_dns_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.serverAltDnsNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    server_ca_secret: {
      value: cdktf.stringToHclTerraform(struct!.serverCaSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_tls_secret: {
      value: cdktf.stringToHclTerraform(struct!.serverTlsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificatesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificates | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCaSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCaSecret = this._clientCaSecret;
    }
    if (this._replicationTlsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicationTlsSecret = this._replicationTlsSecret;
    }
    if (this._serverAltDnsNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverAltDnsNames = this._serverAltDnsNames;
    }
    if (this._serverCaSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverCaSecret = this._serverCaSecret;
    }
    if (this._serverTlsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverTlsSecret = this._serverTlsSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecCertificates | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCaSecret = undefined;
      this._replicationTlsSecret = undefined;
      this._serverAltDnsNames = undefined;
      this._serverCaSecret = undefined;
      this._serverTlsSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCaSecret = value.clientCaSecret;
      this._replicationTlsSecret = value.replicationTlsSecret;
      this._serverAltDnsNames = value.serverAltDnsNames;
      this._serverCaSecret = value.serverCaSecret;
      this._serverTlsSecret = value.serverTlsSecret;
    }
  }

  // client_ca_secret - computed: false, optional: true, required: false
  private _clientCaSecret?: string; 
  public get clientCaSecret() {
    return this.getStringAttribute('client_ca_secret');
  }
  public set clientCaSecret(value: string) {
    this._clientCaSecret = value;
  }
  public resetClientCaSecret() {
    this._clientCaSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCaSecretInput() {
    return this._clientCaSecret;
  }

  // replication_tls_secret - computed: false, optional: true, required: false
  private _replicationTlsSecret?: string; 
  public get replicationTlsSecret() {
    return this.getStringAttribute('replication_tls_secret');
  }
  public set replicationTlsSecret(value: string) {
    this._replicationTlsSecret = value;
  }
  public resetReplicationTlsSecret() {
    this._replicationTlsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicationTlsSecretInput() {
    return this._replicationTlsSecret;
  }

  // server_alt_dns_names - computed: false, optional: true, required: false
  private _serverAltDnsNames?: string[]; 
  public get serverAltDnsNames() {
    return this.getListAttribute('server_alt_dns_names');
  }
  public set serverAltDnsNames(value: string[]) {
    this._serverAltDnsNames = value;
  }
  public resetServerAltDnsNames() {
    this._serverAltDnsNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverAltDnsNamesInput() {
    return this._serverAltDnsNames;
  }

  // server_ca_secret - computed: false, optional: true, required: false
  private _serverCaSecret?: string; 
  public get serverCaSecret() {
    return this.getStringAttribute('server_ca_secret');
  }
  public set serverCaSecret(value: string) {
    this._serverCaSecret = value;
  }
  public resetServerCaSecret() {
    this._serverCaSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverCaSecretInput() {
    return this._serverCaSecret;
  }

  // server_tls_secret - computed: false, optional: true, required: false
  private _serverTlsSecret?: string; 
  public get serverTlsSecret() {
    return this.getStringAttribute('server_tls_secret');
  }
  public set serverTlsSecret(value: string) {
    this._serverTlsSecret = value;
  }
  public resetServerTlsSecret() {
    this._serverTlsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverTlsSecretInput() {
    return this._serverTlsSecret;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_version DataK8SPostgresqlCnpgIoClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#field_path DataK8SPostgresqlCnpgIoClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#container_name DataK8SPostgresqlCnpgIoClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#divisor DataK8SPostgresqlCnpgIoClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#resource DataK8SPostgresqlCnpgIoClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#config_map_key_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#field_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#resource_field_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_key_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#value DataK8SPostgresqlCnpgIoClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#value_from DataK8SPostgresqlCnpgIoClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFrom {
  /**
  * The ConfigMap to select from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#config_map_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef;
  /**
  * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#prefix DataK8SPostgresqlCnpgIoClusterV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * The Secret to select from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRefToTerraform(struct!.configMapRef),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    secret_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._prefix = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._prefix = value.prefix;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFrom[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEnvFromOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource {
  /**
  * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_group DataK8SPostgresqlCnpgIoClusterV1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind is the type of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#kind DataK8SPostgresqlCnpgIoClusterV1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name is the name of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef {
  /**
  * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_group DataK8SPostgresqlCnpgIoClusterV1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind is the type of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#kind DataK8SPostgresqlCnpgIoClusterV1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name is the name of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#namespace DataK8SPostgresqlCnpgIoClusterV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources {
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#limits DataK8SPostgresqlCnpgIoClusterV1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#requests DataK8SPostgresqlCnpgIoClusterV1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec {
  /**
  * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#access_modes DataK8SPostgresqlCnpgIoClusterV1Manifest#access_modes}
  */
  readonly accessModes?: string[];
  /**
  * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#data_source DataK8SPostgresqlCnpgIoClusterV1Manifest#data_source}
  */
  readonly dataSource?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource;
  /**
  * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#data_source_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#data_source_ref}
  */
  readonly dataSourceRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef;
  /**
  * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#resources DataK8SPostgresqlCnpgIoClusterV1Manifest#resources}
  */
  readonly resources?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources;
  /**
  * selector is a label query over volumes to consider for binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#selector DataK8SPostgresqlCnpgIoClusterV1Manifest#selector}
  */
  readonly selector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector;
  /**
  * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_class_name DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_class_name}
  */
  readonly storageClassName?: string;
  /**
  * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it's not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/ (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#volume_attributes_class_name DataK8SPostgresqlCnpgIoClusterV1Manifest#volume_attributes_class_name}
  */
  readonly volumeAttributesClassName?: string;
  /**
  * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#volume_mode DataK8SPostgresqlCnpgIoClusterV1Manifest#volume_mode}
  */
  readonly volumeMode?: string;
  /**
  * volumeName is the binding reference to the PersistentVolume backing this claim.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#volume_name DataK8SPostgresqlCnpgIoClusterV1Manifest#volume_name}
  */
  readonly volumeName?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_modes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessModes),
    data_source: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceToTerraform(struct!.dataSource),
    data_source_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRefToTerraform(struct!.dataSourceRef),
    resources: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesToTerraform(struct!.resources),
    selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorToTerraform(struct!.selector),
    storage_class_name: cdktf.stringToTerraform(struct!.storageClassName),
    volume_attributes_class_name: cdktf.stringToTerraform(struct!.volumeAttributesClassName),
    volume_mode: cdktf.stringToTerraform(struct!.volumeMode),
    volume_name: cdktf.stringToTerraform(struct!.volumeName),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_modes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessModes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    data_source: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceToHclTerraform(struct!.dataSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource",
    },
    data_source_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRefToHclTerraform(struct!.dataSourceRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef",
    },
    resources: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources",
    },
    selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector",
    },
    storage_class_name: {
      value: cdktf.stringToHclTerraform(struct!.storageClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_attributes_class_name: {
      value: cdktf.stringToHclTerraform(struct!.volumeAttributesClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_mode: {
      value: cdktf.stringToHclTerraform(struct!.volumeMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_name: {
      value: cdktf.stringToHclTerraform(struct!.volumeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessModes !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessModes = this._accessModes;
    }
    if (this._dataSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataSource = this._dataSource?.internalValue;
    }
    if (this._dataSourceRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataSourceRef = this._dataSourceRef?.internalValue;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    if (this._storageClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClassName = this._storageClassName;
    }
    if (this._volumeAttributesClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeAttributesClassName = this._volumeAttributesClassName;
    }
    if (this._volumeMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeMode = this._volumeMode;
    }
    if (this._volumeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeName = this._volumeName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessModes = undefined;
      this._dataSource.internalValue = undefined;
      this._dataSourceRef.internalValue = undefined;
      this._resources.internalValue = undefined;
      this._selector.internalValue = undefined;
      this._storageClassName = undefined;
      this._volumeAttributesClassName = undefined;
      this._volumeMode = undefined;
      this._volumeName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessModes = value.accessModes;
      this._dataSource.internalValue = value.dataSource;
      this._dataSourceRef.internalValue = value.dataSourceRef;
      this._resources.internalValue = value.resources;
      this._selector.internalValue = value.selector;
      this._storageClassName = value.storageClassName;
      this._volumeAttributesClassName = value.volumeAttributesClassName;
      this._volumeMode = value.volumeMode;
      this._volumeName = value.volumeName;
    }
  }

  // access_modes - computed: false, optional: true, required: false
  private _accessModes?: string[]; 
  public get accessModes() {
    return this.getListAttribute('access_modes');
  }
  public set accessModes(value: string[]) {
    this._accessModes = value;
  }
  public resetAccessModes() {
    this._accessModes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessModesInput() {
    return this._accessModes;
  }

  // data_source - computed: false, optional: true, required: false
  private _dataSource = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceOutputReference(this, "data_source");
  public get dataSource() {
    return this._dataSource;
  }
  public putDataSource(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSource) {
    this._dataSource.internalValue = value;
  }
  public resetDataSource() {
    this._dataSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataSourceInput() {
    return this._dataSource.internalValue;
  }

  // data_source_ref - computed: false, optional: true, required: false
  private _dataSourceRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRefOutputReference(this, "data_source_ref");
  public get dataSourceRef() {
    return this._dataSourceRef;
  }
  public putDataSourceRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecDataSourceRef) {
    this._dataSourceRef.internalValue = value;
  }
  public resetDataSourceRef() {
    this._dataSourceRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataSourceRefInput() {
    return this._dataSourceRef.internalValue;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }

  // storage_class_name - computed: false, optional: true, required: false
  private _storageClassName?: string; 
  public get storageClassName() {
    return this.getStringAttribute('storage_class_name');
  }
  public set storageClassName(value: string) {
    this._storageClassName = value;
  }
  public resetStorageClassName() {
    this._storageClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassNameInput() {
    return this._storageClassName;
  }

  // volume_attributes_class_name - computed: false, optional: true, required: false
  private _volumeAttributesClassName?: string; 
  public get volumeAttributesClassName() {
    return this.getStringAttribute('volume_attributes_class_name');
  }
  public set volumeAttributesClassName(value: string) {
    this._volumeAttributesClassName = value;
  }
  public resetVolumeAttributesClassName() {
    this._volumeAttributesClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeAttributesClassNameInput() {
    return this._volumeAttributesClassName;
  }

  // volume_mode - computed: false, optional: true, required: false
  private _volumeMode?: string; 
  public get volumeMode() {
    return this.getStringAttribute('volume_mode');
  }
  public set volumeMode(value: string) {
    this._volumeMode = value;
  }
  public resetVolumeMode() {
    this._volumeMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeModeInput() {
    return this._volumeMode;
  }

  // volume_name - computed: false, optional: true, required: false
  private _volumeName?: string; 
  public get volumeName() {
    return this.getStringAttribute('volume_name');
  }
  public set volumeName(value: string) {
    this._volumeName = value;
  }
  public resetVolumeName() {
    this._volumeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeNameInput() {
    return this._volumeName;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate {
  /**
  * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#metadata DataK8SPostgresqlCnpgIoClusterV1Manifest#metadata}
  */
  readonly metadata?: { [key: string]: string };
  /**
  * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#spec DataK8SPostgresqlCnpgIoClusterV1Manifest#spec}
  */
  readonly spec: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.metadata),
    spec: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecToTerraform(struct!.spec),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.metadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    spec: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata?: { [key: string]: string }; 
  public get metadata() {
    return this.getStringMapAttribute('metadata');
  }
  public set metadata(value: { [key: string]: string }) {
    this._metadata = value;
  }
  public resetMetadata() {
    this._metadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata;
  }

  // spec - computed: false, optional: false, required: true
  private _spec = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateSpec) {
    this._spec.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSource {
  /**
  * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod. The name of the PVC will be '<pod name>-<volume name>' where '<volume name>' is the name from the 'PodSpec.Volumes' array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long). An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster. This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created. Required, must not be nil.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#volume_claim_template DataK8SPostgresqlCnpgIoClusterV1Manifest#volume_claim_template}
  */
  readonly volumeClaimTemplate?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    volume_claim_template: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateToTerraform(struct!.volumeClaimTemplate),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    volume_claim_template: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateToHclTerraform(struct!.volumeClaimTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._volumeClaimTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeClaimTemplate = this._volumeClaimTemplate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._volumeClaimTemplate.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._volumeClaimTemplate.internalValue = value.volumeClaimTemplate;
    }
  }

  // volume_claim_template - computed: false, optional: true, required: false
  private _volumeClaimTemplate = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplateOutputReference(this, "volume_claim_template");
  public get volumeClaimTemplate() {
    return this._volumeClaimTemplate;
  }
  public putVolumeClaimTemplate(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumeSourceVolumeClaimTemplate) {
    this._volumeClaimTemplate.internalValue = value;
  }
  public resetVolumeClaimTemplate() {
    this._volumeClaimTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeClaimTemplateInput() {
    return this._volumeClaimTemplate.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimit {
  /**
  * Shm is the size limit of the shared memory volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#shm DataK8SPostgresqlCnpgIoClusterV1Manifest#shm}
  */
  readonly shm?: string;
  /**
  * TemporaryData is the size limit of the temporary data volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#temporary_data DataK8SPostgresqlCnpgIoClusterV1Manifest#temporary_data}
  */
  readonly temporaryData?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimitToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    shm: cdktf.stringToTerraform(struct!.shm),
    temporary_data: cdktf.stringToTerraform(struct!.temporaryData),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimitToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    shm: {
      value: cdktf.stringToHclTerraform(struct!.shm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    temporary_data: {
      value: cdktf.stringToHclTerraform(struct!.temporaryData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._shm !== undefined) {
      hasAnyValues = true;
      internalValueResult.shm = this._shm;
    }
    if (this._temporaryData !== undefined) {
      hasAnyValues = true;
      internalValueResult.temporaryData = this._temporaryData;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecEphemeralVolumesSizeLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._shm = undefined;
      this._temporaryData = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._shm = value.shm;
      this._temporaryData = value.temporaryData;
    }
  }

  // shm - computed: false, optional: true, required: false
  private _shm?: string; 
  public get shm() {
    return this.getStringAttribute('shm');
  }
  public set shm(value: string) {
    this._shm = value;
  }
  public resetShm() {
    this._shm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shmInput() {
    return this._shm;
  }

  // temporary_data - computed: false, optional: true, required: false
  private _temporaryData?: string; 
  public get temporaryData() {
    return this.getStringAttribute('temporary_data');
  }
  public set temporaryData(value: string) {
    this._temporaryData = value;
  }
  public resetTemporaryData() {
    this._temporaryData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get temporaryDataInput() {
    return this._temporaryData;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionStringToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionStringToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionStringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccountToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccountToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKeyToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKeyToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasTokenToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasTokenToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials {
  /**
  * The connection string to be used
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#connection_string DataK8SPostgresqlCnpgIoClusterV1Manifest#connection_string}
  */
  readonly connectionString?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString;
  /**
  * Use the Azure AD based authentication without providing explicitly the keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#inherit_from_azure_ad DataK8SPostgresqlCnpgIoClusterV1Manifest#inherit_from_azure_ad}
  */
  readonly inheritFromAzureAd?: boolean | cdktf.IResolvable;
  /**
  * The storage account where to upload data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_account DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_account}
  */
  readonly storageAccount?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount;
  /**
  * The storage account key to be used in conjunction with the storage account name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_key DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_key}
  */
  readonly storageKey?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey;
  /**
  * A shared-access-signature to be used in conjunction with the storage account name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#storage_sas_token DataK8SPostgresqlCnpgIoClusterV1Manifest#storage_sas_token}
  */
  readonly storageSasToken?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_string: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionStringToTerraform(struct!.connectionString),
    inherit_from_azure_ad: cdktf.booleanToTerraform(struct!.inheritFromAzureAd),
    storage_account: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccountToTerraform(struct!.storageAccount),
    storage_key: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKeyToTerraform(struct!.storageKey),
    storage_sas_token: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasTokenToTerraform(struct!.storageSasToken),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_string: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionStringToHclTerraform(struct!.connectionString),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString",
    },
    inherit_from_azure_ad: {
      value: cdktf.booleanToHclTerraform(struct!.inheritFromAzureAd),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    storage_account: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccountToHclTerraform(struct!.storageAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount",
    },
    storage_key: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKeyToHclTerraform(struct!.storageKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey",
    },
    storage_sas_token: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasTokenToHclTerraform(struct!.storageSasToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionString?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString?.internalValue;
    }
    if (this._inheritFromAzureAd !== undefined) {
      hasAnyValues = true;
      internalValueResult.inheritFromAzureAd = this._inheritFromAzureAd;
    }
    if (this._storageAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageAccount = this._storageAccount?.internalValue;
    }
    if (this._storageKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageKey = this._storageKey?.internalValue;
    }
    if (this._storageSasToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageSasToken = this._storageSasToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionString.internalValue = undefined;
      this._inheritFromAzureAd = undefined;
      this._storageAccount.internalValue = undefined;
      this._storageKey.internalValue = undefined;
      this._storageSasToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionString.internalValue = value.connectionString;
      this._inheritFromAzureAd = value.inheritFromAzureAd;
      this._storageAccount.internalValue = value.storageAccount;
      this._storageKey.internalValue = value.storageKey;
      this._storageSasToken.internalValue = value.storageSasToken;
    }
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionStringOutputReference(this, "connection_string");
  public get connectionString() {
    return this._connectionString;
  }
  public putConnectionString(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsConnectionString) {
    this._connectionString.internalValue = value;
  }
  public resetConnectionString() {
    this._connectionString.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString.internalValue;
  }

  // inherit_from_azure_ad - computed: false, optional: true, required: false
  private _inheritFromAzureAd?: boolean | cdktf.IResolvable; 
  public get inheritFromAzureAd() {
    return this.getBooleanAttribute('inherit_from_azure_ad');
  }
  public set inheritFromAzureAd(value: boolean | cdktf.IResolvable) {
    this._inheritFromAzureAd = value;
  }
  public resetInheritFromAzureAd() {
    this._inheritFromAzureAd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritFromAzureAdInput() {
    return this._inheritFromAzureAd;
  }

  // storage_account - computed: false, optional: true, required: false
  private _storageAccount = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccountOutputReference(this, "storage_account");
  public get storageAccount() {
    return this._storageAccount;
  }
  public putStorageAccount(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageAccount) {
    this._storageAccount.internalValue = value;
  }
  public resetStorageAccount() {
    this._storageAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageAccountInput() {
    return this._storageAccount.internalValue;
  }

  // storage_key - computed: false, optional: true, required: false
  private _storageKey = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKeyOutputReference(this, "storage_key");
  public get storageKey() {
    return this._storageKey;
  }
  public putStorageKey(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageKey) {
    this._storageKey.internalValue = value;
  }
  public resetStorageKey() {
    this._storageKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageKeyInput() {
    return this._storageKey.internalValue;
  }

  // storage_sas_token - computed: false, optional: true, required: false
  private _storageSasToken = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasTokenOutputReference(this, "storage_sas_token");
  public get storageSasToken() {
    return this._storageSasToken;
  }
  public putStorageSasToken(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsStorageSasToken) {
    this._storageSasToken.internalValue = value;
  }
  public resetStorageSasToken() {
    this._storageSasToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageSasTokenInput() {
    return this._storageSasToken.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData {
  /**
  * AdditionalCommandArgs represents additional arguments that can be appended to the 'barman-cloud-backup' command-line invocation. These arguments provide flexibility to customize the backup process further according to specific requirements or configurations. Example: In a scenario where specialized backup options are required, such as setting a specific timeout or defining custom behavior, users can use this field to specify additional command arguments. Note: It's essential to ensure that the provided arguments are valid and supported by the 'barman-cloud-backup' command, to avoid potential errors or unintended behavior during execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#additional_command_args DataK8SPostgresqlCnpgIoClusterV1Manifest#additional_command_args}
  */
  readonly additionalCommandArgs?: string[];
  /**
  * Compress a backup file (a tar file per tablespace) while streaming it to the object store. Available options are empty string (no compression, default), 'gzip', 'bzip2' or 'snappy'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#compression DataK8SPostgresqlCnpgIoClusterV1Manifest#compression}
  */
  readonly compression?: string;
  /**
  * Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), 'AES256' and 'aws:kms'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#encryption DataK8SPostgresqlCnpgIoClusterV1Manifest#encryption}
  */
  readonly encryption?: string;
  /**
  * Control whether the I/O workload for the backup initial checkpoint will be limited, according to the 'checkpoint_completion_target' setting on the PostgreSQL server. If set to true, an immediate checkpoint will be used, meaning PostgreSQL will complete the checkpoint as soon as possible. 'false' by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#immediate_checkpoint DataK8SPostgresqlCnpgIoClusterV1Manifest#immediate_checkpoint}
  */
  readonly immediateCheckpoint?: boolean | cdktf.IResolvable;
  /**
  * The number of parallel jobs to be used to upload the backup, defaults to 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#jobs DataK8SPostgresqlCnpgIoClusterV1Manifest#jobs}
  */
  readonly jobs?: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreDataToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_command_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalCommandArgs),
    compression: cdktf.stringToTerraform(struct!.compression),
    encryption: cdktf.stringToTerraform(struct!.encryption),
    immediate_checkpoint: cdktf.booleanToTerraform(struct!.immediateCheckpoint),
    jobs: cdktf.numberToTerraform(struct!.jobs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreDataToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_command_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalCommandArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encryption: {
      value: cdktf.stringToHclTerraform(struct!.encryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    immediate_checkpoint: {
      value: cdktf.booleanToHclTerraform(struct!.immediateCheckpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jobs: {
      value: cdktf.numberToHclTerraform(struct!.jobs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalCommandArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalCommandArgs = this._additionalCommandArgs;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._encryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption;
    }
    if (this._immediateCheckpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.immediateCheckpoint = this._immediateCheckpoint;
    }
    if (this._jobs !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobs = this._jobs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalCommandArgs = undefined;
      this._compression = undefined;
      this._encryption = undefined;
      this._immediateCheckpoint = undefined;
      this._jobs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalCommandArgs = value.additionalCommandArgs;
      this._compression = value.compression;
      this._encryption = value.encryption;
      this._immediateCheckpoint = value.immediateCheckpoint;
      this._jobs = value.jobs;
    }
  }

  // additional_command_args - computed: false, optional: true, required: false
  private _additionalCommandArgs?: string[]; 
  public get additionalCommandArgs() {
    return this.getListAttribute('additional_command_args');
  }
  public set additionalCommandArgs(value: string[]) {
    this._additionalCommandArgs = value;
  }
  public resetAdditionalCommandArgs() {
    this._additionalCommandArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalCommandArgsInput() {
    return this._additionalCommandArgs;
  }

  // compression - computed: false, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption?: string; 
  public get encryption() {
    return this.getStringAttribute('encryption');
  }
  public set encryption(value: string) {
    this._encryption = value;
  }
  public resetEncryption() {
    this._encryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption;
  }

  // immediate_checkpoint - computed: false, optional: true, required: false
  private _immediateCheckpoint?: boolean | cdktf.IResolvable; 
  public get immediateCheckpoint() {
    return this.getBooleanAttribute('immediate_checkpoint');
  }
  public set immediateCheckpoint(value: boolean | cdktf.IResolvable) {
    this._immediateCheckpoint = value;
  }
  public resetImmediateCheckpoint() {
    this._immediateCheckpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get immediateCheckpointInput() {
    return this._immediateCheckpoint;
  }

  // jobs - computed: false, optional: true, required: false
  private _jobs?: number; 
  public get jobs() {
    return this.getNumberAttribute('jobs');
  }
  public set jobs(value: number) {
    this._jobs = value;
  }
  public resetJobs() {
    this._jobs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobsInput() {
    return this._jobs;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCaToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCaToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials {
  /**
  * The secret containing the Google Cloud Storage JSON file with the credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#application_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#application_credentials}
  */
  readonly applicationCredentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials;
  /**
  * If set to true, will presume that it's running inside a GKE environment, default to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#gke_environment DataK8SPostgresqlCnpgIoClusterV1Manifest#gke_environment}
  */
  readonly gkeEnvironment?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    application_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentialsToTerraform(struct!.applicationCredentials),
    gke_environment: cdktf.booleanToTerraform(struct!.gkeEnvironment),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    application_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentialsToHclTerraform(struct!.applicationCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials",
    },
    gke_environment: {
      value: cdktf.booleanToHclTerraform(struct!.gkeEnvironment),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applicationCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.applicationCredentials = this._applicationCredentials?.internalValue;
    }
    if (this._gkeEnvironment !== undefined) {
      hasAnyValues = true;
      internalValueResult.gkeEnvironment = this._gkeEnvironment;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._applicationCredentials.internalValue = undefined;
      this._gkeEnvironment = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._applicationCredentials.internalValue = value.applicationCredentials;
      this._gkeEnvironment = value.gkeEnvironment;
    }
  }

  // application_credentials - computed: false, optional: true, required: false
  private _applicationCredentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentialsOutputReference(this, "application_credentials");
  public get applicationCredentials() {
    return this._applicationCredentials;
  }
  public putApplicationCredentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsApplicationCredentials) {
    this._applicationCredentials.internalValue = value;
  }
  public resetApplicationCredentials() {
    this._applicationCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationCredentialsInput() {
    return this._applicationCredentials.internalValue;
  }

  // gke_environment - computed: false, optional: true, required: false
  private _gkeEnvironment?: boolean | cdktf.IResolvable; 
  public get gkeEnvironment() {
    return this.getBooleanAttribute('gke_environment');
  }
  public set gkeEnvironment(value: boolean | cdktf.IResolvable) {
    this._gkeEnvironment = value;
  }
  public resetGkeEnvironment() {
    this._gkeEnvironment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gkeEnvironmentInput() {
    return this._gkeEnvironment;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyIdToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyIdToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegionToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegionToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKeyToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKeyToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionTokenToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionTokenToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials {
  /**
  * The reference to the access key id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#access_key_id DataK8SPostgresqlCnpgIoClusterV1Manifest#access_key_id}
  */
  readonly accessKeyId?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId;
  /**
  * Use the role based authentication without providing explicitly the keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#inherit_from_iam_role DataK8SPostgresqlCnpgIoClusterV1Manifest#inherit_from_iam_role}
  */
  readonly inheritFromIamRole?: boolean | cdktf.IResolvable;
  /**
  * The reference to the secret containing the region name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#region DataK8SPostgresqlCnpgIoClusterV1Manifest#region}
  */
  readonly region?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion;
  /**
  * The reference to the secret access key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#secret_access_key DataK8SPostgresqlCnpgIoClusterV1Manifest#secret_access_key}
  */
  readonly secretAccessKey?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey;
  /**
  * The references to the session key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#session_token DataK8SPostgresqlCnpgIoClusterV1Manifest#session_token}
  */
  readonly sessionToken?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyIdToTerraform(struct!.accessKeyId),
    inherit_from_iam_role: cdktf.booleanToTerraform(struct!.inheritFromIamRole),
    region: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegionToTerraform(struct!.region),
    secret_access_key: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKeyToTerraform(struct!.secretAccessKey),
    session_token: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionTokenToTerraform(struct!.sessionToken),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyIdToHclTerraform(struct!.accessKeyId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId",
    },
    inherit_from_iam_role: {
      value: cdktf.booleanToHclTerraform(struct!.inheritFromIamRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegionToHclTerraform(struct!.region),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion",
    },
    secret_access_key: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKeyToHclTerraform(struct!.secretAccessKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey",
    },
    session_token: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionTokenToHclTerraform(struct!.sessionToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyId = this._accessKeyId?.internalValue;
    }
    if (this._inheritFromIamRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.inheritFromIamRole = this._inheritFromIamRole;
    }
    if (this._region?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region?.internalValue;
    }
    if (this._secretAccessKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey?.internalValue;
    }
    if (this._sessionToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionToken = this._sessionToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyId.internalValue = undefined;
      this._inheritFromIamRole = undefined;
      this._region.internalValue = undefined;
      this._secretAccessKey.internalValue = undefined;
      this._sessionToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyId.internalValue = value.accessKeyId;
      this._inheritFromIamRole = value.inheritFromIamRole;
      this._region.internalValue = value.region;
      this._secretAccessKey.internalValue = value.secretAccessKey;
      this._sessionToken.internalValue = value.sessionToken;
    }
  }

  // access_key_id - computed: false, optional: true, required: false
  private _accessKeyId = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyIdOutputReference(this, "access_key_id");
  public get accessKeyId() {
    return this._accessKeyId;
  }
  public putAccessKeyId(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsAccessKeyId) {
    this._accessKeyId.internalValue = value;
  }
  public resetAccessKeyId() {
    this._accessKeyId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdInput() {
    return this._accessKeyId.internalValue;
  }

  // inherit_from_iam_role - computed: false, optional: true, required: false
  private _inheritFromIamRole?: boolean | cdktf.IResolvable; 
  public get inheritFromIamRole() {
    return this.getBooleanAttribute('inherit_from_iam_role');
  }
  public set inheritFromIamRole(value: boolean | cdktf.IResolvable) {
    this._inheritFromIamRole = value;
  }
  public resetInheritFromIamRole() {
    this._inheritFromIamRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritFromIamRoleInput() {
    return this._inheritFromIamRole;
  }

  // region - computed: false, optional: true, required: false
  private _region = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegionOutputReference(this, "region");
  public get region() {
    return this._region;
  }
  public putRegion(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsRegion) {
    this._region.internalValue = value;
  }
  public resetRegion() {
    this._region.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region.internalValue;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKeyOutputReference(this, "secret_access_key");
  public get secretAccessKey() {
    return this._secretAccessKey;
  }
  public putSecretAccessKey(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSecretAccessKey) {
    this._secretAccessKey.internalValue = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey.internalValue;
  }

  // session_token - computed: false, optional: true, required: false
  private _sessionToken = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionTokenOutputReference(this, "session_token");
  public get sessionToken() {
    return this._sessionToken;
  }
  public putSessionToken(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsSessionToken) {
    this._sessionToken.internalValue = value;
  }
  public resetSessionToken() {
    this._sessionToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTokenInput() {
    return this._sessionToken.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal {
  /**
  * Additional arguments that can be appended to the 'barman-cloud-wal-archive' command-line invocation. These arguments provide flexibility to customize the WAL archive process further, according to specific requirements or configurations. Example: In a scenario where specialized backup options are required, such as setting a specific timeout or defining custom behavior, users can use this field to specify additional command arguments. Note: It's essential to ensure that the provided arguments are valid and supported by the 'barman-cloud-wal-archive' command, to avoid potential errors or unintended behavior during execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#archive_additional_command_args DataK8SPostgresqlCnpgIoClusterV1Manifest#archive_additional_command_args}
  */
  readonly archiveAdditionalCommandArgs?: string[];
  /**
  * Compress a WAL file before sending it to the object store. Available options are empty string (no compression, default), 'gzip', 'bzip2' or 'snappy'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#compression DataK8SPostgresqlCnpgIoClusterV1Manifest#compression}
  */
  readonly compression?: string;
  /**
  * Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), 'AES256' and 'aws:kms'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#encryption DataK8SPostgresqlCnpgIoClusterV1Manifest#encryption}
  */
  readonly encryption?: string;
  /**
  * Number of WAL files to be either archived in parallel (when the PostgreSQL instance is archiving to a backup object store) or restored in parallel (when a PostgreSQL standby is fetching WAL files from a recovery object store). If not specified, WAL files will be processed one at a time. It accepts a positive integer as a value - with 1 being the minimum accepted value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#max_parallel DataK8SPostgresqlCnpgIoClusterV1Manifest#max_parallel}
  */
  readonly maxParallel?: number;
  /**
  * Additional arguments that can be appended to the 'barman-cloud-wal-restore' command-line invocation. These arguments provide flexibility to customize the WAL restore process further, according to specific requirements or configurations. Example: In a scenario where specialized backup options are required, such as setting a specific timeout or defining custom behavior, users can use this field to specify additional command arguments. Note: It's essential to ensure that the provided arguments are valid and supported by the 'barman-cloud-wal-restore' command, to avoid potential errors or unintended behavior during execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#restore_additional_command_args DataK8SPostgresqlCnpgIoClusterV1Manifest#restore_additional_command_args}
  */
  readonly restoreAdditionalCommandArgs?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWalToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    archive_additional_command_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.archiveAdditionalCommandArgs),
    compression: cdktf.stringToTerraform(struct!.compression),
    encryption: cdktf.stringToTerraform(struct!.encryption),
    max_parallel: cdktf.numberToTerraform(struct!.maxParallel),
    restore_additional_command_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.restoreAdditionalCommandArgs),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWalToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    archive_additional_command_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.archiveAdditionalCommandArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encryption: {
      value: cdktf.stringToHclTerraform(struct!.encryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_parallel: {
      value: cdktf.numberToHclTerraform(struct!.maxParallel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    restore_additional_command_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.restoreAdditionalCommandArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._archiveAdditionalCommandArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.archiveAdditionalCommandArgs = this._archiveAdditionalCommandArgs;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._encryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryption = this._encryption;
    }
    if (this._maxParallel !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxParallel = this._maxParallel;
    }
    if (this._restoreAdditionalCommandArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.restoreAdditionalCommandArgs = this._restoreAdditionalCommandArgs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._archiveAdditionalCommandArgs = undefined;
      this._compression = undefined;
      this._encryption = undefined;
      this._maxParallel = undefined;
      this._restoreAdditionalCommandArgs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._archiveAdditionalCommandArgs = value.archiveAdditionalCommandArgs;
      this._compression = value.compression;
      this._encryption = value.encryption;
      this._maxParallel = value.maxParallel;
      this._restoreAdditionalCommandArgs = value.restoreAdditionalCommandArgs;
    }
  }

  // archive_additional_command_args - computed: false, optional: true, required: false
  private _archiveAdditionalCommandArgs?: string[]; 
  public get archiveAdditionalCommandArgs() {
    return this.getListAttribute('archive_additional_command_args');
  }
  public set archiveAdditionalCommandArgs(value: string[]) {
    this._archiveAdditionalCommandArgs = value;
  }
  public resetArchiveAdditionalCommandArgs() {
    this._archiveAdditionalCommandArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get archiveAdditionalCommandArgsInput() {
    return this._archiveAdditionalCommandArgs;
  }

  // compression - computed: false, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // encryption - computed: false, optional: true, required: false
  private _encryption?: string; 
  public get encryption() {
    return this.getStringAttribute('encryption');
  }
  public set encryption(value: string) {
    this._encryption = value;
  }
  public resetEncryption() {
    this._encryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionInput() {
    return this._encryption;
  }

  // max_parallel - computed: false, optional: true, required: false
  private _maxParallel?: number; 
  public get maxParallel() {
    return this.getNumberAttribute('max_parallel');
  }
  public set maxParallel(value: number) {
    this._maxParallel = value;
  }
  public resetMaxParallel() {
    this._maxParallel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxParallelInput() {
    return this._maxParallel;
  }

  // restore_additional_command_args - computed: false, optional: true, required: false
  private _restoreAdditionalCommandArgs?: string[]; 
  public get restoreAdditionalCommandArgs() {
    return this.getListAttribute('restore_additional_command_args');
  }
  public set restoreAdditionalCommandArgs(value: string[]) {
    this._restoreAdditionalCommandArgs = value;
  }
  public resetRestoreAdditionalCommandArgs() {
    this._restoreAdditionalCommandArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restoreAdditionalCommandArgsInput() {
    return this._restoreAdditionalCommandArgs;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore {
  /**
  * The credentials to use to upload data to Azure Blob Storage
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#azure_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#azure_credentials}
  */
  readonly azureCredentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials;
  /**
  * The configuration to be used to backup the data files When not defined, base backups files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#data DataK8SPostgresqlCnpgIoClusterV1Manifest#data}
  */
  readonly data?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData;
  /**
  * The path where to store the backup (i.e. s3://bucket/path/to/folder) this path, with different destination folders, will be used for WALs and for data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#destination_path DataK8SPostgresqlCnpgIoClusterV1Manifest#destination_path}
  */
  readonly destinationPath: string;
  /**
  * EndpointCA store the CA bundle of the barman endpoint. Useful when using self-signed certificates to avoid errors with certificate issuer and barman-cloud-wal-archive
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#endpoint_ca DataK8SPostgresqlCnpgIoClusterV1Manifest#endpoint_ca}
  */
  readonly endpointCa?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa;
  /**
  * Endpoint to be used to upload data to the cloud, overriding the automatic endpoint discovery
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#endpoint_url DataK8SPostgresqlCnpgIoClusterV1Manifest#endpoint_url}
  */
  readonly endpointUrl?: string;
  /**
  * The credentials to use to upload data to Google Cloud Storage
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#google_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#google_credentials}
  */
  readonly googleCredentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials;
  /**
  * HistoryTags is a list of key value pairs that will be passed to the Barman --history-tags option.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#history_tags DataK8SPostgresqlCnpgIoClusterV1Manifest#history_tags}
  */
  readonly historyTags?: { [key: string]: string };
  /**
  * The credentials to use to upload data to S3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#s3_credentials DataK8SPostgresqlCnpgIoClusterV1Manifest#s3_credentials}
  */
  readonly s3Credentials?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials;
  /**
  * The server name on S3, the cluster name is used if this parameter is omitted
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#server_name DataK8SPostgresqlCnpgIoClusterV1Manifest#server_name}
  */
  readonly serverName?: string;
  /**
  * Tags is a list of key value pairs that will be passed to the Barman --tags option.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tags DataK8SPostgresqlCnpgIoClusterV1Manifest#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The configuration for the backup of the WAL stream. When not defined, WAL files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#wal DataK8SPostgresqlCnpgIoClusterV1Manifest#wal}
  */
  readonly wal?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsToTerraform(struct!.azureCredentials),
    data: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreDataToTerraform(struct!.data),
    destination_path: cdktf.stringToTerraform(struct!.destinationPath),
    endpoint_ca: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCaToTerraform(struct!.endpointCa),
    endpoint_url: cdktf.stringToTerraform(struct!.endpointUrl),
    google_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsToTerraform(struct!.googleCredentials),
    history_tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.historyTags),
    s3_credentials: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsToTerraform(struct!.s3Credentials),
    server_name: cdktf.stringToTerraform(struct!.serverName),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    wal: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWalToTerraform(struct!.wal),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsToHclTerraform(struct!.azureCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials",
    },
    data: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreDataToHclTerraform(struct!.data),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData",
    },
    destination_path: {
      value: cdktf.stringToHclTerraform(struct!.destinationPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_ca: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCaToHclTerraform(struct!.endpointCa),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa",
    },
    endpoint_url: {
      value: cdktf.stringToHclTerraform(struct!.endpointUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    google_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsToHclTerraform(struct!.googleCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials",
    },
    history_tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.historyTags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    s3_credentials: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsToHclTerraform(struct!.s3Credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    wal: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWalToHclTerraform(struct!.wal),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azureCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureCredentials = this._azureCredentials?.internalValue;
    }
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._destinationPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationPath = this._destinationPath;
    }
    if (this._endpointCa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointCa = this._endpointCa?.internalValue;
    }
    if (this._endpointUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointUrl = this._endpointUrl;
    }
    if (this._googleCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleCredentials = this._googleCredentials?.internalValue;
    }
    if (this._historyTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.historyTags = this._historyTags;
    }
    if (this._s3Credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3Credentials = this._s3Credentials?.internalValue;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._wal?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wal = this._wal?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azureCredentials.internalValue = undefined;
      this._data.internalValue = undefined;
      this._destinationPath = undefined;
      this._endpointCa.internalValue = undefined;
      this._endpointUrl = undefined;
      this._googleCredentials.internalValue = undefined;
      this._historyTags = undefined;
      this._s3Credentials.internalValue = undefined;
      this._serverName = undefined;
      this._tags = undefined;
      this._wal.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azureCredentials.internalValue = value.azureCredentials;
      this._data.internalValue = value.data;
      this._destinationPath = value.destinationPath;
      this._endpointCa.internalValue = value.endpointCa;
      this._endpointUrl = value.endpointUrl;
      this._googleCredentials.internalValue = value.googleCredentials;
      this._historyTags = value.historyTags;
      this._s3Credentials.internalValue = value.s3Credentials;
      this._serverName = value.serverName;
      this._tags = value.tags;
      this._wal.internalValue = value.wal;
    }
  }

  // azure_credentials - computed: false, optional: true, required: false
  private _azureCredentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentialsOutputReference(this, "azure_credentials");
  public get azureCredentials() {
    return this._azureCredentials;
  }
  public putAzureCredentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreAzureCredentials) {
    this._azureCredentials.internalValue = value;
  }
  public resetAzureCredentials() {
    this._azureCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCredentialsInput() {
    return this._azureCredentials.internalValue;
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreDataOutputReference(this, "data");
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreData) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // destination_path - computed: false, optional: false, required: true
  private _destinationPath?: string; 
  public get destinationPath() {
    return this.getStringAttribute('destination_path');
  }
  public set destinationPath(value: string) {
    this._destinationPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationPathInput() {
    return this._destinationPath;
  }

  // endpoint_ca - computed: false, optional: true, required: false
  private _endpointCa = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCaOutputReference(this, "endpoint_ca");
  public get endpointCa() {
    return this._endpointCa;
  }
  public putEndpointCa(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreEndpointCa) {
    this._endpointCa.internalValue = value;
  }
  public resetEndpointCa() {
    this._endpointCa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointCaInput() {
    return this._endpointCa.internalValue;
  }

  // endpoint_url - computed: false, optional: true, required: false
  private _endpointUrl?: string; 
  public get endpointUrl() {
    return this.getStringAttribute('endpoint_url');
  }
  public set endpointUrl(value: string) {
    this._endpointUrl = value;
  }
  public resetEndpointUrl() {
    this._endpointUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointUrlInput() {
    return this._endpointUrl;
  }

  // google_credentials - computed: false, optional: true, required: false
  private _googleCredentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentialsOutputReference(this, "google_credentials");
  public get googleCredentials() {
    return this._googleCredentials;
  }
  public putGoogleCredentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreGoogleCredentials) {
    this._googleCredentials.internalValue = value;
  }
  public resetGoogleCredentials() {
    this._googleCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleCredentialsInput() {
    return this._googleCredentials.internalValue;
  }

  // history_tags - computed: false, optional: true, required: false
  private _historyTags?: { [key: string]: string }; 
  public get historyTags() {
    return this.getStringMapAttribute('history_tags');
  }
  public set historyTags(value: { [key: string]: string }) {
    this._historyTags = value;
  }
  public resetHistoryTags() {
    this._historyTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get historyTagsInput() {
    return this._historyTags;
  }

  // s3_credentials - computed: false, optional: true, required: false
  private _s3Credentials = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3CredentialsOutputReference(this, "s3_credentials");
  public get s3Credentials() {
    return this._s3Credentials;
  }
  public putS3Credentials(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreS3Credentials) {
    this._s3Credentials.internalValue = value;
  }
  public resetS3Credentials() {
    this._s3Credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3CredentialsInput() {
    return this._s3Credentials.internalValue;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // wal - computed: false, optional: true, required: false
  private _wal = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWalOutputReference(this, "wal");
  public get wal() {
    return this._wal;
  }
  public putWal(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreWal) {
    this._wal.internalValue = value;
  }
  public resetWal() {
    this._wal.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get walInput() {
    return this._wal.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPasswordToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPasswordToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCertToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCertToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKeyToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKeyToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCertToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCertToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClusters {
  /**
  * The configuration for the barman-cloud tool suite
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#barman_object_store DataK8SPostgresqlCnpgIoClusterV1Manifest#barman_object_store}
  */
  readonly barmanObjectStore?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore;
  /**
  * The list of connection parameters, such as dbname, host, username, etc
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#connection_parameters DataK8SPostgresqlCnpgIoClusterV1Manifest#connection_parameters}
  */
  readonly connectionParameters?: { [key: string]: string };
  /**
  * The server name, required
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * The reference to the password to be used to connect to the server. If a password is provided, CloudNativePG creates a PostgreSQL passfile at '/controller/external/NAME/pass' (where 'NAME' is the cluster's name). This passfile is automatically referenced in the connection string when establishing a connection to the remote PostgreSQL server from the current PostgreSQL 'Cluster'. This ensures secure and efficient password management for external clusters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#password DataK8SPostgresqlCnpgIoClusterV1Manifest#password}
  */
  readonly password?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword;
  /**
  * The reference to an SSL certificate to be used to connect to this instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ssl_cert DataK8SPostgresqlCnpgIoClusterV1Manifest#ssl_cert}
  */
  readonly sslCert?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert;
  /**
  * The reference to an SSL private key to be used to connect to this instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ssl_key DataK8SPostgresqlCnpgIoClusterV1Manifest#ssl_key}
  */
  readonly sslKey?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey;
  /**
  * The reference to an SSL CA public key to be used to connect to this instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ssl_root_cert DataK8SPostgresqlCnpgIoClusterV1Manifest#ssl_root_cert}
  */
  readonly sslRootCert?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    barman_object_store: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreToTerraform(struct!.barmanObjectStore),
    connection_parameters: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectionParameters),
    name: cdktf.stringToTerraform(struct!.name),
    password: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPasswordToTerraform(struct!.password),
    ssl_cert: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCertToTerraform(struct!.sslCert),
    ssl_key: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKeyToTerraform(struct!.sslKey),
    ssl_root_cert: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCertToTerraform(struct!.sslRootCert),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    barman_object_store: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreToHclTerraform(struct!.barmanObjectStore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore",
    },
    connection_parameters: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectionParameters),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPasswordToHclTerraform(struct!.password),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword",
    },
    ssl_cert: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCertToHclTerraform(struct!.sslCert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert",
    },
    ssl_key: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKeyToHclTerraform(struct!.sslKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey",
    },
    ssl_root_cert: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCertToHclTerraform(struct!.sslRootCert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._barmanObjectStore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.barmanObjectStore = this._barmanObjectStore?.internalValue;
    }
    if (this._connectionParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionParameters = this._connectionParameters;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password?.internalValue;
    }
    if (this._sslCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslCert = this._sslCert?.internalValue;
    }
    if (this._sslKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslKey = this._sslKey?.internalValue;
    }
    if (this._sslRootCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslRootCert = this._sslRootCert?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._barmanObjectStore.internalValue = undefined;
      this._connectionParameters = undefined;
      this._name = undefined;
      this._password.internalValue = undefined;
      this._sslCert.internalValue = undefined;
      this._sslKey.internalValue = undefined;
      this._sslRootCert.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._barmanObjectStore.internalValue = value.barmanObjectStore;
      this._connectionParameters = value.connectionParameters;
      this._name = value.name;
      this._password.internalValue = value.password;
      this._sslCert.internalValue = value.sslCert;
      this._sslKey.internalValue = value.sslKey;
      this._sslRootCert.internalValue = value.sslRootCert;
    }
  }

  // barman_object_store - computed: false, optional: true, required: false
  private _barmanObjectStore = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStoreOutputReference(this, "barman_object_store");
  public get barmanObjectStore() {
    return this._barmanObjectStore;
  }
  public putBarmanObjectStore(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersBarmanObjectStore) {
    this._barmanObjectStore.internalValue = value;
  }
  public resetBarmanObjectStore() {
    this._barmanObjectStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get barmanObjectStoreInput() {
    return this._barmanObjectStore.internalValue;
  }

  // connection_parameters - computed: false, optional: true, required: false
  private _connectionParameters?: { [key: string]: string }; 
  public get connectionParameters() {
    return this.getStringMapAttribute('connection_parameters');
  }
  public set connectionParameters(value: { [key: string]: string }) {
    this._connectionParameters = value;
  }
  public resetConnectionParameters() {
    this._connectionParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionParametersInput() {
    return this._connectionParameters;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPasswordOutputReference(this, "password");
  public get password() {
    return this._password;
  }
  public putPassword(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersPassword) {
    this._password.internalValue = value;
  }
  public resetPassword() {
    this._password.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password.internalValue;
  }

  // ssl_cert - computed: false, optional: true, required: false
  private _sslCert = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCertOutputReference(this, "ssl_cert");
  public get sslCert() {
    return this._sslCert;
  }
  public putSslCert(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslCert) {
    this._sslCert.internalValue = value;
  }
  public resetSslCert() {
    this._sslCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslCertInput() {
    return this._sslCert.internalValue;
  }

  // ssl_key - computed: false, optional: true, required: false
  private _sslKey = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKeyOutputReference(this, "ssl_key");
  public get sslKey() {
    return this._sslKey;
  }
  public putSslKey(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslKey) {
    this._sslKey.internalValue = value;
  }
  public resetSslKey() {
    this._sslKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslKeyInput() {
    return this._sslKey.internalValue;
  }

  // ssl_root_cert - computed: false, optional: true, required: false
  private _sslRootCert = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCertOutputReference(this, "ssl_root_cert");
  public get sslRootCert() {
    return this._sslRootCert;
  }
  public putSslRootCert(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersSslRootCert) {
    this._sslRootCert.internalValue = value;
  }
  public resetSslRootCert() {
    this._sslRootCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslRootCertInput() {
    return this._sslRootCert.internalValue;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClusters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecExternalClustersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRef {
  /**
  * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_group DataK8SPostgresqlCnpgIoClusterV1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind is the type of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#kind DataK8SPostgresqlCnpgIoClusterV1Manifest#kind}
  */
  readonly kind: string;
  /**
  * The major version of PostgreSQL we want to use from the ImageCatalog
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#major DataK8SPostgresqlCnpgIoClusterV1Manifest#major}
  */
  readonly major: number;
  /**
  * Name is the name of resource being referenced
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    major: cdktf.numberToTerraform(struct!.major),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    major: {
      value: cdktf.numberToHclTerraform(struct!.major),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._major !== undefined) {
      hasAnyValues = true;
      internalValueResult.major = this._major;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImageCatalogRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._major = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._major = value.major;
      this._name = value.name;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // major - computed: false, optional: false, required: true
  private _major?: number; 
  public get major() {
    return this.getNumberAttribute('major');
  }
  public set major(value: number) {
    this._major = value;
  }
  // Temporarily expose input value. Use with caution.
  public get majorInput() {
    return this._major;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecrets {
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecretsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecretsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecretsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecImagePullSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#annotations DataK8SPostgresqlCnpgIoClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#labels DataK8SPostgresqlCnpgIoClusterV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadataToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadataToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecInheritedMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret {
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecretToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecretToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles {
  /**
  * Whether a role bypasses every row-level security (RLS) policy. Default is 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#bypassrls DataK8SPostgresqlCnpgIoClusterV1Manifest#bypassrls}
  */
  readonly bypassrls?: boolean | cdktf.IResolvable;
  /**
  * Description of the role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#comment DataK8SPostgresqlCnpgIoClusterV1Manifest#comment}
  */
  readonly comment?: string;
  /**
  * If the role can log in, this specifies how many concurrent connections the role can make. '-1' (the default) means no limit.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#connection_limit DataK8SPostgresqlCnpgIoClusterV1Manifest#connection_limit}
  */
  readonly connectionLimit?: number;
  /**
  * When set to 'true', the role being defined will be allowed to create new databases. Specifying 'false' (default) will deny a role the ability to create databases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#createdb DataK8SPostgresqlCnpgIoClusterV1Manifest#createdb}
  */
  readonly createdb?: boolean | cdktf.IResolvable;
  /**
  * Whether the role will be permitted to create, alter, drop, comment on, change the security label for, and grant or revoke membership in other roles. Default is 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#createrole DataK8SPostgresqlCnpgIoClusterV1Manifest#createrole}
  */
  readonly createrole?: boolean | cdktf.IResolvable;
  /**
  * DisablePassword indicates that a role's password should be set to NULL in Postgres
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#disable_password DataK8SPostgresqlCnpgIoClusterV1Manifest#disable_password}
  */
  readonly disablePassword?: boolean | cdktf.IResolvable;
  /**
  * Ensure the role is 'present' or 'absent' - defaults to 'present'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ensure DataK8SPostgresqlCnpgIoClusterV1Manifest#ensure}
  */
  readonly ensure?: string;
  /**
  * List of one or more existing roles to which this role will be immediately added as a new member. Default empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#in_roles DataK8SPostgresqlCnpgIoClusterV1Manifest#in_roles}
  */
  readonly inRoles?: string[];
  /**
  * Whether a role 'inherits' the privileges of roles it is a member of. Defaults is 'true'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#inherit DataK8SPostgresqlCnpgIoClusterV1Manifest#inherit}
  */
  readonly inherit?: boolean | cdktf.IResolvable;
  /**
  * Whether the role is allowed to log in. A role having the 'login' attribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. Default is 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#login DataK8SPostgresqlCnpgIoClusterV1Manifest#login}
  */
  readonly login?: boolean | cdktf.IResolvable;
  /**
  * Name of the role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Secret containing the password of the role (if present) If null, the password will be ignored unless DisablePassword is set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#password_secret DataK8SPostgresqlCnpgIoClusterV1Manifest#password_secret}
  */
  readonly passwordSecret?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret;
  /**
  * Whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the 'replication' attribute is a very highly privileged role, and should only be used on roles actually used for replication. Default is 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#replication DataK8SPostgresqlCnpgIoClusterV1Manifest#replication}
  */
  readonly replication?: boolean | cdktf.IResolvable;
  /**
  * Whether the role is a 'superuser' who can override all access restrictions within the database - superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. Defaults is 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#superuser DataK8SPostgresqlCnpgIoClusterV1Manifest#superuser}
  */
  readonly superuser?: boolean | cdktf.IResolvable;
  /**
  * Date and time after which the role's password is no longer valid. When omitted, the password will never expire (default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#valid_until DataK8SPostgresqlCnpgIoClusterV1Manifest#valid_until}
  */
  readonly validUntil?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bypassrls: cdktf.booleanToTerraform(struct!.bypassrls),
    comment: cdktf.stringToTerraform(struct!.comment),
    connection_limit: cdktf.numberToTerraform(struct!.connectionLimit),
    createdb: cdktf.booleanToTerraform(struct!.createdb),
    createrole: cdktf.booleanToTerraform(struct!.createrole),
    disable_password: cdktf.booleanToTerraform(struct!.disablePassword),
    ensure: cdktf.stringToTerraform(struct!.ensure),
    in_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.inRoles),
    inherit: cdktf.booleanToTerraform(struct!.inherit),
    login: cdktf.booleanToTerraform(struct!.login),
    name: cdktf.stringToTerraform(struct!.name),
    password_secret: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecretToTerraform(struct!.passwordSecret),
    replication: cdktf.booleanToTerraform(struct!.replication),
    superuser: cdktf.booleanToTerraform(struct!.superuser),
    valid_until: cdktf.stringToTerraform(struct!.validUntil),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bypassrls: {
      value: cdktf.booleanToHclTerraform(struct!.bypassrls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    comment: {
      value: cdktf.stringToHclTerraform(struct!.comment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_limit: {
      value: cdktf.numberToHclTerraform(struct!.connectionLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    createdb: {
      value: cdktf.booleanToHclTerraform(struct!.createdb),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    createrole: {
      value: cdktf.booleanToHclTerraform(struct!.createrole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_password: {
      value: cdktf.booleanToHclTerraform(struct!.disablePassword),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ensure: {
      value: cdktf.stringToHclTerraform(struct!.ensure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    in_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.inRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    inherit: {
      value: cdktf.booleanToHclTerraform(struct!.inherit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    login: {
      value: cdktf.booleanToHclTerraform(struct!.login),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password_secret: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecretToHclTerraform(struct!.passwordSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret",
    },
    replication: {
      value: cdktf.booleanToHclTerraform(struct!.replication),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    superuser: {
      value: cdktf.booleanToHclTerraform(struct!.superuser),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    valid_until: {
      value: cdktf.stringToHclTerraform(struct!.validUntil),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bypassrls !== undefined) {
      hasAnyValues = true;
      internalValueResult.bypassrls = this._bypassrls;
    }
    if (this._comment !== undefined) {
      hasAnyValues = true;
      internalValueResult.comment = this._comment;
    }
    if (this._connectionLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionLimit = this._connectionLimit;
    }
    if (this._createdb !== undefined) {
      hasAnyValues = true;
      internalValueResult.createdb = this._createdb;
    }
    if (this._createrole !== undefined) {
      hasAnyValues = true;
      internalValueResult.createrole = this._createrole;
    }
    if (this._disablePassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.disablePassword = this._disablePassword;
    }
    if (this._ensure !== undefined) {
      hasAnyValues = true;
      internalValueResult.ensure = this._ensure;
    }
    if (this._inRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.inRoles = this._inRoles;
    }
    if (this._inherit !== undefined) {
      hasAnyValues = true;
      internalValueResult.inherit = this._inherit;
    }
    if (this._login !== undefined) {
      hasAnyValues = true;
      internalValueResult.login = this._login;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._passwordSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecret = this._passwordSecret?.internalValue;
    }
    if (this._replication !== undefined) {
      hasAnyValues = true;
      internalValueResult.replication = this._replication;
    }
    if (this._superuser !== undefined) {
      hasAnyValues = true;
      internalValueResult.superuser = this._superuser;
    }
    if (this._validUntil !== undefined) {
      hasAnyValues = true;
      internalValueResult.validUntil = this._validUntil;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bypassrls = undefined;
      this._comment = undefined;
      this._connectionLimit = undefined;
      this._createdb = undefined;
      this._createrole = undefined;
      this._disablePassword = undefined;
      this._ensure = undefined;
      this._inRoles = undefined;
      this._inherit = undefined;
      this._login = undefined;
      this._name = undefined;
      this._passwordSecret.internalValue = undefined;
      this._replication = undefined;
      this._superuser = undefined;
      this._validUntil = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bypassrls = value.bypassrls;
      this._comment = value.comment;
      this._connectionLimit = value.connectionLimit;
      this._createdb = value.createdb;
      this._createrole = value.createrole;
      this._disablePassword = value.disablePassword;
      this._ensure = value.ensure;
      this._inRoles = value.inRoles;
      this._inherit = value.inherit;
      this._login = value.login;
      this._name = value.name;
      this._passwordSecret.internalValue = value.passwordSecret;
      this._replication = value.replication;
      this._superuser = value.superuser;
      this._validUntil = value.validUntil;
    }
  }

  // bypassrls - computed: false, optional: true, required: false
  private _bypassrls?: boolean | cdktf.IResolvable; 
  public get bypassrls() {
    return this.getBooleanAttribute('bypassrls');
  }
  public set bypassrls(value: boolean | cdktf.IResolvable) {
    this._bypassrls = value;
  }
  public resetBypassrls() {
    this._bypassrls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bypassrlsInput() {
    return this._bypassrls;
  }

  // comment - computed: false, optional: true, required: false
  private _comment?: string; 
  public get comment() {
    return this.getStringAttribute('comment');
  }
  public set comment(value: string) {
    this._comment = value;
  }
  public resetComment() {
    this._comment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commentInput() {
    return this._comment;
  }

  // connection_limit - computed: false, optional: true, required: false
  private _connectionLimit?: number; 
  public get connectionLimit() {
    return this.getNumberAttribute('connection_limit');
  }
  public set connectionLimit(value: number) {
    this._connectionLimit = value;
  }
  public resetConnectionLimit() {
    this._connectionLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionLimitInput() {
    return this._connectionLimit;
  }

  // createdb - computed: false, optional: true, required: false
  private _createdb?: boolean | cdktf.IResolvable; 
  public get createdb() {
    return this.getBooleanAttribute('createdb');
  }
  public set createdb(value: boolean | cdktf.IResolvable) {
    this._createdb = value;
  }
  public resetCreatedb() {
    this._createdb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createdbInput() {
    return this._createdb;
  }

  // createrole - computed: false, optional: true, required: false
  private _createrole?: boolean | cdktf.IResolvable; 
  public get createrole() {
    return this.getBooleanAttribute('createrole');
  }
  public set createrole(value: boolean | cdktf.IResolvable) {
    this._createrole = value;
  }
  public resetCreaterole() {
    this._createrole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createroleInput() {
    return this._createrole;
  }

  // disable_password - computed: false, optional: true, required: false
  private _disablePassword?: boolean | cdktf.IResolvable; 
  public get disablePassword() {
    return this.getBooleanAttribute('disable_password');
  }
  public set disablePassword(value: boolean | cdktf.IResolvable) {
    this._disablePassword = value;
  }
  public resetDisablePassword() {
    this._disablePassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disablePasswordInput() {
    return this._disablePassword;
  }

  // ensure - computed: false, optional: true, required: false
  private _ensure?: string; 
  public get ensure() {
    return this.getStringAttribute('ensure');
  }
  public set ensure(value: string) {
    this._ensure = value;
  }
  public resetEnsure() {
    this._ensure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ensureInput() {
    return this._ensure;
  }

  // in_roles - computed: false, optional: true, required: false
  private _inRoles?: string[]; 
  public get inRoles() {
    return this.getListAttribute('in_roles');
  }
  public set inRoles(value: string[]) {
    this._inRoles = value;
  }
  public resetInRoles() {
    this._inRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inRolesInput() {
    return this._inRoles;
  }

  // inherit - computed: false, optional: true, required: false
  private _inherit?: boolean | cdktf.IResolvable; 
  public get inherit() {
    return this.getBooleanAttribute('inherit');
  }
  public set inherit(value: boolean | cdktf.IResolvable) {
    this._inherit = value;
  }
  public resetInherit() {
    this._inherit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritInput() {
    return this._inherit;
  }

  // login - computed: false, optional: true, required: false
  private _login?: boolean | cdktf.IResolvable; 
  public get login() {
    return this.getBooleanAttribute('login');
  }
  public set login(value: boolean | cdktf.IResolvable) {
    this._login = value;
  }
  public resetLogin() {
    this._login = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginInput() {
    return this._login;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password_secret - computed: false, optional: true, required: false
  private _passwordSecret = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecretOutputReference(this, "password_secret");
  public get passwordSecret() {
    return this._passwordSecret;
  }
  public putPasswordSecret(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesPasswordSecret) {
    this._passwordSecret.internalValue = value;
  }
  public resetPasswordSecret() {
    this._passwordSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretInput() {
    return this._passwordSecret.internalValue;
  }

  // replication - computed: false, optional: true, required: false
  private _replication?: boolean | cdktf.IResolvable; 
  public get replication() {
    return this.getBooleanAttribute('replication');
  }
  public set replication(value: boolean | cdktf.IResolvable) {
    this._replication = value;
  }
  public resetReplication() {
    this._replication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicationInput() {
    return this._replication;
  }

  // superuser - computed: false, optional: true, required: false
  private _superuser?: boolean | cdktf.IResolvable; 
  public get superuser() {
    return this.getBooleanAttribute('superuser');
  }
  public set superuser(value: boolean | cdktf.IResolvable) {
    this._superuser = value;
  }
  public resetSuperuser() {
    this._superuser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get superuserInput() {
    return this._superuser;
  }

  // valid_until - computed: false, optional: true, required: false
  private _validUntil?: string; 
  public get validUntil() {
    return this.getStringAttribute('valid_until');
  }
  public set validUntil(value: string) {
    this._validUntil = value;
  }
  public resetValidUntil() {
    this._validUntil = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validUntilInput() {
    return this._validUntil;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata {
  /**
  * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#annotations DataK8SPostgresqlCnpgIoClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#labels DataK8SPostgresqlCnpgIoClusterV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * The name of the resource. Only supported for certain types
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadataToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadataToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts {
  /**
  * The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either: * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). * Kubernetes-defined prefixed names: * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior- * 'kubernetes.io/ws' - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455 * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455 * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#app_protocol DataK8SPostgresqlCnpgIoClusterV1Manifest#app_protocol}
  */
  readonly appProtocol?: string;
  /**
  * The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * The port on each node on which this service is exposed when type is NodePort or LoadBalancer. Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail. If not specified, a port will be allocated if this Service requires one. If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#node_port DataK8SPostgresqlCnpgIoClusterV1Manifest#node_port}
  */
  readonly nodePort?: number;
  /**
  * The port that will be exposed by this service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#port DataK8SPostgresqlCnpgIoClusterV1Manifest#port}
  */
  readonly port: number;
  /**
  * The IP protocol for this port. Supports 'TCP', 'UDP', and 'SCTP'. Default is TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#protocol DataK8SPostgresqlCnpgIoClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_port DataK8SPostgresqlCnpgIoClusterV1Manifest#target_port}
  */
  readonly targetPort?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_protocol: cdktf.stringToTerraform(struct!.appProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    node_port: cdktf.numberToTerraform(struct!.nodePort),
    port: cdktf.numberToTerraform(struct!.port),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    target_port: cdktf.stringToTerraform(struct!.targetPort),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_protocol: {
      value: cdktf.stringToHclTerraform(struct!.appProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_port: {
      value: cdktf.numberToHclTerraform(struct!.nodePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_port: {
      value: cdktf.stringToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.appProtocol = this._appProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._nodePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodePort = this._nodePort;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appProtocol = undefined;
      this._name = undefined;
      this._nodePort = undefined;
      this._port = undefined;
      this._protocol = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appProtocol = value.appProtocol;
      this._name = value.name;
      this._nodePort = value.nodePort;
      this._port = value.port;
      this._protocol = value.protocol;
      this._targetPort = value.targetPort;
    }
  }

  // app_protocol - computed: false, optional: true, required: false
  private _appProtocol?: string; 
  public get appProtocol() {
    return this.getStringAttribute('app_protocol');
  }
  public set appProtocol(value: string) {
    this._appProtocol = value;
  }
  public resetAppProtocol() {
    this._appProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appProtocolInput() {
    return this._appProtocol;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // node_port - computed: false, optional: true, required: false
  private _nodePort?: number; 
  public get nodePort() {
    return this.getNumberAttribute('node_port');
  }
  public set nodePort(value: number) {
    this._nodePort = value;
  }
  public resetNodePort() {
    this._nodePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodePortInput() {
    return this._nodePort;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: string; 
  public get targetPort() {
    return this.getStringAttribute('target_port');
  }
  public set targetPort(value: string) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp {
  /**
  * timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == 'ClientIP'. Default value is 10800(for 3 hours).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#timeout_seconds DataK8SPostgresqlCnpgIoClusterV1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIpToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIpToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig {
  /**
  * clientIP contains the configurations of Client IP based session affinity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#client_ip DataK8SPostgresqlCnpgIoClusterV1Manifest#client_ip}
  */
  readonly clientIp?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_ip: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIpToTerraform(struct!.clientIp),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_ip: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIpToHclTerraform(struct!.clientIp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientIp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientIp = this._clientIp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientIp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientIp.internalValue = value.clientIp;
    }
  }

  // client_ip - computed: false, optional: true, required: false
  private _clientIp = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIpOutputReference(this, "client_ip");
  public get clientIp() {
    return this._clientIp;
  }
  public putClientIp(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigClientIp) {
    this._clientIp.internalValue = value;
  }
  public resetClientIp() {
    this._clientIp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIpInput() {
    return this._clientIp.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec {
  /**
  * allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer. Default is 'true'. It may be set to 'false' if the cluster load-balancer does not rely on NodePorts. If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#allocate_load_balancer_node_ports DataK8SPostgresqlCnpgIoClusterV1Manifest#allocate_load_balancer_node_ports}
  */
  readonly allocateLoadBalancerNodePorts?: boolean | cdktf.IResolvable;
  /**
  * ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above). Valid values are 'None', empty string (''), or a valid IP address. Setting this to 'None' makes a 'headless service' (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. If this field is not specified, it will be initialized from the clusterIP field. If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#cluster_i_ps DataK8SPostgresqlCnpgIoClusterV1Manifest#cluster_i_ps}
  */
  readonly clusterIPs?: string[];
  /**
  * clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above). Valid values are 'None', empty string (''), or a valid IP address. Setting this to 'None' makes a 'headless service' (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#cluster_ip DataK8SPostgresqlCnpgIoClusterV1Manifest#cluster_ip}
  */
  readonly clusterIp?: string;
  /**
  * externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#external_i_ps DataK8SPostgresqlCnpgIoClusterV1Manifest#external_i_ps}
  */
  readonly externalIPs?: string[];
  /**
  * externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved. Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires 'type' to be 'ExternalName'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#external_name DataK8SPostgresqlCnpgIoClusterV1Manifest#external_name}
  */
  readonly externalName?: string;
  /**
  * externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's 'externally-facing' addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to 'Local', the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, 'Cluster', uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get 'Cluster' semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#external_traffic_policy DataK8SPostgresqlCnpgIoClusterV1Manifest#external_traffic_policy}
  */
  readonly externalTrafficPolicy?: string;
  /**
  * healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used. If not specified, a value will be automatically allocated. External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not. If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type). This field cannot be updated once set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#health_check_node_port DataK8SPostgresqlCnpgIoClusterV1Manifest#health_check_node_port}
  */
  readonly healthCheckNodePort?: number;
  /**
  * InternalTrafficPolicy describes how nodes distribute service traffic they receive on the ClusterIP. If set to 'Local', the proxy will assume that pods only want to talk to endpoints of the service on the same node as the pod, dropping the traffic if there are no local endpoints. The default value, 'Cluster', uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#internal_traffic_policy DataK8SPostgresqlCnpgIoClusterV1Manifest#internal_traffic_policy}
  */
  readonly internalTrafficPolicy?: string;
  /**
  * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are 'IPv4' and 'IPv6'. This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to 'headless' services. This field will be wiped when updating a Service to type ExternalName. This field may hold a maximum of two entries (dual-stack families, in either order). These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ip_families DataK8SPostgresqlCnpgIoClusterV1Manifest#ip_families}
  */
  readonly ipFamilies?: string[];
  /**
  * IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be 'SingleStack' (a single IP family), 'PreferDualStack' (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or 'RequireDualStack' (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ip_family_policy DataK8SPostgresqlCnpgIoClusterV1Manifest#ip_family_policy}
  */
  readonly ipFamilyPolicy?: string;
  /**
  * loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. 'internal-vip' or 'example.com/internal-vip'. Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#load_balancer_class DataK8SPostgresqlCnpgIoClusterV1Manifest#load_balancer_class}
  */
  readonly loadBalancerClass?: string;
  /**
  * Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations. Using it is non-portable and it may not support dual-stack. Users are encouraged to use implementation-specific annotations when available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#load_balancer_ip DataK8SPostgresqlCnpgIoClusterV1Manifest#load_balancer_ip}
  */
  readonly loadBalancerIp?: string;
  /**
  * If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.' More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#load_balancer_source_ranges DataK8SPostgresqlCnpgIoClusterV1Manifest#load_balancer_source_ranges}
  */
  readonly loadBalancerSourceRanges?: string[];
  /**
  * The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ports DataK8SPostgresqlCnpgIoClusterV1Manifest#ports}
  */
  readonly ports?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts[] | cdktf.IResolvable;
  /**
  * publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered 'ready' even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#publish_not_ready_addresses DataK8SPostgresqlCnpgIoClusterV1Manifest#publish_not_ready_addresses}
  */
  readonly publishNotReadyAddresses?: boolean | cdktf.IResolvable;
  /**
  * Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#selector DataK8SPostgresqlCnpgIoClusterV1Manifest#selector}
  */
  readonly selector?: { [key: string]: string };
  /**
  * Supports 'ClientIP' and 'None'. Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#session_affinity DataK8SPostgresqlCnpgIoClusterV1Manifest#session_affinity}
  */
  readonly sessionAffinity?: string;
  /**
  * sessionAffinityConfig contains the configurations of session affinity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#session_affinity_config DataK8SPostgresqlCnpgIoClusterV1Manifest#session_affinity_config}
  */
  readonly sessionAffinityConfig?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig;
  /**
  * TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to 'PreferClose', implementations should prioritize endpoints that are topologically close (e.g., same zone). This is an alpha field and requires enabling ServiceTrafficDistribution feature.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#traffic_distribution DataK8SPostgresqlCnpgIoClusterV1Manifest#traffic_distribution}
  */
  readonly trafficDistribution?: string;
  /**
  * type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. 'ClusterIP' allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is 'None', no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. 'NodePort' builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. 'LoadBalancer' builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. 'ExternalName' aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#type DataK8SPostgresqlCnpgIoClusterV1Manifest#type}
  */
  readonly type?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allocate_load_balancer_node_ports: cdktf.booleanToTerraform(struct!.allocateLoadBalancerNodePorts),
    cluster_i_ps: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterIPs),
    cluster_ip: cdktf.stringToTerraform(struct!.clusterIp),
    external_i_ps: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.externalIPs),
    external_name: cdktf.stringToTerraform(struct!.externalName),
    external_traffic_policy: cdktf.stringToTerraform(struct!.externalTrafficPolicy),
    health_check_node_port: cdktf.numberToTerraform(struct!.healthCheckNodePort),
    internal_traffic_policy: cdktf.stringToTerraform(struct!.internalTrafficPolicy),
    ip_families: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ipFamilies),
    ip_family_policy: cdktf.stringToTerraform(struct!.ipFamilyPolicy),
    load_balancer_class: cdktf.stringToTerraform(struct!.loadBalancerClass),
    load_balancer_ip: cdktf.stringToTerraform(struct!.loadBalancerIp),
    load_balancer_source_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loadBalancerSourceRanges),
    ports: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsToTerraform, false)(struct!.ports),
    publish_not_ready_addresses: cdktf.booleanToTerraform(struct!.publishNotReadyAddresses),
    selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.selector),
    session_affinity: cdktf.stringToTerraform(struct!.sessionAffinity),
    session_affinity_config: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigToTerraform(struct!.sessionAffinityConfig),
    traffic_distribution: cdktf.stringToTerraform(struct!.trafficDistribution),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allocate_load_balancer_node_ports: {
      value: cdktf.booleanToHclTerraform(struct!.allocateLoadBalancerNodePorts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    cluster_i_ps: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterIPs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cluster_ip: {
      value: cdktf.stringToHclTerraform(struct!.clusterIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_i_ps: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.externalIPs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    external_name: {
      value: cdktf.stringToHclTerraform(struct!.externalName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_traffic_policy: {
      value: cdktf.stringToHclTerraform(struct!.externalTrafficPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    health_check_node_port: {
      value: cdktf.numberToHclTerraform(struct!.healthCheckNodePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    internal_traffic_policy: {
      value: cdktf.stringToHclTerraform(struct!.internalTrafficPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_families: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ipFamilies),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ip_family_policy: {
      value: cdktf.stringToHclTerraform(struct!.ipFamilyPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_class: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_ip: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_source_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loadBalancerSourceRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ports: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsToHclTerraform, false)(struct!.ports),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsList",
    },
    publish_not_ready_addresses: {
      value: cdktf.booleanToHclTerraform(struct!.publishNotReadyAddresses),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.selector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    session_affinity: {
      value: cdktf.stringToHclTerraform(struct!.sessionAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_affinity_config: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigToHclTerraform(struct!.sessionAffinityConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig",
    },
    traffic_distribution: {
      value: cdktf.stringToHclTerraform(struct!.trafficDistribution),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allocateLoadBalancerNodePorts !== undefined) {
      hasAnyValues = true;
      internalValueResult.allocateLoadBalancerNodePorts = this._allocateLoadBalancerNodePorts;
    }
    if (this._clusterIPs !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterIPs = this._clusterIPs;
    }
    if (this._clusterIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterIp = this._clusterIp;
    }
    if (this._externalIPs !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalIPs = this._externalIPs;
    }
    if (this._externalName !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalName = this._externalName;
    }
    if (this._externalTrafficPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalTrafficPolicy = this._externalTrafficPolicy;
    }
    if (this._healthCheckNodePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheckNodePort = this._healthCheckNodePort;
    }
    if (this._internalTrafficPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalTrafficPolicy = this._internalTrafficPolicy;
    }
    if (this._ipFamilies !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipFamilies = this._ipFamilies;
    }
    if (this._ipFamilyPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipFamilyPolicy = this._ipFamilyPolicy;
    }
    if (this._loadBalancerClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerClass = this._loadBalancerClass;
    }
    if (this._loadBalancerIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerIp = this._loadBalancerIp;
    }
    if (this._loadBalancerSourceRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSourceRanges = this._loadBalancerSourceRanges;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._publishNotReadyAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.publishNotReadyAddresses = this._publishNotReadyAddresses;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._sessionAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionAffinity = this._sessionAffinity;
    }
    if (this._sessionAffinityConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionAffinityConfig = this._sessionAffinityConfig?.internalValue;
    }
    if (this._trafficDistribution !== undefined) {
      hasAnyValues = true;
      internalValueResult.trafficDistribution = this._trafficDistribution;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allocateLoadBalancerNodePorts = undefined;
      this._clusterIPs = undefined;
      this._clusterIp = undefined;
      this._externalIPs = undefined;
      this._externalName = undefined;
      this._externalTrafficPolicy = undefined;
      this._healthCheckNodePort = undefined;
      this._internalTrafficPolicy = undefined;
      this._ipFamilies = undefined;
      this._ipFamilyPolicy = undefined;
      this._loadBalancerClass = undefined;
      this._loadBalancerIp = undefined;
      this._loadBalancerSourceRanges = undefined;
      this._ports.internalValue = undefined;
      this._publishNotReadyAddresses = undefined;
      this._selector = undefined;
      this._sessionAffinity = undefined;
      this._sessionAffinityConfig.internalValue = undefined;
      this._trafficDistribution = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allocateLoadBalancerNodePorts = value.allocateLoadBalancerNodePorts;
      this._clusterIPs = value.clusterIPs;
      this._clusterIp = value.clusterIp;
      this._externalIPs = value.externalIPs;
      this._externalName = value.externalName;
      this._externalTrafficPolicy = value.externalTrafficPolicy;
      this._healthCheckNodePort = value.healthCheckNodePort;
      this._internalTrafficPolicy = value.internalTrafficPolicy;
      this._ipFamilies = value.ipFamilies;
      this._ipFamilyPolicy = value.ipFamilyPolicy;
      this._loadBalancerClass = value.loadBalancerClass;
      this._loadBalancerIp = value.loadBalancerIp;
      this._loadBalancerSourceRanges = value.loadBalancerSourceRanges;
      this._ports.internalValue = value.ports;
      this._publishNotReadyAddresses = value.publishNotReadyAddresses;
      this._selector = value.selector;
      this._sessionAffinity = value.sessionAffinity;
      this._sessionAffinityConfig.internalValue = value.sessionAffinityConfig;
      this._trafficDistribution = value.trafficDistribution;
      this._type = value.type;
    }
  }

  // allocate_load_balancer_node_ports - computed: false, optional: true, required: false
  private _allocateLoadBalancerNodePorts?: boolean | cdktf.IResolvable; 
  public get allocateLoadBalancerNodePorts() {
    return this.getBooleanAttribute('allocate_load_balancer_node_ports');
  }
  public set allocateLoadBalancerNodePorts(value: boolean | cdktf.IResolvable) {
    this._allocateLoadBalancerNodePorts = value;
  }
  public resetAllocateLoadBalancerNodePorts() {
    this._allocateLoadBalancerNodePorts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allocateLoadBalancerNodePortsInput() {
    return this._allocateLoadBalancerNodePorts;
  }

  // cluster_i_ps - computed: false, optional: true, required: false
  private _clusterIPs?: string[]; 
  public get clusterIPs() {
    return this.getListAttribute('cluster_i_ps');
  }
  public set clusterIPs(value: string[]) {
    this._clusterIPs = value;
  }
  public resetClusterIPs() {
    this._clusterIPs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIPsInput() {
    return this._clusterIPs;
  }

  // cluster_ip - computed: false, optional: true, required: false
  private _clusterIp?: string; 
  public get clusterIp() {
    return this.getStringAttribute('cluster_ip');
  }
  public set clusterIp(value: string) {
    this._clusterIp = value;
  }
  public resetClusterIp() {
    this._clusterIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIpInput() {
    return this._clusterIp;
  }

  // external_i_ps - computed: false, optional: true, required: false
  private _externalIPs?: string[]; 
  public get externalIPs() {
    return this.getListAttribute('external_i_ps');
  }
  public set externalIPs(value: string[]) {
    this._externalIPs = value;
  }
  public resetExternalIPs() {
    this._externalIPs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIPsInput() {
    return this._externalIPs;
  }

  // external_name - computed: false, optional: true, required: false
  private _externalName?: string; 
  public get externalName() {
    return this.getStringAttribute('external_name');
  }
  public set externalName(value: string) {
    this._externalName = value;
  }
  public resetExternalName() {
    this._externalName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalNameInput() {
    return this._externalName;
  }

  // external_traffic_policy - computed: false, optional: true, required: false
  private _externalTrafficPolicy?: string; 
  public get externalTrafficPolicy() {
    return this.getStringAttribute('external_traffic_policy');
  }
  public set externalTrafficPolicy(value: string) {
    this._externalTrafficPolicy = value;
  }
  public resetExternalTrafficPolicy() {
    this._externalTrafficPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalTrafficPolicyInput() {
    return this._externalTrafficPolicy;
  }

  // health_check_node_port - computed: false, optional: true, required: false
  private _healthCheckNodePort?: number; 
  public get healthCheckNodePort() {
    return this.getNumberAttribute('health_check_node_port');
  }
  public set healthCheckNodePort(value: number) {
    this._healthCheckNodePort = value;
  }
  public resetHealthCheckNodePort() {
    this._healthCheckNodePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckNodePortInput() {
    return this._healthCheckNodePort;
  }

  // internal_traffic_policy - computed: false, optional: true, required: false
  private _internalTrafficPolicy?: string; 
  public get internalTrafficPolicy() {
    return this.getStringAttribute('internal_traffic_policy');
  }
  public set internalTrafficPolicy(value: string) {
    this._internalTrafficPolicy = value;
  }
  public resetInternalTrafficPolicy() {
    this._internalTrafficPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalTrafficPolicyInput() {
    return this._internalTrafficPolicy;
  }

  // ip_families - computed: false, optional: true, required: false
  private _ipFamilies?: string[]; 
  public get ipFamilies() {
    return this.getListAttribute('ip_families');
  }
  public set ipFamilies(value: string[]) {
    this._ipFamilies = value;
  }
  public resetIpFamilies() {
    this._ipFamilies = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipFamiliesInput() {
    return this._ipFamilies;
  }

  // ip_family_policy - computed: false, optional: true, required: false
  private _ipFamilyPolicy?: string; 
  public get ipFamilyPolicy() {
    return this.getStringAttribute('ip_family_policy');
  }
  public set ipFamilyPolicy(value: string) {
    this._ipFamilyPolicy = value;
  }
  public resetIpFamilyPolicy() {
    this._ipFamilyPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipFamilyPolicyInput() {
    return this._ipFamilyPolicy;
  }

  // load_balancer_class - computed: false, optional: true, required: false
  private _loadBalancerClass?: string; 
  public get loadBalancerClass() {
    return this.getStringAttribute('load_balancer_class');
  }
  public set loadBalancerClass(value: string) {
    this._loadBalancerClass = value;
  }
  public resetLoadBalancerClass() {
    this._loadBalancerClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerClassInput() {
    return this._loadBalancerClass;
  }

  // load_balancer_ip - computed: false, optional: true, required: false
  private _loadBalancerIp?: string; 
  public get loadBalancerIp() {
    return this.getStringAttribute('load_balancer_ip');
  }
  public set loadBalancerIp(value: string) {
    this._loadBalancerIp = value;
  }
  public resetLoadBalancerIp() {
    this._loadBalancerIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerIpInput() {
    return this._loadBalancerIp;
  }

  // load_balancer_source_ranges - computed: false, optional: true, required: false
  private _loadBalancerSourceRanges?: string[]; 
  public get loadBalancerSourceRanges() {
    return this.getListAttribute('load_balancer_source_ranges');
  }
  public set loadBalancerSourceRanges(value: string[]) {
    this._loadBalancerSourceRanges = value;
  }
  public resetLoadBalancerSourceRanges() {
    this._loadBalancerSourceRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSourceRangesInput() {
    return this._loadBalancerSourceRanges;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPortsList(this, "ports", false);
  public get ports() {
    return this._ports;
  }
  public putPorts(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecPorts[] | cdktf.IResolvable) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // publish_not_ready_addresses - computed: false, optional: true, required: false
  private _publishNotReadyAddresses?: boolean | cdktf.IResolvable; 
  public get publishNotReadyAddresses() {
    return this.getBooleanAttribute('publish_not_ready_addresses');
  }
  public set publishNotReadyAddresses(value: boolean | cdktf.IResolvable) {
    this._publishNotReadyAddresses = value;
  }
  public resetPublishNotReadyAddresses() {
    this._publishNotReadyAddresses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publishNotReadyAddressesInput() {
    return this._publishNotReadyAddresses;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: { [key: string]: string }; 
  public get selector() {
    return this.getStringMapAttribute('selector');
  }
  public set selector(value: { [key: string]: string }) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // session_affinity - computed: false, optional: true, required: false
  private _sessionAffinity?: string; 
  public get sessionAffinity() {
    return this.getStringAttribute('session_affinity');
  }
  public set sessionAffinity(value: string) {
    this._sessionAffinity = value;
  }
  public resetSessionAffinity() {
    this._sessionAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionAffinityInput() {
    return this._sessionAffinity;
  }

  // session_affinity_config - computed: false, optional: true, required: false
  private _sessionAffinityConfig = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfigOutputReference(this, "session_affinity_config");
  public get sessionAffinityConfig() {
    return this._sessionAffinityConfig;
  }
  public putSessionAffinityConfig(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecSessionAffinityConfig) {
    this._sessionAffinityConfig.internalValue = value;
  }
  public resetSessionAffinityConfig() {
    this._sessionAffinityConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionAffinityConfigInput() {
    return this._sessionAffinityConfig.internalValue;
  }

  // traffic_distribution - computed: false, optional: true, required: false
  private _trafficDistribution?: string; 
  public get trafficDistribution() {
    return this.getStringAttribute('traffic_distribution');
  }
  public set trafficDistribution(value: string) {
    this._trafficDistribution = value;
  }
  public resetTrafficDistribution() {
    this._trafficDistribution = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trafficDistributionInput() {
    return this._trafficDistribution;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate {
  /**
  * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#metadata DataK8SPostgresqlCnpgIoClusterV1Manifest#metadata}
  */
  readonly metadata?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata;
  /**
  * Specification of the desired behavior of the service. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#spec DataK8SPostgresqlCnpgIoClusterV1Manifest#spec}
  */
  readonly spec?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadataToTerraform(struct!.metadata),
    spec: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecToTerraform(struct!.spec),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata",
    },
    spec: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional {
  /**
  * SelectorType specifies the type of selectors that the service will have. Valid values are 'rw', 'r', and 'ro', representing read-write, read, and read-only services.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#selector_type DataK8SPostgresqlCnpgIoClusterV1Manifest#selector_type}
  */
  readonly selectorType: string;
  /**
  * ServiceTemplate is the template specification for the service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#service_template DataK8SPostgresqlCnpgIoClusterV1Manifest#service_template}
  */
  readonly serviceTemplate: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate;
  /**
  * UpdateStrategy describes how the service differences should be reconciled
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#update_strategy DataK8SPostgresqlCnpgIoClusterV1Manifest#update_strategy}
  */
  readonly updateStrategy?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector_type: cdktf.stringToTerraform(struct!.selectorType),
    service_template: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateToTerraform(struct!.serviceTemplate),
    update_strategy: cdktf.stringToTerraform(struct!.updateStrategy),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector_type: {
      value: cdktf.stringToHclTerraform(struct!.selectorType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_template: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateToHclTerraform(struct!.serviceTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate",
    },
    update_strategy: {
      value: cdktf.stringToHclTerraform(struct!.updateStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selectorType !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectorType = this._selectorType;
    }
    if (this._serviceTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceTemplate = this._serviceTemplate?.internalValue;
    }
    if (this._updateStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateStrategy = this._updateStrategy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selectorType = undefined;
      this._serviceTemplate.internalValue = undefined;
      this._updateStrategy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selectorType = value.selectorType;
      this._serviceTemplate.internalValue = value.serviceTemplate;
      this._updateStrategy = value.updateStrategy;
    }
  }

  // selector_type - computed: false, optional: false, required: true
  private _selectorType?: string; 
  public get selectorType() {
    return this.getStringAttribute('selector_type');
  }
  public set selectorType(value: string) {
    this._selectorType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorTypeInput() {
    return this._selectorType;
  }

  // service_template - computed: false, optional: false, required: true
  private _serviceTemplate = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplateOutputReference(this, "service_template");
  public get serviceTemplate() {
    return this._serviceTemplate;
  }
  public putServiceTemplate(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalServiceTemplate) {
    this._serviceTemplate.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceTemplateInput() {
    return this._serviceTemplate.internalValue;
  }

  // update_strategy - computed: false, optional: true, required: false
  private _updateStrategy?: string; 
  public get updateStrategy() {
    return this.getStringAttribute('update_strategy');
  }
  public set updateStrategy(value: string) {
    this._updateStrategy = value;
  }
  public resetUpdateStrategy() {
    this._updateStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateStrategyInput() {
    return this._updateStrategy;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices {
  /**
  * Additional is a list of additional managed services specified by the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#additional DataK8SPostgresqlCnpgIoClusterV1Manifest#additional}
  */
  readonly additional?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional[] | cdktf.IResolvable;
  /**
  * DisabledDefaultServices is a list of service types that are disabled by default. Valid values are 'r', and 'ro', representing read, and read-only services.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#disabled_default_services DataK8SPostgresqlCnpgIoClusterV1Manifest#disabled_default_services}
  */
  readonly disabledDefaultServices?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalToTerraform, false)(struct!.additional),
    disabled_default_services: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.disabledDefaultServices),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalToHclTerraform, false)(struct!.additional),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalList",
    },
    disabled_default_services: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.disabledDefaultServices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additional?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additional = this._additional?.internalValue;
    }
    if (this._disabledDefaultServices !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabledDefaultServices = this._disabledDefaultServices;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additional.internalValue = undefined;
      this._disabledDefaultServices = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additional.internalValue = value.additional;
      this._disabledDefaultServices = value.disabledDefaultServices;
    }
  }

  // additional - computed: false, optional: true, required: false
  private _additional = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditionalList(this, "additional", false);
  public get additional() {
    return this._additional;
  }
  public putAdditional(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesAdditional[] | cdktf.IResolvable) {
    this._additional.internalValue = value;
  }
  public resetAdditional() {
    this._additional.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalInput() {
    return this._additional.internalValue;
  }

  // disabled_default_services - computed: false, optional: true, required: false
  private _disabledDefaultServices?: string[]; 
  public get disabledDefaultServices() {
    return this.getListAttribute('disabled_default_services');
  }
  public set disabledDefaultServices(value: string[]) {
    this._disabledDefaultServices = value;
  }
  public resetDisabledDefaultServices() {
    this._disabledDefaultServices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledDefaultServicesInput() {
    return this._disabledDefaultServices;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManaged {
  /**
  * Database roles managed by the 'Cluster'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#roles DataK8SPostgresqlCnpgIoClusterV1Manifest#roles}
  */
  readonly roles?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles[] | cdktf.IResolvable;
  /**
  * Services roles managed by the 'Cluster'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#services DataK8SPostgresqlCnpgIoClusterV1Manifest#services}
  */
  readonly services?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    roles: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesToTerraform, false)(struct!.roles),
    services: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesToTerraform(struct!.services),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    roles: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesToHclTerraform, false)(struct!.roles),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesList",
    },
    services: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesToHclTerraform(struct!.services),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManaged | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._roles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles?.internalValue;
    }
    if (this._services?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManaged | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._roles.internalValue = undefined;
      this._services.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._roles.internalValue = value.roles;
      this._services.internalValue = value.services;
    }
  }

  // roles - computed: false, optional: true, required: false
  private _roles = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRolesList(this, "roles", false);
  public get roles() {
    return this._roles;
  }
  public putRoles(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedRoles[] | cdktf.IResolvable) {
    this._roles.internalValue = value;
  }
  public resetRoles() {
    this._roles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServicesOutputReference(this, "services");
  public get services() {
    return this._services;
  }
  public putServices(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecManagedServices) {
    this._services.internalValue = value;
  }
  public resetServices() {
    this._services.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret {
  /**
  * The key to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings {
  /**
  * Action to perform based on the regex matching. 'Uppercase' and 'Lowercase' actions require Prometheus >= v2.36.0. 'DropEqual' and 'KeepEqual' actions require Prometheus >= v2.41.0. Default: 'Replace'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#action DataK8SPostgresqlCnpgIoClusterV1Manifest#action}
  */
  readonly action?: string;
  /**
  * Modulus to take of the hash of the source label values. Only applicable when the action is 'HashMod'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#modulus DataK8SPostgresqlCnpgIoClusterV1Manifest#modulus}
  */
  readonly modulus?: number;
  /**
  * Regular expression against which the extracted value is matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#regex DataK8SPostgresqlCnpgIoClusterV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Replacement value against which a Replace action is performed if the regular expression matches. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#replacement DataK8SPostgresqlCnpgIoClusterV1Manifest#replacement}
  */
  readonly replacement?: string;
  /**
  * Separator is the string between concatenated SourceLabels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#separator DataK8SPostgresqlCnpgIoClusterV1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#source_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#source_labels}
  */
  readonly sourceLabels?: string[];
  /**
  * Label to which the resulting string is written in a replacement. It is mandatory for 'Replace', 'HashMod', 'Lowercase', 'Uppercase', 'KeepEqual' and 'DropEqual' actions. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_label DataK8SPostgresqlCnpgIoClusterV1Manifest#target_label}
  */
  readonly targetLabel?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    modulus: cdktf.numberToTerraform(struct!.modulus),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement: cdktf.stringToTerraform(struct!.replacement),
    separator: cdktf.stringToTerraform(struct!.separator),
    source_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sourceLabels),
    target_label: cdktf.stringToTerraform(struct!.targetLabel),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    modulus: {
      value: cdktf.numberToHclTerraform(struct!.modulus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement: {
      value: cdktf.stringToHclTerraform(struct!.replacement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sourceLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_label: {
      value: cdktf.stringToHclTerraform(struct!.targetLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._modulus !== undefined) {
      hasAnyValues = true;
      internalValueResult.modulus = this._modulus;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacement !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacement = this._replacement;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._sourceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceLabels = this._sourceLabels;
    }
    if (this._targetLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLabel = this._targetLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._modulus = undefined;
      this._regex = undefined;
      this._replacement = undefined;
      this._separator = undefined;
      this._sourceLabels = undefined;
      this._targetLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._modulus = value.modulus;
      this._regex = value.regex;
      this._replacement = value.replacement;
      this._separator = value.separator;
      this._sourceLabels = value.sourceLabels;
      this._targetLabel = value.targetLabel;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // modulus - computed: false, optional: true, required: false
  private _modulus?: number; 
  public get modulus() {
    return this.getNumberAttribute('modulus');
  }
  public set modulus(value: number) {
    this._modulus = value;
  }
  public resetModulus() {
    this._modulus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modulusInput() {
    return this._modulus;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement - computed: false, optional: true, required: false
  private _replacement?: string; 
  public get replacement() {
    return this.getStringAttribute('replacement');
  }
  public set replacement(value: string) {
    this._replacement = value;
  }
  public resetReplacement() {
    this._replacement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementInput() {
    return this._replacement;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // source_labels - computed: false, optional: true, required: false
  private _sourceLabels?: string[]; 
  public get sourceLabels() {
    return this.getListAttribute('source_labels');
  }
  public set sourceLabels(value: string[]) {
    this._sourceLabels = value;
  }
  public resetSourceLabels() {
    this._sourceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceLabelsInput() {
    return this._sourceLabels;
  }

  // target_label - computed: false, optional: true, required: false
  private _targetLabel?: string; 
  public get targetLabel() {
    return this.getStringAttribute('target_label');
  }
  public set targetLabel(value: string) {
    this._targetLabel = value;
  }
  public resetTargetLabel() {
    this._targetLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLabelInput() {
    return this._targetLabel;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings {
  /**
  * Action to perform based on the regex matching. 'Uppercase' and 'Lowercase' actions require Prometheus >= v2.36.0. 'DropEqual' and 'KeepEqual' actions require Prometheus >= v2.41.0. Default: 'Replace'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#action DataK8SPostgresqlCnpgIoClusterV1Manifest#action}
  */
  readonly action?: string;
  /**
  * Modulus to take of the hash of the source label values. Only applicable when the action is 'HashMod'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#modulus DataK8SPostgresqlCnpgIoClusterV1Manifest#modulus}
  */
  readonly modulus?: number;
  /**
  * Regular expression against which the extracted value is matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#regex DataK8SPostgresqlCnpgIoClusterV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Replacement value against which a Replace action is performed if the regular expression matches. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#replacement DataK8SPostgresqlCnpgIoClusterV1Manifest#replacement}
  */
  readonly replacement?: string;
  /**
  * Separator is the string between concatenated SourceLabels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#separator DataK8SPostgresqlCnpgIoClusterV1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#source_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#source_labels}
  */
  readonly sourceLabels?: string[];
  /**
  * Label to which the resulting string is written in a replacement. It is mandatory for 'Replace', 'HashMod', 'Lowercase', 'Uppercase', 'KeepEqual' and 'DropEqual' actions. Regex capture groups are available.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#target_label DataK8SPostgresqlCnpgIoClusterV1Manifest#target_label}
  */
  readonly targetLabel?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    modulus: cdktf.numberToTerraform(struct!.modulus),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement: cdktf.stringToTerraform(struct!.replacement),
    separator: cdktf.stringToTerraform(struct!.separator),
    source_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sourceLabels),
    target_label: cdktf.stringToTerraform(struct!.targetLabel),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    modulus: {
      value: cdktf.numberToHclTerraform(struct!.modulus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement: {
      value: cdktf.stringToHclTerraform(struct!.replacement),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sourceLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_label: {
      value: cdktf.stringToHclTerraform(struct!.targetLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._modulus !== undefined) {
      hasAnyValues = true;
      internalValueResult.modulus = this._modulus;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacement !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacement = this._replacement;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._sourceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceLabels = this._sourceLabels;
    }
    if (this._targetLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetLabel = this._targetLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._modulus = undefined;
      this._regex = undefined;
      this._replacement = undefined;
      this._separator = undefined;
      this._sourceLabels = undefined;
      this._targetLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._modulus = value.modulus;
      this._regex = value.regex;
      this._replacement = value.replacement;
      this._separator = value.separator;
      this._sourceLabels = value.sourceLabels;
      this._targetLabel = value.targetLabel;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // modulus - computed: false, optional: true, required: false
  private _modulus?: number; 
  public get modulus() {
    return this.getNumberAttribute('modulus');
  }
  public set modulus(value: number) {
    this._modulus = value;
  }
  public resetModulus() {
    this._modulus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modulusInput() {
    return this._modulus;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement - computed: false, optional: true, required: false
  private _replacement?: string; 
  public get replacement() {
    return this.getStringAttribute('replacement');
  }
  public set replacement(value: string) {
    this._replacement = value;
  }
  public resetReplacement() {
    this._replacement = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementInput() {
    return this._replacement;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // source_labels - computed: false, optional: true, required: false
  private _sourceLabels?: string[]; 
  public get sourceLabels() {
    return this.getListAttribute('source_labels');
  }
  public set sourceLabels(value: string[]) {
    this._sourceLabels = value;
  }
  public resetSourceLabels() {
    this._sourceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceLabelsInput() {
    return this._sourceLabels;
  }

  // target_label - computed: false, optional: true, required: false
  private _targetLabel?: string; 
  public get targetLabel() {
    return this.getStringAttribute('target_label');
  }
  public set targetLabel(value: string) {
    this._targetLabel = value;
  }
  public resetTargetLabel() {
    this._targetLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetLabelInput() {
    return this._targetLabel;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls {
  /**
  * Enable TLS for the monitoring endpoint. Changing this option will force a rollout of all instances.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#enabled DataK8SPostgresqlCnpgIoClusterV1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTlsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTlsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoring {
  /**
  * The list of config maps containing the custom queries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#custom_queries_config_map DataK8SPostgresqlCnpgIoClusterV1Manifest#custom_queries_config_map}
  */
  readonly customQueriesConfigMap?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap[] | cdktf.IResolvable;
  /**
  * The list of secrets containing the custom queries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#custom_queries_secret DataK8SPostgresqlCnpgIoClusterV1Manifest#custom_queries_secret}
  */
  readonly customQueriesSecret?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret[] | cdktf.IResolvable;
  /**
  * Whether the default queries should be injected. Set it to 'true' if you don't want to inject default queries into the cluster. Default: false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#disable_default_queries DataK8SPostgresqlCnpgIoClusterV1Manifest#disable_default_queries}
  */
  readonly disableDefaultQueries?: boolean | cdktf.IResolvable;
  /**
  * Enable or disable the 'PodMonitor'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#enable_pod_monitor DataK8SPostgresqlCnpgIoClusterV1Manifest#enable_pod_monitor}
  */
  readonly enablePodMonitor?: boolean | cdktf.IResolvable;
  /**
  * The list of metric relabelings for the 'PodMonitor'. Applied to samples before ingestion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pod_monitor_metric_relabelings DataK8SPostgresqlCnpgIoClusterV1Manifest#pod_monitor_metric_relabelings}
  */
  readonly podMonitorMetricRelabelings?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings[] | cdktf.IResolvable;
  /**
  * The list of relabelings for the 'PodMonitor'. Applied to samples before scraping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pod_monitor_relabelings DataK8SPostgresqlCnpgIoClusterV1Manifest#pod_monitor_relabelings}
  */
  readonly podMonitorRelabelings?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings[] | cdktf.IResolvable;
  /**
  * Configure TLS communication for the metrics endpoint. Changing tls.enabled option will force a rollout of all instances.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tls DataK8SPostgresqlCnpgIoClusterV1Manifest#tls}
  */
  readonly tls?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoring | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_queries_config_map: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapToTerraform, false)(struct!.customQueriesConfigMap),
    custom_queries_secret: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretToTerraform, false)(struct!.customQueriesSecret),
    disable_default_queries: cdktf.booleanToTerraform(struct!.disableDefaultQueries),
    enable_pod_monitor: cdktf.booleanToTerraform(struct!.enablePodMonitor),
    pod_monitor_metric_relabelings: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsToTerraform, false)(struct!.podMonitorMetricRelabelings),
    pod_monitor_relabelings: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsToTerraform, false)(struct!.podMonitorRelabelings),
    tls: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTlsToTerraform(struct!.tls),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoring | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_queries_config_map: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapToHclTerraform, false)(struct!.customQueriesConfigMap),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapList",
    },
    custom_queries_secret: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretToHclTerraform, false)(struct!.customQueriesSecret),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretList",
    },
    disable_default_queries: {
      value: cdktf.booleanToHclTerraform(struct!.disableDefaultQueries),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_pod_monitor: {
      value: cdktf.booleanToHclTerraform(struct!.enablePodMonitor),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pod_monitor_metric_relabelings: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsToHclTerraform, false)(struct!.podMonitorMetricRelabelings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsList",
    },
    pod_monitor_relabelings: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsToHclTerraform, false)(struct!.podMonitorRelabelings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsList",
    },
    tls: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoring | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customQueriesConfigMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customQueriesConfigMap = this._customQueriesConfigMap?.internalValue;
    }
    if (this._customQueriesSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customQueriesSecret = this._customQueriesSecret?.internalValue;
    }
    if (this._disableDefaultQueries !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableDefaultQueries = this._disableDefaultQueries;
    }
    if (this._enablePodMonitor !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePodMonitor = this._enablePodMonitor;
    }
    if (this._podMonitorMetricRelabelings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podMonitorMetricRelabelings = this._podMonitorMetricRelabelings?.internalValue;
    }
    if (this._podMonitorRelabelings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podMonitorRelabelings = this._podMonitorRelabelings?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoring | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customQueriesConfigMap.internalValue = undefined;
      this._customQueriesSecret.internalValue = undefined;
      this._disableDefaultQueries = undefined;
      this._enablePodMonitor = undefined;
      this._podMonitorMetricRelabelings.internalValue = undefined;
      this._podMonitorRelabelings.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customQueriesConfigMap.internalValue = value.customQueriesConfigMap;
      this._customQueriesSecret.internalValue = value.customQueriesSecret;
      this._disableDefaultQueries = value.disableDefaultQueries;
      this._enablePodMonitor = value.enablePodMonitor;
      this._podMonitorMetricRelabelings.internalValue = value.podMonitorMetricRelabelings;
      this._podMonitorRelabelings.internalValue = value.podMonitorRelabelings;
      this._tls.internalValue = value.tls;
    }
  }

  // custom_queries_config_map - computed: false, optional: true, required: false
  private _customQueriesConfigMap = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMapList(this, "custom_queries_config_map", false);
  public get customQueriesConfigMap() {
    return this._customQueriesConfigMap;
  }
  public putCustomQueriesConfigMap(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesConfigMap[] | cdktf.IResolvable) {
    this._customQueriesConfigMap.internalValue = value;
  }
  public resetCustomQueriesConfigMap() {
    this._customQueriesConfigMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customQueriesConfigMapInput() {
    return this._customQueriesConfigMap.internalValue;
  }

  // custom_queries_secret - computed: false, optional: true, required: false
  private _customQueriesSecret = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecretList(this, "custom_queries_secret", false);
  public get customQueriesSecret() {
    return this._customQueriesSecret;
  }
  public putCustomQueriesSecret(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringCustomQueriesSecret[] | cdktf.IResolvable) {
    this._customQueriesSecret.internalValue = value;
  }
  public resetCustomQueriesSecret() {
    this._customQueriesSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customQueriesSecretInput() {
    return this._customQueriesSecret.internalValue;
  }

  // disable_default_queries - computed: false, optional: true, required: false
  private _disableDefaultQueries?: boolean | cdktf.IResolvable; 
  public get disableDefaultQueries() {
    return this.getBooleanAttribute('disable_default_queries');
  }
  public set disableDefaultQueries(value: boolean | cdktf.IResolvable) {
    this._disableDefaultQueries = value;
  }
  public resetDisableDefaultQueries() {
    this._disableDefaultQueries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableDefaultQueriesInput() {
    return this._disableDefaultQueries;
  }

  // enable_pod_monitor - computed: false, optional: true, required: false
  private _enablePodMonitor?: boolean | cdktf.IResolvable; 
  public get enablePodMonitor() {
    return this.getBooleanAttribute('enable_pod_monitor');
  }
  public set enablePodMonitor(value: boolean | cdktf.IResolvable) {
    this._enablePodMonitor = value;
  }
  public resetEnablePodMonitor() {
    this._enablePodMonitor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePodMonitorInput() {
    return this._enablePodMonitor;
  }

  // pod_monitor_metric_relabelings - computed: false, optional: true, required: false
  private _podMonitorMetricRelabelings = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelingsList(this, "pod_monitor_metric_relabelings", false);
  public get podMonitorMetricRelabelings() {
    return this._podMonitorMetricRelabelings;
  }
  public putPodMonitorMetricRelabelings(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorMetricRelabelings[] | cdktf.IResolvable) {
    this._podMonitorMetricRelabelings.internalValue = value;
  }
  public resetPodMonitorMetricRelabelings() {
    this._podMonitorMetricRelabelings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podMonitorMetricRelabelingsInput() {
    return this._podMonitorMetricRelabelings.internalValue;
  }

  // pod_monitor_relabelings - computed: false, optional: true, required: false
  private _podMonitorRelabelings = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelingsList(this, "pod_monitor_relabelings", false);
  public get podMonitorRelabelings() {
    return this._podMonitorRelabelings;
  }
  public putPodMonitorRelabelings(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringPodMonitorRelabelings[] | cdktf.IResolvable) {
    this._podMonitorRelabelings.internalValue = value;
  }
  public resetPodMonitorRelabelings() {
    this._podMonitorRelabelings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podMonitorRelabelingsInput() {
    return this._podMonitorRelabelings.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecMonitoringTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindow {
  /**
  * Is there a node maintenance activity in progress?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#in_progress DataK8SPostgresqlCnpgIoClusterV1Manifest#in_progress}
  */
  readonly inProgress?: boolean | cdktf.IResolvable;
  /**
  * Reuse the existing PVC (wait for the node to come up again) or not (recreate it elsewhere - when 'instances' >1)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#reuse_pvc DataK8SPostgresqlCnpgIoClusterV1Manifest#reuse_pvc}
  */
  readonly reusePvc?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindowToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    in_progress: cdktf.booleanToTerraform(struct!.inProgress),
    reuse_pvc: cdktf.booleanToTerraform(struct!.reusePvc),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindowToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    in_progress: {
      value: cdktf.booleanToHclTerraform(struct!.inProgress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_pvc: {
      value: cdktf.booleanToHclTerraform(struct!.reusePvc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inProgress !== undefined) {
      hasAnyValues = true;
      internalValueResult.inProgress = this._inProgress;
    }
    if (this._reusePvc !== undefined) {
      hasAnyValues = true;
      internalValueResult.reusePvc = this._reusePvc;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecNodeMaintenanceWindow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inProgress = undefined;
      this._reusePvc = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inProgress = value.inProgress;
      this._reusePvc = value.reusePvc;
    }
  }

  // in_progress - computed: false, optional: true, required: false
  private _inProgress?: boolean | cdktf.IResolvable; 
  public get inProgress() {
    return this.getBooleanAttribute('in_progress');
  }
  public set inProgress(value: boolean | cdktf.IResolvable) {
    this._inProgress = value;
  }
  public resetInProgress() {
    this._inProgress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inProgressInput() {
    return this._inProgress;
  }

  // reuse_pvc - computed: false, optional: true, required: false
  private _reusePvc?: boolean | cdktf.IResolvable; 
  public get reusePvc() {
    return this.getBooleanAttribute('reuse_pvc');
  }
  public set reusePvc(value: boolean | cdktf.IResolvable) {
    this._reusePvc = value;
  }
  public resetReusePvc() {
    this._reusePvc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reusePvcInput() {
    return this._reusePvc;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPlugins {
  /**
  * Enabled is true if this plugin will be used
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#enabled DataK8SPostgresqlCnpgIoClusterV1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Name is the plugin name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Parameters is the configuration of the plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#parameters DataK8SPostgresqlCnpgIoClusterV1Manifest#parameters}
  */
  readonly parameters?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPluginsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    name: cdktf.stringToTerraform(struct!.name),
    parameters: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.parameters),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPluginsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parameters: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.parameters),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPluginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPlugins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._parameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPlugins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._name = undefined;
      this._parameters = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._name = value.name;
      this._parameters = value.parameters;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters?: { [key: string]: string }; 
  public get parameters() {
    return this.getStringMapAttribute('parameters');
  }
  public set parameters(value: { [key: string]: string }) {
    this._parameters = value;
  }
  public resetParameters() {
    this._parameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPluginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPlugins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPluginsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPluginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth {
  /**
  * Prefix for the bind authentication option
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#prefix DataK8SPostgresqlCnpgIoClusterV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Suffix for the bind authentication option
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#suffix DataK8SPostgresqlCnpgIoClusterV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuthToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuthToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
      this._suffix = value.suffix;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPasswordToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPasswordToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth {
  /**
  * Root DN to begin the user search
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#base_dn DataK8SPostgresqlCnpgIoClusterV1Manifest#base_dn}
  */
  readonly baseDn?: string;
  /**
  * DN of the user to bind to the directory
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#bind_dn DataK8SPostgresqlCnpgIoClusterV1Manifest#bind_dn}
  */
  readonly bindDn?: string;
  /**
  * Secret with the password for the user to bind to the directory
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#bind_password DataK8SPostgresqlCnpgIoClusterV1Manifest#bind_password}
  */
  readonly bindPassword?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword;
  /**
  * Attribute to match against the username
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#search_attribute DataK8SPostgresqlCnpgIoClusterV1Manifest#search_attribute}
  */
  readonly searchAttribute?: string;
  /**
  * Search filter to use when doing the search+bind authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#search_filter DataK8SPostgresqlCnpgIoClusterV1Manifest#search_filter}
  */
  readonly searchFilter?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_dn: cdktf.stringToTerraform(struct!.baseDn),
    bind_dn: cdktf.stringToTerraform(struct!.bindDn),
    bind_password: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPasswordToTerraform(struct!.bindPassword),
    search_attribute: cdktf.stringToTerraform(struct!.searchAttribute),
    search_filter: cdktf.stringToTerraform(struct!.searchFilter),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_dn: {
      value: cdktf.stringToHclTerraform(struct!.baseDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_dn: {
      value: cdktf.stringToHclTerraform(struct!.bindDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_password: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPasswordToHclTerraform(struct!.bindPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword",
    },
    search_attribute: {
      value: cdktf.stringToHclTerraform(struct!.searchAttribute),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_filter: {
      value: cdktf.stringToHclTerraform(struct!.searchFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseDn = this._baseDn;
    }
    if (this._bindDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindDn = this._bindDn;
    }
    if (this._bindPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindPassword = this._bindPassword?.internalValue;
    }
    if (this._searchAttribute !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchAttribute = this._searchAttribute;
    }
    if (this._searchFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseDn = undefined;
      this._bindDn = undefined;
      this._bindPassword.internalValue = undefined;
      this._searchAttribute = undefined;
      this._searchFilter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseDn = value.baseDn;
      this._bindDn = value.bindDn;
      this._bindPassword.internalValue = value.bindPassword;
      this._searchAttribute = value.searchAttribute;
      this._searchFilter = value.searchFilter;
    }
  }

  // base_dn - computed: false, optional: true, required: false
  private _baseDn?: string; 
  public get baseDn() {
    return this.getStringAttribute('base_dn');
  }
  public set baseDn(value: string) {
    this._baseDn = value;
  }
  public resetBaseDn() {
    this._baseDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseDnInput() {
    return this._baseDn;
  }

  // bind_dn - computed: false, optional: true, required: false
  private _bindDn?: string; 
  public get bindDn() {
    return this.getStringAttribute('bind_dn');
  }
  public set bindDn(value: string) {
    this._bindDn = value;
  }
  public resetBindDn() {
    this._bindDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindDnInput() {
    return this._bindDn;
  }

  // bind_password - computed: false, optional: true, required: false
  private _bindPassword = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPasswordOutputReference(this, "bind_password");
  public get bindPassword() {
    return this._bindPassword;
  }
  public putBindPassword(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthBindPassword) {
    this._bindPassword.internalValue = value;
  }
  public resetBindPassword() {
    this._bindPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindPasswordInput() {
    return this._bindPassword.internalValue;
  }

  // search_attribute - computed: false, optional: true, required: false
  private _searchAttribute?: string; 
  public get searchAttribute() {
    return this.getStringAttribute('search_attribute');
  }
  public set searchAttribute(value: string) {
    this._searchAttribute = value;
  }
  public resetSearchAttribute() {
    this._searchAttribute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchAttributeInput() {
    return this._searchAttribute;
  }

  // search_filter - computed: false, optional: true, required: false
  private _searchFilter?: string; 
  public get searchFilter() {
    return this.getStringAttribute('search_filter');
  }
  public set searchFilter(value: string) {
    this._searchFilter = value;
  }
  public resetSearchFilter() {
    this._searchFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap {
  /**
  * Bind as authentication configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#bind_as_auth DataK8SPostgresqlCnpgIoClusterV1Manifest#bind_as_auth}
  */
  readonly bindAsAuth?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth;
  /**
  * Bind+Search authentication configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#bind_search_auth DataK8SPostgresqlCnpgIoClusterV1Manifest#bind_search_auth}
  */
  readonly bindSearchAuth?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth;
  /**
  * LDAP server port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#port DataK8SPostgresqlCnpgIoClusterV1Manifest#port}
  */
  readonly port?: number;
  /**
  * LDAP schema to be used, possible options are 'ldap' and 'ldaps'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#scheme DataK8SPostgresqlCnpgIoClusterV1Manifest#scheme}
  */
  readonly scheme?: string;
  /**
  * LDAP hostname or IP address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#server DataK8SPostgresqlCnpgIoClusterV1Manifest#server}
  */
  readonly server?: string;
  /**
  * Set to 'true' to enable LDAP over TLS. 'false' is default
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#tls DataK8SPostgresqlCnpgIoClusterV1Manifest#tls}
  */
  readonly tls?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_as_auth: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuthToTerraform(struct!.bindAsAuth),
    bind_search_auth: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthToTerraform(struct!.bindSearchAuth),
    port: cdktf.numberToTerraform(struct!.port),
    scheme: cdktf.stringToTerraform(struct!.scheme),
    server: cdktf.stringToTerraform(struct!.server),
    tls: cdktf.booleanToTerraform(struct!.tls),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_as_auth: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuthToHclTerraform(struct!.bindAsAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth",
    },
    bind_search_auth: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthToHclTerraform(struct!.bindSearchAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scheme: {
      value: cdktf.stringToHclTerraform(struct!.scheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: cdktf.stringToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.booleanToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindAsAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindAsAuth = this._bindAsAuth?.internalValue;
    }
    if (this._bindSearchAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindSearchAuth = this._bindSearchAuth?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._scheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.scheme = this._scheme;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindAsAuth.internalValue = undefined;
      this._bindSearchAuth.internalValue = undefined;
      this._port = undefined;
      this._scheme = undefined;
      this._server = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindAsAuth.internalValue = value.bindAsAuth;
      this._bindSearchAuth.internalValue = value.bindSearchAuth;
      this._port = value.port;
      this._scheme = value.scheme;
      this._server = value.server;
      this._tls = value.tls;
    }
  }

  // bind_as_auth - computed: false, optional: true, required: false
  private _bindAsAuth = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuthOutputReference(this, "bind_as_auth");
  public get bindAsAuth() {
    return this._bindAsAuth;
  }
  public putBindAsAuth(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindAsAuth) {
    this._bindAsAuth.internalValue = value;
  }
  public resetBindAsAuth() {
    this._bindAsAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindAsAuthInput() {
    return this._bindAsAuth.internalValue;
  }

  // bind_search_auth - computed: false, optional: true, required: false
  private _bindSearchAuth = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuthOutputReference(this, "bind_search_auth");
  public get bindSearchAuth() {
    return this._bindSearchAuth;
  }
  public putBindSearchAuth(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapBindSearchAuth) {
    this._bindSearchAuth.internalValue = value;
  }
  public resetBindSearchAuth() {
    this._bindSearchAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindSearchAuthInput() {
    return this._bindSearchAuth.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // scheme - computed: false, optional: true, required: false
  private _scheme?: string; 
  public get scheme() {
    return this.getStringAttribute('scheme');
  }
  public set scheme(value: string) {
    this._scheme = value;
  }
  public resetScheme() {
    this._scheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemeInput() {
    return this._scheme;
  }

  // server - computed: false, optional: true, required: false
  private _server?: string; 
  public get server() {
    return this.getStringAttribute('server');
  }
  public set server(value: string) {
    this._server = value;
  }
  public resetServer() {
    this._server = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: boolean | cdktf.IResolvable; 
  public get tls() {
    return this.getBooleanAttribute('tls');
  }
  public set tls(value: boolean | cdktf.IResolvable) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint {
  /**
  * This flag enables the constraints for sync replicas
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#enabled DataK8SPostgresqlCnpgIoClusterV1Manifest#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * A list of node labels values to extract and compare to evaluate if the pods reside in the same topology or not
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#node_labels_anti_affinity DataK8SPostgresqlCnpgIoClusterV1Manifest#node_labels_anti_affinity}
  */
  readonly nodeLabelsAntiAffinity?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraintToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    node_labels_anti_affinity: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nodeLabelsAntiAffinity),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraintToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    node_labels_anti_affinity: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nodeLabelsAntiAffinity),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraintOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._nodeLabelsAntiAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeLabelsAntiAffinity = this._nodeLabelsAntiAffinity;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._nodeLabelsAntiAffinity = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._nodeLabelsAntiAffinity = value.nodeLabelsAntiAffinity;
    }
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // node_labels_anti_affinity - computed: false, optional: true, required: false
  private _nodeLabelsAntiAffinity?: string[]; 
  public get nodeLabelsAntiAffinity() {
    return this.getListAttribute('node_labels_anti_affinity');
  }
  public set nodeLabelsAntiAffinity(value: string[]) {
    this._nodeLabelsAntiAffinity = value;
  }
  public resetNodeLabelsAntiAffinity() {
    this._nodeLabelsAntiAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeLabelsAntiAffinityInput() {
    return this._nodeLabelsAntiAffinity;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous {
  /**
  * Specifies the maximum number of local cluster pods that can be automatically included in the 'synchronous_standby_names' option in PostgreSQL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#max_standby_names_from_cluster DataK8SPostgresqlCnpgIoClusterV1Manifest#max_standby_names_from_cluster}
  */
  readonly maxStandbyNamesFromCluster?: number;
  /**
  * Method to select synchronous replication standbys from the listed servers, accepting 'any' (quorum-based synchronous replication) or 'first' (priority-based synchronous replication) as values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#method DataK8SPostgresqlCnpgIoClusterV1Manifest#method}
  */
  readonly method: string;
  /**
  * Specifies the number of synchronous standby servers that transactions must wait for responses from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#number DataK8SPostgresqlCnpgIoClusterV1Manifest#number}
  */
  readonly number: number;
  /**
  * A user-defined list of application names to be added to 'synchronous_standby_names' after local cluster pods (the order is only useful for priority-based synchronous replication).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#standby_names_post DataK8SPostgresqlCnpgIoClusterV1Manifest#standby_names_post}
  */
  readonly standbyNamesPost?: string[];
  /**
  * A user-defined list of application names to be added to 'synchronous_standby_names' before local cluster pods (the order is only useful for priority-based synchronous replication).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#standby_names_pre DataK8SPostgresqlCnpgIoClusterV1Manifest#standby_names_pre}
  */
  readonly standbyNamesPre?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronousToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_standby_names_from_cluster: cdktf.numberToTerraform(struct!.maxStandbyNamesFromCluster),
    method: cdktf.stringToTerraform(struct!.method),
    number: cdktf.numberToTerraform(struct!.number),
    standby_names_post: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.standbyNamesPost),
    standby_names_pre: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.standbyNamesPre),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronousToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_standby_names_from_cluster: {
      value: cdktf.numberToHclTerraform(struct!.maxStandbyNamesFromCluster),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    number: {
      value: cdktf.numberToHclTerraform(struct!.number),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    standby_names_post: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.standbyNamesPost),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    standby_names_pre: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.standbyNamesPre),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronousOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxStandbyNamesFromCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxStandbyNamesFromCluster = this._maxStandbyNamesFromCluster;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._number !== undefined) {
      hasAnyValues = true;
      internalValueResult.number = this._number;
    }
    if (this._standbyNamesPost !== undefined) {
      hasAnyValues = true;
      internalValueResult.standbyNamesPost = this._standbyNamesPost;
    }
    if (this._standbyNamesPre !== undefined) {
      hasAnyValues = true;
      internalValueResult.standbyNamesPre = this._standbyNamesPre;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxStandbyNamesFromCluster = undefined;
      this._method = undefined;
      this._number = undefined;
      this._standbyNamesPost = undefined;
      this._standbyNamesPre = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxStandbyNamesFromCluster = value.maxStandbyNamesFromCluster;
      this._method = value.method;
      this._number = value.number;
      this._standbyNamesPost = value.standbyNamesPost;
      this._standbyNamesPre = value.standbyNamesPre;
    }
  }

  // max_standby_names_from_cluster - computed: false, optional: true, required: false
  private _maxStandbyNamesFromCluster?: number; 
  public get maxStandbyNamesFromCluster() {
    return this.getNumberAttribute('max_standby_names_from_cluster');
  }
  public set maxStandbyNamesFromCluster(value: number) {
    this._maxStandbyNamesFromCluster = value;
  }
  public resetMaxStandbyNamesFromCluster() {
    this._maxStandbyNamesFromCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxStandbyNamesFromClusterInput() {
    return this._maxStandbyNamesFromCluster;
  }

  // method - computed: false, optional: false, required: true
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // number - computed: false, optional: false, required: true
  private _number?: number; 
  public get number() {
    return this.getNumberAttribute('number');
  }
  public set number(value: number) {
    this._number = value;
  }
  // Temporarily expose input value. Use with caution.
  public get numberInput() {
    return this._number;
  }

  // standby_names_post - computed: false, optional: true, required: false
  private _standbyNamesPost?: string[]; 
  public get standbyNamesPost() {
    return this.getListAttribute('standby_names_post');
  }
  public set standbyNamesPost(value: string[]) {
    this._standbyNamesPost = value;
  }
  public resetStandbyNamesPost() {
    this._standbyNamesPost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get standbyNamesPostInput() {
    return this._standbyNamesPost;
  }

  // standby_names_pre - computed: false, optional: true, required: false
  private _standbyNamesPre?: string[]; 
  public get standbyNamesPre() {
    return this.getListAttribute('standby_names_pre');
  }
  public set standbyNamesPre(value: string[]) {
    this._standbyNamesPre = value;
  }
  public resetStandbyNamesPre() {
    this._standbyNamesPre = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get standbyNamesPreInput() {
    return this._standbyNamesPre;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresql {
  /**
  * If this parameter is true, the user will be able to invoke 'ALTER SYSTEM' on this CloudNativePG Cluster. This should only be used for debugging and troubleshooting. Defaults to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#enable_alter_system DataK8SPostgresqlCnpgIoClusterV1Manifest#enable_alter_system}
  */
  readonly enableAlterSystem?: boolean | cdktf.IResolvable;
  /**
  * Options to specify LDAP configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#ldap DataK8SPostgresqlCnpgIoClusterV1Manifest#ldap}
  */
  readonly ldap?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap;
  /**
  * PostgreSQL configuration options (postgresql.conf)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#parameters DataK8SPostgresqlCnpgIoClusterV1Manifest#parameters}
  */
  readonly parameters?: { [key: string]: string };
  /**
  * PostgreSQL Host Based Authentication rules (lines to be appended to the pg_hba.conf file)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pg_hba DataK8SPostgresqlCnpgIoClusterV1Manifest#pg_hba}
  */
  readonly pgHba?: string[];
  /**
  * PostgreSQL User Name Maps rules (lines to be appended to the pg_ident.conf file)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#pg_ident DataK8SPostgresqlCnpgIoClusterV1Manifest#pg_ident}
  */
  readonly pgIdent?: string[];
  /**
  * Specifies the maximum number of seconds to wait when promoting an instance to primary. Default value is 40000000, greater than one year in seconds, big enough to simulate an infinite timeout
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#promotion_timeout DataK8SPostgresqlCnpgIoClusterV1Manifest#promotion_timeout}
  */
  readonly promotionTimeout?: number;
  /**
  * Lists of shared preload libraries to add to the default ones
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#shared_preload_libraries DataK8SPostgresqlCnpgIoClusterV1Manifest#shared_preload_libraries}
  */
  readonly sharedPreloadLibraries?: string[];
  /**
  * Requirements to be met by sync replicas. This will affect how the 'synchronous_standby_names' parameter will be set up.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#sync_replica_election_constraint DataK8SPostgresqlCnpgIoClusterV1Manifest#sync_replica_election_constraint}
  */
  readonly syncReplicaElectionConstraint?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint;
  /**
  * Configuration of the PostgreSQL synchronous replication feature
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#synchronous DataK8SPostgresqlCnpgIoClusterV1Manifest#synchronous}
  */
  readonly synchronous?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_alter_system: cdktf.booleanToTerraform(struct!.enableAlterSystem),
    ldap: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapToTerraform(struct!.ldap),
    parameters: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.parameters),
    pg_hba: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.pgHba),
    pg_ident: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.pgIdent),
    promotion_timeout: cdktf.numberToTerraform(struct!.promotionTimeout),
    shared_preload_libraries: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sharedPreloadLibraries),
    sync_replica_election_constraint: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraintToTerraform(struct!.syncReplicaElectionConstraint),
    synchronous: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronousToTerraform(struct!.synchronous),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_alter_system: {
      value: cdktf.booleanToHclTerraform(struct!.enableAlterSystem),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ldap: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapToHclTerraform(struct!.ldap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap",
    },
    parameters: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.parameters),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    pg_hba: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.pgHba),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    pg_ident: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.pgIdent),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    promotion_timeout: {
      value: cdktf.numberToHclTerraform(struct!.promotionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shared_preload_libraries: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sharedPreloadLibraries),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    sync_replica_election_constraint: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraintToHclTerraform(struct!.syncReplicaElectionConstraint),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint",
    },
    synchronous: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronousToHclTerraform(struct!.synchronous),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableAlterSystem !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAlterSystem = this._enableAlterSystem;
    }
    if (this._ldap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldap = this._ldap?.internalValue;
    }
    if (this._parameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters;
    }
    if (this._pgHba !== undefined) {
      hasAnyValues = true;
      internalValueResult.pgHba = this._pgHba;
    }
    if (this._pgIdent !== undefined) {
      hasAnyValues = true;
      internalValueResult.pgIdent = this._pgIdent;
    }
    if (this._promotionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.promotionTimeout = this._promotionTimeout;
    }
    if (this._sharedPreloadLibraries !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedPreloadLibraries = this._sharedPreloadLibraries;
    }
    if (this._syncReplicaElectionConstraint?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncReplicaElectionConstraint = this._syncReplicaElectionConstraint?.internalValue;
    }
    if (this._synchronous?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.synchronous = this._synchronous?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enableAlterSystem = undefined;
      this._ldap.internalValue = undefined;
      this._parameters = undefined;
      this._pgHba = undefined;
      this._pgIdent = undefined;
      this._promotionTimeout = undefined;
      this._sharedPreloadLibraries = undefined;
      this._syncReplicaElectionConstraint.internalValue = undefined;
      this._synchronous.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enableAlterSystem = value.enableAlterSystem;
      this._ldap.internalValue = value.ldap;
      this._parameters = value.parameters;
      this._pgHba = value.pgHba;
      this._pgIdent = value.pgIdent;
      this._promotionTimeout = value.promotionTimeout;
      this._sharedPreloadLibraries = value.sharedPreloadLibraries;
      this._syncReplicaElectionConstraint.internalValue = value.syncReplicaElectionConstraint;
      this._synchronous.internalValue = value.synchronous;
    }
  }

  // enable_alter_system - computed: false, optional: true, required: false
  private _enableAlterSystem?: boolean | cdktf.IResolvable; 
  public get enableAlterSystem() {
    return this.getBooleanAttribute('enable_alter_system');
  }
  public set enableAlterSystem(value: boolean | cdktf.IResolvable) {
    this._enableAlterSystem = value;
  }
  public resetEnableAlterSystem() {
    this._enableAlterSystem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAlterSystemInput() {
    return this._enableAlterSystem;
  }

  // ldap - computed: false, optional: true, required: false
  private _ldap = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdapOutputReference(this, "ldap");
  public get ldap() {
    return this._ldap;
  }
  public putLdap(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlLdap) {
    this._ldap.internalValue = value;
  }
  public resetLdap() {
    this._ldap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapInput() {
    return this._ldap.internalValue;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters?: { [key: string]: string }; 
  public get parameters() {
    return this.getStringMapAttribute('parameters');
  }
  public set parameters(value: { [key: string]: string }) {
    this._parameters = value;
  }
  public resetParameters() {
    this._parameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters;
  }

  // pg_hba - computed: false, optional: true, required: false
  private _pgHba?: string[]; 
  public get pgHba() {
    return this.getListAttribute('pg_hba');
  }
  public set pgHba(value: string[]) {
    this._pgHba = value;
  }
  public resetPgHba() {
    this._pgHba = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pgHbaInput() {
    return this._pgHba;
  }

  // pg_ident - computed: false, optional: true, required: false
  private _pgIdent?: string[]; 
  public get pgIdent() {
    return this.getListAttribute('pg_ident');
  }
  public set pgIdent(value: string[]) {
    this._pgIdent = value;
  }
  public resetPgIdent() {
    this._pgIdent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pgIdentInput() {
    return this._pgIdent;
  }

  // promotion_timeout - computed: false, optional: true, required: false
  private _promotionTimeout?: number; 
  public get promotionTimeout() {
    return this.getNumberAttribute('promotion_timeout');
  }
  public set promotionTimeout(value: number) {
    this._promotionTimeout = value;
  }
  public resetPromotionTimeout() {
    this._promotionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promotionTimeoutInput() {
    return this._promotionTimeout;
  }

  // shared_preload_libraries - computed: false, optional: true, required: false
  private _sharedPreloadLibraries?: string[]; 
  public get sharedPreloadLibraries() {
    return this.getListAttribute('shared_preload_libraries');
  }
  public set sharedPreloadLibraries(value: string[]) {
    this._sharedPreloadLibraries = value;
  }
  public resetSharedPreloadLibraries() {
    this._sharedPreloadLibraries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedPreloadLibrariesInput() {
    return this._sharedPreloadLibraries;
  }

  // sync_replica_election_constraint - computed: false, optional: true, required: false
  private _syncReplicaElectionConstraint = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraintOutputReference(this, "sync_replica_election_constraint");
  public get syncReplicaElectionConstraint() {
    return this._syncReplicaElectionConstraint;
  }
  public putSyncReplicaElectionConstraint(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSyncReplicaElectionConstraint) {
    this._syncReplicaElectionConstraint.internalValue = value;
  }
  public resetSyncReplicaElectionConstraint() {
    this._syncReplicaElectionConstraint.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncReplicaElectionConstraintInput() {
    return this._syncReplicaElectionConstraint.internalValue;
  }

  // synchronous - computed: false, optional: true, required: false
  private _synchronous = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronousOutputReference(this, "synchronous");
  public get synchronous() {
    return this._synchronous;
  }
  public putSynchronous(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecPostgresqlSynchronous) {
    this._synchronous.internalValue = value;
  }
  public resetSynchronous() {
    this._synchronous.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get synchronousInput() {
    return this._synchronous.internalValue;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#operator DataK8SPostgresqlCnpgIoClusterV1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#values DataK8SPostgresqlCnpgIoClusterV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_expressions DataK8SPostgresqlCnpgIoClusterV1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#match_labels DataK8SPostgresqlCnpgIoClusterV1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundle {
  /**
  * Select all ClusterTrustBundles that match this label selector. Only has effect if signerName is set. Mutually-exclusive with name. If unset, interpreted as 'match nothing'. If set but empty, interpreted as 'match everything'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#label_selector DataK8SPostgresqlCnpgIoClusterV1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector;
  /**
  * Select a single ClusterTrustBundle by object name. Mutually-exclusive with signerName and labelSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * If true, don't block pod startup if the referenced ClusterTrustBundle(s) aren't available. If using name, then the named ClusterTrustBundle is allowed not to exist. If using signerName, then the combination of signerName and labelSelector is allowed to match zero ClusterTrustBundles.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
  /**
  * Relative path from the volume root to write the bundle.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#path DataK8SPostgresqlCnpgIoClusterV1Manifest#path}
  */
  readonly path: string;
  /**
  * Select all ClusterTrustBundles that match this signer name. Mutually-exclusive with name. The contents of all selected ClusterTrustBundles will be unified and deduplicated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#signer_name DataK8SPostgresqlCnpgIoClusterV1Manifest#signer_name}
  */
  readonly signerName?: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorToTerraform(struct!.labelSelector),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
    path: cdktf.stringToTerraform(struct!.path),
    signer_name: cdktf.stringToTerraform(struct!.signerName),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signer_name: {
      value: cdktf.stringToHclTerraform(struct!.signerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundle | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._signerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.signerName = this._signerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundle | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._name = undefined;
      this._optional = undefined;
      this._path = undefined;
      this._signerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._name = value.name;
      this._optional = value.optional;
      this._path = value.path;
      this._signerName = value.signerName;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesClusterTrustBundleLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // signer_name - computed: false, optional: true, required: false
  private _signerName?: string; 
  public get signerName() {
    return this.getStringAttribute('signer_name');
  }
  public set signerName(value: string) {
    this._signerName = value;
  }
  public resetSignerName() {
    this._signerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signerNameInput() {
    return this._signerName;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems {
  /**
  * key is the key to project.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#key DataK8SPostgresqlCnpgIoClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#mode DataK8SPostgresqlCnpgIoClusterV1Manifest#mode}
  */
  readonly mode?: number;
  /**
  * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#path DataK8SPostgresqlCnpgIoClusterV1Manifest#path}
  */
  readonly path: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    mode: cdktf.numberToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.numberToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: number; 
  public get mode() {
    return this.getNumberAttribute('mode');
  }
  public set mode(value: number) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMap {
  /**
  * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#items DataK8SPostgresqlCnpgIoClusterV1Manifest#items}
  */
  readonly items?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems[] | cdktf.IResolvable;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#name DataK8SPostgresqlCnpgIoClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * optional specify whether the ConfigMap or its keys must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#optional DataK8SPostgresqlCnpgIoClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    items: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsToTerraform, false)(struct!.items),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    items: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsToHclTerraform, false)(struct!.items),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._items?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.items = this._items?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._items.internalValue = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._items.internalValue = value.items;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // items - computed: false, optional: true, required: false
  private _items = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItemsList(this, "items", false);
  public get items() {
    return this._items;
  }
  public putItems(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesConfigMapItems[] | cdktf.IResolvable) {
    this._items.internalValue = value;
  }
  public resetItems() {
    this._items.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get itemsInput() {
    return this._items.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#api_version DataK8SPostgresqlCnpgIoClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#field_path DataK8SPostgresqlCnpgIoClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#container_name DataK8SPostgresqlCnpgIoClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#divisor DataK8SPostgresqlCnpgIoClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#resource DataK8SPostgresqlCnpgIoClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems {
  /**
  * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#field_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef;
  /**
  * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#mode DataK8SPostgresqlCnpgIoClusterV1Manifest#mode}
  */
  readonly mode?: number;
  /**
  * Required: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#path DataK8SPostgresqlCnpgIoClusterV1Manifest#path}
  */
  readonly path: string;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#resource_field_ref DataK8SPostgresqlCnpgIoClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRefToTerraform(struct!.fieldRef),
    mode: cdktf.numberToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    resource_field_ref: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefToTerraform(struct!.resourceFieldRef),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef",
    },
    mode: {
      value: cdktf.numberToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_field_ref: {
      value: dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._resourceFieldRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fieldRef.internalValue = value.fieldRef;
      this._mode = value.mode;
      this._path = value.path;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
    }
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: number; 
  public get mode() {
    return this.getNumberAttribute('mode');
  }
  public set mode(value: number) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsList extends cdktf.ComplexList {
  public internalValue? : DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsOutputReference {
    return new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApi {
  /**
  * Items is a list of DownwardAPIVolume file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/postgresql_cnpg_io_cluster_v1_manifest#items DataK8SPostgresqlCnpgIoClusterV1Manifest#items}
  */
  readonly items?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems[] | cdktf.IResolvable;
}

export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiToTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    items: cdktf.listMapper(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsToTerraform, false)(struct!.items),
  }
}


export function dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiToHclTerraform(struct?: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    items: {
      value: cdktf.listMapperHcl(dataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsToHclTerraform, false)(struct!.items),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._items?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.items = this._items?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._items.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._items.internalValue = value.items;
    }
  }

  // items - computed: false, optional: true, required: false
  private _items = new DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItemsList(this, "items", false);
  public get items() {
    return this._items;
  }
  public putItems(value: DataK8SPostgresqlCnpgIoClusterV1ManifestSpecProjectedVolumeTemplateSourcesDownwardApiItems[] | cdktf.IResolvable) {
    this._items.internalValue = value;
  }
  public resetItems() {
    this._items.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get itemsInput() {
    return this._items.internalValue;
  }
}
