import * as cdktf from 'cdktf';
export interface DataK8SOrgEclipseCheCheClusterV2ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotations DataK8SOrgEclipseCheCheClusterV2Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#labels DataK8SOrgEclipseCheCheClusterV2Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#namespace DataK8SOrgEclipseCheCheClusterV2Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestMetadataToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestMetadataToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#api_version DataK8SOrgEclipseCheCheClusterV2Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_path DataK8SOrgEclipseCheCheClusterV2Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_name DataK8SOrgEclipseCheCheClusterV2Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#divisor DataK8SOrgEclipseCheCheClusterV2Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource DataK8SOrgEclipseCheCheClusterV2Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value_from DataK8SOrgEclipseCheCheClusterV2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources {
  /**
  * Describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#limits DataK8SOrgEclipseCheCheClusterV2Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits;
  /**
  * Describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#request DataK8SOrgEclipseCheCheClusterV2Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers {
  /**
  * List of environment variables to set in the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv[] | cdktf.IResolvable;
  /**
  * Container image. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Image pull policy. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Container name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Compute resources required by this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resources DataK8SOrgEclipseCheCheClusterV2Manifest#resources}
  */
  readonly resources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    name: cdktf.stringToTerraform(struct!.name),
    resources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesToTerraform(struct!.resources),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._name = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._name = value.name;
      this._resources.internalValue = value.resources;
    }
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#fs_group DataK8SOrgEclipseCheCheClusterV2Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * The UID to run the entrypoint of the container process. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user}
  */
  readonly runAsUser?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContextToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContextToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._runAsUser = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._runAsUser = value.runAsUser;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#effect DataK8SOrgEclipseCheCheClusterV2Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#operator DataK8SOrgEclipseCheCheClusterV2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#toleration_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment {
  /**
  * List of containers belonging to the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#containers DataK8SOrgEclipseCheCheClusterV2Manifest#containers}
  */
  readonly containers?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers[] | cdktf.IResolvable;
  /**
  * The node selector limits the nodes that can run the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#node_selector DataK8SOrgEclipseCheCheClusterV2Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Security options the pod should run with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#security_context DataK8SOrgEclipseCheCheClusterV2Manifest#security_context}
  */
  readonly securityContext?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext;
  /**
  * The pod tolerations of the component pod limit where the pod can run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#tolerations DataK8SOrgEclipseCheCheClusterV2Manifest#tolerations}
  */
  readonly tolerations?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    containers: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersToTerraform, false)(struct!.containers),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    security_context: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContextToTerraform(struct!.securityContext),
    tolerations: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsToTerraform, false)(struct!.tolerations),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    containers: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersToHclTerraform, false)(struct!.containers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    security_context: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContextToHclTerraform(struct!.securityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containers = this._containers?.internalValue;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._securityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContext = this._securityContext?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containers.internalValue = undefined;
      this._nodeSelector = undefined;
      this._securityContext.internalValue = undefined;
      this._tolerations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containers.internalValue = value.containers;
      this._nodeSelector = value.nodeSelector;
      this._securityContext.internalValue = value.securityContext;
      this._tolerations.internalValue = value.tolerations;
    }
  }

  // containers - computed: false, optional: true, required: false
  private _containers = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainersList(this, "containers", false);
  public get containers() {
    return this._containers;
  }
  public putContainers(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentContainers[] | cdktf.IResolvable) {
    this._containers.internalValue = value;
  }
  public resetContainers() {
    this._containers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containersInput() {
    return this._containers.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // security_context - computed: false, optional: true, required: false
  private _securityContext = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContextOutputReference(this, "security_context");
  public get securityContext() {
    return this._securityContext;
  }
  public putSecurityContext(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentSecurityContext) {
    this._securityContext.internalValue = value;
  }
  public resetSecurityContext() {
    this._securityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextInput() {
    return this._securityContext.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy {
  /**
  * The secret name that contains 'user' and 'password' for a proxy server. The secret must have a 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#credentials_secret_name DataK8SOrgEclipseCheCheClusterV2Manifest#credentials_secret_name}
  */
  readonly credentialsSecretName?: string;
  /**
  * A list of hosts that can be reached directly, bypassing the proxy. Specify wild card domain use the following form '.<DOMAIN>', for example: - localhost - my.host.com - 123.42.12.32 Use only when a proxy configuration is required. The Operator respects OpenShift cluster-wide proxy configuration, defining 'nonProxyHosts' in a custom resource leads to merging non-proxy hosts lists from the cluster proxy configuration, and the ones defined in the custom resources. See the following page: https://docs.openshift.com/container-platform/latest/networking/enable-cluster-wide-proxy.html.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#non_proxy_hosts DataK8SOrgEclipseCheCheClusterV2Manifest#non_proxy_hosts}
  */
  readonly nonProxyHosts?: string[];
  /**
  * Proxy server port.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#port DataK8SOrgEclipseCheCheClusterV2Manifest#port}
  */
  readonly port?: string;
  /**
  * URL (protocol+hostname) of the proxy server. Use only when a proxy configuration is required. The Operator respects OpenShift cluster-wide proxy configuration, defining 'url' in a custom resource leads to overriding the cluster proxy configuration. See the following page: https://docs.openshift.com/container-platform/latest/networking/enable-cluster-wide-proxy.html.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#url DataK8SOrgEclipseCheCheClusterV2Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxyToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret_name: cdktf.stringToTerraform(struct!.credentialsSecretName),
    non_proxy_hosts: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nonProxyHosts),
    port: cdktf.stringToTerraform(struct!.port),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxyToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    non_proxy_hosts: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nonProxyHosts),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    port: {
      value: cdktf.stringToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecretName = this._credentialsSecretName;
    }
    if (this._nonProxyHosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonProxyHosts = this._nonProxyHosts;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecretName = undefined;
      this._nonProxyHosts = undefined;
      this._port = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecretName = value.credentialsSecretName;
      this._nonProxyHosts = value.nonProxyHosts;
      this._port = value.port;
      this._url = value.url;
    }
  }

  // credentials_secret_name - computed: false, optional: true, required: false
  private _credentialsSecretName?: string; 
  public get credentialsSecretName() {
    return this.getStringAttribute('credentials_secret_name');
  }
  public set credentialsSecretName(value: string) {
    this._credentialsSecretName = value;
  }
  public resetCredentialsSecretName() {
    this._credentialsSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretNameInput() {
    return this._credentialsSecretName;
  }

  // non_proxy_hosts - computed: false, optional: true, required: false
  private _nonProxyHosts?: string[]; 
  public get nonProxyHosts() {
    return this.getListAttribute('non_proxy_hosts');
  }
  public set nonProxyHosts(value: string[]) {
    this._nonProxyHosts = value;
  }
  public resetNonProxyHosts() {
    this._nonProxyHosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonProxyHostsInput() {
    return this._nonProxyHosts;
  }

  // port - computed: false, optional: true, required: false
  private _port?: string; 
  public get port() {
    return this.getStringAttribute('port');
  }
  public set port(value: string) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer {
  /**
  * Additional ClusterRoles assigned to Che ServiceAccount. Each role must have a 'app.kubernetes.io/part-of=che.eclipse.org' label. The defaults roles are: - '<che-namespace>-cheworkspaces-clusterrole' - '<che-namespace>-cheworkspaces-namespaces-clusterrole' - '<che-namespace>-cheworkspaces-devworkspace-clusterrole' where the <che-namespace> is the namespace where the CheCluster CR is created. The Che Operator must already have all permissions in these ClusterRoles to grant them.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cluster_roles DataK8SOrgEclipseCheCheClusterV2Manifest#cluster_roles}
  */
  readonly clusterRoles?: string[];
  /**
  * Enables the debug mode for Che server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#debug DataK8SOrgEclipseCheCheClusterV2Manifest#debug}
  */
  readonly debug?: boolean | cdktf.IResolvable;
  /**
  * Deployment override options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment DataK8SOrgEclipseCheCheClusterV2Manifest#deployment}
  */
  readonly deployment?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment;
  /**
  * A map of additional environment variables applied in the generated 'che' ConfigMap to be used by the Che server in addition to the values already generated from other fields of the 'CheCluster' custom resource (CR). If the 'extraProperties' field contains a property normally generated in 'che' ConfigMap from other CR fields, the value defined in the 'extraProperties' is used instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#extra_properties DataK8SOrgEclipseCheCheClusterV2Manifest#extra_properties}
  */
  readonly extraProperties?: { [key: string]: string };
  /**
  * The log level for the Che server: 'INFO' or 'DEBUG'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#log_level DataK8SOrgEclipseCheCheClusterV2Manifest#log_level}
  */
  readonly logLevel?: string;
  /**
  * Proxy server settings for Kubernetes cluster. No additional configuration is required for OpenShift cluster. By specifying these settings for the OpenShift cluster, you override the OpenShift proxy configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#proxy DataK8SOrgEclipseCheCheClusterV2Manifest#proxy}
  */
  readonly proxy?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterRoles),
    debug: cdktf.booleanToTerraform(struct!.debug),
    deployment: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentToTerraform(struct!.deployment),
    extra_properties: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraProperties),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    proxy: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxyToTerraform(struct!.proxy),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    debug: {
      value: cdktf.booleanToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deployment: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment",
    },
    extra_properties: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraProperties),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxyToHclTerraform(struct!.proxy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterRoles = this._clusterRoles;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    if (this._extraProperties !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraProperties = this._extraProperties;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._proxy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy = this._proxy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterRoles = undefined;
      this._debug = undefined;
      this._deployment.internalValue = undefined;
      this._extraProperties = undefined;
      this._logLevel = undefined;
      this._proxy.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterRoles = value.clusterRoles;
      this._debug = value.debug;
      this._deployment.internalValue = value.deployment;
      this._extraProperties = value.extraProperties;
      this._logLevel = value.logLevel;
      this._proxy.internalValue = value.proxy;
    }
  }

  // cluster_roles - computed: false, optional: true, required: false
  private _clusterRoles?: string[]; 
  public get clusterRoles() {
    return this.getListAttribute('cluster_roles');
  }
  public set clusterRoles(value: string[]) {
    this._clusterRoles = value;
  }
  public resetClusterRoles() {
    this._clusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterRolesInput() {
    return this._clusterRoles;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: boolean | cdktf.IResolvable; 
  public get debug() {
    return this.getBooleanAttribute('debug');
  }
  public set debug(value: boolean | cdktf.IResolvable) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }

  // extra_properties - computed: false, optional: true, required: false
  private _extraProperties?: { [key: string]: string }; 
  public get extraProperties() {
    return this.getStringMapAttribute('extra_properties');
  }
  public set extraProperties(value: { [key: string]: string }) {
    this._extraProperties = value;
  }
  public resetExtraProperties() {
    this._extraProperties = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraPropertiesInput() {
    return this._extraProperties;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // proxy - computed: false, optional: true, required: false
  private _proxy = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxyOutputReference(this, "proxy");
  public get proxy() {
    return this._proxy;
  }
  public putProxy(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerProxy) {
    this._proxy.internalValue = value;
  }
  public resetProxy() {
    this._proxy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyInput() {
    return this._proxy.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#base64data DataK8SOrgEclipseCheCheClusterV2Manifest#base64data}
  */
  readonly base64Data: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#mediatype DataK8SOrgEclipseCheCheClusterV2Manifest#mediatype}
  */
  readonly mediatype: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogoToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base64data: cdktf.stringToTerraform(struct!.base64Data),
    mediatype: cdktf.stringToTerraform(struct!.mediatype),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogoToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base64data: {
      value: cdktf.stringToHclTerraform(struct!.base64Data),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mediatype: {
      value: cdktf.stringToHclTerraform(struct!.mediatype),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._base64Data !== undefined) {
      hasAnyValues = true;
      internalValueResult.base64Data = this._base64Data;
    }
    if (this._mediatype !== undefined) {
      hasAnyValues = true;
      internalValueResult.mediatype = this._mediatype;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._base64Data = undefined;
      this._mediatype = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._base64Data = value.base64Data;
      this._mediatype = value.mediatype;
    }
  }

  // base64data - computed: false, optional: false, required: true
  private _base64Data?: string; 
  public get base64Data() {
    return this.getStringAttribute('base64data');
  }
  public set base64Data(value: string) {
    this._base64Data = value;
  }
  // Temporarily expose input value. Use with caution.
  public get base64DataInput() {
    return this._base64Data;
  }

  // mediatype - computed: false, optional: false, required: true
  private _mediatype?: string; 
  public get mediatype() {
    return this.getStringAttribute('mediatype');
  }
  public set mediatype(value: string) {
    this._mediatype = value;
  }
  // Temporarily expose input value. Use with caution.
  public get mediatypeInput() {
    return this._mediatype;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding {
  /**
  * Dashboard logo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#logo DataK8SOrgEclipseCheCheClusterV2Manifest#logo}
  */
  readonly logo?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    logo: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogoToTerraform(struct!.logo),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    logo: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogoToHclTerraform(struct!.logo),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._logo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logo = this._logo?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._logo.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._logo.internalValue = value.logo;
    }
  }

  // logo - computed: false, optional: true, required: false
  private _logo = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogoOutputReference(this, "logo");
  public get logo() {
    return this._logo;
  }
  public putLogo(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingLogo) {
    this._logo.internalValue = value;
  }
  public resetLogo() {
    this._logo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logoInput() {
    return this._logo.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#api_version DataK8SOrgEclipseCheCheClusterV2Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_path DataK8SOrgEclipseCheCheClusterV2Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_name DataK8SOrgEclipseCheCheClusterV2Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#divisor DataK8SOrgEclipseCheCheClusterV2Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource DataK8SOrgEclipseCheCheClusterV2Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value_from DataK8SOrgEclipseCheCheClusterV2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources {
  /**
  * Describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#limits DataK8SOrgEclipseCheCheClusterV2Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits;
  /**
  * Describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#request DataK8SOrgEclipseCheCheClusterV2Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers {
  /**
  * List of environment variables to set in the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv[] | cdktf.IResolvable;
  /**
  * Container image. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Image pull policy. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Container name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Compute resources required by this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resources DataK8SOrgEclipseCheCheClusterV2Manifest#resources}
  */
  readonly resources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    name: cdktf.stringToTerraform(struct!.name),
    resources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesToTerraform(struct!.resources),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._name = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._name = value.name;
      this._resources.internalValue = value.resources;
    }
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#fs_group DataK8SOrgEclipseCheCheClusterV2Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * The UID to run the entrypoint of the container process. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user}
  */
  readonly runAsUser?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContextToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContextToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._runAsUser = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._runAsUser = value.runAsUser;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#effect DataK8SOrgEclipseCheCheClusterV2Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#operator DataK8SOrgEclipseCheCheClusterV2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#toleration_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment {
  /**
  * List of containers belonging to the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#containers DataK8SOrgEclipseCheCheClusterV2Manifest#containers}
  */
  readonly containers?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers[] | cdktf.IResolvable;
  /**
  * The node selector limits the nodes that can run the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#node_selector DataK8SOrgEclipseCheCheClusterV2Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Security options the pod should run with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#security_context DataK8SOrgEclipseCheCheClusterV2Manifest#security_context}
  */
  readonly securityContext?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext;
  /**
  * The pod tolerations of the component pod limit where the pod can run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#tolerations DataK8SOrgEclipseCheCheClusterV2Manifest#tolerations}
  */
  readonly tolerations?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    containers: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersToTerraform, false)(struct!.containers),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    security_context: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContextToTerraform(struct!.securityContext),
    tolerations: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsToTerraform, false)(struct!.tolerations),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    containers: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersToHclTerraform, false)(struct!.containers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    security_context: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContextToHclTerraform(struct!.securityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containers = this._containers?.internalValue;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._securityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContext = this._securityContext?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containers.internalValue = undefined;
      this._nodeSelector = undefined;
      this._securityContext.internalValue = undefined;
      this._tolerations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containers.internalValue = value.containers;
      this._nodeSelector = value.nodeSelector;
      this._securityContext.internalValue = value.securityContext;
      this._tolerations.internalValue = value.tolerations;
    }
  }

  // containers - computed: false, optional: true, required: false
  private _containers = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainersList(this, "containers", false);
  public get containers() {
    return this._containers;
  }
  public putContainers(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentContainers[] | cdktf.IResolvable) {
    this._containers.internalValue = value;
  }
  public resetContainers() {
    this._containers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containersInput() {
    return this._containers.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // security_context - computed: false, optional: true, required: false
  private _securityContext = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContextOutputReference(this, "security_context");
  public get securityContext() {
    return this._securityContext;
  }
  public putSecurityContext(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentSecurityContext) {
    this._securityContext.internalValue = value;
  }
  public resetSecurityContext() {
    this._securityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextInput() {
    return this._securityContext.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage {
  /**
  * Instructs dashboard to show the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#show DataK8SOrgEclipseCheCheClusterV2Manifest#show}
  */
  readonly show?: boolean | cdktf.IResolvable;
  /**
  * Warning message displayed on the user dashboard.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#text DataK8SOrgEclipseCheCheClusterV2Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    show: cdktf.booleanToTerraform(struct!.show),
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    show: {
      value: cdktf.booleanToHclTerraform(struct!.show),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._show !== undefined) {
      hasAnyValues = true;
      internalValueResult.show = this._show;
    }
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._show = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._show = value.show;
      this._text = value.text;
    }
  }

  // show - computed: false, optional: true, required: false
  private _show?: boolean | cdktf.IResolvable; 
  public get show() {
    return this.getBooleanAttribute('show');
  }
  public set show(value: boolean | cdktf.IResolvable) {
    this._show = value;
  }
  public resetShow() {
    this._show = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showInput() {
    return this._show;
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard {
  /**
  * Dashboard branding resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#branding DataK8SOrgEclipseCheCheClusterV2Manifest#branding}
  */
  readonly branding?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding;
  /**
  * Deployment override options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment DataK8SOrgEclipseCheCheClusterV2Manifest#deployment}
  */
  readonly deployment?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment;
  /**
  * Dashboard header message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#header_message DataK8SOrgEclipseCheCheClusterV2Manifest#header_message}
  */
  readonly headerMessage?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage;
  /**
  * The log level for the Dashboard.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#log_level DataK8SOrgEclipseCheCheClusterV2Manifest#log_level}
  */
  readonly logLevel?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    branding: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingToTerraform(struct!.branding),
    deployment: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentToTerraform(struct!.deployment),
    header_message: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessageToTerraform(struct!.headerMessage),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    branding: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingToHclTerraform(struct!.branding),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding",
    },
    deployment: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment",
    },
    header_message: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessageToHclTerraform(struct!.headerMessage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._branding?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.branding = this._branding?.internalValue;
    }
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    if (this._headerMessage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerMessage = this._headerMessage?.internalValue;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._branding.internalValue = undefined;
      this._deployment.internalValue = undefined;
      this._headerMessage.internalValue = undefined;
      this._logLevel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._branding.internalValue = value.branding;
      this._deployment.internalValue = value.deployment;
      this._headerMessage.internalValue = value.headerMessage;
      this._logLevel = value.logLevel;
    }
  }

  // branding - computed: false, optional: true, required: false
  private _branding = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBrandingOutputReference(this, "branding");
  public get branding() {
    return this._branding;
  }
  public putBranding(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardBranding) {
    this._branding.internalValue = value;
  }
  public resetBranding() {
    this._branding.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brandingInput() {
    return this._branding.internalValue;
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }

  // header_message - computed: false, optional: true, required: false
  private _headerMessage = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessageOutputReference(this, "header_message");
  public get headerMessage() {
    return this._headerMessage;
  }
  public putHeaderMessage(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardHeaderMessage) {
    this._headerMessage.internalValue = value;
  }
  public resetHeaderMessage() {
    this._headerMessage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerMessageInput() {
    return this._headerMessage.internalValue;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace {
  /**
  * Deprecated in favor of 'MaxNumberOfRunningWorkspacesPerUser' The maximum number of running workspaces per user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#running_limit DataK8SOrgEclipseCheCheClusterV2Manifest#running_limit}
  */
  readonly runningLimit?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspaceToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    running_limit: cdktf.stringToTerraform(struct!.runningLimit),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspaceToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    running_limit: {
      value: cdktf.stringToHclTerraform(struct!.runningLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._runningLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.runningLimit = this._runningLimit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._runningLimit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._runningLimit = value.runningLimit;
    }
  }

  // running_limit - computed: false, optional: true, required: false
  private _runningLimit?: string; 
  public get runningLimit() {
    return this.getStringAttribute('running_limit');
  }
  public set runningLimit(value: string) {
    this._runningLimit = value;
  }
  public resetRunningLimit() {
    this._runningLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runningLimitInput() {
    return this._runningLimit;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#api_version DataK8SOrgEclipseCheCheClusterV2Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_path DataK8SOrgEclipseCheCheClusterV2Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_name DataK8SOrgEclipseCheCheClusterV2Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#divisor DataK8SOrgEclipseCheCheClusterV2Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource DataK8SOrgEclipseCheCheClusterV2Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value_from DataK8SOrgEclipseCheCheClusterV2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources {
  /**
  * Describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#limits DataK8SOrgEclipseCheCheClusterV2Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits;
  /**
  * Describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#request DataK8SOrgEclipseCheCheClusterV2Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers {
  /**
  * List of environment variables to set in the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv[] | cdktf.IResolvable;
  /**
  * Container image. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Image pull policy. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Container name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Compute resources required by this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resources DataK8SOrgEclipseCheCheClusterV2Manifest#resources}
  */
  readonly resources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    name: cdktf.stringToTerraform(struct!.name),
    resources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesToTerraform(struct!.resources),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._name = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._name = value.name;
      this._resources.internalValue = value.resources;
    }
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#fs_group DataK8SOrgEclipseCheCheClusterV2Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * The UID to run the entrypoint of the container process. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user}
  */
  readonly runAsUser?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContextToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContextToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._runAsUser = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._runAsUser = value.runAsUser;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#effect DataK8SOrgEclipseCheCheClusterV2Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#operator DataK8SOrgEclipseCheCheClusterV2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#toleration_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment {
  /**
  * List of containers belonging to the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#containers DataK8SOrgEclipseCheCheClusterV2Manifest#containers}
  */
  readonly containers?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers[] | cdktf.IResolvable;
  /**
  * The node selector limits the nodes that can run the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#node_selector DataK8SOrgEclipseCheCheClusterV2Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Security options the pod should run with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#security_context DataK8SOrgEclipseCheCheClusterV2Manifest#security_context}
  */
  readonly securityContext?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext;
  /**
  * The pod tolerations of the component pod limit where the pod can run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#tolerations DataK8SOrgEclipseCheCheClusterV2Manifest#tolerations}
  */
  readonly tolerations?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    containers: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersToTerraform, false)(struct!.containers),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    security_context: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContextToTerraform(struct!.securityContext),
    tolerations: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsToTerraform, false)(struct!.tolerations),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    containers: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersToHclTerraform, false)(struct!.containers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    security_context: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContextToHclTerraform(struct!.securityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containers = this._containers?.internalValue;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._securityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContext = this._securityContext?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containers.internalValue = undefined;
      this._nodeSelector = undefined;
      this._securityContext.internalValue = undefined;
      this._tolerations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containers.internalValue = value.containers;
      this._nodeSelector = value.nodeSelector;
      this._securityContext.internalValue = value.securityContext;
      this._tolerations.internalValue = value.tolerations;
    }
  }

  // containers - computed: false, optional: true, required: false
  private _containers = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainersList(this, "containers", false);
  public get containers() {
    return this._containers;
  }
  public putContainers(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentContainers[] | cdktf.IResolvable) {
    this._containers.internalValue = value;
  }
  public resetContainers() {
    this._containers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containersInput() {
    return this._containers.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // security_context - computed: false, optional: true, required: false
  private _securityContext = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContextOutputReference(this, "security_context");
  public get securityContext() {
    return this._securityContext;
  }
  public putSecurityContext(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentSecurityContext) {
    this._securityContext.internalValue = value;
  }
  public resetSecurityContext() {
    this._securityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextInput() {
    return this._securityContext.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries {
  /**
  * The public UR of the devfile registry that serves sample ready-to-use devfiles.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#url DataK8SOrgEclipseCheCheClusterV2Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry {
  /**
  * Deprecated deployment override options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment DataK8SOrgEclipseCheCheClusterV2Manifest#deployment}
  */
  readonly deployment?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment;
  /**
  * Disables internal devfile registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#disable_internal_registry DataK8SOrgEclipseCheCheClusterV2Manifest#disable_internal_registry}
  */
  readonly disableInternalRegistry?: boolean | cdktf.IResolvable;
  /**
  * External devfile registries serving sample ready-to-use devfiles.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#external_devfile_registries DataK8SOrgEclipseCheCheClusterV2Manifest#external_devfile_registries}
  */
  readonly externalDevfileRegistries?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentToTerraform(struct!.deployment),
    disable_internal_registry: cdktf.booleanToTerraform(struct!.disableInternalRegistry),
    external_devfile_registries: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesToTerraform, false)(struct!.externalDevfileRegistries),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment",
    },
    disable_internal_registry: {
      value: cdktf.booleanToHclTerraform(struct!.disableInternalRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    external_devfile_registries: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesToHclTerraform, false)(struct!.externalDevfileRegistries),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    if (this._disableInternalRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInternalRegistry = this._disableInternalRegistry;
    }
    if (this._externalDevfileRegistries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalDevfileRegistries = this._externalDevfileRegistries?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
      this._disableInternalRegistry = undefined;
      this._externalDevfileRegistries.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
      this._disableInternalRegistry = value.disableInternalRegistry;
      this._externalDevfileRegistries.internalValue = value.externalDevfileRegistries;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }

  // disable_internal_registry - computed: false, optional: true, required: false
  private _disableInternalRegistry?: boolean | cdktf.IResolvable; 
  public get disableInternalRegistry() {
    return this.getBooleanAttribute('disable_internal_registry');
  }
  public set disableInternalRegistry(value: boolean | cdktf.IResolvable) {
    this._disableInternalRegistry = value;
  }
  public resetDisableInternalRegistry() {
    this._disableInternalRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInternalRegistryInput() {
    return this._disableInternalRegistry;
  }

  // external_devfile_registries - computed: false, optional: true, required: false
  private _externalDevfileRegistries = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistriesList(this, "external_devfile_registries", false);
  public get externalDevfileRegistries() {
    return this._externalDevfileRegistries;
  }
  public putExternalDevfileRegistries(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryExternalDevfileRegistries[] | cdktf.IResolvable) {
    this._externalDevfileRegistries.internalValue = value;
  }
  public resetExternalDevfileRegistries() {
    this._externalDevfileRegistries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalDevfileRegistriesInput() {
    return this._externalDevfileRegistries.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#affinity DataK8SOrgEclipseCheCheClusterV2Manifest#affinity}
  */
  readonly affinity?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#caching_cpu_limit DataK8SOrgEclipseCheCheClusterV2Manifest#caching_cpu_limit}
  */
  readonly cachingCpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#caching_cpu_request DataK8SOrgEclipseCheCheClusterV2Manifest#caching_cpu_request}
  */
  readonly cachingCpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#caching_interval_hours DataK8SOrgEclipseCheCheClusterV2Manifest#caching_interval_hours}
  */
  readonly cachingIntervalHours?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#caching_memory_limit DataK8SOrgEclipseCheCheClusterV2Manifest#caching_memory_limit}
  */
  readonly cachingMemoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#caching_memory_request DataK8SOrgEclipseCheCheClusterV2Manifest#caching_memory_request}
  */
  readonly cachingMemoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_name DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_name}
  */
  readonly configMapName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#daemonset_name DataK8SOrgEclipseCheCheClusterV2Manifest#daemonset_name}
  */
  readonly daemonsetName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment_name DataK8SOrgEclipseCheCheClusterV2Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_secrets DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_secrets}
  */
  readonly imagePullSecrets?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_puller_image DataK8SOrgEclipseCheCheClusterV2Manifest#image_puller_image}
  */
  readonly imagePullerImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#images DataK8SOrgEclipseCheCheClusterV2Manifest#images}
  */
  readonly images?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#node_selector DataK8SOrgEclipseCheCheClusterV2Manifest#node_selector}
  */
  readonly nodeSelector?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpecToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    affinity: cdktf.stringToTerraform(struct!.affinity),
    caching_cpu_limit: cdktf.stringToTerraform(struct!.cachingCpuLimit),
    caching_cpu_request: cdktf.stringToTerraform(struct!.cachingCpuRequest),
    caching_interval_hours: cdktf.stringToTerraform(struct!.cachingIntervalHours),
    caching_memory_limit: cdktf.stringToTerraform(struct!.cachingMemoryLimit),
    caching_memory_request: cdktf.stringToTerraform(struct!.cachingMemoryRequest),
    config_map_name: cdktf.stringToTerraform(struct!.configMapName),
    daemonset_name: cdktf.stringToTerraform(struct!.daemonsetName),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    image_pull_secrets: cdktf.stringToTerraform(struct!.imagePullSecrets),
    image_puller_image: cdktf.stringToTerraform(struct!.imagePullerImage),
    images: cdktf.stringToTerraform(struct!.images),
    node_selector: cdktf.stringToTerraform(struct!.nodeSelector),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpecToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    affinity: {
      value: cdktf.stringToHclTerraform(struct!.affinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cachingCpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cachingCpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_interval_hours: {
      value: cdktf.stringToHclTerraform(struct!.cachingIntervalHours),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.cachingMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_memory_request: {
      value: cdktf.stringToHclTerraform(struct!.cachingMemoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    config_map_name: {
      value: cdktf.stringToHclTerraform(struct!.configMapName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    daemonset_name: {
      value: cdktf.stringToHclTerraform(struct!.daemonsetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secrets: {
      value: cdktf.stringToHclTerraform(struct!.imagePullSecrets),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_puller_image: {
      value: cdktf.stringToHclTerraform(struct!.imagePullerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    images: {
      value: cdktf.stringToHclTerraform(struct!.images),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_selector: {
      value: cdktf.stringToHclTerraform(struct!.nodeSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._affinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity;
    }
    if (this._cachingCpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingCpuLimit = this._cachingCpuLimit;
    }
    if (this._cachingCpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingCpuRequest = this._cachingCpuRequest;
    }
    if (this._cachingIntervalHours !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingIntervalHours = this._cachingIntervalHours;
    }
    if (this._cachingMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingMemoryLimit = this._cachingMemoryLimit;
    }
    if (this._cachingMemoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingMemoryRequest = this._cachingMemoryRequest;
    }
    if (this._configMapName !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapName = this._configMapName;
    }
    if (this._daemonsetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.daemonsetName = this._daemonsetName;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._imagePullSecrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecrets = this._imagePullSecrets;
    }
    if (this._imagePullerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullerImage = this._imagePullerImage;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._affinity = undefined;
      this._cachingCpuLimit = undefined;
      this._cachingCpuRequest = undefined;
      this._cachingIntervalHours = undefined;
      this._cachingMemoryLimit = undefined;
      this._cachingMemoryRequest = undefined;
      this._configMapName = undefined;
      this._daemonsetName = undefined;
      this._deploymentName = undefined;
      this._imagePullSecrets = undefined;
      this._imagePullerImage = undefined;
      this._images = undefined;
      this._nodeSelector = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._affinity = value.affinity;
      this._cachingCpuLimit = value.cachingCpuLimit;
      this._cachingCpuRequest = value.cachingCpuRequest;
      this._cachingIntervalHours = value.cachingIntervalHours;
      this._cachingMemoryLimit = value.cachingMemoryLimit;
      this._cachingMemoryRequest = value.cachingMemoryRequest;
      this._configMapName = value.configMapName;
      this._daemonsetName = value.daemonsetName;
      this._deploymentName = value.deploymentName;
      this._imagePullSecrets = value.imagePullSecrets;
      this._imagePullerImage = value.imagePullerImage;
      this._images = value.images;
      this._nodeSelector = value.nodeSelector;
    }
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity?: string; 
  public get affinity() {
    return this.getStringAttribute('affinity');
  }
  public set affinity(value: string) {
    this._affinity = value;
  }
  public resetAffinity() {
    this._affinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity;
  }

  // caching_cpu_limit - computed: false, optional: true, required: false
  private _cachingCpuLimit?: string; 
  public get cachingCpuLimit() {
    return this.getStringAttribute('caching_cpu_limit');
  }
  public set cachingCpuLimit(value: string) {
    this._cachingCpuLimit = value;
  }
  public resetCachingCpuLimit() {
    this._cachingCpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingCpuLimitInput() {
    return this._cachingCpuLimit;
  }

  // caching_cpu_request - computed: false, optional: true, required: false
  private _cachingCpuRequest?: string; 
  public get cachingCpuRequest() {
    return this.getStringAttribute('caching_cpu_request');
  }
  public set cachingCpuRequest(value: string) {
    this._cachingCpuRequest = value;
  }
  public resetCachingCpuRequest() {
    this._cachingCpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingCpuRequestInput() {
    return this._cachingCpuRequest;
  }

  // caching_interval_hours - computed: false, optional: true, required: false
  private _cachingIntervalHours?: string; 
  public get cachingIntervalHours() {
    return this.getStringAttribute('caching_interval_hours');
  }
  public set cachingIntervalHours(value: string) {
    this._cachingIntervalHours = value;
  }
  public resetCachingIntervalHours() {
    this._cachingIntervalHours = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingIntervalHoursInput() {
    return this._cachingIntervalHours;
  }

  // caching_memory_limit - computed: false, optional: true, required: false
  private _cachingMemoryLimit?: string; 
  public get cachingMemoryLimit() {
    return this.getStringAttribute('caching_memory_limit');
  }
  public set cachingMemoryLimit(value: string) {
    this._cachingMemoryLimit = value;
  }
  public resetCachingMemoryLimit() {
    this._cachingMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingMemoryLimitInput() {
    return this._cachingMemoryLimit;
  }

  // caching_memory_request - computed: false, optional: true, required: false
  private _cachingMemoryRequest?: string; 
  public get cachingMemoryRequest() {
    return this.getStringAttribute('caching_memory_request');
  }
  public set cachingMemoryRequest(value: string) {
    this._cachingMemoryRequest = value;
  }
  public resetCachingMemoryRequest() {
    this._cachingMemoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingMemoryRequestInput() {
    return this._cachingMemoryRequest;
  }

  // config_map_name - computed: false, optional: true, required: false
  private _configMapName?: string; 
  public get configMapName() {
    return this.getStringAttribute('config_map_name');
  }
  public set configMapName(value: string) {
    this._configMapName = value;
  }
  public resetConfigMapName() {
    this._configMapName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapNameInput() {
    return this._configMapName;
  }

  // daemonset_name - computed: false, optional: true, required: false
  private _daemonsetName?: string; 
  public get daemonsetName() {
    return this.getStringAttribute('daemonset_name');
  }
  public set daemonsetName(value: string) {
    this._daemonsetName = value;
  }
  public resetDaemonsetName() {
    this._daemonsetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get daemonsetNameInput() {
    return this._daemonsetName;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // image_pull_secrets - computed: false, optional: true, required: false
  private _imagePullSecrets?: string; 
  public get imagePullSecrets() {
    return this.getStringAttribute('image_pull_secrets');
  }
  public set imagePullSecrets(value: string) {
    this._imagePullSecrets = value;
  }
  public resetImagePullSecrets() {
    this._imagePullSecrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretsInput() {
    return this._imagePullSecrets;
  }

  // image_puller_image - computed: false, optional: true, required: false
  private _imagePullerImage?: string; 
  public get imagePullerImage() {
    return this.getStringAttribute('image_puller_image');
  }
  public set imagePullerImage(value: string) {
    this._imagePullerImage = value;
  }
  public resetImagePullerImage() {
    this._imagePullerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullerImageInput() {
    return this._imagePullerImage;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string; 
  public get images() {
    return this.getStringAttribute('images');
  }
  public set images(value: string) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: string; 
  public get nodeSelector() {
    return this.getStringAttribute('node_selector');
  }
  public set nodeSelector(value: string) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller {
  /**
  * Install and configure the community supported Kubernetes Image Puller Operator. When you set the value to 'true' without providing any specs, it creates a default Kubernetes Image Puller object managed by the Operator. When you set the value to 'false', the Kubernetes Image Puller object is deleted, and the Operator uninstalled, regardless of whether a spec is provided. If you leave the 'spec.images' field empty, a set of recommended workspace-related images is automatically detected and pre-pulled after installation. Note that while this Operator and its behavior is community-supported, its payload may be commercially-supported for pulling commercially-supported images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#enable DataK8SOrgEclipseCheCheClusterV2Manifest#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * A Kubernetes Image Puller spec to configure the image puller in the CheCluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#spec DataK8SOrgEclipseCheCheClusterV2Manifest#spec}
  */
  readonly spec?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    spec: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpecToTerraform(struct!.spec),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    spec: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._spec.internalValue = value.spec;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics {
  /**
  * Enables 'metrics' for the Che server endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#enable DataK8SOrgEclipseCheCheClusterV2Manifest#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetricsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetricsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#api_version DataK8SOrgEclipseCheCheClusterV2Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_path DataK8SOrgEclipseCheCheClusterV2Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_name DataK8SOrgEclipseCheCheClusterV2Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#divisor DataK8SOrgEclipseCheCheClusterV2Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource DataK8SOrgEclipseCheCheClusterV2Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value_from DataK8SOrgEclipseCheCheClusterV2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources {
  /**
  * Describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#limits DataK8SOrgEclipseCheCheClusterV2Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits;
  /**
  * Describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#request DataK8SOrgEclipseCheCheClusterV2Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers {
  /**
  * List of environment variables to set in the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv[] | cdktf.IResolvable;
  /**
  * Container image. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Image pull policy. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Container name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Compute resources required by this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resources DataK8SOrgEclipseCheCheClusterV2Manifest#resources}
  */
  readonly resources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    name: cdktf.stringToTerraform(struct!.name),
    resources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesToTerraform(struct!.resources),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._name = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._name = value.name;
      this._resources.internalValue = value.resources;
    }
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#fs_group DataK8SOrgEclipseCheCheClusterV2Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * The UID to run the entrypoint of the container process. The default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user}
  */
  readonly runAsUser?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContextToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContextToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._runAsUser = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._runAsUser = value.runAsUser;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#effect DataK8SOrgEclipseCheCheClusterV2Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#operator DataK8SOrgEclipseCheCheClusterV2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#toleration_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment {
  /**
  * List of containers belonging to the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#containers DataK8SOrgEclipseCheCheClusterV2Manifest#containers}
  */
  readonly containers?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers[] | cdktf.IResolvable;
  /**
  * The node selector limits the nodes that can run the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#node_selector DataK8SOrgEclipseCheCheClusterV2Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Security options the pod should run with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#security_context DataK8SOrgEclipseCheCheClusterV2Manifest#security_context}
  */
  readonly securityContext?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext;
  /**
  * The pod tolerations of the component pod limit where the pod can run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#tolerations DataK8SOrgEclipseCheCheClusterV2Manifest#tolerations}
  */
  readonly tolerations?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    containers: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersToTerraform, false)(struct!.containers),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    security_context: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContextToTerraform(struct!.securityContext),
    tolerations: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsToTerraform, false)(struct!.tolerations),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    containers: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersToHclTerraform, false)(struct!.containers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    security_context: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContextToHclTerraform(struct!.securityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containers = this._containers?.internalValue;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._securityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContext = this._securityContext?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containers.internalValue = undefined;
      this._nodeSelector = undefined;
      this._securityContext.internalValue = undefined;
      this._tolerations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containers.internalValue = value.containers;
      this._nodeSelector = value.nodeSelector;
      this._securityContext.internalValue = value.securityContext;
      this._tolerations.internalValue = value.tolerations;
    }
  }

  // containers - computed: false, optional: true, required: false
  private _containers = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainersList(this, "containers", false);
  public get containers() {
    return this._containers;
  }
  public putContainers(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentContainers[] | cdktf.IResolvable) {
    this._containers.internalValue = value;
  }
  public resetContainers() {
    this._containers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containersInput() {
    return this._containers.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // security_context - computed: false, optional: true, required: false
  private _securityContext = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContextOutputReference(this, "security_context");
  public get securityContext() {
    return this._securityContext;
  }
  public putSecurityContext(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentSecurityContext) {
    this._securityContext.internalValue = value;
  }
  public resetSecurityContext() {
    this._securityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextInput() {
    return this._securityContext.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries {
  /**
  * Public URL of the plug-in registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#url DataK8SOrgEclipseCheCheClusterV2Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry {
  /**
  * Deployment override options.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment DataK8SOrgEclipseCheCheClusterV2Manifest#deployment}
  */
  readonly deployment?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment;
  /**
  * Disables internal plug-in registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#disable_internal_registry DataK8SOrgEclipseCheCheClusterV2Manifest#disable_internal_registry}
  */
  readonly disableInternalRegistry?: boolean | cdktf.IResolvable;
  /**
  * External plugin registries.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#external_plugin_registries DataK8SOrgEclipseCheCheClusterV2Manifest#external_plugin_registries}
  */
  readonly externalPluginRegistries?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries[] | cdktf.IResolvable;
  /**
  * Open VSX registry URL. If omitted an embedded instance will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#open_vsx_url DataK8SOrgEclipseCheCheClusterV2Manifest#open_vsx_url}
  */
  readonly openVsxUrl?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentToTerraform(struct!.deployment),
    disable_internal_registry: cdktf.booleanToTerraform(struct!.disableInternalRegistry),
    external_plugin_registries: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesToTerraform, false)(struct!.externalPluginRegistries),
    open_vsx_url: cdktf.stringToTerraform(struct!.openVsxUrl),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentToHclTerraform(struct!.deployment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment",
    },
    disable_internal_registry: {
      value: cdktf.booleanToHclTerraform(struct!.disableInternalRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    external_plugin_registries: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesToHclTerraform, false)(struct!.externalPluginRegistries),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesList",
    },
    open_vsx_url: {
      value: cdktf.stringToHclTerraform(struct!.openVsxUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment?.internalValue;
    }
    if (this._disableInternalRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInternalRegistry = this._disableInternalRegistry;
    }
    if (this._externalPluginRegistries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalPluginRegistries = this._externalPluginRegistries?.internalValue;
    }
    if (this._openVsxUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.openVsxUrl = this._openVsxUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment.internalValue = undefined;
      this._disableInternalRegistry = undefined;
      this._externalPluginRegistries.internalValue = undefined;
      this._openVsxUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment.internalValue = value.deployment;
      this._disableInternalRegistry = value.disableInternalRegistry;
      this._externalPluginRegistries.internalValue = value.externalPluginRegistries;
      this._openVsxUrl = value.openVsxUrl;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeploymentOutputReference(this, "deployment");
  public get deployment() {
    return this._deployment;
  }
  public putDeployment(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryDeployment) {
    this._deployment.internalValue = value;
  }
  public resetDeployment() {
    this._deployment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment.internalValue;
  }

  // disable_internal_registry - computed: false, optional: true, required: false
  private _disableInternalRegistry?: boolean | cdktf.IResolvable; 
  public get disableInternalRegistry() {
    return this.getBooleanAttribute('disable_internal_registry');
  }
  public set disableInternalRegistry(value: boolean | cdktf.IResolvable) {
    this._disableInternalRegistry = value;
  }
  public resetDisableInternalRegistry() {
    this._disableInternalRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInternalRegistryInput() {
    return this._disableInternalRegistry;
  }

  // external_plugin_registries - computed: false, optional: true, required: false
  private _externalPluginRegistries = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistriesList(this, "external_plugin_registries", false);
  public get externalPluginRegistries() {
    return this._externalPluginRegistries;
  }
  public putExternalPluginRegistries(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryExternalPluginRegistries[] | cdktf.IResolvable) {
    this._externalPluginRegistries.internalValue = value;
  }
  public resetExternalPluginRegistries() {
    this._externalPluginRegistries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalPluginRegistriesInput() {
    return this._externalPluginRegistries.internalValue;
  }

  // open_vsx_url - computed: false, optional: true, required: false
  private _openVsxUrl?: string; 
  public get openVsxUrl() {
    return this.getStringAttribute('open_vsx_url');
  }
  public set openVsxUrl(value: string) {
    this._openVsxUrl = value;
  }
  public resetOpenVsxUrl() {
    this._openVsxUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openVsxUrlInput() {
    return this._openVsxUrl;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponents {
  /**
  * General configuration settings related to the Che server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#che_server DataK8SOrgEclipseCheCheClusterV2Manifest#che_server}
  */
  readonly cheServer?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer;
  /**
  * Configuration settings related to the dashboard used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#dashboard DataK8SOrgEclipseCheCheClusterV2Manifest#dashboard}
  */
  readonly dashboard?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard;
  /**
  * DevWorkspace Operator configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#dev_workspace DataK8SOrgEclipseCheCheClusterV2Manifest#dev_workspace}
  */
  readonly devWorkspace?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace;
  /**
  * Configuration settings related to the devfile registry used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#devfile_registry DataK8SOrgEclipseCheCheClusterV2Manifest#devfile_registry}
  */
  readonly devfileRegistry?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry;
  /**
  * Kubernetes Image Puller configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_puller DataK8SOrgEclipseCheCheClusterV2Manifest#image_puller}
  */
  readonly imagePuller?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller;
  /**
  * Che server metrics configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#metrics DataK8SOrgEclipseCheCheClusterV2Manifest#metrics}
  */
  readonly metrics?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics;
  /**
  * Configuration settings related to the plug-in registry used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#plugin_registry DataK8SOrgEclipseCheCheClusterV2Manifest#plugin_registry}
  */
  readonly pluginRegistry?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    che_server: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerToTerraform(struct!.cheServer),
    dashboard: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardToTerraform(struct!.dashboard),
    dev_workspace: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspaceToTerraform(struct!.devWorkspace),
    devfile_registry: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryToTerraform(struct!.devfileRegistry),
    image_puller: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerToTerraform(struct!.imagePuller),
    metrics: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetricsToTerraform(struct!.metrics),
    plugin_registry: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryToTerraform(struct!.pluginRegistry),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    che_server: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerToHclTerraform(struct!.cheServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer",
    },
    dashboard: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardToHclTerraform(struct!.dashboard),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard",
    },
    dev_workspace: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspaceToHclTerraform(struct!.devWorkspace),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace",
    },
    devfile_registry: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryToHclTerraform(struct!.devfileRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry",
    },
    image_puller: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerToHclTerraform(struct!.imagePuller),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller",
    },
    metrics: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics",
    },
    plugin_registry: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryToHclTerraform(struct!.pluginRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cheServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheServer = this._cheServer?.internalValue;
    }
    if (this._dashboard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboard = this._dashboard?.internalValue;
    }
    if (this._devWorkspace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devWorkspace = this._devWorkspace?.internalValue;
    }
    if (this._devfileRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistry = this._devfileRegistry?.internalValue;
    }
    if (this._imagePuller?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePuller = this._imagePuller?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._pluginRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistry = this._pluginRegistry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cheServer.internalValue = undefined;
      this._dashboard.internalValue = undefined;
      this._devWorkspace.internalValue = undefined;
      this._devfileRegistry.internalValue = undefined;
      this._imagePuller.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._pluginRegistry.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cheServer.internalValue = value.cheServer;
      this._dashboard.internalValue = value.dashboard;
      this._devWorkspace.internalValue = value.devWorkspace;
      this._devfileRegistry.internalValue = value.devfileRegistry;
      this._imagePuller.internalValue = value.imagePuller;
      this._metrics.internalValue = value.metrics;
      this._pluginRegistry.internalValue = value.pluginRegistry;
    }
  }

  // che_server - computed: false, optional: true, required: false
  private _cheServer = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServerOutputReference(this, "che_server");
  public get cheServer() {
    return this._cheServer;
  }
  public putCheServer(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsCheServer) {
    this._cheServer.internalValue = value;
  }
  public resetCheServer() {
    this._cheServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheServerInput() {
    return this._cheServer.internalValue;
  }

  // dashboard - computed: false, optional: true, required: false
  private _dashboard = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboardOutputReference(this, "dashboard");
  public get dashboard() {
    return this._dashboard;
  }
  public putDashboard(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDashboard) {
    this._dashboard.internalValue = value;
  }
  public resetDashboard() {
    this._dashboard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardInput() {
    return this._dashboard.internalValue;
  }

  // dev_workspace - computed: false, optional: true, required: false
  private _devWorkspace = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspaceOutputReference(this, "dev_workspace");
  public get devWorkspace() {
    return this._devWorkspace;
  }
  public putDevWorkspace(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevWorkspace) {
    this._devWorkspace.internalValue = value;
  }
  public resetDevWorkspace() {
    this._devWorkspace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devWorkspaceInput() {
    return this._devWorkspace.internalValue;
  }

  // devfile_registry - computed: false, optional: true, required: false
  private _devfileRegistry = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistryOutputReference(this, "devfile_registry");
  public get devfileRegistry() {
    return this._devfileRegistry;
  }
  public putDevfileRegistry(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsDevfileRegistry) {
    this._devfileRegistry.internalValue = value;
  }
  public resetDevfileRegistry() {
    this._devfileRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryInput() {
    return this._devfileRegistry.internalValue;
  }

  // image_puller - computed: false, optional: true, required: false
  private _imagePuller = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePullerOutputReference(this, "image_puller");
  public get imagePuller() {
    return this._imagePuller;
  }
  public putImagePuller(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsImagePuller) {
    this._imagePuller.internalValue = value;
  }
  public resetImagePuller() {
    this._imagePuller.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullerInput() {
    return this._imagePuller.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // plugin_registry - computed: false, optional: true, required: false
  private _pluginRegistry = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistryOutputReference(this, "plugin_registry");
  public get pluginRegistry() {
    return this._pluginRegistry;
  }
  public putPluginRegistry(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecComponentsPluginRegistry) {
    this._pluginRegistry.internalValue = value;
  }
  public resetPluginRegistry() {
    this._pluginRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryInput() {
    return this._pluginRegistry.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistry {
  /**
  * An optional hostname or URL of an alternative container registry to pull images from. This value overrides the container registry hostname defined in all the default container images involved in a Che deployment. This is particularly useful for installing Che in a restricted environment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#hostname DataK8SOrgEclipseCheCheClusterV2Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * An optional repository name of an alternative registry to pull images from. This value overrides the container registry organization defined in all the default container images involved in a Che deployment. This is particularly useful for installing Eclipse Che in a restricted environment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#organization DataK8SOrgEclipseCheCheClusterV2Manifest#organization}
  */
  readonly organization?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    organization: cdktf.stringToTerraform(struct!.organization),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization: {
      value: cdktf.stringToHclTerraform(struct!.organization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._organization !== undefined) {
      hasAnyValues = true;
      internalValueResult.organization = this._organization;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecContainerRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._organization = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._organization = value.organization;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // organization - computed: false, optional: true, required: false
  private _organization?: string; 
  public get organization() {
    return this.getStringAttribute('organization');
  }
  public set organization(value: string) {
    this._organization = value;
  }
  public resetOrganization() {
    this._organization = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationInput() {
    return this._organization;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources {
  /**
  * The list of approved URLs for starting Cloud Development Environments (CDEs). CDEs can only be initiated from these URLs. Wildcards '*' are supported in URLs, allowing flexible matching for specific URL patterns. For instance, 'https://example.com/*' would allow CDEs to be initiated from any path within 'example.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#urls DataK8SOrgEclipseCheCheClusterV2Manifest#urls}
  */
  readonly urls?: string[];
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    urls: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.urls),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    urls: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.urls),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._urls !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._urls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._urls = value.urls;
    }
  }

  // urls - computed: false, optional: true, required: false
  private _urls?: string[]; 
  public get urls() {
    return this.getListAttribute('urls');
  }
  public set urls(value: string[]) {
    this._urls = value;
  }
  public resetUrls() {
    this._urls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration {
  /**
  * OpenShift security context constraint to build containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#open_shift_security_context_constraint DataK8SOrgEclipseCheCheClusterV2Manifest#open_shift_security_context_constraint}
  */
  readonly openShiftSecurityContextConstraint?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfigurationToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    open_shift_security_context_constraint: cdktf.stringToTerraform(struct!.openShiftSecurityContextConstraint),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfigurationToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    open_shift_security_context_constraint: {
      value: cdktf.stringToHclTerraform(struct!.openShiftSecurityContextConstraint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._openShiftSecurityContextConstraint !== undefined) {
      hasAnyValues = true;
      internalValueResult.openShiftSecurityContextConstraint = this._openShiftSecurityContextConstraint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._openShiftSecurityContextConstraint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._openShiftSecurityContextConstraint = value.openShiftSecurityContextConstraint;
    }
  }

  // open_shift_security_context_constraint - computed: false, optional: true, required: false
  private _openShiftSecurityContextConstraint?: string; 
  public get openShiftSecurityContextConstraint() {
    return this.getStringAttribute('open_shift_security_context_constraint');
  }
  public set openShiftSecurityContextConstraint(value: string) {
    this._openShiftSecurityContextConstraint = value;
  }
  public resetOpenShiftSecurityContextConstraint() {
    this._openShiftSecurityContextConstraint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openShiftSecurityContextConstraintInput() {
    return this._openShiftSecurityContextConstraint;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation {
  /**
  * Annotations to be added to deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment DataK8SOrgEclipseCheCheClusterV2Manifest#deployment}
  */
  readonly deployment?: { [key: string]: string };
  /**
  * Annotations to be added to service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#service DataK8SOrgEclipseCheCheClusterV2Manifest#service}
  */
  readonly service?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotationToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deployment),
    service: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.service),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotationToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deployment),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.service),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment = value.deployment;
      this._service = value.service;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment?: { [key: string]: string }; 
  public get deployment() {
    return this.getStringMapAttribute('deployment');
  }
  public set deployment(value: { [key: string]: string }) {
    this._deployment = value;
  }
  public resetDeployment() {
    this._deployment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment;
  }

  // service - computed: false, optional: true, required: false
  private _service?: { [key: string]: string }; 
  public get service() {
    return this.getStringMapAttribute('service');
  }
  public set service(value: { [key: string]: string }) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exposure DataK8SOrgEclipseCheCheClusterV2Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#protocol DataK8SOrgEclipseCheCheClusterV2Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secure DataK8SOrgEclipseCheCheClusterV2Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#target_port DataK8SOrgEclipseCheCheClusterV2Manifest#target_port}
  */
  readonly targetPort: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: false, required: true
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts {
  /**
  * The volume mount name is the name of an existing 'Volume' component. If several containers mount the same volume name then they will reuse the same volume and will be able to access to the same files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * The path in the component container where the volume should be mounted. If not path is mentioned, default path is the is '/<name>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer {
  /**
  * Annotations that should be added to specific resources for this container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation;
  /**
  * The arguments to supply to the command running the dockerimage component. The arguments are supplied either to the default command provided in the image or to the overridden command. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#args DataK8SOrgEclipseCheCheClusterV2Manifest#args}
  */
  readonly args?: string[];
  /**
  * The command to run in the dockerimage component instead of the default one provided in the image. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#command DataK8SOrgEclipseCheCheClusterV2Manifest#command}
  */
  readonly command?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu_limit DataK8SOrgEclipseCheCheClusterV2Manifest#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu_request DataK8SOrgEclipseCheCheClusterV2Manifest#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Specify if a container should run in its own separated pod, instead of running as part of the main development environment pod. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#dedicated_pod DataK8SOrgEclipseCheCheClusterV2Manifest#dedicated_pod}
  */
  readonly dedicatedPod?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoints DataK8SOrgEclipseCheCheClusterV2Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints[] | cdktf.IResolvable;
  /**
  * Environment variables used in this container. The following variables are reserved and cannot be overridden via env: - '$PROJECTS_ROOT' - '$PROJECT_SOURCE'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory_limit DataK8SOrgEclipseCheCheClusterV2Manifest#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory_request DataK8SOrgEclipseCheCheClusterV2Manifest#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Toggles whether or not the project source code should be mounted in the component. Defaults to true for all component types except plugins and components that set 'dedicatedPod' to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#mount_sources DataK8SOrgEclipseCheCheClusterV2Manifest#mount_sources}
  */
  readonly mountSources?: boolean | cdktf.IResolvable;
  /**
  * Optional specification of the path in the container where project sources should be transferred/mounted when 'mountSources' is 'true'. When omitted, the default value of /projects is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#source_mapping DataK8SOrgEclipseCheCheClusterV2Manifest#source_mapping}
  */
  readonly sourceMapping?: string;
  /**
  * List of volumes mounts that should be mounted is this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#volume_mounts DataK8SOrgEclipseCheCheClusterV2Manifest#volume_mounts}
  */
  readonly volumeMounts?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotationToTerraform(struct!.annotation),
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    dedicated_pod: cdktf.booleanToTerraform(struct!.dedicatedPod),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsToTerraform, false)(struct!.endpoints),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    mount_sources: cdktf.booleanToTerraform(struct!.mountSources),
    source_mapping: cdktf.stringToTerraform(struct!.sourceMapping),
    volume_mounts: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsToTerraform, false)(struct!.volumeMounts),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotationToHclTerraform(struct!.annotation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation",
    },
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dedicated_pod: {
      value: cdktf.booleanToHclTerraform(struct!.dedicatedPod),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsList",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mount_sources: {
      value: cdktf.booleanToHclTerraform(struct!.mountSources),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source_mapping: {
      value: cdktf.stringToHclTerraform(struct!.sourceMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_mounts: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsToHclTerraform, false)(struct!.volumeMounts),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation?.internalValue;
    }
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._dedicatedPod !== undefined) {
      hasAnyValues = true;
      internalValueResult.dedicatedPod = this._dedicatedPod;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._mountSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountSources = this._mountSources;
    }
    if (this._sourceMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceMapping = this._sourceMapping;
    }
    if (this._volumeMounts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeMounts = this._volumeMounts?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation.internalValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._dedicatedPod = undefined;
      this._endpoints.internalValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._mountSources = undefined;
      this._sourceMapping = undefined;
      this._volumeMounts.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation.internalValue = value.annotation;
      this._args = value.args;
      this._command = value.command;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._dedicatedPod = value.dedicatedPod;
      this._endpoints.internalValue = value.endpoints;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._mountSources = value.mountSources;
      this._sourceMapping = value.sourceMapping;
      this._volumeMounts.internalValue = value.volumeMounts;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotationOutputReference(this, "annotation");
  public get annotation() {
    return this._annotation;
  }
  public putAnnotation(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerAnnotation) {
    this._annotation.internalValue = value;
  }
  public resetAnnotation() {
    this._annotation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation.internalValue;
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // dedicated_pod - computed: false, optional: true, required: false
  private _dedicatedPod?: boolean | cdktf.IResolvable; 
  public get dedicatedPod() {
    return this.getBooleanAttribute('dedicated_pod');
  }
  public set dedicatedPod(value: boolean | cdktf.IResolvable) {
    this._dedicatedPod = value;
  }
  public resetDedicatedPod() {
    this._dedicatedPod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dedicatedPodInput() {
    return this._dedicatedPod;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: false, required: true
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // mount_sources - computed: false, optional: true, required: false
  private _mountSources?: boolean | cdktf.IResolvable; 
  public get mountSources() {
    return this.getBooleanAttribute('mount_sources');
  }
  public set mountSources(value: boolean | cdktf.IResolvable) {
    this._mountSources = value;
  }
  public resetMountSources() {
    this._mountSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountSourcesInput() {
    return this._mountSources;
  }

  // source_mapping - computed: false, optional: true, required: false
  private _sourceMapping?: string; 
  public get sourceMapping() {
    return this.getStringAttribute('source_mapping');
  }
  public set sourceMapping(value: string) {
    this._sourceMapping = value;
  }
  public resetSourceMapping() {
    this._sourceMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceMappingInput() {
    return this._sourceMapping;
  }

  // volume_mounts - computed: false, optional: true, required: false
  private _volumeMounts = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMountsList(this, "volume_mounts", false);
  public get volumeMounts() {
    return this._volumeMounts;
  }
  public putVolumeMounts(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerVolumeMounts[] | cdktf.IResolvable) {
    this._volumeMounts.internalValue = value;
  }
  public resetVolumeMounts() {
    this._volumeMounts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeMountsInput() {
    return this._volumeMounts.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom {
  /**
  * Class of component that the associated implementation controller should use to process this command with the appropriate logic
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#component_class DataK8SOrgEclipseCheCheClusterV2Manifest#component_class}
  */
  readonly componentClass: string;
  /**
  * Additional free-form configuration for this custom component that the implementation controller will know how to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#embedded_resource DataK8SOrgEclipseCheCheClusterV2Manifest#embedded_resource}
  */
  readonly embeddedResource: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustomToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    component_class: cdktf.stringToTerraform(struct!.componentClass),
    embedded_resource: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.embeddedResource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustomToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    component_class: {
      value: cdktf.stringToHclTerraform(struct!.componentClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    embedded_resource: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.embeddedResource),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._componentClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.componentClass = this._componentClass;
    }
    if (this._embeddedResource !== undefined) {
      hasAnyValues = true;
      internalValueResult.embeddedResource = this._embeddedResource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._componentClass = undefined;
      this._embeddedResource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._componentClass = value.componentClass;
      this._embeddedResource = value.embeddedResource;
    }
  }

  // component_class - computed: false, optional: false, required: true
  private _componentClass?: string; 
  public get componentClass() {
    return this.getStringAttribute('component_class');
  }
  public set componentClass(value: string) {
    this._componentClass = value;
  }
  // Temporarily expose input value. Use with caution.
  public get componentClassInput() {
    return this._componentClass;
  }

  // embedded_resource - computed: false, optional: false, required: true
  private _embeddedResource?: { [key: string]: string }; 
  public get embeddedResource() {
    return this.getStringMapAttribute('embedded_resource');
  }
  public set embeddedResource(value: { [key: string]: string }) {
    this._embeddedResource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get embeddedResourceInput() {
    return this._embeddedResource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry {
  /**
  * Id in a devfile registry that contains a Dockerfile. The src in the OCI registry required for the Dockerfile build will be downloaded for building the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#id DataK8SOrgEclipseCheCheClusterV2Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Devfile Registry URL to pull the Dockerfile from when using the Devfile Registry as Dockerfile src. To ensure the Dockerfile gets resolved consistently in different environments, it is recommended to always specify the 'devfileRegistryUrl' when 'Id' is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#registry_url DataK8SOrgEclipseCheCheClusterV2Manifest#registry_url}
  */
  readonly registryUrl?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    registry_url: cdktf.stringToTerraform(struct!.registryUrl),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    registry_url: {
      value: cdktf.stringToHclTerraform(struct!.registryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._registryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryUrl = this._registryUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._registryUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._registryUrl = value.registryUrl;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // registry_url - computed: false, optional: true, required: false
  private _registryUrl?: string; 
  public get registryUrl() {
    return this.getStringAttribute('registry_url');
  }
  public set registryUrl(value: string) {
    this._registryUrl = value;
  }
  public resetRegistryUrl() {
    this._registryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryUrlInput() {
    return this._registryUrl;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom {
  /**
  * The remote name should be used as init. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#remote DataK8SOrgEclipseCheCheClusterV2Manifest#remote}
  */
  readonly remote?: string;
  /**
  * The revision to checkout from. Should be branch name, tag or commit id. Default branch is used if missing or specified revision is not found.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#revision DataK8SOrgEclipseCheCheClusterV2Manifest#revision}
  */
  readonly revision?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    remote: cdktf.stringToTerraform(struct!.remote),
    revision: cdktf.stringToTerraform(struct!.revision),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    remote: {
      value: cdktf.stringToHclTerraform(struct!.remote),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision: {
      value: cdktf.stringToHclTerraform(struct!.revision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._remote !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote;
    }
    if (this._revision !== undefined) {
      hasAnyValues = true;
      internalValueResult.revision = this._revision;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._remote = undefined;
      this._revision = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._remote = value.remote;
      this._revision = value.revision;
    }
  }

  // remote - computed: false, optional: true, required: false
  private _remote?: string; 
  public get remote() {
    return this.getStringAttribute('remote');
  }
  public set remote(value: string) {
    this._remote = value;
  }
  public resetRemote() {
    this._remote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote;
  }

  // revision - computed: false, optional: true, required: false
  private _revision?: string; 
  public get revision() {
    return this.getStringAttribute('revision');
  }
  public set revision(value: string) {
    this._revision = value;
  }
  public resetRevision() {
    this._revision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionInput() {
    return this._revision;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit {
  /**
  * Defines from what the project should be checked out. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#checkout_from DataK8SOrgEclipseCheCheClusterV2Manifest#checkout_from}
  */
  readonly checkoutFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom;
  /**
  * Location of the Dockerfile in the Git repository when using git as Dockerfile src. Defaults to Dockerfile.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#file_location DataK8SOrgEclipseCheCheClusterV2Manifest#file_location}
  */
  readonly fileLocation?: string;
  /**
  * The remotes map which should be initialized in the git project. Projects must have at least one remote configured while StarterProjects & Image Component's Git source can only have at most one remote configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#remotes DataK8SOrgEclipseCheCheClusterV2Manifest#remotes}
  */
  readonly remotes: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    checkout_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFromToTerraform(struct!.checkoutFrom),
    file_location: cdktf.stringToTerraform(struct!.fileLocation),
    remotes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remotes),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    checkout_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct!.checkoutFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom",
    },
    file_location: {
      value: cdktf.stringToHclTerraform(struct!.fileLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remotes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remotes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._checkoutFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkoutFrom = this._checkoutFrom?.internalValue;
    }
    if (this._fileLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileLocation = this._fileLocation;
    }
    if (this._remotes !== undefined) {
      hasAnyValues = true;
      internalValueResult.remotes = this._remotes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = undefined;
      this._fileLocation = undefined;
      this._remotes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = value.checkoutFrom;
      this._fileLocation = value.fileLocation;
      this._remotes = value.remotes;
    }
  }

  // checkout_from - computed: false, optional: true, required: false
  private _checkoutFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFromOutputReference(this, "checkout_from");
  public get checkoutFrom() {
    return this._checkoutFrom;
  }
  public putCheckoutFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitCheckoutFrom) {
    this._checkoutFrom.internalValue = value;
  }
  public resetCheckoutFrom() {
    this._checkoutFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkoutFromInput() {
    return this._checkoutFrom.internalValue;
  }

  // file_location - computed: false, optional: true, required: false
  private _fileLocation?: string; 
  public get fileLocation() {
    return this.getStringAttribute('file_location');
  }
  public set fileLocation(value: string) {
    this._fileLocation = value;
  }
  public resetFileLocation() {
    this._fileLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileLocationInput() {
    return this._fileLocation;
  }

  // remotes - computed: false, optional: false, required: true
  private _remotes?: { [key: string]: string }; 
  public get remotes() {
    return this.getStringMapAttribute('remotes');
  }
  public set remotes(value: { [key: string]: string }) {
    this._remotes = value;
  }
  // Temporarily expose input value. Use with caution.
  public get remotesInput() {
    return this._remotes;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile {
  /**
  * The arguments to supply to the dockerfile build.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#args DataK8SOrgEclipseCheCheClusterV2Manifest#args}
  */
  readonly args?: string[];
  /**
  * Path of source directory to establish build context. Defaults to ${PROJECT_SOURCE} in the container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#build_context DataK8SOrgEclipseCheCheClusterV2Manifest#build_context}
  */
  readonly buildContext?: string;
  /**
  * Dockerfile's Devfile Registry source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#devfile_registry DataK8SOrgEclipseCheCheClusterV2Manifest#devfile_registry}
  */
  readonly devfileRegistry?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry;
  /**
  * Dockerfile's Git source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#git DataK8SOrgEclipseCheCheClusterV2Manifest#git}
  */
  readonly git?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit;
  /**
  * Specify if a privileged builder pod is required. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#root_required DataK8SOrgEclipseCheCheClusterV2Manifest#root_required}
  */
  readonly rootRequired?: boolean | cdktf.IResolvable;
  /**
  * Type of Dockerfile src
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#src_type DataK8SOrgEclipseCheCheClusterV2Manifest#src_type}
  */
  readonly srcType?: string;
  /**
  * URI Reference of a Dockerfile. It can be a full URL or a relative URI from the current devfile as the base URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    build_context: cdktf.stringToTerraform(struct!.buildContext),
    devfile_registry: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistryToTerraform(struct!.devfileRegistry),
    git: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitToTerraform(struct!.git),
    root_required: cdktf.booleanToTerraform(struct!.rootRequired),
    src_type: cdktf.stringToTerraform(struct!.srcType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    build_context: {
      value: cdktf.stringToHclTerraform(struct!.buildContext),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistryToHclTerraform(struct!.devfileRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry",
    },
    git: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitToHclTerraform(struct!.git),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit",
    },
    root_required: {
      value: cdktf.booleanToHclTerraform(struct!.rootRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    src_type: {
      value: cdktf.stringToHclTerraform(struct!.srcType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._buildContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.buildContext = this._buildContext;
    }
    if (this._devfileRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistry = this._devfileRegistry?.internalValue;
    }
    if (this._git?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.git = this._git?.internalValue;
    }
    if (this._rootRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootRequired = this._rootRequired;
    }
    if (this._srcType !== undefined) {
      hasAnyValues = true;
      internalValueResult.srcType = this._srcType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._buildContext = undefined;
      this._devfileRegistry.internalValue = undefined;
      this._git.internalValue = undefined;
      this._rootRequired = undefined;
      this._srcType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._buildContext = value.buildContext;
      this._devfileRegistry.internalValue = value.devfileRegistry;
      this._git.internalValue = value.git;
      this._rootRequired = value.rootRequired;
      this._srcType = value.srcType;
      this._uri = value.uri;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // build_context - computed: false, optional: true, required: false
  private _buildContext?: string; 
  public get buildContext() {
    return this.getStringAttribute('build_context');
  }
  public set buildContext(value: string) {
    this._buildContext = value;
  }
  public resetBuildContext() {
    this._buildContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get buildContextInput() {
    return this._buildContext;
  }

  // devfile_registry - computed: false, optional: true, required: false
  private _devfileRegistry = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistryOutputReference(this, "devfile_registry");
  public get devfileRegistry() {
    return this._devfileRegistry;
  }
  public putDevfileRegistry(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileDevfileRegistry) {
    this._devfileRegistry.internalValue = value;
  }
  public resetDevfileRegistry() {
    this._devfileRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryInput() {
    return this._devfileRegistry.internalValue;
  }

  // git - computed: false, optional: true, required: false
  private _git = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGitOutputReference(this, "git");
  public get git() {
    return this._git;
  }
  public putGit(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileGit) {
    this._git.internalValue = value;
  }
  public resetGit() {
    this._git.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitInput() {
    return this._git.internalValue;
  }

  // root_required - computed: false, optional: true, required: false
  private _rootRequired?: boolean | cdktf.IResolvable; 
  public get rootRequired() {
    return this.getBooleanAttribute('root_required');
  }
  public set rootRequired(value: boolean | cdktf.IResolvable) {
    this._rootRequired = value;
  }
  public resetRootRequired() {
    this._rootRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootRequiredInput() {
    return this._rootRequired;
  }

  // src_type - computed: false, optional: true, required: false
  private _srcType?: string; 
  public get srcType() {
    return this.getStringAttribute('src_type');
  }
  public set srcType(value: string) {
    this._srcType = value;
  }
  public resetSrcType() {
    this._srcType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcTypeInput() {
    return this._srcType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage {
  /**
  * Defines if the image should be built during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#auto_build DataK8SOrgEclipseCheCheClusterV2Manifest#auto_build}
  */
  readonly autoBuild?: boolean | cdktf.IResolvable;
  /**
  * Allows specifying dockerfile type build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#dockerfile DataK8SOrgEclipseCheCheClusterV2Manifest#dockerfile}
  */
  readonly dockerfile?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile;
  /**
  * Name of the image for the resulting outerloop build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_name DataK8SOrgEclipseCheCheClusterV2Manifest#image_name}
  */
  readonly imageName: string;
  /**
  * Type of image
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_type DataK8SOrgEclipseCheCheClusterV2Manifest#image_type}
  */
  readonly imageType?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_build: cdktf.booleanToTerraform(struct!.autoBuild),
    dockerfile: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileToTerraform(struct!.dockerfile),
    image_name: cdktf.stringToTerraform(struct!.imageName),
    image_type: cdktf.stringToTerraform(struct!.imageType),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_build: {
      value: cdktf.booleanToHclTerraform(struct!.autoBuild),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dockerfile: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileToHclTerraform(struct!.dockerfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile",
    },
    image_name: {
      value: cdktf.stringToHclTerraform(struct!.imageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_type: {
      value: cdktf.stringToHclTerraform(struct!.imageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoBuild !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBuild = this._autoBuild;
    }
    if (this._dockerfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerfile = this._dockerfile?.internalValue;
    }
    if (this._imageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageName = this._imageName;
    }
    if (this._imageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageType = this._imageType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoBuild = undefined;
      this._dockerfile.internalValue = undefined;
      this._imageName = undefined;
      this._imageType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoBuild = value.autoBuild;
      this._dockerfile.internalValue = value.dockerfile;
      this._imageName = value.imageName;
      this._imageType = value.imageType;
    }
  }

  // auto_build - computed: false, optional: true, required: false
  private _autoBuild?: boolean | cdktf.IResolvable; 
  public get autoBuild() {
    return this.getBooleanAttribute('auto_build');
  }
  public set autoBuild(value: boolean | cdktf.IResolvable) {
    this._autoBuild = value;
  }
  public resetAutoBuild() {
    this._autoBuild = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBuildInput() {
    return this._autoBuild;
  }

  // dockerfile - computed: false, optional: true, required: false
  private _dockerfile = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfileOutputReference(this, "dockerfile");
  public get dockerfile() {
    return this._dockerfile;
  }
  public putDockerfile(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageDockerfile) {
    this._dockerfile.internalValue = value;
  }
  public resetDockerfile() {
    this._dockerfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerfileInput() {
    return this._dockerfile.internalValue;
  }

  // image_name - computed: false, optional: false, required: true
  private _imageName?: string; 
  public get imageName() {
    return this.getStringAttribute('image_name');
  }
  public set imageName(value: string) {
    this._imageName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageNameInput() {
    return this._imageName;
  }

  // image_type - computed: false, optional: true, required: false
  private _imageType?: string; 
  public get imageType() {
    return this.getStringAttribute('image_type');
  }
  public set imageType(value: string) {
    this._imageType = value;
  }
  public resetImageType() {
    this._imageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageTypeInput() {
    return this._imageType;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exposure DataK8SOrgEclipseCheCheClusterV2Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#protocol DataK8SOrgEclipseCheCheClusterV2Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secure DataK8SOrgEclipseCheCheClusterV2Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#target_port DataK8SOrgEclipseCheCheClusterV2Manifest#target_port}
  */
  readonly targetPort: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: false, required: true
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV2Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoints DataK8SOrgEclipseCheCheClusterV2Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#inlined DataK8SOrgEclipseCheCheClusterV2Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#location_type DataK8SOrgEclipseCheCheClusterV2Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exposure DataK8SOrgEclipseCheCheClusterV2Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#protocol DataK8SOrgEclipseCheCheClusterV2Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secure DataK8SOrgEclipseCheCheClusterV2Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#target_port DataK8SOrgEclipseCheCheClusterV2Manifest#target_port}
  */
  readonly targetPort: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: false, required: true
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV2Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoints DataK8SOrgEclipseCheCheClusterV2Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#inlined DataK8SOrgEclipseCheCheClusterV2Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#location_type DataK8SOrgEclipseCheCheClusterV2Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup {
  /**
  * Identifies the default command for a given group kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#is_default DataK8SOrgEclipseCheCheClusterV2Manifest#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Kind of group the command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#kind DataK8SOrgEclipseCheCheClusterV2Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroupToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroupToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._kind = value.kind;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply {
  /**
  * Describes component that will be applied
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#component DataK8SOrgEclipseCheCheClusterV2Manifest#component}
  */
  readonly component?: string;
  /**
  * Defines the group this command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#group DataK8SOrgEclipseCheCheClusterV2Manifest#group}
  */
  readonly group?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup;
  /**
  * Optional label that provides a label for this command to be used in Editor UI menus for example
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#label DataK8SOrgEclipseCheCheClusterV2Manifest#label}
  */
  readonly label?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    component: cdktf.stringToTerraform(struct!.component),
    group: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroupToTerraform(struct!.group),
    label: cdktf.stringToTerraform(struct!.label),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    component: {
      value: cdktf.stringToHclTerraform(struct!.component),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._component !== undefined) {
      hasAnyValues = true;
      internalValueResult.component = this._component;
    }
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._component = undefined;
      this._group.internalValue = undefined;
      this._label = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._component = value.component;
      this._group.internalValue = value.group;
      this._label = value.label;
    }
  }

  // component - computed: false, optional: true, required: false
  private _component?: string; 
  public get component() {
    return this.getStringAttribute('component');
  }
  public set component(value: string) {
    this._component = value;
  }
  public resetComponent() {
    this._component = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentInput() {
    return this._component;
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup {
  /**
  * Identifies the default command for a given group kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#is_default DataK8SOrgEclipseCheCheClusterV2Manifest#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Kind of group the command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#kind DataK8SOrgEclipseCheCheClusterV2Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroupToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroupToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._kind = value.kind;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite {
  /**
  * The commands that comprise this composite command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#commands DataK8SOrgEclipseCheCheClusterV2Manifest#commands}
  */
  readonly commands?: string[];
  /**
  * Defines the group this command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#group DataK8SOrgEclipseCheCheClusterV2Manifest#group}
  */
  readonly group?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup;
  /**
  * Optional label that provides a label for this command to be used in Editor UI menus for example
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#label DataK8SOrgEclipseCheCheClusterV2Manifest#label}
  */
  readonly label?: string;
  /**
  * Indicates if the sub-commands should be executed concurrently
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#parallel DataK8SOrgEclipseCheCheClusterV2Manifest#parallel}
  */
  readonly parallel?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commands: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.commands),
    group: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroupToTerraform(struct!.group),
    label: cdktf.stringToTerraform(struct!.label),
    parallel: cdktf.booleanToTerraform(struct!.parallel),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commands: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.commands),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parallel: {
      value: cdktf.booleanToHclTerraform(struct!.parallel),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commands !== undefined) {
      hasAnyValues = true;
      internalValueResult.commands = this._commands;
    }
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._parallel !== undefined) {
      hasAnyValues = true;
      internalValueResult.parallel = this._parallel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commands = undefined;
      this._group.internalValue = undefined;
      this._label = undefined;
      this._parallel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commands = value.commands;
      this._group.internalValue = value.group;
      this._label = value.label;
      this._parallel = value.parallel;
    }
  }

  // commands - computed: false, optional: true, required: false
  private _commands?: string[]; 
  public get commands() {
    return this.getListAttribute('commands');
  }
  public set commands(value: string[]) {
    this._commands = value;
  }
  public resetCommands() {
    this._commands = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandsInput() {
    return this._commands;
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // parallel - computed: false, optional: true, required: false
  private _parallel?: boolean | cdktf.IResolvable; 
  public get parallel() {
    return this.getBooleanAttribute('parallel');
  }
  public set parallel(value: boolean | cdktf.IResolvable) {
    this._parallel = value;
  }
  public resetParallel() {
    this._parallel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parallelInput() {
    return this._parallel;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup {
  /**
  * Identifies the default command for a given group kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#is_default DataK8SOrgEclipseCheCheClusterV2Manifest#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Kind of group the command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#kind DataK8SOrgEclipseCheCheClusterV2Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroupToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroupToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._kind = value.kind;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec {
  /**
  * The actual command-line string Special variables that can be used: - '$PROJECTS_ROOT': A path where projects sources are mounted as defined by container component's sourceMapping. - '$PROJECT_SOURCE': A path to a project source ($PROJECTS_ROOT/<project-name>). If there are multiple projects, this will point to the directory of the first one.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#command_line DataK8SOrgEclipseCheCheClusterV2Manifest#command_line}
  */
  readonly commandLine?: string;
  /**
  * Describes component to which given action relates
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#component DataK8SOrgEclipseCheCheClusterV2Manifest#component}
  */
  readonly component?: string;
  /**
  * Optional list of environment variables that have to be set before running the command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv[] | cdktf.IResolvable;
  /**
  * Defines the group this command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#group DataK8SOrgEclipseCheCheClusterV2Manifest#group}
  */
  readonly group?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup;
  /**
  * Specify whether the command is restarted or not when the source code changes. If set to 'true' the command won't be restarted. A *hotReloadCapable* 'run' or 'debug' command is expected to handle file changes on its own and won't be restarted. A *hotReloadCapable* 'build' command is expected to be executed only once and won't be executed again. This field is taken into account only for commands 'build', 'run' and 'debug' with 'isDefault' set to 'true'. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#hot_reload_capable DataK8SOrgEclipseCheCheClusterV2Manifest#hot_reload_capable}
  */
  readonly hotReloadCapable?: boolean | cdktf.IResolvable;
  /**
  * Optional label that provides a label for this command to be used in Editor UI menus for example
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#label DataK8SOrgEclipseCheCheClusterV2Manifest#label}
  */
  readonly label?: string;
  /**
  * Working directory where the command should be executed Special variables that can be used: - '$PROJECTS_ROOT': A path where projects sources are mounted as defined by container component's sourceMapping. - '$PROJECT_SOURCE': A path to a project source ($PROJECTS_ROOT/<project-name>). If there are multiple projects, this will point to the directory of the first one.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#working_dir DataK8SOrgEclipseCheCheClusterV2Manifest#working_dir}
  */
  readonly workingDir?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command_line: cdktf.stringToTerraform(struct!.commandLine),
    component: cdktf.stringToTerraform(struct!.component),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvToTerraform, false)(struct!.env),
    group: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroupToTerraform(struct!.group),
    hot_reload_capable: cdktf.booleanToTerraform(struct!.hotReloadCapable),
    label: cdktf.stringToTerraform(struct!.label),
    working_dir: cdktf.stringToTerraform(struct!.workingDir),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command_line: {
      value: cdktf.stringToHclTerraform(struct!.commandLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    component: {
      value: cdktf.stringToHclTerraform(struct!.component),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvList",
    },
    group: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup",
    },
    hot_reload_capable: {
      value: cdktf.booleanToHclTerraform(struct!.hotReloadCapable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    working_dir: {
      value: cdktf.stringToHclTerraform(struct!.workingDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commandLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.commandLine = this._commandLine;
    }
    if (this._component !== undefined) {
      hasAnyValues = true;
      internalValueResult.component = this._component;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._hotReloadCapable !== undefined) {
      hasAnyValues = true;
      internalValueResult.hotReloadCapable = this._hotReloadCapable;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._workingDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workingDir = this._workingDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commandLine = undefined;
      this._component = undefined;
      this._env.internalValue = undefined;
      this._group.internalValue = undefined;
      this._hotReloadCapable = undefined;
      this._label = undefined;
      this._workingDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commandLine = value.commandLine;
      this._component = value.component;
      this._env.internalValue = value.env;
      this._group.internalValue = value.group;
      this._hotReloadCapable = value.hotReloadCapable;
      this._label = value.label;
      this._workingDir = value.workingDir;
    }
  }

  // command_line - computed: false, optional: true, required: false
  private _commandLine?: string; 
  public get commandLine() {
    return this.getStringAttribute('command_line');
  }
  public set commandLine(value: string) {
    this._commandLine = value;
  }
  public resetCommandLine() {
    this._commandLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandLineInput() {
    return this._commandLine;
  }

  // component - computed: false, optional: true, required: false
  private _component?: string; 
  public get component() {
    return this.getStringAttribute('component');
  }
  public set component(value: string) {
    this._component = value;
  }
  public resetComponent() {
    this._component = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentInput() {
    return this._component;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // hot_reload_capable - computed: false, optional: true, required: false
  private _hotReloadCapable?: boolean | cdktf.IResolvable; 
  public get hotReloadCapable() {
    return this.getBooleanAttribute('hot_reload_capable');
  }
  public set hotReloadCapable(value: boolean | cdktf.IResolvable) {
    this._hotReloadCapable = value;
  }
  public resetHotReloadCapable() {
    this._hotReloadCapable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hotReloadCapableInput() {
    return this._hotReloadCapable;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // working_dir - computed: false, optional: true, required: false
  private _workingDir?: string; 
  public get workingDir() {
    return this.getStringAttribute('working_dir');
  }
  public set workingDir(value: string) {
    this._workingDir = value;
  }
  public resetWorkingDir() {
    this._workingDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workingDirInput() {
    return this._workingDir;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands {
  /**
  * Command that consists in applying a given component definition, typically bound to a devworkspace event. For example, when an 'apply' command is bound to a 'preStart' event, and references a 'container' component, it will start the container as a K8S initContainer in the devworkspace POD, unless the component has its 'dedicatedPod' field set to 'true'. When no 'apply' command exist for a given component, it is assumed the component will be applied at devworkspace start by default, unless 'deployByDefault' for that component is set to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#apply DataK8SOrgEclipseCheCheClusterV2Manifest#apply}
  */
  readonly apply?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply;
  /**
  * Map of implementation-dependant free-form YAML attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Type of devworkspace command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#command_type DataK8SOrgEclipseCheCheClusterV2Manifest#command_type}
  */
  readonly commandType?: string;
  /**
  * Composite command that allows executing several sub-commands either sequentially or concurrently
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#composite DataK8SOrgEclipseCheCheClusterV2Manifest#composite}
  */
  readonly composite?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite;
  /**
  * CLI Command executed in an existing component container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exec DataK8SOrgEclipseCheCheClusterV2Manifest#exec}
  */
  readonly exec?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec;
  /**
  * Mandatory identifier that allows referencing this command in composite commands, from a parent, or in events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#id DataK8SOrgEclipseCheCheClusterV2Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apply: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyToTerraform(struct!.apply),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    command_type: cdktf.stringToTerraform(struct!.commandType),
    composite: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeToTerraform(struct!.composite),
    exec: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecToTerraform(struct!.exec),
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apply: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyToHclTerraform(struct!.apply),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    command_type: {
      value: cdktf.stringToHclTerraform(struct!.commandType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    composite: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeToHclTerraform(struct!.composite),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite",
    },
    exec: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecToHclTerraform(struct!.exec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apply?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apply = this._apply?.internalValue;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._commandType !== undefined) {
      hasAnyValues = true;
      internalValueResult.commandType = this._commandType;
    }
    if (this._composite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.composite = this._composite?.internalValue;
    }
    if (this._exec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apply.internalValue = undefined;
      this._attributes = undefined;
      this._commandType = undefined;
      this._composite.internalValue = undefined;
      this._exec.internalValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apply.internalValue = value.apply;
      this._attributes = value.attributes;
      this._commandType = value.commandType;
      this._composite.internalValue = value.composite;
      this._exec.internalValue = value.exec;
      this._id = value.id;
    }
  }

  // apply - computed: false, optional: true, required: false
  private _apply = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApplyOutputReference(this, "apply");
  public get apply() {
    return this._apply;
  }
  public putApply(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsApply) {
    this._apply.internalValue = value;
  }
  public resetApply() {
    this._apply.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applyInput() {
    return this._apply.internalValue;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // command_type - computed: false, optional: true, required: false
  private _commandType?: string; 
  public get commandType() {
    return this.getStringAttribute('command_type');
  }
  public set commandType(value: string) {
    this._commandType = value;
  }
  public resetCommandType() {
    this._commandType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandTypeInput() {
    return this._commandType;
  }

  // composite - computed: false, optional: true, required: false
  private _composite = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsCompositeOutputReference(this, "composite");
  public get composite() {
    return this._composite;
  }
  public putComposite(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsComposite) {
    this._composite.internalValue = value;
  }
  public resetComposite() {
    this._composite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compositeInput() {
    return this._composite.internalValue;
  }

  // exec - computed: false, optional: true, required: false
  private _exec = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExecOutputReference(this, "exec");
  public get exec() {
    return this._exec;
  }
  public putExec(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsExec) {
    this._exec.internalValue = value;
  }
  public resetExec() {
    this._exec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation {
  /**
  * Annotations to be added to deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment DataK8SOrgEclipseCheCheClusterV2Manifest#deployment}
  */
  readonly deployment?: { [key: string]: string };
  /**
  * Annotations to be added to service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#service DataK8SOrgEclipseCheCheClusterV2Manifest#service}
  */
  readonly service?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotationToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deployment),
    service: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.service),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotationToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deployment),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.service),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment = value.deployment;
      this._service = value.service;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment?: { [key: string]: string }; 
  public get deployment() {
    return this.getStringMapAttribute('deployment');
  }
  public set deployment(value: { [key: string]: string }) {
    this._deployment = value;
  }
  public resetDeployment() {
    this._deployment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment;
  }

  // service - computed: false, optional: true, required: false
  private _service?: { [key: string]: string }; 
  public get service() {
    return this.getStringMapAttribute('service');
  }
  public set service(value: { [key: string]: string }) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exposure DataK8SOrgEclipseCheCheClusterV2Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#protocol DataK8SOrgEclipseCheCheClusterV2Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secure DataK8SOrgEclipseCheCheClusterV2Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#target_port DataK8SOrgEclipseCheCheClusterV2Manifest#target_port}
  */
  readonly targetPort?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts {
  /**
  * The volume mount name is the name of an existing 'Volume' component. If several containers mount the same volume name then they will reuse the same volume and will be able to access to the same files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * The path in the component container where the volume should be mounted. If not path is mentioned, default path is the is '/<name>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer {
  /**
  * Annotations that should be added to specific resources for this container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation;
  /**
  * The arguments to supply to the command running the dockerimage component. The arguments are supplied either to the default command provided in the image or to the overridden command. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#args DataK8SOrgEclipseCheCheClusterV2Manifest#args}
  */
  readonly args?: string[];
  /**
  * The command to run in the dockerimage component instead of the default one provided in the image. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#command DataK8SOrgEclipseCheCheClusterV2Manifest#command}
  */
  readonly command?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu_limit DataK8SOrgEclipseCheCheClusterV2Manifest#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu_request DataK8SOrgEclipseCheCheClusterV2Manifest#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Specify if a container should run in its own separated pod, instead of running as part of the main development environment pod. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#dedicated_pod DataK8SOrgEclipseCheCheClusterV2Manifest#dedicated_pod}
  */
  readonly dedicatedPod?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoints DataK8SOrgEclipseCheCheClusterV2Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints[] | cdktf.IResolvable;
  /**
  * Environment variables used in this container. The following variables are reserved and cannot be overridden via env: - '$PROJECTS_ROOT' - '$PROJECT_SOURCE'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory_limit DataK8SOrgEclipseCheCheClusterV2Manifest#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory_request DataK8SOrgEclipseCheCheClusterV2Manifest#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Toggles whether or not the project source code should be mounted in the component. Defaults to true for all component types except plugins and components that set 'dedicatedPod' to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#mount_sources DataK8SOrgEclipseCheCheClusterV2Manifest#mount_sources}
  */
  readonly mountSources?: boolean | cdktf.IResolvable;
  /**
  * Optional specification of the path in the container where project sources should be transferred/mounted when 'mountSources' is 'true'. When omitted, the default value of /projects is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#source_mapping DataK8SOrgEclipseCheCheClusterV2Manifest#source_mapping}
  */
  readonly sourceMapping?: string;
  /**
  * List of volumes mounts that should be mounted is this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#volume_mounts DataK8SOrgEclipseCheCheClusterV2Manifest#volume_mounts}
  */
  readonly volumeMounts?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotationToTerraform(struct!.annotation),
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    dedicated_pod: cdktf.booleanToTerraform(struct!.dedicatedPod),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsToTerraform, false)(struct!.endpoints),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    mount_sources: cdktf.booleanToTerraform(struct!.mountSources),
    source_mapping: cdktf.stringToTerraform(struct!.sourceMapping),
    volume_mounts: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsToTerraform, false)(struct!.volumeMounts),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotationToHclTerraform(struct!.annotation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation",
    },
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dedicated_pod: {
      value: cdktf.booleanToHclTerraform(struct!.dedicatedPod),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsList",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mount_sources: {
      value: cdktf.booleanToHclTerraform(struct!.mountSources),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source_mapping: {
      value: cdktf.stringToHclTerraform(struct!.sourceMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_mounts: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsToHclTerraform, false)(struct!.volumeMounts),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation?.internalValue;
    }
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._dedicatedPod !== undefined) {
      hasAnyValues = true;
      internalValueResult.dedicatedPod = this._dedicatedPod;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._mountSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountSources = this._mountSources;
    }
    if (this._sourceMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceMapping = this._sourceMapping;
    }
    if (this._volumeMounts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeMounts = this._volumeMounts?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation.internalValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._dedicatedPod = undefined;
      this._endpoints.internalValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._mountSources = undefined;
      this._sourceMapping = undefined;
      this._volumeMounts.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation.internalValue = value.annotation;
      this._args = value.args;
      this._command = value.command;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._dedicatedPod = value.dedicatedPod;
      this._endpoints.internalValue = value.endpoints;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._mountSources = value.mountSources;
      this._sourceMapping = value.sourceMapping;
      this._volumeMounts.internalValue = value.volumeMounts;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotationOutputReference(this, "annotation");
  public get annotation() {
    return this._annotation;
  }
  public putAnnotation(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerAnnotation) {
    this._annotation.internalValue = value;
  }
  public resetAnnotation() {
    this._annotation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation.internalValue;
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // dedicated_pod - computed: false, optional: true, required: false
  private _dedicatedPod?: boolean | cdktf.IResolvable; 
  public get dedicatedPod() {
    return this.getBooleanAttribute('dedicated_pod');
  }
  public set dedicatedPod(value: boolean | cdktf.IResolvable) {
    this._dedicatedPod = value;
  }
  public resetDedicatedPod() {
    this._dedicatedPod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dedicatedPodInput() {
    return this._dedicatedPod;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // mount_sources - computed: false, optional: true, required: false
  private _mountSources?: boolean | cdktf.IResolvable; 
  public get mountSources() {
    return this.getBooleanAttribute('mount_sources');
  }
  public set mountSources(value: boolean | cdktf.IResolvable) {
    this._mountSources = value;
  }
  public resetMountSources() {
    this._mountSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountSourcesInput() {
    return this._mountSources;
  }

  // source_mapping - computed: false, optional: true, required: false
  private _sourceMapping?: string; 
  public get sourceMapping() {
    return this.getStringAttribute('source_mapping');
  }
  public set sourceMapping(value: string) {
    this._sourceMapping = value;
  }
  public resetSourceMapping() {
    this._sourceMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceMappingInput() {
    return this._sourceMapping;
  }

  // volume_mounts - computed: false, optional: true, required: false
  private _volumeMounts = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMountsList(this, "volume_mounts", false);
  public get volumeMounts() {
    return this._volumeMounts;
  }
  public putVolumeMounts(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerVolumeMounts[] | cdktf.IResolvable) {
    this._volumeMounts.internalValue = value;
  }
  public resetVolumeMounts() {
    this._volumeMounts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeMountsInput() {
    return this._volumeMounts.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry {
  /**
  * Id in a devfile registry that contains a Dockerfile. The src in the OCI registry required for the Dockerfile build will be downloaded for building the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#id DataK8SOrgEclipseCheCheClusterV2Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Devfile Registry URL to pull the Dockerfile from when using the Devfile Registry as Dockerfile src. To ensure the Dockerfile gets resolved consistently in different environments, it is recommended to always specify the 'devfileRegistryUrl' when 'Id' is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#registry_url DataK8SOrgEclipseCheCheClusterV2Manifest#registry_url}
  */
  readonly registryUrl?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    registry_url: cdktf.stringToTerraform(struct!.registryUrl),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    registry_url: {
      value: cdktf.stringToHclTerraform(struct!.registryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._registryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryUrl = this._registryUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._registryUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._registryUrl = value.registryUrl;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // registry_url - computed: false, optional: true, required: false
  private _registryUrl?: string; 
  public get registryUrl() {
    return this.getStringAttribute('registry_url');
  }
  public set registryUrl(value: string) {
    this._registryUrl = value;
  }
  public resetRegistryUrl() {
    this._registryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryUrlInput() {
    return this._registryUrl;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom {
  /**
  * The remote name should be used as init. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#remote DataK8SOrgEclipseCheCheClusterV2Manifest#remote}
  */
  readonly remote?: string;
  /**
  * The revision to checkout from. Should be branch name, tag or commit id. Default branch is used if missing or specified revision is not found.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#revision DataK8SOrgEclipseCheCheClusterV2Manifest#revision}
  */
  readonly revision?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    remote: cdktf.stringToTerraform(struct!.remote),
    revision: cdktf.stringToTerraform(struct!.revision),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    remote: {
      value: cdktf.stringToHclTerraform(struct!.remote),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision: {
      value: cdktf.stringToHclTerraform(struct!.revision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._remote !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote;
    }
    if (this._revision !== undefined) {
      hasAnyValues = true;
      internalValueResult.revision = this._revision;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._remote = undefined;
      this._revision = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._remote = value.remote;
      this._revision = value.revision;
    }
  }

  // remote - computed: false, optional: true, required: false
  private _remote?: string; 
  public get remote() {
    return this.getStringAttribute('remote');
  }
  public set remote(value: string) {
    this._remote = value;
  }
  public resetRemote() {
    this._remote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote;
  }

  // revision - computed: false, optional: true, required: false
  private _revision?: string; 
  public get revision() {
    return this.getStringAttribute('revision');
  }
  public set revision(value: string) {
    this._revision = value;
  }
  public resetRevision() {
    this._revision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionInput() {
    return this._revision;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit {
  /**
  * Defines from what the project should be checked out. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#checkout_from DataK8SOrgEclipseCheCheClusterV2Manifest#checkout_from}
  */
  readonly checkoutFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom;
  /**
  * Location of the Dockerfile in the Git repository when using git as Dockerfile src. Defaults to Dockerfile.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#file_location DataK8SOrgEclipseCheCheClusterV2Manifest#file_location}
  */
  readonly fileLocation?: string;
  /**
  * The remotes map which should be initialized in the git project. Projects must have at least one remote configured while StarterProjects & Image Component's Git source can only have at most one remote configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#remotes DataK8SOrgEclipseCheCheClusterV2Manifest#remotes}
  */
  readonly remotes?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    checkout_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToTerraform(struct!.checkoutFrom),
    file_location: cdktf.stringToTerraform(struct!.fileLocation),
    remotes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remotes),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    checkout_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct!.checkoutFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom",
    },
    file_location: {
      value: cdktf.stringToHclTerraform(struct!.fileLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remotes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remotes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._checkoutFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkoutFrom = this._checkoutFrom?.internalValue;
    }
    if (this._fileLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileLocation = this._fileLocation;
    }
    if (this._remotes !== undefined) {
      hasAnyValues = true;
      internalValueResult.remotes = this._remotes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = undefined;
      this._fileLocation = undefined;
      this._remotes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = value.checkoutFrom;
      this._fileLocation = value.fileLocation;
      this._remotes = value.remotes;
    }
  }

  // checkout_from - computed: false, optional: true, required: false
  private _checkoutFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromOutputReference(this, "checkout_from");
  public get checkoutFrom() {
    return this._checkoutFrom;
  }
  public putCheckoutFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom) {
    this._checkoutFrom.internalValue = value;
  }
  public resetCheckoutFrom() {
    this._checkoutFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkoutFromInput() {
    return this._checkoutFrom.internalValue;
  }

  // file_location - computed: false, optional: true, required: false
  private _fileLocation?: string; 
  public get fileLocation() {
    return this.getStringAttribute('file_location');
  }
  public set fileLocation(value: string) {
    this._fileLocation = value;
  }
  public resetFileLocation() {
    this._fileLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileLocationInput() {
    return this._fileLocation;
  }

  // remotes - computed: false, optional: true, required: false
  private _remotes?: { [key: string]: string }; 
  public get remotes() {
    return this.getStringMapAttribute('remotes');
  }
  public set remotes(value: { [key: string]: string }) {
    this._remotes = value;
  }
  public resetRemotes() {
    this._remotes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remotesInput() {
    return this._remotes;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile {
  /**
  * The arguments to supply to the dockerfile build.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#args DataK8SOrgEclipseCheCheClusterV2Manifest#args}
  */
  readonly args?: string[];
  /**
  * Path of source directory to establish build context. Defaults to ${PROJECT_SOURCE} in the container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#build_context DataK8SOrgEclipseCheCheClusterV2Manifest#build_context}
  */
  readonly buildContext?: string;
  /**
  * Dockerfile's Devfile Registry source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#devfile_registry DataK8SOrgEclipseCheCheClusterV2Manifest#devfile_registry}
  */
  readonly devfileRegistry?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry;
  /**
  * Dockerfile's Git source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#git DataK8SOrgEclipseCheCheClusterV2Manifest#git}
  */
  readonly git?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit;
  /**
  * Specify if a privileged builder pod is required. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#root_required DataK8SOrgEclipseCheCheClusterV2Manifest#root_required}
  */
  readonly rootRequired?: boolean | cdktf.IResolvable;
  /**
  * Type of Dockerfile src
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#src_type DataK8SOrgEclipseCheCheClusterV2Manifest#src_type}
  */
  readonly srcType?: string;
  /**
  * URI Reference of a Dockerfile. It can be a full URL or a relative URI from the current devfile as the base URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    build_context: cdktf.stringToTerraform(struct!.buildContext),
    devfile_registry: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToTerraform(struct!.devfileRegistry),
    git: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitToTerraform(struct!.git),
    root_required: cdktf.booleanToTerraform(struct!.rootRequired),
    src_type: cdktf.stringToTerraform(struct!.srcType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    build_context: {
      value: cdktf.stringToHclTerraform(struct!.buildContext),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToHclTerraform(struct!.devfileRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry",
    },
    git: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitToHclTerraform(struct!.git),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit",
    },
    root_required: {
      value: cdktf.booleanToHclTerraform(struct!.rootRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    src_type: {
      value: cdktf.stringToHclTerraform(struct!.srcType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._buildContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.buildContext = this._buildContext;
    }
    if (this._devfileRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistry = this._devfileRegistry?.internalValue;
    }
    if (this._git?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.git = this._git?.internalValue;
    }
    if (this._rootRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootRequired = this._rootRequired;
    }
    if (this._srcType !== undefined) {
      hasAnyValues = true;
      internalValueResult.srcType = this._srcType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._buildContext = undefined;
      this._devfileRegistry.internalValue = undefined;
      this._git.internalValue = undefined;
      this._rootRequired = undefined;
      this._srcType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._buildContext = value.buildContext;
      this._devfileRegistry.internalValue = value.devfileRegistry;
      this._git.internalValue = value.git;
      this._rootRequired = value.rootRequired;
      this._srcType = value.srcType;
      this._uri = value.uri;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // build_context - computed: false, optional: true, required: false
  private _buildContext?: string; 
  public get buildContext() {
    return this.getStringAttribute('build_context');
  }
  public set buildContext(value: string) {
    this._buildContext = value;
  }
  public resetBuildContext() {
    this._buildContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get buildContextInput() {
    return this._buildContext;
  }

  // devfile_registry - computed: false, optional: true, required: false
  private _devfileRegistry = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryOutputReference(this, "devfile_registry");
  public get devfileRegistry() {
    return this._devfileRegistry;
  }
  public putDevfileRegistry(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry) {
    this._devfileRegistry.internalValue = value;
  }
  public resetDevfileRegistry() {
    this._devfileRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryInput() {
    return this._devfileRegistry.internalValue;
  }

  // git - computed: false, optional: true, required: false
  private _git = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGitOutputReference(this, "git");
  public get git() {
    return this._git;
  }
  public putGit(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileGit) {
    this._git.internalValue = value;
  }
  public resetGit() {
    this._git.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitInput() {
    return this._git.internalValue;
  }

  // root_required - computed: false, optional: true, required: false
  private _rootRequired?: boolean | cdktf.IResolvable; 
  public get rootRequired() {
    return this.getBooleanAttribute('root_required');
  }
  public set rootRequired(value: boolean | cdktf.IResolvable) {
    this._rootRequired = value;
  }
  public resetRootRequired() {
    this._rootRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootRequiredInput() {
    return this._rootRequired;
  }

  // src_type - computed: false, optional: true, required: false
  private _srcType?: string; 
  public get srcType() {
    return this.getStringAttribute('src_type');
  }
  public set srcType(value: string) {
    this._srcType = value;
  }
  public resetSrcType() {
    this._srcType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcTypeInput() {
    return this._srcType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage {
  /**
  * Defines if the image should be built during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#auto_build DataK8SOrgEclipseCheCheClusterV2Manifest#auto_build}
  */
  readonly autoBuild?: boolean | cdktf.IResolvable;
  /**
  * Allows specifying dockerfile type build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#dockerfile DataK8SOrgEclipseCheCheClusterV2Manifest#dockerfile}
  */
  readonly dockerfile?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile;
  /**
  * Name of the image for the resulting outerloop build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_name DataK8SOrgEclipseCheCheClusterV2Manifest#image_name}
  */
  readonly imageName?: string;
  /**
  * Type of image
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_type DataK8SOrgEclipseCheCheClusterV2Manifest#image_type}
  */
  readonly imageType?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_build: cdktf.booleanToTerraform(struct!.autoBuild),
    dockerfile: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileToTerraform(struct!.dockerfile),
    image_name: cdktf.stringToTerraform(struct!.imageName),
    image_type: cdktf.stringToTerraform(struct!.imageType),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_build: {
      value: cdktf.booleanToHclTerraform(struct!.autoBuild),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dockerfile: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileToHclTerraform(struct!.dockerfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile",
    },
    image_name: {
      value: cdktf.stringToHclTerraform(struct!.imageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_type: {
      value: cdktf.stringToHclTerraform(struct!.imageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoBuild !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBuild = this._autoBuild;
    }
    if (this._dockerfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerfile = this._dockerfile?.internalValue;
    }
    if (this._imageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageName = this._imageName;
    }
    if (this._imageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageType = this._imageType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoBuild = undefined;
      this._dockerfile.internalValue = undefined;
      this._imageName = undefined;
      this._imageType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoBuild = value.autoBuild;
      this._dockerfile.internalValue = value.dockerfile;
      this._imageName = value.imageName;
      this._imageType = value.imageType;
    }
  }

  // auto_build - computed: false, optional: true, required: false
  private _autoBuild?: boolean | cdktf.IResolvable; 
  public get autoBuild() {
    return this.getBooleanAttribute('auto_build');
  }
  public set autoBuild(value: boolean | cdktf.IResolvable) {
    this._autoBuild = value;
  }
  public resetAutoBuild() {
    this._autoBuild = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBuildInput() {
    return this._autoBuild;
  }

  // dockerfile - computed: false, optional: true, required: false
  private _dockerfile = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfileOutputReference(this, "dockerfile");
  public get dockerfile() {
    return this._dockerfile;
  }
  public putDockerfile(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageDockerfile) {
    this._dockerfile.internalValue = value;
  }
  public resetDockerfile() {
    this._dockerfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerfileInput() {
    return this._dockerfile.internalValue;
  }

  // image_name - computed: false, optional: true, required: false
  private _imageName?: string; 
  public get imageName() {
    return this.getStringAttribute('image_name');
  }
  public set imageName(value: string) {
    this._imageName = value;
  }
  public resetImageName() {
    this._imageName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageNameInput() {
    return this._imageName;
  }

  // image_type - computed: false, optional: true, required: false
  private _imageType?: string; 
  public get imageType() {
    return this.getStringAttribute('image_type');
  }
  public set imageType(value: string) {
    this._imageType = value;
  }
  public resetImageType() {
    this._imageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageTypeInput() {
    return this._imageType;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exposure DataK8SOrgEclipseCheCheClusterV2Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#protocol DataK8SOrgEclipseCheCheClusterV2Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secure DataK8SOrgEclipseCheCheClusterV2Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#target_port DataK8SOrgEclipseCheCheClusterV2Manifest#target_port}
  */
  readonly targetPort?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV2Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoints DataK8SOrgEclipseCheCheClusterV2Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#inlined DataK8SOrgEclipseCheCheClusterV2Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#location_type DataK8SOrgEclipseCheCheClusterV2Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#annotation DataK8SOrgEclipseCheCheClusterV2Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#exposure DataK8SOrgEclipseCheCheClusterV2Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#protocol DataK8SOrgEclipseCheCheClusterV2Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secure DataK8SOrgEclipseCheCheClusterV2Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#target_port DataK8SOrgEclipseCheCheClusterV2Manifest#target_port}
  */
  readonly targetPort?: number;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV2Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoints DataK8SOrgEclipseCheCheClusterV2Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#inlined DataK8SOrgEclipseCheCheClusterV2Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#location_type DataK8SOrgEclipseCheCheClusterV2Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume {
  /**
  * Ephemeral volumes are not stored persistently across restarts. Defaults to false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#ephemeral DataK8SOrgEclipseCheCheClusterV2Manifest#ephemeral}
  */
  readonly ephemeral?: boolean | cdktf.IResolvable;
  /**
  * Size of the volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#size DataK8SOrgEclipseCheCheClusterV2Manifest#size}
  */
  readonly size?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolumeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ephemeral: cdktf.booleanToTerraform(struct!.ephemeral),
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolumeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ephemeral: {
      value: cdktf.booleanToHclTerraform(struct!.ephemeral),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ephemeral !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeral = this._ephemeral;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ephemeral = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ephemeral = value.ephemeral;
      this._size = value.size;
    }
  }

  // ephemeral - computed: false, optional: true, required: false
  private _ephemeral?: boolean | cdktf.IResolvable; 
  public get ephemeral() {
    return this.getBooleanAttribute('ephemeral');
  }
  public set ephemeral(value: boolean | cdktf.IResolvable) {
    this._ephemeral = value;
  }
  public resetEphemeral() {
    this._ephemeral = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralInput() {
    return this._ephemeral;
  }

  // size - computed: false, optional: true, required: false
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents {
  /**
  * Map of implementation-dependant free-form YAML attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Type of component
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#component_type DataK8SOrgEclipseCheCheClusterV2Manifest#component_type}
  */
  readonly componentType?: string;
  /**
  * Allows adding and configuring devworkspace-related containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container DataK8SOrgEclipseCheCheClusterV2Manifest#container}
  */
  readonly container?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer;
  /**
  * Allows specifying the definition of an image for outer loop builds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage;
  /**
  * Allows importing into the devworkspace the Kubernetes resources defined in a given manifest. For example this allows reusing the Kubernetes definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#kubernetes DataK8SOrgEclipseCheCheClusterV2Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes;
  /**
  * Mandatory name that allows referencing the component from other elements (such as commands) or from an external devfile that may reference this component through a parent or a plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Allows importing into the devworkspace the OpenShift resources defined in a given manifest. For example this allows reusing the OpenShift definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#openshift DataK8SOrgEclipseCheCheClusterV2Manifest#openshift}
  */
  readonly openshift?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift;
  /**
  * Allows specifying the definition of a volume shared by several other components
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#volume DataK8SOrgEclipseCheCheClusterV2Manifest#volume}
  */
  readonly volume?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    component_type: cdktf.stringToTerraform(struct!.componentType),
    container: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerToTerraform(struct!.container),
    image: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageToTerraform(struct!.image),
    kubernetes: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesToTerraform(struct!.kubernetes),
    name: cdktf.stringToTerraform(struct!.name),
    openshift: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftToTerraform(struct!.openshift),
    volume: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolumeToTerraform(struct!.volume),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    component_type: {
      value: cdktf.stringToHclTerraform(struct!.componentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerToHclTerraform(struct!.container),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer",
    },
    image: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage",
    },
    kubernetes: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    openshift: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftToHclTerraform(struct!.openshift),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift",
    },
    volume: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._componentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.componentType = this._componentType;
    }
    if (this._container?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container?.internalValue;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._openshift?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openshift = this._openshift?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributes = undefined;
      this._componentType = undefined;
      this._container.internalValue = undefined;
      this._image.internalValue = undefined;
      this._kubernetes.internalValue = undefined;
      this._name = undefined;
      this._openshift.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributes = value.attributes;
      this._componentType = value.componentType;
      this._container.internalValue = value.container;
      this._image.internalValue = value.image;
      this._kubernetes.internalValue = value.kubernetes;
      this._name = value.name;
      this._openshift.internalValue = value.openshift;
      this._volume.internalValue = value.volume;
    }
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // component_type - computed: false, optional: true, required: false
  private _componentType?: string; 
  public get componentType() {
    return this.getStringAttribute('component_type');
  }
  public set componentType(value: string) {
    this._componentType = value;
  }
  public resetComponentType() {
    this._componentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentTypeInput() {
    return this._componentType;
  }

  // container - computed: false, optional: true, required: false
  private _container = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainerOutputReference(this, "container");
  public get container() {
    return this._container;
  }
  public putContainer(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsContainer) {
    this._container.internalValue = value;
  }
  public resetContainer() {
    this._container.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsImage) {
    this._image.internalValue = value;
  }
  public resetImage() {
    this._image.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // openshift - computed: false, optional: true, required: false
  private _openshift = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshiftOutputReference(this, "openshift");
  public get openshift() {
    return this._openshift;
  }
  public putOpenshift(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOpenshift) {
    this._openshift.internalValue = value;
  }
  public resetOpenshift() {
    this._openshift.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openshiftInput() {
    return this._openshift.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#namespace DataK8SOrgEclipseCheCheClusterV2Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin {
  /**
  * Overrides of commands encapsulated in a parent devfile or a plugin. Overriding is done according to K8S strategic merge patch standard rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#commands DataK8SOrgEclipseCheCheClusterV2Manifest#commands}
  */
  readonly commands?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands[] | cdktf.IResolvable;
  /**
  * Overrides of components encapsulated in a parent devfile or a plugin. Overriding is done according to K8S strategic merge patch standard rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#components DataK8SOrgEclipseCheCheClusterV2Manifest#components}
  */
  readonly components?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents[] | cdktf.IResolvable;
  /**
  * Id in a registry that contains a Devfile yaml file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#id DataK8SOrgEclipseCheCheClusterV2Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * type of location from where the referenced template structure should be retrieved
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#import_reference_type DataK8SOrgEclipseCheCheClusterV2Manifest#import_reference_type}
  */
  readonly importReferenceType?: string;
  /**
  * Reference to a Kubernetes CRD of type DevWorkspaceTemplate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#kubernetes DataK8SOrgEclipseCheCheClusterV2Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes;
  /**
  * Registry URL to pull the parent devfile from when using id in the parent reference. To ensure the parent devfile gets resolved consistently in different environments, it is recommended to always specify the 'registryUrl' when 'id' is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#registry_url DataK8SOrgEclipseCheCheClusterV2Manifest#registry_url}
  */
  readonly registryUrl?: string;
  /**
  * URI Reference of a parent devfile YAML file. It can be a full URL or a relative URI with the current devfile as the base URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#uri DataK8SOrgEclipseCheCheClusterV2Manifest#uri}
  */
  readonly uri?: string;
  /**
  * Specific stack/sample version to pull the parent devfile from, when using id in the parent reference. To specify 'version', 'id' must be defined and used as the import reference source. 'version' can be either a specific stack version, or 'latest'. If no 'version' specified, default version will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#version DataK8SOrgEclipseCheCheClusterV2Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commands: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsToTerraform, false)(struct!.commands),
    components: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsToTerraform, false)(struct!.components),
    id: cdktf.stringToTerraform(struct!.id),
    import_reference_type: cdktf.stringToTerraform(struct!.importReferenceType),
    kubernetes: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetesToTerraform(struct!.kubernetes),
    registry_url: cdktf.stringToTerraform(struct!.registryUrl),
    uri: cdktf.stringToTerraform(struct!.uri),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commands: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsToHclTerraform, false)(struct!.commands),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsList",
    },
    components: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsToHclTerraform, false)(struct!.components),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    import_reference_type: {
      value: cdktf.stringToHclTerraform(struct!.importReferenceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubernetes: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes",
    },
    registry_url: {
      value: cdktf.stringToHclTerraform(struct!.registryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commands?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.commands = this._commands?.internalValue;
    }
    if (this._components?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.components = this._components?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._importReferenceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.importReferenceType = this._importReferenceType;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._registryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryUrl = this._registryUrl;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commands.internalValue = undefined;
      this._components.internalValue = undefined;
      this._id = undefined;
      this._importReferenceType = undefined;
      this._kubernetes.internalValue = undefined;
      this._registryUrl = undefined;
      this._uri = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commands.internalValue = value.commands;
      this._components.internalValue = value.components;
      this._id = value.id;
      this._importReferenceType = value.importReferenceType;
      this._kubernetes.internalValue = value.kubernetes;
      this._registryUrl = value.registryUrl;
      this._uri = value.uri;
      this._version = value.version;
    }
  }

  // commands - computed: false, optional: true, required: false
  private _commands = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommandsList(this, "commands", false);
  public get commands() {
    return this._commands;
  }
  public putCommands(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginCommands[] | cdktf.IResolvable) {
    this._commands.internalValue = value;
  }
  public resetCommands() {
    this._commands.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandsInput() {
    return this._commands.internalValue;
  }

  // components - computed: false, optional: true, required: false
  private _components = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponentsList(this, "components", false);
  public get components() {
    return this._components;
  }
  public putComponents(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginComponents[] | cdktf.IResolvable) {
    this._components.internalValue = value;
  }
  public resetComponents() {
    this._components.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentsInput() {
    return this._components.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // import_reference_type - computed: false, optional: true, required: false
  private _importReferenceType?: string; 
  public get importReferenceType() {
    return this.getStringAttribute('import_reference_type');
  }
  public set importReferenceType(value: string) {
    this._importReferenceType = value;
  }
  public resetImportReferenceType() {
    this._importReferenceType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importReferenceTypeInput() {
    return this._importReferenceType;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // registry_url - computed: false, optional: true, required: false
  private _registryUrl?: string; 
  public get registryUrl() {
    return this.getStringAttribute('registry_url');
  }
  public set registryUrl(value: string) {
    this._registryUrl = value;
  }
  public resetRegistryUrl() {
    this._registryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryUrlInput() {
    return this._registryUrl;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume {
  /**
  * Ephemeral volumes are not stored persistently across restarts. Defaults to false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#ephemeral DataK8SOrgEclipseCheCheClusterV2Manifest#ephemeral}
  */
  readonly ephemeral?: boolean | cdktf.IResolvable;
  /**
  * Size of the volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#size DataK8SOrgEclipseCheCheClusterV2Manifest#size}
  */
  readonly size?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolumeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ephemeral: cdktf.booleanToTerraform(struct!.ephemeral),
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolumeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ephemeral: {
      value: cdktf.booleanToHclTerraform(struct!.ephemeral),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ephemeral !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeral = this._ephemeral;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ephemeral = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ephemeral = value.ephemeral;
      this._size = value.size;
    }
  }

  // ephemeral - computed: false, optional: true, required: false
  private _ephemeral?: boolean | cdktf.IResolvable; 
  public get ephemeral() {
    return this.getBooleanAttribute('ephemeral');
  }
  public set ephemeral(value: boolean | cdktf.IResolvable) {
    this._ephemeral = value;
  }
  public resetEphemeral() {
    this._ephemeral = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralInput() {
    return this._ephemeral;
  }

  // size - computed: false, optional: true, required: false
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents {
  /**
  * Map of implementation-dependant free-form YAML attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#attributes DataK8SOrgEclipseCheCheClusterV2Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Type of component
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#component_type DataK8SOrgEclipseCheCheClusterV2Manifest#component_type}
  */
  readonly componentType?: string;
  /**
  * Allows adding and configuring devworkspace-related containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container DataK8SOrgEclipseCheCheClusterV2Manifest#container}
  */
  readonly container?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer;
  /**
  * Custom component whose logic is implementation-dependant and should be provided by the user possibly through some dedicated controller
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#custom DataK8SOrgEclipseCheCheClusterV2Manifest#custom}
  */
  readonly custom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom;
  /**
  * Allows specifying the definition of an image for outer loop builds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage;
  /**
  * Allows importing into the devworkspace the Kubernetes resources defined in a given manifest. For example this allows reusing the Kubernetes definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#kubernetes DataK8SOrgEclipseCheCheClusterV2Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes;
  /**
  * Mandatory name that allows referencing the component from other elements (such as commands) or from an external devfile that may reference this component through a parent or a plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Allows importing into the devworkspace the OpenShift resources defined in a given manifest. For example this allows reusing the OpenShift definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#openshift DataK8SOrgEclipseCheCheClusterV2Manifest#openshift}
  */
  readonly openshift?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift;
  /**
  * Allows importing a plugin. Plugins are mainly imported devfiles that contribute components, commands and events as a consistent single unit. They are defined in either YAML files following the devfile syntax, or as 'DevWorkspaceTemplate' Kubernetes Custom Resources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#plugin DataK8SOrgEclipseCheCheClusterV2Manifest#plugin}
  */
  readonly plugin?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin;
  /**
  * Allows specifying the definition of a volume shared by several other components
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#volume DataK8SOrgEclipseCheCheClusterV2Manifest#volume}
  */
  readonly volume?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    component_type: cdktf.stringToTerraform(struct!.componentType),
    container: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerToTerraform(struct!.container),
    custom: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustomToTerraform(struct!.custom),
    image: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageToTerraform(struct!.image),
    kubernetes: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesToTerraform(struct!.kubernetes),
    name: cdktf.stringToTerraform(struct!.name),
    openshift: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftToTerraform(struct!.openshift),
    plugin: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginToTerraform(struct!.plugin),
    volume: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolumeToTerraform(struct!.volume),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    component_type: {
      value: cdktf.stringToHclTerraform(struct!.componentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerToHclTerraform(struct!.container),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer",
    },
    custom: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustomToHclTerraform(struct!.custom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom",
    },
    image: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage",
    },
    kubernetes: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    openshift: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftToHclTerraform(struct!.openshift),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift",
    },
    plugin: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin",
    },
    volume: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._componentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.componentType = this._componentType;
    }
    if (this._container?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container?.internalValue;
    }
    if (this._custom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.custom = this._custom?.internalValue;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._openshift?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openshift = this._openshift?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributes = undefined;
      this._componentType = undefined;
      this._container.internalValue = undefined;
      this._custom.internalValue = undefined;
      this._image.internalValue = undefined;
      this._kubernetes.internalValue = undefined;
      this._name = undefined;
      this._openshift.internalValue = undefined;
      this._plugin.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributes = value.attributes;
      this._componentType = value.componentType;
      this._container.internalValue = value.container;
      this._custom.internalValue = value.custom;
      this._image.internalValue = value.image;
      this._kubernetes.internalValue = value.kubernetes;
      this._name = value.name;
      this._openshift.internalValue = value.openshift;
      this._plugin.internalValue = value.plugin;
      this._volume.internalValue = value.volume;
    }
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // component_type - computed: false, optional: true, required: false
  private _componentType?: string; 
  public get componentType() {
    return this.getStringAttribute('component_type');
  }
  public set componentType(value: string) {
    this._componentType = value;
  }
  public resetComponentType() {
    this._componentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentTypeInput() {
    return this._componentType;
  }

  // container - computed: false, optional: true, required: false
  private _container = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainerOutputReference(this, "container");
  public get container() {
    return this._container;
  }
  public putContainer(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsContainer) {
    this._container.internalValue = value;
  }
  public resetContainer() {
    this._container.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container.internalValue;
  }

  // custom - computed: false, optional: true, required: false
  private _custom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustomOutputReference(this, "custom");
  public get custom() {
    return this._custom;
  }
  public putCustom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsCustom) {
    this._custom.internalValue = value;
  }
  public resetCustom() {
    this._custom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInput() {
    return this._custom.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsImage) {
    this._image.internalValue = value;
  }
  public resetImage() {
    this._image.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // openshift - computed: false, optional: true, required: false
  private _openshift = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshiftOutputReference(this, "openshift");
  public get openshift() {
    return this._openshift;
  }
  public putOpenshift(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOpenshift) {
    this._openshift.internalValue = value;
  }
  public resetOpenshift() {
    this._openshift.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openshiftInput() {
    return this._openshift.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsPlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace {
  /**
  * Indicates if is allowed to automatically create a user namespace. If it set to false, then user namespace must be pre-created by a cluster administrator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#auto_provision DataK8SOrgEclipseCheCheClusterV2Manifest#auto_provision}
  */
  readonly autoProvision?: boolean | cdktf.IResolvable;
  /**
  * If you don't create the user namespaces in advance, this field defines the Kubernetes namespace created when you start your first workspace. You can use '<username>' and '<userid>' placeholders, such as che-workspace-<username>.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#template DataK8SOrgEclipseCheCheClusterV2Manifest#template}
  */
  readonly template?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespaceToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_provision: cdktf.booleanToTerraform(struct!.autoProvision),
    template: cdktf.stringToTerraform(struct!.template),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespaceToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_provision: {
      value: cdktf.booleanToHclTerraform(struct!.autoProvision),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    template: {
      value: cdktf.stringToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoProvision !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoProvision = this._autoProvision;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoProvision = undefined;
      this._template = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoProvision = value.autoProvision;
      this._template = value.template;
    }
  }

  // auto_provision - computed: false, optional: true, required: false
  private _autoProvision?: boolean | cdktf.IResolvable; 
  public get autoProvision() {
    return this.getBooleanAttribute('auto_provision');
  }
  public set autoProvision(value: boolean | cdktf.IResolvable) {
    this._autoProvision = value;
  }
  public resetAutoProvision() {
    this._autoProvision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoProvisionInput() {
    return this._autoProvision;
  }

  // template - computed: false, optional: true, required: false
  private _template?: string; 
  public get template() {
    return this.getStringAttribute('template');
  }
  public set template(value: string) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins {
  /**
  * The editor ID to specify default plug-ins for. The plugin ID must have 'publisher/name/version' format.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#editor DataK8SOrgEclipseCheCheClusterV2Manifest#editor}
  */
  readonly editor?: string;
  /**
  * Default plug-in URIs for the specified editor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#plugins DataK8SOrgEclipseCheCheClusterV2Manifest#plugins}
  */
  readonly plugins?: string[];
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    editor: cdktf.stringToTerraform(struct!.editor),
    plugins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.plugins),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    editor: {
      value: cdktf.stringToHclTerraform(struct!.editor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.plugins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._editor !== undefined) {
      hasAnyValues = true;
      internalValueResult.editor = this._editor;
    }
    if (this._plugins !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugins = this._plugins;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._editor = undefined;
      this._plugins = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._editor = value.editor;
      this._plugins = value.plugins;
    }
  }

  // editor - computed: false, optional: true, required: false
  private _editor?: string; 
  public get editor() {
    return this.getStringAttribute('editor');
  }
  public set editor(value: string) {
    this._editor = value;
  }
  public resetEditor() {
    this._editor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get editorInput() {
    return this._editor;
  }

  // plugins - computed: false, optional: true, required: false
  private _plugins?: string[]; 
  public get plugins() {
    return this.getListAttribute('plugins');
  }
  public set plugins(value: string[]) {
    this._plugins = value;
  }
  public resetPlugins() {
    this._plugins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginsInput() {
    return this._plugins;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#api_version DataK8SOrgEclipseCheCheClusterV2Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_path DataK8SOrgEclipseCheCheClusterV2Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_name DataK8SOrgEclipseCheCheClusterV2Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#divisor DataK8SOrgEclipseCheCheClusterV2Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource DataK8SOrgEclipseCheCheClusterV2Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value_from DataK8SOrgEclipseCheCheClusterV2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources {
  /**
  * Describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#limits DataK8SOrgEclipseCheCheClusterV2Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits;
  /**
  * Describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#request DataK8SOrgEclipseCheCheClusterV2Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer {
  /**
  * List of environment variables to set in the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv[] | cdktf.IResolvable;
  /**
  * Container image. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Image pull policy. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Container name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Compute resources required by this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resources DataK8SOrgEclipseCheCheClusterV2Manifest#resources}
  */
  readonly resources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    name: cdktf.stringToTerraform(struct!.name),
    resources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesToTerraform(struct!.resources),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._name = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._name = value.name;
      this._resources.internalValue = value.resources;
    }
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome {
  /**
  * Determines whether the init container that initializes the persistent home directory should be disabled. When the '/home/user' directory is persisted, the init container is used to initialize the directory before the workspace starts. If set to true, the init container will not be created. Disabling the init container allows home persistence to be initialized by the entrypoint present in the workspace's first container component. This field is not used if the 'devEnvironments.persistUserHome.enabled' field is set to false. The init container is enabled by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#disable_init_container DataK8SOrgEclipseCheCheClusterV2Manifest#disable_init_container}
  */
  readonly disableInitContainer?: boolean | cdktf.IResolvable;
  /**
  * Determines whether the user home directory in workspaces should persist between workspace shutdown and startup. Must be used with the 'per-user' or 'per-workspace' PVC strategy in order to take effect. Disabled by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#enabled DataK8SOrgEclipseCheCheClusterV2Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHomeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable_init_container: cdktf.booleanToTerraform(struct!.disableInitContainer),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHomeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable_init_container: {
      value: cdktf.booleanToHclTerraform(struct!.disableInitContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHomeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disableInitContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInitContainer = this._disableInitContainer;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disableInitContainer = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disableInitContainer = value.disableInitContainer;
      this._enabled = value.enabled;
    }
  }

  // disable_init_container - computed: false, optional: true, required: false
  private _disableInitContainer?: boolean | cdktf.IResolvable; 
  public get disableInitContainer() {
    return this.getBooleanAttribute('disable_init_container');
  }
  public set disableInitContainer(value: boolean | cdktf.IResolvable) {
    this._disableInitContainer = value;
  }
  public resetDisableInitContainer() {
    this._disableInitContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInitContainerInput() {
    return this._disableInitContainer;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#api_version DataK8SOrgEclipseCheCheClusterV2Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_path DataK8SOrgEclipseCheCheClusterV2Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_name DataK8SOrgEclipseCheCheClusterV2Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#divisor DataK8SOrgEclipseCheCheClusterV2Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource DataK8SOrgEclipseCheCheClusterV2Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#optional DataK8SOrgEclipseCheCheClusterV2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV2Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value_from DataK8SOrgEclipseCheCheClusterV2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cpu DataK8SOrgEclipseCheCheClusterV2Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024) If the value is not specified, then the default value is set depending on the component. If value is '0', then no value is set for the component.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#memory DataK8SOrgEclipseCheCheClusterV2Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources {
  /**
  * Describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#limits DataK8SOrgEclipseCheCheClusterV2Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits;
  /**
  * Describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#request DataK8SOrgEclipseCheCheClusterV2Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer {
  /**
  * List of environment variables to set in the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#env DataK8SOrgEclipseCheCheClusterV2Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv[] | cdktf.IResolvable;
  /**
  * Container image. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image DataK8SOrgEclipseCheCheClusterV2Manifest#image}
  */
  readonly image?: string;
  /**
  * Image pull policy. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * Container name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name?: string;
  /**
  * Compute resources required by this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#resources DataK8SOrgEclipseCheCheClusterV2Manifest#resources}
  */
  readonly resources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    name: cdktf.stringToTerraform(struct!.name),
    resources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesToTerraform(struct!.resources),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._name = undefined;
      this._resources.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._name = value.name;
      this._resources.internalValue = value.resources;
    }
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities {
  /**
  * Added capabilities
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#add DataK8SOrgEclipseCheCheClusterV2Manifest#add}
  */
  readonly add?: string[];
  /**
  * Removed capabilities
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#drop DataK8SOrgEclipseCheCheClusterV2Manifest#drop}
  */
  readonly drop?: string[];
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilitiesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.add),
    drop: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.drop),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilitiesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.add),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    drop: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.drop),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilitiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._add !== undefined) {
      hasAnyValues = true;
      internalValueResult.add = this._add;
    }
    if (this._drop !== undefined) {
      hasAnyValues = true;
      internalValueResult.drop = this._drop;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._add = undefined;
      this._drop = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._add = value.add;
      this._drop = value.drop;
    }
  }

  // add - computed: false, optional: true, required: false
  private _add?: string[]; 
  public get add() {
    return this.getListAttribute('add');
  }
  public set add(value: string[]) {
    this._add = value;
  }
  public resetAdd() {
    this._add = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addInput() {
    return this._add;
  }

  // drop - computed: false, optional: true, required: false
  private _drop?: string[]; 
  public get drop() {
    return this.getListAttribute('drop');
  }
  public set drop(value: string[]) {
    this._drop = value;
  }
  public resetDrop() {
    this._drop = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropInput() {
    return this._drop;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions {
  /**
  * Level is SELinux level label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#level DataK8SOrgEclipseCheCheClusterV2Manifest#level}
  */
  readonly level?: string;
  /**
  * Role is a SELinux role label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#role DataK8SOrgEclipseCheCheClusterV2Manifest#role}
  */
  readonly role?: string;
  /**
  * Type is a SELinux type label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#type DataK8SOrgEclipseCheCheClusterV2Manifest#type}
  */
  readonly type?: string;
  /**
  * User is a SELinux user label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#user DataK8SOrgEclipseCheCheClusterV2Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptionsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
    role: cdktf.stringToTerraform(struct!.role),
    type: cdktf.stringToTerraform(struct!.type),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptionsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._role = undefined;
      this._type = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._role = value.role;
      this._type = value.type;
      this._user = value.user;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile {
  /**
  * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is 'Localhost'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#localhost_profile DataK8SOrgEclipseCheCheClusterV2Manifest#localhost_profile}
  */
  readonly localhostProfile?: string;
  /**
  * type indicates which kind of seccomp profile will be applied. Valid options are: Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#type DataK8SOrgEclipseCheCheClusterV2Manifest#type}
  */
  readonly type: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfileToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    localhost_profile: cdktf.stringToTerraform(struct!.localhostProfile),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfileToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    localhost_profile: {
      value: cdktf.stringToHclTerraform(struct!.localhostProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localhostProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.localhostProfile = this._localhostProfile;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localhostProfile = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localhostProfile = value.localhostProfile;
      this._type = value.type;
    }
  }

  // localhost_profile - computed: false, optional: true, required: false
  private _localhostProfile?: string; 
  public get localhostProfile() {
    return this.getStringAttribute('localhost_profile');
  }
  public set localhostProfile(value: string) {
    this._localhostProfile = value;
  }
  public resetLocalhostProfile() {
    this._localhostProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localhostProfileInput() {
    return this._localhostProfile;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions {
  /**
  * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#gmsa_credential_spec DataK8SOrgEclipseCheCheClusterV2Manifest#gmsa_credential_spec}
  */
  readonly gmsaCredentialSpec?: string;
  /**
  * GMSACredentialSpecName is the name of the GMSA credential spec to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#gmsa_credential_spec_name DataK8SOrgEclipseCheCheClusterV2Manifest#gmsa_credential_spec_name}
  */
  readonly gmsaCredentialSpecName?: string;
  /**
  * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#host_process DataK8SOrgEclipseCheCheClusterV2Manifest#host_process}
  */
  readonly hostProcess?: boolean | cdktf.IResolvable;
  /**
  * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user_name DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user_name}
  */
  readonly runAsUserName?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptionsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gmsa_credential_spec: cdktf.stringToTerraform(struct!.gmsaCredentialSpec),
    gmsa_credential_spec_name: cdktf.stringToTerraform(struct!.gmsaCredentialSpecName),
    host_process: cdktf.booleanToTerraform(struct!.hostProcess),
    run_as_user_name: cdktf.stringToTerraform(struct!.runAsUserName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptionsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gmsa_credential_spec: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gmsa_credential_spec_name: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpecName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_process: {
      value: cdktf.booleanToHclTerraform(struct!.hostProcess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user_name: {
      value: cdktf.stringToHclTerraform(struct!.runAsUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gmsaCredentialSpec !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpec = this._gmsaCredentialSpec;
    }
    if (this._gmsaCredentialSpecName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpecName = this._gmsaCredentialSpecName;
    }
    if (this._hostProcess !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostProcess = this._hostProcess;
    }
    if (this._runAsUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUserName = this._runAsUserName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = undefined;
      this._gmsaCredentialSpecName = undefined;
      this._hostProcess = undefined;
      this._runAsUserName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = value.gmsaCredentialSpec;
      this._gmsaCredentialSpecName = value.gmsaCredentialSpecName;
      this._hostProcess = value.hostProcess;
      this._runAsUserName = value.runAsUserName;
    }
  }

  // gmsa_credential_spec - computed: false, optional: true, required: false
  private _gmsaCredentialSpec?: string; 
  public get gmsaCredentialSpec() {
    return this.getStringAttribute('gmsa_credential_spec');
  }
  public set gmsaCredentialSpec(value: string) {
    this._gmsaCredentialSpec = value;
  }
  public resetGmsaCredentialSpec() {
    this._gmsaCredentialSpec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecInput() {
    return this._gmsaCredentialSpec;
  }

  // gmsa_credential_spec_name - computed: false, optional: true, required: false
  private _gmsaCredentialSpecName?: string; 
  public get gmsaCredentialSpecName() {
    return this.getStringAttribute('gmsa_credential_spec_name');
  }
  public set gmsaCredentialSpecName(value: string) {
    this._gmsaCredentialSpecName = value;
  }
  public resetGmsaCredentialSpecName() {
    this._gmsaCredentialSpecName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecNameInput() {
    return this._gmsaCredentialSpecName;
  }

  // host_process - computed: false, optional: true, required: false
  private _hostProcess?: boolean | cdktf.IResolvable; 
  public get hostProcess() {
    return this.getBooleanAttribute('host_process');
  }
  public set hostProcess(value: boolean | cdktf.IResolvable) {
    this._hostProcess = value;
  }
  public resetHostProcess() {
    this._hostProcess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostProcessInput() {
    return this._hostProcess;
  }

  // run_as_user_name - computed: false, optional: true, required: false
  private _runAsUserName?: string; 
  public get runAsUserName() {
    return this.getStringAttribute('run_as_user_name');
  }
  public set runAsUserName(value: string) {
    this._runAsUserName = value;
  }
  public resetRunAsUserName() {
    this._runAsUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserNameInput() {
    return this._runAsUserName;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext {
  /**
  * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#allow_privilege_escalation DataK8SOrgEclipseCheCheClusterV2Manifest#allow_privilege_escalation}
  */
  readonly allowPrivilegeEscalation?: boolean | cdktf.IResolvable;
  /**
  * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#capabilities DataK8SOrgEclipseCheCheClusterV2Manifest#capabilities}
  */
  readonly capabilities?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities;
  /**
  * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#privileged DataK8SOrgEclipseCheCheClusterV2Manifest#privileged}
  */
  readonly privileged?: boolean | cdktf.IResolvable;
  /**
  * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#proc_mount DataK8SOrgEclipseCheCheClusterV2Manifest#proc_mount}
  */
  readonly procMount?: string;
  /**
  * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#read_only_root_filesystem DataK8SOrgEclipseCheCheClusterV2Manifest#read_only_root_filesystem}
  */
  readonly readOnlyRootFilesystem?: boolean | cdktf.IResolvable;
  /**
  * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_group DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_group}
  */
  readonly runAsGroup?: number;
  /**
  * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_non_root DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_non_root}
  */
  readonly runAsNonRoot?: boolean | cdktf.IResolvable;
  /**
  * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user}
  */
  readonly runAsUser?: number;
  /**
  * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#se_linux_options DataK8SOrgEclipseCheCheClusterV2Manifest#se_linux_options}
  */
  readonly seLinuxOptions?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions;
  /**
  * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#seccomp_profile DataK8SOrgEclipseCheCheClusterV2Manifest#seccomp_profile}
  */
  readonly seccompProfile?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile;
  /**
  * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#windows_options DataK8SOrgEclipseCheCheClusterV2Manifest#windows_options}
  */
  readonly windowsOptions?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_privilege_escalation: cdktf.booleanToTerraform(struct!.allowPrivilegeEscalation),
    capabilities: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilitiesToTerraform(struct!.capabilities),
    privileged: cdktf.booleanToTerraform(struct!.privileged),
    proc_mount: cdktf.stringToTerraform(struct!.procMount),
    read_only_root_filesystem: cdktf.booleanToTerraform(struct!.readOnlyRootFilesystem),
    run_as_group: cdktf.numberToTerraform(struct!.runAsGroup),
    run_as_non_root: cdktf.booleanToTerraform(struct!.runAsNonRoot),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
    se_linux_options: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptionsToTerraform(struct!.seLinuxOptions),
    seccomp_profile: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfileToTerraform(struct!.seccompProfile),
    windows_options: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptionsToTerraform(struct!.windowsOptions),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_privilege_escalation: {
      value: cdktf.booleanToHclTerraform(struct!.allowPrivilegeEscalation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    capabilities: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilitiesToHclTerraform(struct!.capabilities),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities",
    },
    privileged: {
      value: cdktf.booleanToHclTerraform(struct!.privileged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proc_mount: {
      value: cdktf.stringToHclTerraform(struct!.procMount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only_root_filesystem: {
      value: cdktf.booleanToHclTerraform(struct!.readOnlyRootFilesystem),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_group: {
      value: cdktf.numberToHclTerraform(struct!.runAsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_non_root: {
      value: cdktf.booleanToHclTerraform(struct!.runAsNonRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    se_linux_options: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptionsToHclTerraform(struct!.seLinuxOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions",
    },
    seccomp_profile: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfileToHclTerraform(struct!.seccompProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile",
    },
    windows_options: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptionsToHclTerraform(struct!.windowsOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPrivilegeEscalation !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPrivilegeEscalation = this._allowPrivilegeEscalation;
    }
    if (this._capabilities?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.capabilities = this._capabilities?.internalValue;
    }
    if (this._privileged !== undefined) {
      hasAnyValues = true;
      internalValueResult.privileged = this._privileged;
    }
    if (this._procMount !== undefined) {
      hasAnyValues = true;
      internalValueResult.procMount = this._procMount;
    }
    if (this._readOnlyRootFilesystem !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnlyRootFilesystem = this._readOnlyRootFilesystem;
    }
    if (this._runAsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsGroup = this._runAsGroup;
    }
    if (this._runAsNonRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsNonRoot = this._runAsNonRoot;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    if (this._seLinuxOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seLinuxOptions = this._seLinuxOptions?.internalValue;
    }
    if (this._seccompProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfile = this._seccompProfile?.internalValue;
    }
    if (this._windowsOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowsOptions = this._windowsOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowPrivilegeEscalation = undefined;
      this._capabilities.internalValue = undefined;
      this._privileged = undefined;
      this._procMount = undefined;
      this._readOnlyRootFilesystem = undefined;
      this._runAsGroup = undefined;
      this._runAsNonRoot = undefined;
      this._runAsUser = undefined;
      this._seLinuxOptions.internalValue = undefined;
      this._seccompProfile.internalValue = undefined;
      this._windowsOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowPrivilegeEscalation = value.allowPrivilegeEscalation;
      this._capabilities.internalValue = value.capabilities;
      this._privileged = value.privileged;
      this._procMount = value.procMount;
      this._readOnlyRootFilesystem = value.readOnlyRootFilesystem;
      this._runAsGroup = value.runAsGroup;
      this._runAsNonRoot = value.runAsNonRoot;
      this._runAsUser = value.runAsUser;
      this._seLinuxOptions.internalValue = value.seLinuxOptions;
      this._seccompProfile.internalValue = value.seccompProfile;
      this._windowsOptions.internalValue = value.windowsOptions;
    }
  }

  // allow_privilege_escalation - computed: false, optional: true, required: false
  private _allowPrivilegeEscalation?: boolean | cdktf.IResolvable; 
  public get allowPrivilegeEscalation() {
    return this.getBooleanAttribute('allow_privilege_escalation');
  }
  public set allowPrivilegeEscalation(value: boolean | cdktf.IResolvable) {
    this._allowPrivilegeEscalation = value;
  }
  public resetAllowPrivilegeEscalation() {
    this._allowPrivilegeEscalation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPrivilegeEscalationInput() {
    return this._allowPrivilegeEscalation;
  }

  // capabilities - computed: false, optional: true, required: false
  private _capabilities = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilitiesOutputReference(this, "capabilities");
  public get capabilities() {
    return this._capabilities;
  }
  public putCapabilities(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextCapabilities) {
    this._capabilities.internalValue = value;
  }
  public resetCapabilities() {
    this._capabilities.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capabilitiesInput() {
    return this._capabilities.internalValue;
  }

  // privileged - computed: false, optional: true, required: false
  private _privileged?: boolean | cdktf.IResolvable; 
  public get privileged() {
    return this.getBooleanAttribute('privileged');
  }
  public set privileged(value: boolean | cdktf.IResolvable) {
    this._privileged = value;
  }
  public resetPrivileged() {
    this._privileged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privilegedInput() {
    return this._privileged;
  }

  // proc_mount - computed: false, optional: true, required: false
  private _procMount?: string; 
  public get procMount() {
    return this.getStringAttribute('proc_mount');
  }
  public set procMount(value: string) {
    this._procMount = value;
  }
  public resetProcMount() {
    this._procMount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get procMountInput() {
    return this._procMount;
  }

  // read_only_root_filesystem - computed: false, optional: true, required: false
  private _readOnlyRootFilesystem?: boolean | cdktf.IResolvable; 
  public get readOnlyRootFilesystem() {
    return this.getBooleanAttribute('read_only_root_filesystem');
  }
  public set readOnlyRootFilesystem(value: boolean | cdktf.IResolvable) {
    this._readOnlyRootFilesystem = value;
  }
  public resetReadOnlyRootFilesystem() {
    this._readOnlyRootFilesystem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyRootFilesystemInput() {
    return this._readOnlyRootFilesystem;
  }

  // run_as_group - computed: false, optional: true, required: false
  private _runAsGroup?: number; 
  public get runAsGroup() {
    return this.getNumberAttribute('run_as_group');
  }
  public set runAsGroup(value: number) {
    this._runAsGroup = value;
  }
  public resetRunAsGroup() {
    this._runAsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsGroupInput() {
    return this._runAsGroup;
  }

  // run_as_non_root - computed: false, optional: true, required: false
  private _runAsNonRoot?: boolean | cdktf.IResolvable; 
  public get runAsNonRoot() {
    return this.getBooleanAttribute('run_as_non_root');
  }
  public set runAsNonRoot(value: boolean | cdktf.IResolvable) {
    this._runAsNonRoot = value;
  }
  public resetRunAsNonRoot() {
    this._runAsNonRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsNonRootInput() {
    return this._runAsNonRoot;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }

  // se_linux_options - computed: false, optional: true, required: false
  private _seLinuxOptions = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptionsOutputReference(this, "se_linux_options");
  public get seLinuxOptions() {
    return this._seLinuxOptions;
  }
  public putSeLinuxOptions(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeLinuxOptions) {
    this._seLinuxOptions.internalValue = value;
  }
  public resetSeLinuxOptions() {
    this._seLinuxOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seLinuxOptionsInput() {
    return this._seLinuxOptions.internalValue;
  }

  // seccomp_profile - computed: false, optional: true, required: false
  private _seccompProfile = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfileOutputReference(this, "seccomp_profile");
  public get seccompProfile() {
    return this._seccompProfile;
  }
  public putSeccompProfile(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextSeccompProfile) {
    this._seccompProfile.internalValue = value;
  }
  public resetSeccompProfile() {
    this._seccompProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileInput() {
    return this._seccompProfile.internalValue;
  }

  // windows_options - computed: false, optional: true, required: false
  private _windowsOptions = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptionsOutputReference(this, "windows_options");
  public get windowsOptions() {
    return this._windowsOptions;
  }
  public putWindowsOptions(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextWindowsOptions) {
    this._windowsOptions.internalValue = value;
  }
  public resetWindowsOptions() {
    this._windowsOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsOptionsInput() {
    return this._windowsOptions.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions {
  /**
  * Level is SELinux level label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#level DataK8SOrgEclipseCheCheClusterV2Manifest#level}
  */
  readonly level?: string;
  /**
  * Role is a SELinux role label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#role DataK8SOrgEclipseCheCheClusterV2Manifest#role}
  */
  readonly role?: string;
  /**
  * Type is a SELinux type label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#type DataK8SOrgEclipseCheCheClusterV2Manifest#type}
  */
  readonly type?: string;
  /**
  * User is a SELinux user label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#user DataK8SOrgEclipseCheCheClusterV2Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptionsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
    role: cdktf.stringToTerraform(struct!.role),
    type: cdktf.stringToTerraform(struct!.type),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptionsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._role = undefined;
      this._type = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._role = value.role;
      this._type = value.type;
      this._user = value.user;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile {
  /**
  * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is 'Localhost'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#localhost_profile DataK8SOrgEclipseCheCheClusterV2Manifest#localhost_profile}
  */
  readonly localhostProfile?: string;
  /**
  * type indicates which kind of seccomp profile will be applied. Valid options are: Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#type DataK8SOrgEclipseCheCheClusterV2Manifest#type}
  */
  readonly type: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfileToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    localhost_profile: cdktf.stringToTerraform(struct!.localhostProfile),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfileToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    localhost_profile: {
      value: cdktf.stringToHclTerraform(struct!.localhostProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localhostProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.localhostProfile = this._localhostProfile;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localhostProfile = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localhostProfile = value.localhostProfile;
      this._type = value.type;
    }
  }

  // localhost_profile - computed: false, optional: true, required: false
  private _localhostProfile?: string; 
  public get localhostProfile() {
    return this.getStringAttribute('localhost_profile');
  }
  public set localhostProfile(value: string) {
    this._localhostProfile = value;
  }
  public resetLocalhostProfile() {
    this._localhostProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localhostProfileInput() {
    return this._localhostProfile;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls {
  /**
  * Name of a property to set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Value of a property to set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions {
  /**
  * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#gmsa_credential_spec DataK8SOrgEclipseCheCheClusterV2Manifest#gmsa_credential_spec}
  */
  readonly gmsaCredentialSpec?: string;
  /**
  * GMSACredentialSpecName is the name of the GMSA credential spec to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#gmsa_credential_spec_name DataK8SOrgEclipseCheCheClusterV2Manifest#gmsa_credential_spec_name}
  */
  readonly gmsaCredentialSpecName?: string;
  /**
  * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#host_process DataK8SOrgEclipseCheCheClusterV2Manifest#host_process}
  */
  readonly hostProcess?: boolean | cdktf.IResolvable;
  /**
  * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user_name DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user_name}
  */
  readonly runAsUserName?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptionsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gmsa_credential_spec: cdktf.stringToTerraform(struct!.gmsaCredentialSpec),
    gmsa_credential_spec_name: cdktf.stringToTerraform(struct!.gmsaCredentialSpecName),
    host_process: cdktf.booleanToTerraform(struct!.hostProcess),
    run_as_user_name: cdktf.stringToTerraform(struct!.runAsUserName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptionsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gmsa_credential_spec: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gmsa_credential_spec_name: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpecName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_process: {
      value: cdktf.booleanToHclTerraform(struct!.hostProcess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user_name: {
      value: cdktf.stringToHclTerraform(struct!.runAsUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gmsaCredentialSpec !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpec = this._gmsaCredentialSpec;
    }
    if (this._gmsaCredentialSpecName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpecName = this._gmsaCredentialSpecName;
    }
    if (this._hostProcess !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostProcess = this._hostProcess;
    }
    if (this._runAsUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUserName = this._runAsUserName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = undefined;
      this._gmsaCredentialSpecName = undefined;
      this._hostProcess = undefined;
      this._runAsUserName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = value.gmsaCredentialSpec;
      this._gmsaCredentialSpecName = value.gmsaCredentialSpecName;
      this._hostProcess = value.hostProcess;
      this._runAsUserName = value.runAsUserName;
    }
  }

  // gmsa_credential_spec - computed: false, optional: true, required: false
  private _gmsaCredentialSpec?: string; 
  public get gmsaCredentialSpec() {
    return this.getStringAttribute('gmsa_credential_spec');
  }
  public set gmsaCredentialSpec(value: string) {
    this._gmsaCredentialSpec = value;
  }
  public resetGmsaCredentialSpec() {
    this._gmsaCredentialSpec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecInput() {
    return this._gmsaCredentialSpec;
  }

  // gmsa_credential_spec_name - computed: false, optional: true, required: false
  private _gmsaCredentialSpecName?: string; 
  public get gmsaCredentialSpecName() {
    return this.getStringAttribute('gmsa_credential_spec_name');
  }
  public set gmsaCredentialSpecName(value: string) {
    this._gmsaCredentialSpecName = value;
  }
  public resetGmsaCredentialSpecName() {
    this._gmsaCredentialSpecName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecNameInput() {
    return this._gmsaCredentialSpecName;
  }

  // host_process - computed: false, optional: true, required: false
  private _hostProcess?: boolean | cdktf.IResolvable; 
  public get hostProcess() {
    return this.getBooleanAttribute('host_process');
  }
  public set hostProcess(value: boolean | cdktf.IResolvable) {
    this._hostProcess = value;
  }
  public resetHostProcess() {
    this._hostProcess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostProcessInput() {
    return this._hostProcess;
  }

  // run_as_user_name - computed: false, optional: true, required: false
  private _runAsUserName?: string; 
  public get runAsUserName() {
    return this.getStringAttribute('run_as_user_name');
  }
  public set runAsUserName(value: string) {
    this._runAsUserName = value;
  }
  public resetRunAsUserName() {
    this._runAsUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserNameInput() {
    return this._runAsUserName;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#fs_group DataK8SOrgEclipseCheCheClusterV2Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are 'OnRootMismatch' and 'Always'. If not specified, 'Always' is used. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#fs_group_change_policy DataK8SOrgEclipseCheCheClusterV2Manifest#fs_group_change_policy}
  */
  readonly fsGroupChangePolicy?: string;
  /**
  * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_group DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_group}
  */
  readonly runAsGroup?: number;
  /**
  * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_non_root DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_non_root}
  */
  readonly runAsNonRoot?: boolean | cdktf.IResolvable;
  /**
  * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#run_as_user DataK8SOrgEclipseCheCheClusterV2Manifest#run_as_user}
  */
  readonly runAsUser?: number;
  /**
  * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#se_linux_options DataK8SOrgEclipseCheCheClusterV2Manifest#se_linux_options}
  */
  readonly seLinuxOptions?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions;
  /**
  * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#seccomp_profile DataK8SOrgEclipseCheCheClusterV2Manifest#seccomp_profile}
  */
  readonly seccompProfile?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile;
  /**
  * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#supplemental_groups DataK8SOrgEclipseCheCheClusterV2Manifest#supplemental_groups}
  */
  readonly supplementalGroups?: string[];
  /**
  * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#sysctls DataK8SOrgEclipseCheCheClusterV2Manifest#sysctls}
  */
  readonly sysctls?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls[] | cdktf.IResolvable;
  /**
  * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#windows_options DataK8SOrgEclipseCheCheClusterV2Manifest#windows_options}
  */
  readonly windowsOptions?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    fs_group_change_policy: cdktf.stringToTerraform(struct!.fsGroupChangePolicy),
    run_as_group: cdktf.numberToTerraform(struct!.runAsGroup),
    run_as_non_root: cdktf.booleanToTerraform(struct!.runAsNonRoot),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
    se_linux_options: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptionsToTerraform(struct!.seLinuxOptions),
    seccomp_profile: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfileToTerraform(struct!.seccompProfile),
    supplemental_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.supplementalGroups),
    sysctls: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsToTerraform, false)(struct!.sysctls),
    windows_options: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptionsToTerraform(struct!.windowsOptions),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    fs_group_change_policy: {
      value: cdktf.stringToHclTerraform(struct!.fsGroupChangePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    run_as_group: {
      value: cdktf.numberToHclTerraform(struct!.runAsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_non_root: {
      value: cdktf.booleanToHclTerraform(struct!.runAsNonRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    se_linux_options: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptionsToHclTerraform(struct!.seLinuxOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions",
    },
    seccomp_profile: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfileToHclTerraform(struct!.seccompProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile",
    },
    supplemental_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.supplementalGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    sysctls: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsToHclTerraform, false)(struct!.sysctls),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsList",
    },
    windows_options: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptionsToHclTerraform(struct!.windowsOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._fsGroupChangePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroupChangePolicy = this._fsGroupChangePolicy;
    }
    if (this._runAsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsGroup = this._runAsGroup;
    }
    if (this._runAsNonRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsNonRoot = this._runAsNonRoot;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    if (this._seLinuxOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seLinuxOptions = this._seLinuxOptions?.internalValue;
    }
    if (this._seccompProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfile = this._seccompProfile?.internalValue;
    }
    if (this._supplementalGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.supplementalGroups = this._supplementalGroups;
    }
    if (this._sysctls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysctls = this._sysctls?.internalValue;
    }
    if (this._windowsOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowsOptions = this._windowsOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._fsGroupChangePolicy = undefined;
      this._runAsGroup = undefined;
      this._runAsNonRoot = undefined;
      this._runAsUser = undefined;
      this._seLinuxOptions.internalValue = undefined;
      this._seccompProfile.internalValue = undefined;
      this._supplementalGroups = undefined;
      this._sysctls.internalValue = undefined;
      this._windowsOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._fsGroupChangePolicy = value.fsGroupChangePolicy;
      this._runAsGroup = value.runAsGroup;
      this._runAsNonRoot = value.runAsNonRoot;
      this._runAsUser = value.runAsUser;
      this._seLinuxOptions.internalValue = value.seLinuxOptions;
      this._seccompProfile.internalValue = value.seccompProfile;
      this._supplementalGroups = value.supplementalGroups;
      this._sysctls.internalValue = value.sysctls;
      this._windowsOptions.internalValue = value.windowsOptions;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // fs_group_change_policy - computed: false, optional: true, required: false
  private _fsGroupChangePolicy?: string; 
  public get fsGroupChangePolicy() {
    return this.getStringAttribute('fs_group_change_policy');
  }
  public set fsGroupChangePolicy(value: string) {
    this._fsGroupChangePolicy = value;
  }
  public resetFsGroupChangePolicy() {
    this._fsGroupChangePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupChangePolicyInput() {
    return this._fsGroupChangePolicy;
  }

  // run_as_group - computed: false, optional: true, required: false
  private _runAsGroup?: number; 
  public get runAsGroup() {
    return this.getNumberAttribute('run_as_group');
  }
  public set runAsGroup(value: number) {
    this._runAsGroup = value;
  }
  public resetRunAsGroup() {
    this._runAsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsGroupInput() {
    return this._runAsGroup;
  }

  // run_as_non_root - computed: false, optional: true, required: false
  private _runAsNonRoot?: boolean | cdktf.IResolvable; 
  public get runAsNonRoot() {
    return this.getBooleanAttribute('run_as_non_root');
  }
  public set runAsNonRoot(value: boolean | cdktf.IResolvable) {
    this._runAsNonRoot = value;
  }
  public resetRunAsNonRoot() {
    this._runAsNonRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsNonRootInput() {
    return this._runAsNonRoot;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }

  // se_linux_options - computed: false, optional: true, required: false
  private _seLinuxOptions = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptionsOutputReference(this, "se_linux_options");
  public get seLinuxOptions() {
    return this._seLinuxOptions;
  }
  public putSeLinuxOptions(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeLinuxOptions) {
    this._seLinuxOptions.internalValue = value;
  }
  public resetSeLinuxOptions() {
    this._seLinuxOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seLinuxOptionsInput() {
    return this._seLinuxOptions.internalValue;
  }

  // seccomp_profile - computed: false, optional: true, required: false
  private _seccompProfile = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfileOutputReference(this, "seccomp_profile");
  public get seccompProfile() {
    return this._seccompProfile;
  }
  public putSeccompProfile(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSeccompProfile) {
    this._seccompProfile.internalValue = value;
  }
  public resetSeccompProfile() {
    this._seccompProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileInput() {
    return this._seccompProfile.internalValue;
  }

  // supplemental_groups - computed: false, optional: true, required: false
  private _supplementalGroups?: string[]; 
  public get supplementalGroups() {
    return this.getListAttribute('supplemental_groups');
  }
  public set supplementalGroups(value: string[]) {
    this._supplementalGroups = value;
  }
  public resetSupplementalGroups() {
    this._supplementalGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get supplementalGroupsInput() {
    return this._supplementalGroups;
  }

  // sysctls - computed: false, optional: true, required: false
  private _sysctls = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctlsList(this, "sysctls", false);
  public get sysctls() {
    return this._sysctls;
  }
  public putSysctls(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextSysctls[] | cdktf.IResolvable) {
    this._sysctls.internalValue = value;
  }
  public resetSysctls() {
    this._sysctls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysctlsInput() {
    return this._sysctls.internalValue;
  }

  // windows_options - computed: false, optional: true, required: false
  private _windowsOptions = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptionsOutputReference(this, "windows_options");
  public get windowsOptions() {
    return this._windowsOptions;
  }
  public putWindowsOptions(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextWindowsOptions) {
    this._windowsOptions.internalValue = value;
  }
  public resetWindowsOptions() {
    this._windowsOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsOptionsInput() {
    return this._windowsOptions.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity {
  /**
  * Container SecurityContext used by all workspace-related containers. If set, defined values are merged into the default Container SecurityContext configuration. Requires devEnvironments.disableContainerBuildCapabilities to be set to 'true' in order to take effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_security_context DataK8SOrgEclipseCheCheClusterV2Manifest#container_security_context}
  */
  readonly containerSecurityContext?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext;
  /**
  * PodSecurityContext used by all workspace-related pods. If set, defined values are merged into the default PodSecurityContext configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#pod_security_context DataK8SOrgEclipseCheCheClusterV2Manifest#pod_security_context}
  */
  readonly podSecurityContext?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_security_context: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextToTerraform(struct!.containerSecurityContext),
    pod_security_context: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextToTerraform(struct!.podSecurityContext),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_security_context: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextToHclTerraform(struct!.containerSecurityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext",
    },
    pod_security_context: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextToHclTerraform(struct!.podSecurityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerSecurityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerSecurityContext = this._containerSecurityContext?.internalValue;
    }
    if (this._podSecurityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSecurityContext = this._podSecurityContext?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerSecurityContext.internalValue = undefined;
      this._podSecurityContext.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerSecurityContext.internalValue = value.containerSecurityContext;
      this._podSecurityContext.internalValue = value.podSecurityContext;
    }
  }

  // container_security_context - computed: false, optional: true, required: false
  private _containerSecurityContext = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContextOutputReference(this, "container_security_context");
  public get containerSecurityContext() {
    return this._containerSecurityContext;
  }
  public putContainerSecurityContext(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityContainerSecurityContext) {
    this._containerSecurityContext.internalValue = value;
  }
  public resetContainerSecurityContext() {
    this._containerSecurityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerSecurityContextInput() {
    return this._containerSecurityContext.internalValue;
  }

  // pod_security_context - computed: false, optional: true, required: false
  private _podSecurityContext = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContextOutputReference(this, "pod_security_context");
  public get podSecurityContext() {
    return this._podSecurityContext;
  }
  public putPodSecurityContext(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityPodSecurityContext) {
    this._podSecurityContext.internalValue = value;
  }
  public resetPodSecurityContext() {
    this._podSecurityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSecurityContextInput() {
    return this._podSecurityContext.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens {
  /**
  * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#audience DataK8SOrgEclipseCheCheClusterV2Manifest#audience}
  */
  readonly audience?: string;
  /**
  * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours. Defaults to 1 hour and must be at least 10 minutes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#expiration_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#expiration_seconds}
  */
  readonly expirationSeconds?: number;
  /**
  * Path within the workspace container at which the token should be mounted. Must not contain ':'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#mount_path DataK8SOrgEclipseCheCheClusterV2Manifest#mount_path}
  */
  readonly mountPath: string;
  /**
  * Identifiable name of the ServiceAccount token. If multiple ServiceAccount tokens use the same mount path, a generic name will be used for the projected volume instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#name DataK8SOrgEclipseCheCheClusterV2Manifest#name}
  */
  readonly name: string;
  /**
  * Path is the path relative to the mount point of the file to project the token into.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#path DataK8SOrgEclipseCheCheClusterV2Manifest#path}
  */
  readonly path: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audience: cdktf.stringToTerraform(struct!.audience),
    expiration_seconds: cdktf.numberToTerraform(struct!.expirationSeconds),
    mount_path: cdktf.stringToTerraform(struct!.mountPath),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audience: {
      value: cdktf.stringToHclTerraform(struct!.audience),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expiration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.expirationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    mount_path: {
      value: cdktf.stringToHclTerraform(struct!.mountPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audience !== undefined) {
      hasAnyValues = true;
      internalValueResult.audience = this._audience;
    }
    if (this._expirationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.expirationSeconds = this._expirationSeconds;
    }
    if (this._mountPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountPath = this._mountPath;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audience = undefined;
      this._expirationSeconds = undefined;
      this._mountPath = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audience = value.audience;
      this._expirationSeconds = value.expirationSeconds;
      this._mountPath = value.mountPath;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // audience - computed: false, optional: true, required: false
  private _audience?: string; 
  public get audience() {
    return this.getStringAttribute('audience');
  }
  public set audience(value: string) {
    this._audience = value;
  }
  public resetAudience() {
    this._audience = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audienceInput() {
    return this._audience;
  }

  // expiration_seconds - computed: false, optional: true, required: false
  private _expirationSeconds?: number; 
  public get expirationSeconds() {
    return this.getNumberAttribute('expiration_seconds');
  }
  public set expirationSeconds(value: number) {
    this._expirationSeconds = value;
  }
  public resetExpirationSeconds() {
    this._expirationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expirationSecondsInput() {
    return this._expirationSeconds;
  }

  // mount_path - computed: false, optional: false, required: true
  private _mountPath?: string; 
  public get mountPath() {
    return this.getStringAttribute('mount_path');
  }
  public set mountPath(value: string) {
    this._mountPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get mountPathInput() {
    return this._mountPath;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig {
  /**
  * Persistent Volume Claim size. To update the claim size, the storage class that provisions it must support resizing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#claim_size DataK8SOrgEclipseCheCheClusterV2Manifest#claim_size}
  */
  readonly claimSize?: string;
  /**
  * Storage class for the Persistent Volume Claim. When omitted or left blank, a default storage class is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#storage_class DataK8SOrgEclipseCheCheClusterV2Manifest#storage_class}
  */
  readonly storageClass?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfigToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claim_size: cdktf.stringToTerraform(struct!.claimSize),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfigToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claim_size: {
      value: cdktf.stringToHclTerraform(struct!.claimSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claimSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimSize = this._claimSize;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claimSize = undefined;
      this._storageClass = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claimSize = value.claimSize;
      this._storageClass = value.storageClass;
    }
  }

  // claim_size - computed: false, optional: true, required: false
  private _claimSize?: string; 
  public get claimSize() {
    return this.getStringAttribute('claim_size');
  }
  public set claimSize(value: string) {
    this._claimSize = value;
  }
  public resetClaimSize() {
    this._claimSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimSizeInput() {
    return this._claimSize;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig {
  /**
  * Persistent Volume Claim size. To update the claim size, the storage class that provisions it must support resizing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#claim_size DataK8SOrgEclipseCheCheClusterV2Manifest#claim_size}
  */
  readonly claimSize?: string;
  /**
  * Storage class for the Persistent Volume Claim. When omitted or left blank, a default storage class is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#storage_class DataK8SOrgEclipseCheCheClusterV2Manifest#storage_class}
  */
  readonly storageClass?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfigToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claim_size: cdktf.stringToTerraform(struct!.claimSize),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfigToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claim_size: {
      value: cdktf.stringToHclTerraform(struct!.claimSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claimSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimSize = this._claimSize;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claimSize = undefined;
      this._storageClass = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claimSize = value.claimSize;
      this._storageClass = value.storageClass;
    }
  }

  // claim_size - computed: false, optional: true, required: false
  private _claimSize?: string; 
  public get claimSize() {
    return this.getStringAttribute('claim_size');
  }
  public set claimSize(value: string) {
    this._claimSize = value;
  }
  public resetClaimSize() {
    this._claimSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimSizeInput() {
    return this._claimSize;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage {
  /**
  * PVC settings when using the 'per-user' PVC strategy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#per_user_strategy_pvc_config DataK8SOrgEclipseCheCheClusterV2Manifest#per_user_strategy_pvc_config}
  */
  readonly perUserStrategyPvcConfig?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig;
  /**
  * PVC settings when using the 'per-workspace' PVC strategy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#per_workspace_strategy_pvc_config DataK8SOrgEclipseCheCheClusterV2Manifest#per_workspace_strategy_pvc_config}
  */
  readonly perWorkspaceStrategyPvcConfig?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig;
  /**
  * Persistent volume claim strategy for the Che server. The supported strategies are: 'per-user' (all workspaces PVCs in one volume), 'per-workspace' (each workspace is given its own individual PVC) and 'ephemeral' (non-persistent storage where local changes will be lost when the workspace is stopped.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#pvc_strategy DataK8SOrgEclipseCheCheClusterV2Manifest#pvc_strategy}
  */
  readonly pvcStrategy?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    per_user_strategy_pvc_config: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfigToTerraform(struct!.perUserStrategyPvcConfig),
    per_workspace_strategy_pvc_config: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfigToTerraform(struct!.perWorkspaceStrategyPvcConfig),
    pvc_strategy: cdktf.stringToTerraform(struct!.pvcStrategy),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    per_user_strategy_pvc_config: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfigToHclTerraform(struct!.perUserStrategyPvcConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig",
    },
    per_workspace_strategy_pvc_config: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfigToHclTerraform(struct!.perWorkspaceStrategyPvcConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig",
    },
    pvc_strategy: {
      value: cdktf.stringToHclTerraform(struct!.pvcStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._perUserStrategyPvcConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.perUserStrategyPvcConfig = this._perUserStrategyPvcConfig?.internalValue;
    }
    if (this._perWorkspaceStrategyPvcConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.perWorkspaceStrategyPvcConfig = this._perWorkspaceStrategyPvcConfig?.internalValue;
    }
    if (this._pvcStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvcStrategy = this._pvcStrategy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._perUserStrategyPvcConfig.internalValue = undefined;
      this._perWorkspaceStrategyPvcConfig.internalValue = undefined;
      this._pvcStrategy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._perUserStrategyPvcConfig.internalValue = value.perUserStrategyPvcConfig;
      this._perWorkspaceStrategyPvcConfig.internalValue = value.perWorkspaceStrategyPvcConfig;
      this._pvcStrategy = value.pvcStrategy;
    }
  }

  // per_user_strategy_pvc_config - computed: false, optional: true, required: false
  private _perUserStrategyPvcConfig = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfigOutputReference(this, "per_user_strategy_pvc_config");
  public get perUserStrategyPvcConfig() {
    return this._perUserStrategyPvcConfig;
  }
  public putPerUserStrategyPvcConfig(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerUserStrategyPvcConfig) {
    this._perUserStrategyPvcConfig.internalValue = value;
  }
  public resetPerUserStrategyPvcConfig() {
    this._perUserStrategyPvcConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perUserStrategyPvcConfigInput() {
    return this._perUserStrategyPvcConfig.internalValue;
  }

  // per_workspace_strategy_pvc_config - computed: false, optional: true, required: false
  private _perWorkspaceStrategyPvcConfig = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfigOutputReference(this, "per_workspace_strategy_pvc_config");
  public get perWorkspaceStrategyPvcConfig() {
    return this._perWorkspaceStrategyPvcConfig;
  }
  public putPerWorkspaceStrategyPvcConfig(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStoragePerWorkspaceStrategyPvcConfig) {
    this._perWorkspaceStrategyPvcConfig.internalValue = value;
  }
  public resetPerWorkspaceStrategyPvcConfig() {
    this._perWorkspaceStrategyPvcConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perWorkspaceStrategyPvcConfigInput() {
    return this._perWorkspaceStrategyPvcConfig.internalValue;
  }

  // pvc_strategy - computed: false, optional: true, required: false
  private _pvcStrategy?: string; 
  public get pvcStrategy() {
    return this.getStringAttribute('pvc_strategy');
  }
  public set pvcStrategy(value: string) {
    this._pvcStrategy = value;
  }
  public resetPvcStrategy() {
    this._pvcStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvcStrategyInput() {
    return this._pvcStrategy;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#effect DataK8SOrgEclipseCheCheClusterV2Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#key DataK8SOrgEclipseCheCheClusterV2Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#operator DataK8SOrgEclipseCheCheClusterV2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#toleration_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#value DataK8SOrgEclipseCheCheClusterV2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts {
  /**
  * The ConfigMap contains certificates to propagate to the Che components and to provide a particular configuration for Git. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/deploying-che-with-support-for-git-repositories-with-self-signed-certificates/ The ConfigMap must have a 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#git_trusted_certs_config_map_name DataK8SOrgEclipseCheCheClusterV2Manifest#git_trusted_certs_config_map_name}
  */
  readonly gitTrustedCertsConfigMapName?: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCertsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    git_trusted_certs_config_map_name: cdktf.stringToTerraform(struct!.gitTrustedCertsConfigMapName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCertsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    git_trusted_certs_config_map_name: {
      value: cdktf.stringToHclTerraform(struct!.gitTrustedCertsConfigMapName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCertsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gitTrustedCertsConfigMapName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitTrustedCertsConfigMapName = this._gitTrustedCertsConfigMapName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gitTrustedCertsConfigMapName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gitTrustedCertsConfigMapName = value.gitTrustedCertsConfigMapName;
    }
  }

  // git_trusted_certs_config_map_name - computed: false, optional: true, required: false
  private _gitTrustedCertsConfigMapName?: string; 
  public get gitTrustedCertsConfigMapName() {
    return this.getStringAttribute('git_trusted_certs_config_map_name');
  }
  public set gitTrustedCertsConfigMapName(value: string) {
    this._gitTrustedCertsConfigMapName = value;
  }
  public resetGitTrustedCertsConfigMapName() {
    this._gitTrustedCertsConfigMapName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitTrustedCertsConfigMapNameInput() {
    return this._gitTrustedCertsConfigMapName;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser {
  /**
  * Additional ClusterRoles assigned to the user. The role must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#cluster_roles DataK8SOrgEclipseCheCheClusterV2Manifest#cluster_roles}
  */
  readonly clusterRoles?: string[];
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUserToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterRoles),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUserToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterRoles = this._clusterRoles;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterRoles = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterRoles = value.clusterRoles;
    }
  }

  // cluster_roles - computed: false, optional: true, required: false
  private _clusterRoles?: string[]; 
  public get clusterRoles() {
    return this.getListAttribute('cluster_roles');
  }
  public set clusterRoles(value: string[]) {
    this._clusterRoles = value;
  }
  public resetClusterRoles() {
    this._clusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterRolesInput() {
    return this._clusterRoles;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironments {
  /**
  * AllowedSources defines the allowed sources on which workspaces can be started.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#allowed_sources DataK8SOrgEclipseCheCheClusterV2Manifest#allowed_sources}
  */
  readonly allowedSources?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources;
  /**
  * Container build configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#container_build_configuration DataK8SOrgEclipseCheCheClusterV2Manifest#container_build_configuration}
  */
  readonly containerBuildConfiguration?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration;
  /**
  * Default components applied to DevWorkspaces. These default components are meant to be used when a Devfile, that does not contain any components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#default_components DataK8SOrgEclipseCheCheClusterV2Manifest#default_components}
  */
  readonly defaultComponents?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents[] | cdktf.IResolvable;
  /**
  * The default editor to workspace create with. It could be a plugin ID or a URI. The plugin ID must have 'publisher/name/version' format. The URI must start from 'http://' or 'https://'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#default_editor DataK8SOrgEclipseCheCheClusterV2Manifest#default_editor}
  */
  readonly defaultEditor?: string;
  /**
  * User's default namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#default_namespace DataK8SOrgEclipseCheCheClusterV2Manifest#default_namespace}
  */
  readonly defaultNamespace?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace;
  /**
  * Default plug-ins applied to DevWorkspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#default_plugins DataK8SOrgEclipseCheCheClusterV2Manifest#default_plugins}
  */
  readonly defaultPlugins?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins[] | cdktf.IResolvable;
  /**
  * DeploymentStrategy defines the deployment strategy to use to replace existing workspace pods with new ones. The available deployment stragies are 'Recreate' and 'RollingUpdate'. With the 'Recreate' deployment strategy, the existing workspace pod is killed before the new one is created. With the 'RollingUpdate' deployment strategy, a new workspace pod is created and the existing workspace pod is deleted only when the new workspace pod is in a ready state. If not specified, the default 'Recreate' deployment strategy is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deployment_strategy DataK8SOrgEclipseCheCheClusterV2Manifest#deployment_strategy}
  */
  readonly deploymentStrategy?: string;
  /**
  * Disables the container build capabilities. When set to 'false' (the default value), the devEnvironments.security.containerSecurityContext field is ignored, and the following container SecurityContext is applied: containerSecurityContext: allowPrivilegeEscalation: true capabilities: add: - SETGID - SETUID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#disable_container_build_capabilities DataK8SOrgEclipseCheCheClusterV2Manifest#disable_container_build_capabilities}
  */
  readonly disableContainerBuildCapabilities?: boolean | cdktf.IResolvable;
  /**
  * GatewayContainer configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#gateway_container DataK8SOrgEclipseCheCheClusterV2Manifest#gateway_container}
  */
  readonly gatewayContainer?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer;
  /**
  * IgnoredUnrecoverableEvents defines a list of Kubernetes event names that should be ignored when deciding to fail a workspace that is starting. This option should be used if a transient cluster issue is triggering false-positives (for example, if the cluster occasionally encounters FailedScheduling events). Events listed here will not trigger workspace failures.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#ignored_unrecoverable_events DataK8SOrgEclipseCheCheClusterV2Manifest#ignored_unrecoverable_events}
  */
  readonly ignoredUnrecoverableEvents?: string[];
  /**
  * ImagePullPolicy defines the imagePullPolicy used for containers in a DevWorkspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#image_pull_policy DataK8SOrgEclipseCheCheClusterV2Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * The maximum number of concurrently running workspaces across the entire Kubernetes cluster. This applies to all users in the system. If the value is set to -1, it means there is no limit on the number of running workspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#max_number_of_running_workspaces_per_cluster DataK8SOrgEclipseCheCheClusterV2Manifest#max_number_of_running_workspaces_per_cluster}
  */
  readonly maxNumberOfRunningWorkspacesPerCluster?: number;
  /**
  * The maximum number of running workspaces per user. The value, -1, allows users to run an unlimited number of workspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#max_number_of_running_workspaces_per_user DataK8SOrgEclipseCheCheClusterV2Manifest#max_number_of_running_workspaces_per_user}
  */
  readonly maxNumberOfRunningWorkspacesPerUser?: number;
  /**
  * Total number of workspaces, both stopped and running, that a user can keep. The value, -1, allows users to keep an unlimited number of workspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#max_number_of_workspaces_per_user DataK8SOrgEclipseCheCheClusterV2Manifest#max_number_of_workspaces_per_user}
  */
  readonly maxNumberOfWorkspacesPerUser?: number;
  /**
  * The node selector limits the nodes that can run the workspace pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#node_selector DataK8SOrgEclipseCheCheClusterV2Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * PersistUserHome defines configuration options for persisting the user home directory in workspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#persist_user_home DataK8SOrgEclipseCheCheClusterV2Manifest#persist_user_home}
  */
  readonly persistUserHome?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome;
  /**
  * Pod scheduler for the workspace pods. If not specified, the pod scheduler is set to the default scheduler on the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#pod_scheduler_name DataK8SOrgEclipseCheCheClusterV2Manifest#pod_scheduler_name}
  */
  readonly podSchedulerName?: string;
  /**
  * Project clone container configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#project_clone_container DataK8SOrgEclipseCheCheClusterV2Manifest#project_clone_container}
  */
  readonly projectCloneContainer?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer;
  /**
  * RuntimeClassName specifies the spec.runtimeClassName for workspace pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#runtime_class_name DataK8SOrgEclipseCheCheClusterV2Manifest#runtime_class_name}
  */
  readonly runtimeClassName?: string;
  /**
  * Idle timeout for workspaces in seconds. This timeout is the duration after which a workspace will be idled if there is no activity. To disable workspace idling due to inactivity, set this value to -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#seconds_of_inactivity_before_idling DataK8SOrgEclipseCheCheClusterV2Manifest#seconds_of_inactivity_before_idling}
  */
  readonly secondsOfInactivityBeforeIdling?: number;
  /**
  * Run timeout for workspaces in seconds. This timeout is the maximum duration a workspace runs. To disable workspace run timeout, set this value to -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#seconds_of_run_before_idling DataK8SOrgEclipseCheCheClusterV2Manifest#seconds_of_run_before_idling}
  */
  readonly secondsOfRunBeforeIdling?: number;
  /**
  * Workspace security configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#security DataK8SOrgEclipseCheCheClusterV2Manifest#security}
  */
  readonly security?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity;
  /**
  * ServiceAccount to use by the DevWorkspace operator when starting the workspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#service_account DataK8SOrgEclipseCheCheClusterV2Manifest#service_account}
  */
  readonly serviceAccount?: string;
  /**
  * List of ServiceAccount tokens that will be mounted into workspace pods as projected volumes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#service_account_tokens DataK8SOrgEclipseCheCheClusterV2Manifest#service_account_tokens}
  */
  readonly serviceAccountTokens?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens[] | cdktf.IResolvable;
  /**
  * StartTimeoutSeconds determines the maximum duration (in seconds) that a workspace can take to start before it is automatically failed. If not specified, the default value of 300 seconds (5 minutes) is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#start_timeout_seconds DataK8SOrgEclipseCheCheClusterV2Manifest#start_timeout_seconds}
  */
  readonly startTimeoutSeconds?: number;
  /**
  * Workspaces persistent storage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#storage DataK8SOrgEclipseCheCheClusterV2Manifest#storage}
  */
  readonly storage?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage;
  /**
  * The pod tolerations of the workspace pods limit where the workspace pods can run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#tolerations DataK8SOrgEclipseCheCheClusterV2Manifest#tolerations}
  */
  readonly tolerations?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations[] | cdktf.IResolvable;
  /**
  * Trusted certificate settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#trusted_certs DataK8SOrgEclipseCheCheClusterV2Manifest#trusted_certs}
  */
  readonly trustedCerts?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts;
  /**
  * User configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#user DataK8SOrgEclipseCheCheClusterV2Manifest#user}
  */
  readonly user?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser;
  /**
  * WorkspacesPodAnnotations defines additional annotations for workspace pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#workspaces_pod_annotations DataK8SOrgEclipseCheCheClusterV2Manifest#workspaces_pod_annotations}
  */
  readonly workspacesPodAnnotations?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironments | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_sources: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSourcesToTerraform(struct!.allowedSources),
    container_build_configuration: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfigurationToTerraform(struct!.containerBuildConfiguration),
    default_components: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsToTerraform, false)(struct!.defaultComponents),
    default_editor: cdktf.stringToTerraform(struct!.defaultEditor),
    default_namespace: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespaceToTerraform(struct!.defaultNamespace),
    default_plugins: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsToTerraform, false)(struct!.defaultPlugins),
    deployment_strategy: cdktf.stringToTerraform(struct!.deploymentStrategy),
    disable_container_build_capabilities: cdktf.booleanToTerraform(struct!.disableContainerBuildCapabilities),
    gateway_container: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerToTerraform(struct!.gatewayContainer),
    ignored_unrecoverable_events: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ignoredUnrecoverableEvents),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    max_number_of_running_workspaces_per_cluster: cdktf.numberToTerraform(struct!.maxNumberOfRunningWorkspacesPerCluster),
    max_number_of_running_workspaces_per_user: cdktf.numberToTerraform(struct!.maxNumberOfRunningWorkspacesPerUser),
    max_number_of_workspaces_per_user: cdktf.numberToTerraform(struct!.maxNumberOfWorkspacesPerUser),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    persist_user_home: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHomeToTerraform(struct!.persistUserHome),
    pod_scheduler_name: cdktf.stringToTerraform(struct!.podSchedulerName),
    project_clone_container: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerToTerraform(struct!.projectCloneContainer),
    runtime_class_name: cdktf.stringToTerraform(struct!.runtimeClassName),
    seconds_of_inactivity_before_idling: cdktf.numberToTerraform(struct!.secondsOfInactivityBeforeIdling),
    seconds_of_run_before_idling: cdktf.numberToTerraform(struct!.secondsOfRunBeforeIdling),
    security: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityToTerraform(struct!.security),
    service_account: cdktf.stringToTerraform(struct!.serviceAccount),
    service_account_tokens: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensToTerraform, false)(struct!.serviceAccountTokens),
    start_timeout_seconds: cdktf.numberToTerraform(struct!.startTimeoutSeconds),
    storage: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorageToTerraform(struct!.storage),
    tolerations: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsToTerraform, false)(struct!.tolerations),
    trusted_certs: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCertsToTerraform(struct!.trustedCerts),
    user: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUserToTerraform(struct!.user),
    workspaces_pod_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.workspacesPodAnnotations),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironments | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_sources: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSourcesToHclTerraform(struct!.allowedSources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources",
    },
    container_build_configuration: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfigurationToHclTerraform(struct!.containerBuildConfiguration),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration",
    },
    default_components: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsToHclTerraform, false)(struct!.defaultComponents),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsList",
    },
    default_editor: {
      value: cdktf.stringToHclTerraform(struct!.defaultEditor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_namespace: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespaceToHclTerraform(struct!.defaultNamespace),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace",
    },
    default_plugins: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsToHclTerraform, false)(struct!.defaultPlugins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsList",
    },
    deployment_strategy: {
      value: cdktf.stringToHclTerraform(struct!.deploymentStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_container_build_capabilities: {
      value: cdktf.booleanToHclTerraform(struct!.disableContainerBuildCapabilities),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    gateway_container: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerToHclTerraform(struct!.gatewayContainer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer",
    },
    ignored_unrecoverable_events: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ignoredUnrecoverableEvents),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_number_of_running_workspaces_per_cluster: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfRunningWorkspacesPerCluster),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_running_workspaces_per_user: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfRunningWorkspacesPerUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_workspaces_per_user: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfWorkspacesPerUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    persist_user_home: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHomeToHclTerraform(struct!.persistUserHome),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome",
    },
    pod_scheduler_name: {
      value: cdktf.stringToHclTerraform(struct!.podSchedulerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_clone_container: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerToHclTerraform(struct!.projectCloneContainer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer",
    },
    runtime_class_name: {
      value: cdktf.stringToHclTerraform(struct!.runtimeClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds_of_inactivity_before_idling: {
      value: cdktf.numberToHclTerraform(struct!.secondsOfInactivityBeforeIdling),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    seconds_of_run_before_idling: {
      value: cdktf.numberToHclTerraform(struct!.secondsOfRunBeforeIdling),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    security: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityToHclTerraform(struct!.security),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity",
    },
    service_account: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccount),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_tokens: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensToHclTerraform, false)(struct!.serviceAccountTokens),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensList",
    },
    start_timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.startTimeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    storage: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorageToHclTerraform(struct!.storage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsList",
    },
    trusted_certs: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCertsToHclTerraform(struct!.trustedCerts),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts",
    },
    user: {
      value: dataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUserToHclTerraform(struct!.user),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser",
    },
    workspaces_pod_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.workspacesPodAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironments | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedSources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedSources = this._allowedSources?.internalValue;
    }
    if (this._containerBuildConfiguration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerBuildConfiguration = this._containerBuildConfiguration?.internalValue;
    }
    if (this._defaultComponents?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultComponents = this._defaultComponents?.internalValue;
    }
    if (this._defaultEditor !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultEditor = this._defaultEditor;
    }
    if (this._defaultNamespace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultNamespace = this._defaultNamespace?.internalValue;
    }
    if (this._defaultPlugins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultPlugins = this._defaultPlugins?.internalValue;
    }
    if (this._deploymentStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentStrategy = this._deploymentStrategy;
    }
    if (this._disableContainerBuildCapabilities !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableContainerBuildCapabilities = this._disableContainerBuildCapabilities;
    }
    if (this._gatewayContainer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayContainer = this._gatewayContainer?.internalValue;
    }
    if (this._ignoredUnrecoverableEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoredUnrecoverableEvents = this._ignoredUnrecoverableEvents;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._maxNumberOfRunningWorkspacesPerCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfRunningWorkspacesPerCluster = this._maxNumberOfRunningWorkspacesPerCluster;
    }
    if (this._maxNumberOfRunningWorkspacesPerUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfRunningWorkspacesPerUser = this._maxNumberOfRunningWorkspacesPerUser;
    }
    if (this._maxNumberOfWorkspacesPerUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfWorkspacesPerUser = this._maxNumberOfWorkspacesPerUser;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._persistUserHome?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistUserHome = this._persistUserHome?.internalValue;
    }
    if (this._podSchedulerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSchedulerName = this._podSchedulerName;
    }
    if (this._projectCloneContainer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectCloneContainer = this._projectCloneContainer?.internalValue;
    }
    if (this._runtimeClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeClassName = this._runtimeClassName;
    }
    if (this._secondsOfInactivityBeforeIdling !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondsOfInactivityBeforeIdling = this._secondsOfInactivityBeforeIdling;
    }
    if (this._secondsOfRunBeforeIdling !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondsOfRunBeforeIdling = this._secondsOfRunBeforeIdling;
    }
    if (this._security?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.security = this._security?.internalValue;
    }
    if (this._serviceAccount !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount;
    }
    if (this._serviceAccountTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountTokens = this._serviceAccountTokens?.internalValue;
    }
    if (this._startTimeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.startTimeoutSeconds = this._startTimeoutSeconds;
    }
    if (this._storage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._trustedCerts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.trustedCerts = this._trustedCerts?.internalValue;
    }
    if (this._user?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user?.internalValue;
    }
    if (this._workspacesPodAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspacesPodAnnotations = this._workspacesPodAnnotations;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironments | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedSources.internalValue = undefined;
      this._containerBuildConfiguration.internalValue = undefined;
      this._defaultComponents.internalValue = undefined;
      this._defaultEditor = undefined;
      this._defaultNamespace.internalValue = undefined;
      this._defaultPlugins.internalValue = undefined;
      this._deploymentStrategy = undefined;
      this._disableContainerBuildCapabilities = undefined;
      this._gatewayContainer.internalValue = undefined;
      this._ignoredUnrecoverableEvents = undefined;
      this._imagePullPolicy = undefined;
      this._maxNumberOfRunningWorkspacesPerCluster = undefined;
      this._maxNumberOfRunningWorkspacesPerUser = undefined;
      this._maxNumberOfWorkspacesPerUser = undefined;
      this._nodeSelector = undefined;
      this._persistUserHome.internalValue = undefined;
      this._podSchedulerName = undefined;
      this._projectCloneContainer.internalValue = undefined;
      this._runtimeClassName = undefined;
      this._secondsOfInactivityBeforeIdling = undefined;
      this._secondsOfRunBeforeIdling = undefined;
      this._security.internalValue = undefined;
      this._serviceAccount = undefined;
      this._serviceAccountTokens.internalValue = undefined;
      this._startTimeoutSeconds = undefined;
      this._storage.internalValue = undefined;
      this._tolerations.internalValue = undefined;
      this._trustedCerts.internalValue = undefined;
      this._user.internalValue = undefined;
      this._workspacesPodAnnotations = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedSources.internalValue = value.allowedSources;
      this._containerBuildConfiguration.internalValue = value.containerBuildConfiguration;
      this._defaultComponents.internalValue = value.defaultComponents;
      this._defaultEditor = value.defaultEditor;
      this._defaultNamespace.internalValue = value.defaultNamespace;
      this._defaultPlugins.internalValue = value.defaultPlugins;
      this._deploymentStrategy = value.deploymentStrategy;
      this._disableContainerBuildCapabilities = value.disableContainerBuildCapabilities;
      this._gatewayContainer.internalValue = value.gatewayContainer;
      this._ignoredUnrecoverableEvents = value.ignoredUnrecoverableEvents;
      this._imagePullPolicy = value.imagePullPolicy;
      this._maxNumberOfRunningWorkspacesPerCluster = value.maxNumberOfRunningWorkspacesPerCluster;
      this._maxNumberOfRunningWorkspacesPerUser = value.maxNumberOfRunningWorkspacesPerUser;
      this._maxNumberOfWorkspacesPerUser = value.maxNumberOfWorkspacesPerUser;
      this._nodeSelector = value.nodeSelector;
      this._persistUserHome.internalValue = value.persistUserHome;
      this._podSchedulerName = value.podSchedulerName;
      this._projectCloneContainer.internalValue = value.projectCloneContainer;
      this._runtimeClassName = value.runtimeClassName;
      this._secondsOfInactivityBeforeIdling = value.secondsOfInactivityBeforeIdling;
      this._secondsOfRunBeforeIdling = value.secondsOfRunBeforeIdling;
      this._security.internalValue = value.security;
      this._serviceAccount = value.serviceAccount;
      this._serviceAccountTokens.internalValue = value.serviceAccountTokens;
      this._startTimeoutSeconds = value.startTimeoutSeconds;
      this._storage.internalValue = value.storage;
      this._tolerations.internalValue = value.tolerations;
      this._trustedCerts.internalValue = value.trustedCerts;
      this._user.internalValue = value.user;
      this._workspacesPodAnnotations = value.workspacesPodAnnotations;
    }
  }

  // allowed_sources - computed: false, optional: true, required: false
  private _allowedSources = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSourcesOutputReference(this, "allowed_sources");
  public get allowedSources() {
    return this._allowedSources;
  }
  public putAllowedSources(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsAllowedSources) {
    this._allowedSources.internalValue = value;
  }
  public resetAllowedSources() {
    this._allowedSources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedSourcesInput() {
    return this._allowedSources.internalValue;
  }

  // container_build_configuration - computed: false, optional: true, required: false
  private _containerBuildConfiguration = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfigurationOutputReference(this, "container_build_configuration");
  public get containerBuildConfiguration() {
    return this._containerBuildConfiguration;
  }
  public putContainerBuildConfiguration(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsContainerBuildConfiguration) {
    this._containerBuildConfiguration.internalValue = value;
  }
  public resetContainerBuildConfiguration() {
    this._containerBuildConfiguration.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerBuildConfigurationInput() {
    return this._containerBuildConfiguration.internalValue;
  }

  // default_components - computed: false, optional: true, required: false
  private _defaultComponents = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponentsList(this, "default_components", false);
  public get defaultComponents() {
    return this._defaultComponents;
  }
  public putDefaultComponents(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultComponents[] | cdktf.IResolvable) {
    this._defaultComponents.internalValue = value;
  }
  public resetDefaultComponents() {
    this._defaultComponents.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultComponentsInput() {
    return this._defaultComponents.internalValue;
  }

  // default_editor - computed: false, optional: true, required: false
  private _defaultEditor?: string; 
  public get defaultEditor() {
    return this.getStringAttribute('default_editor');
  }
  public set defaultEditor(value: string) {
    this._defaultEditor = value;
  }
  public resetDefaultEditor() {
    this._defaultEditor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultEditorInput() {
    return this._defaultEditor;
  }

  // default_namespace - computed: false, optional: true, required: false
  private _defaultNamespace = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespaceOutputReference(this, "default_namespace");
  public get defaultNamespace() {
    return this._defaultNamespace;
  }
  public putDefaultNamespace(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultNamespace) {
    this._defaultNamespace.internalValue = value;
  }
  public resetDefaultNamespace() {
    this._defaultNamespace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultNamespaceInput() {
    return this._defaultNamespace.internalValue;
  }

  // default_plugins - computed: false, optional: true, required: false
  private _defaultPlugins = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPluginsList(this, "default_plugins", false);
  public get defaultPlugins() {
    return this._defaultPlugins;
  }
  public putDefaultPlugins(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsDefaultPlugins[] | cdktf.IResolvable) {
    this._defaultPlugins.internalValue = value;
  }
  public resetDefaultPlugins() {
    this._defaultPlugins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultPluginsInput() {
    return this._defaultPlugins.internalValue;
  }

  // deployment_strategy - computed: false, optional: true, required: false
  private _deploymentStrategy?: string; 
  public get deploymentStrategy() {
    return this.getStringAttribute('deployment_strategy');
  }
  public set deploymentStrategy(value: string) {
    this._deploymentStrategy = value;
  }
  public resetDeploymentStrategy() {
    this._deploymentStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentStrategyInput() {
    return this._deploymentStrategy;
  }

  // disable_container_build_capabilities - computed: false, optional: true, required: false
  private _disableContainerBuildCapabilities?: boolean | cdktf.IResolvable; 
  public get disableContainerBuildCapabilities() {
    return this.getBooleanAttribute('disable_container_build_capabilities');
  }
  public set disableContainerBuildCapabilities(value: boolean | cdktf.IResolvable) {
    this._disableContainerBuildCapabilities = value;
  }
  public resetDisableContainerBuildCapabilities() {
    this._disableContainerBuildCapabilities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableContainerBuildCapabilitiesInput() {
    return this._disableContainerBuildCapabilities;
  }

  // gateway_container - computed: false, optional: true, required: false
  private _gatewayContainer = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainerOutputReference(this, "gateway_container");
  public get gatewayContainer() {
    return this._gatewayContainer;
  }
  public putGatewayContainer(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsGatewayContainer) {
    this._gatewayContainer.internalValue = value;
  }
  public resetGatewayContainer() {
    this._gatewayContainer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayContainerInput() {
    return this._gatewayContainer.internalValue;
  }

  // ignored_unrecoverable_events - computed: false, optional: true, required: false
  private _ignoredUnrecoverableEvents?: string[]; 
  public get ignoredUnrecoverableEvents() {
    return this.getListAttribute('ignored_unrecoverable_events');
  }
  public set ignoredUnrecoverableEvents(value: string[]) {
    this._ignoredUnrecoverableEvents = value;
  }
  public resetIgnoredUnrecoverableEvents() {
    this._ignoredUnrecoverableEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoredUnrecoverableEventsInput() {
    return this._ignoredUnrecoverableEvents;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // max_number_of_running_workspaces_per_cluster - computed: false, optional: true, required: false
  private _maxNumberOfRunningWorkspacesPerCluster?: number; 
  public get maxNumberOfRunningWorkspacesPerCluster() {
    return this.getNumberAttribute('max_number_of_running_workspaces_per_cluster');
  }
  public set maxNumberOfRunningWorkspacesPerCluster(value: number) {
    this._maxNumberOfRunningWorkspacesPerCluster = value;
  }
  public resetMaxNumberOfRunningWorkspacesPerCluster() {
    this._maxNumberOfRunningWorkspacesPerCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfRunningWorkspacesPerClusterInput() {
    return this._maxNumberOfRunningWorkspacesPerCluster;
  }

  // max_number_of_running_workspaces_per_user - computed: false, optional: true, required: false
  private _maxNumberOfRunningWorkspacesPerUser?: number; 
  public get maxNumberOfRunningWorkspacesPerUser() {
    return this.getNumberAttribute('max_number_of_running_workspaces_per_user');
  }
  public set maxNumberOfRunningWorkspacesPerUser(value: number) {
    this._maxNumberOfRunningWorkspacesPerUser = value;
  }
  public resetMaxNumberOfRunningWorkspacesPerUser() {
    this._maxNumberOfRunningWorkspacesPerUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfRunningWorkspacesPerUserInput() {
    return this._maxNumberOfRunningWorkspacesPerUser;
  }

  // max_number_of_workspaces_per_user - computed: false, optional: true, required: false
  private _maxNumberOfWorkspacesPerUser?: number; 
  public get maxNumberOfWorkspacesPerUser() {
    return this.getNumberAttribute('max_number_of_workspaces_per_user');
  }
  public set maxNumberOfWorkspacesPerUser(value: number) {
    this._maxNumberOfWorkspacesPerUser = value;
  }
  public resetMaxNumberOfWorkspacesPerUser() {
    this._maxNumberOfWorkspacesPerUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfWorkspacesPerUserInput() {
    return this._maxNumberOfWorkspacesPerUser;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // persist_user_home - computed: false, optional: true, required: false
  private _persistUserHome = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHomeOutputReference(this, "persist_user_home");
  public get persistUserHome() {
    return this._persistUserHome;
  }
  public putPersistUserHome(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsPersistUserHome) {
    this._persistUserHome.internalValue = value;
  }
  public resetPersistUserHome() {
    this._persistUserHome.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistUserHomeInput() {
    return this._persistUserHome.internalValue;
  }

  // pod_scheduler_name - computed: false, optional: true, required: false
  private _podSchedulerName?: string; 
  public get podSchedulerName() {
    return this.getStringAttribute('pod_scheduler_name');
  }
  public set podSchedulerName(value: string) {
    this._podSchedulerName = value;
  }
  public resetPodSchedulerName() {
    this._podSchedulerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSchedulerNameInput() {
    return this._podSchedulerName;
  }

  // project_clone_container - computed: false, optional: true, required: false
  private _projectCloneContainer = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainerOutputReference(this, "project_clone_container");
  public get projectCloneContainer() {
    return this._projectCloneContainer;
  }
  public putProjectCloneContainer(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsProjectCloneContainer) {
    this._projectCloneContainer.internalValue = value;
  }
  public resetProjectCloneContainer() {
    this._projectCloneContainer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectCloneContainerInput() {
    return this._projectCloneContainer.internalValue;
  }

  // runtime_class_name - computed: false, optional: true, required: false
  private _runtimeClassName?: string; 
  public get runtimeClassName() {
    return this.getStringAttribute('runtime_class_name');
  }
  public set runtimeClassName(value: string) {
    this._runtimeClassName = value;
  }
  public resetRuntimeClassName() {
    this._runtimeClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeClassNameInput() {
    return this._runtimeClassName;
  }

  // seconds_of_inactivity_before_idling - computed: false, optional: true, required: false
  private _secondsOfInactivityBeforeIdling?: number; 
  public get secondsOfInactivityBeforeIdling() {
    return this.getNumberAttribute('seconds_of_inactivity_before_idling');
  }
  public set secondsOfInactivityBeforeIdling(value: number) {
    this._secondsOfInactivityBeforeIdling = value;
  }
  public resetSecondsOfInactivityBeforeIdling() {
    this._secondsOfInactivityBeforeIdling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsOfInactivityBeforeIdlingInput() {
    return this._secondsOfInactivityBeforeIdling;
  }

  // seconds_of_run_before_idling - computed: false, optional: true, required: false
  private _secondsOfRunBeforeIdling?: number; 
  public get secondsOfRunBeforeIdling() {
    return this.getNumberAttribute('seconds_of_run_before_idling');
  }
  public set secondsOfRunBeforeIdling(value: number) {
    this._secondsOfRunBeforeIdling = value;
  }
  public resetSecondsOfRunBeforeIdling() {
    this._secondsOfRunBeforeIdling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsOfRunBeforeIdlingInput() {
    return this._secondsOfRunBeforeIdling;
  }

  // security - computed: false, optional: true, required: false
  private _security = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurityOutputReference(this, "security");
  public get security() {
    return this._security;
  }
  public putSecurity(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsSecurity) {
    this._security.internalValue = value;
  }
  public resetSecurity() {
    this._security.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityInput() {
    return this._security.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount?: string; 
  public get serviceAccount() {
    return this.getStringAttribute('service_account');
  }
  public set serviceAccount(value: string) {
    this._serviceAccount = value;
  }
  public resetServiceAccount() {
    this._serviceAccount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount;
  }

  // service_account_tokens - computed: false, optional: true, required: false
  private _serviceAccountTokens = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokensList(this, "service_account_tokens", false);
  public get serviceAccountTokens() {
    return this._serviceAccountTokens;
  }
  public putServiceAccountTokens(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsServiceAccountTokens[] | cdktf.IResolvable) {
    this._serviceAccountTokens.internalValue = value;
  }
  public resetServiceAccountTokens() {
    this._serviceAccountTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountTokensInput() {
    return this._serviceAccountTokens.internalValue;
  }

  // start_timeout_seconds - computed: false, optional: true, required: false
  private _startTimeoutSeconds?: number; 
  public get startTimeoutSeconds() {
    return this.getNumberAttribute('start_timeout_seconds');
  }
  public set startTimeoutSeconds(value: number) {
    this._startTimeoutSeconds = value;
  }
  public resetStartTimeoutSeconds() {
    this._startTimeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startTimeoutSecondsInput() {
    return this._startTimeoutSeconds;
  }

  // storage - computed: false, optional: true, required: false
  private _storage = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorageOutputReference(this, "storage");
  public get storage() {
    return this._storage;
  }
  public putStorage(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsStorage) {
    this._storage.internalValue = value;
  }
  public resetStorage() {
    this._storage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // trusted_certs - computed: false, optional: true, required: false
  private _trustedCerts = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCertsOutputReference(this, "trusted_certs");
  public get trustedCerts() {
    return this._trustedCerts;
  }
  public putTrustedCerts(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsTrustedCerts) {
    this._trustedCerts.internalValue = value;
  }
  public resetTrustedCerts() {
    this._trustedCerts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trustedCertsInput() {
    return this._trustedCerts.internalValue;
  }

  // user - computed: false, optional: true, required: false
  private _user = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUserOutputReference(this, "user");
  public get user() {
    return this._user;
  }
  public putUser(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecDevEnvironmentsUser) {
    this._user.internalValue = value;
  }
  public resetUser() {
    this._user.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user.internalValue;
  }

  // workspaces_pod_annotations - computed: false, optional: true, required: false
  private _workspacesPodAnnotations?: { [key: string]: string }; 
  public get workspacesPodAnnotations() {
    return this.getStringMapAttribute('workspaces_pod_annotations');
  }
  public set workspacesPodAnnotations(value: { [key: string]: string }) {
    this._workspacesPodAnnotations = value;
  }
  public resetWorkspacesPodAnnotations() {
    this._workspacesPodAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspacesPodAnnotationsInput() {
    return this._workspacesPodAnnotations;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure {
  /**
  * Kubernetes secret, that contains Base64-encoded Azure DevOps Service Application ID and Client Secret. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-microsoft-azure-devops-services
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_name DataK8SOrgEclipseCheCheClusterV2Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretName = value.secretName;
    }
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket {
  /**
  * Bitbucket server endpoint URL. Deprecated in favor of 'che.eclipse.org/scm-server-endpoint' annotation. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-1-for-a-bitbucket-server/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoint DataK8SOrgEclipseCheCheClusterV2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Kubernetes secret, that contains Base64-encoded Bitbucket OAuth 1.0 or OAuth 2.0 data. See the following pages for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-1-for-a-bitbucket-server/ and https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-the-bitbucket-cloud/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_name DataK8SOrgEclipseCheCheClusterV2Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint = value.endpoint;
      this._secretName = value.secretName;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub {
  /**
  * Disables subdomain isolation. Deprecated in favor of 'che.eclipse.org/scm-github-disable-subdomain-isolation' annotation. See the following page for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-github/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#disable_subdomain_isolation DataK8SOrgEclipseCheCheClusterV2Manifest#disable_subdomain_isolation}
  */
  readonly disableSubdomainIsolation?: boolean | cdktf.IResolvable;
  /**
  * GitHub server endpoint URL. Deprecated in favor of 'che.eclipse.org/scm-server-endpoint' annotation. See the following page for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-github/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoint DataK8SOrgEclipseCheCheClusterV2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Kubernetes secret, that contains Base64-encoded GitHub OAuth Client id and GitHub OAuth Client secret. See the following page for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-github/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_name DataK8SOrgEclipseCheCheClusterV2Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable_subdomain_isolation: cdktf.booleanToTerraform(struct!.disableSubdomainIsolation),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable_subdomain_isolation: {
      value: cdktf.booleanToHclTerraform(struct!.disableSubdomainIsolation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disableSubdomainIsolation !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableSubdomainIsolation = this._disableSubdomainIsolation;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disableSubdomainIsolation = undefined;
      this._endpoint = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disableSubdomainIsolation = value.disableSubdomainIsolation;
      this._endpoint = value.endpoint;
      this._secretName = value.secretName;
    }
  }

  // disable_subdomain_isolation - computed: false, optional: true, required: false
  private _disableSubdomainIsolation?: boolean | cdktf.IResolvable; 
  public get disableSubdomainIsolation() {
    return this.getBooleanAttribute('disable_subdomain_isolation');
  }
  public set disableSubdomainIsolation(value: boolean | cdktf.IResolvable) {
    this._disableSubdomainIsolation = value;
  }
  public resetDisableSubdomainIsolation() {
    this._disableSubdomainIsolation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableSubdomainIsolationInput() {
    return this._disableSubdomainIsolation;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab {
  /**
  * GitLab server endpoint URL. Deprecated in favor of 'che.eclipse.org/scm-server-endpoint' annotation. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-gitlab/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#endpoint DataK8SOrgEclipseCheCheClusterV2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Kubernetes secret, that contains Base64-encoded GitHub Application id and GitLab Application Client secret. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-gitlab/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#secret_name DataK8SOrgEclipseCheCheClusterV2Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint = value.endpoint;
      this._secretName = value.secretName;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServices {
  /**
  * Enables users to work with repositories hosted on Azure DevOps Service (dev.azure.com).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#azure DataK8SOrgEclipseCheCheClusterV2Manifest#azure}
  */
  readonly azure?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure[] | cdktf.IResolvable;
  /**
  * Enables users to work with repositories hosted on Bitbucket (bitbucket.org or self-hosted).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#bitbucket DataK8SOrgEclipseCheCheClusterV2Manifest#bitbucket}
  */
  readonly bitbucket?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket[] | cdktf.IResolvable;
  /**
  * Enables users to work with repositories hosted on GitHub (github.com or GitHub Enterprise).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#github DataK8SOrgEclipseCheCheClusterV2Manifest#github}
  */
  readonly github?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub[] | cdktf.IResolvable;
  /**
  * Enables users to work with repositories hosted on GitLab (gitlab.com or self-hosted).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#gitlab DataK8SOrgEclipseCheCheClusterV2Manifest#gitlab}
  */
  readonly gitlab?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureToTerraform, false)(struct!.azure),
    bitbucket: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketToTerraform, false)(struct!.bitbucket),
    github: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubToTerraform, false)(struct!.github),
    gitlab: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabToTerraform, false)(struct!.gitlab),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureToHclTerraform, false)(struct!.azure),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureList",
    },
    bitbucket: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketToHclTerraform, false)(struct!.bitbucket),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketList",
    },
    github: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubToHclTerraform, false)(struct!.github),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubList",
    },
    gitlab: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabToHclTerraform, false)(struct!.gitlab),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azure?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azure = this._azure?.internalValue;
    }
    if (this._bitbucket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitbucket = this._bitbucket?.internalValue;
    }
    if (this._github?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.github = this._github?.internalValue;
    }
    if (this._gitlab?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitlab = this._gitlab?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azure.internalValue = undefined;
      this._bitbucket.internalValue = undefined;
      this._github.internalValue = undefined;
      this._gitlab.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azure.internalValue = value.azure;
      this._bitbucket.internalValue = value.bitbucket;
      this._github.internalValue = value.github;
      this._gitlab.internalValue = value.gitlab;
    }
  }

  // azure - computed: false, optional: true, required: false
  private _azure = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzureList(this, "azure", false);
  public get azure() {
    return this._azure;
  }
  public putAzure(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesAzure[] | cdktf.IResolvable) {
    this._azure.internalValue = value;
  }
  public resetAzure() {
    this._azure.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureInput() {
    return this._azure.internalValue;
  }

  // bitbucket - computed: false, optional: true, required: false
  private _bitbucket = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucketList(this, "bitbucket", false);
  public get bitbucket() {
    return this._bitbucket;
  }
  public putBitbucket(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesBitbucket[] | cdktf.IResolvable) {
    this._bitbucket.internalValue = value;
  }
  public resetBitbucket() {
    this._bitbucket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitbucketInput() {
    return this._bitbucket.internalValue;
  }

  // github - computed: false, optional: true, required: false
  private _github = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithubList(this, "github", false);
  public get github() {
    return this._github;
  }
  public putGithub(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGithub[] | cdktf.IResolvable) {
    this._github.internalValue = value;
  }
  public resetGithub() {
    this._github.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get githubInput() {
    return this._github.internalValue;
  }

  // gitlab - computed: false, optional: true, required: false
  private _gitlab = new DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlabList(this, "gitlab", false);
  public get gitlab() {
    return this._gitlab;
  }
  public putGitlab(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecGitServicesGitlab[] | cdktf.IResolvable) {
    this._gitlab.internalValue = value;
  }
  public resetGitlab() {
    this._gitlab.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitlabInput() {
    return this._gitlab.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorization {
  /**
  * List of groups allowed to access Che (currently supported in OpenShift only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#allow_groups DataK8SOrgEclipseCheCheClusterV2Manifest#allow_groups}
  */
  readonly allowGroups?: string[];
  /**
  * List of users allowed to access Che.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#allow_users DataK8SOrgEclipseCheCheClusterV2Manifest#allow_users}
  */
  readonly allowUsers?: string[];
  /**
  * List of groups denied to access Che (currently supported in OpenShift only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deny_groups DataK8SOrgEclipseCheCheClusterV2Manifest#deny_groups}
  */
  readonly denyGroups?: string[];
  /**
  * List of users denied to access Che.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/org_eclipse_che_che_cluster_v2_manifest#deny_users DataK8SOrgEclipseCheCheClusterV2Manifest#deny_users}
  */
  readonly denyUsers?: string[];
}

export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorizationToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowGroups),
    allow_users: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowUsers),
    deny_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.denyGroups),
    deny_users: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.denyUsers),
  }
}


export function dataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorizationToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_users: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowUsers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    deny_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.denyGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    deny_users: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.denyUsers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowGroups = this._allowGroups;
    }
    if (this._allowUsers !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowUsers = this._allowUsers;
    }
    if (this._denyGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.denyGroups = this._denyGroups;
    }
    if (this._denyUsers !== undefined) {
      hasAnyValues = true;
      internalValueResult.denyUsers = this._denyUsers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV2ManifestSpecNetworkingAuthAdvancedAuthorization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowGroups = undefined;
      this._allowUsers = undefined;
      this._denyGroups = undefined;
      this._denyUsers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowGroups = value.allowGroups;
      this._allowUsers = value.allowUsers;
      this._denyGroups = value.denyGroups;
      this._denyUsers = value.denyUsers;
    }
  }

  // allow_groups - computed: false, optional: true, required: false
  private _allowGroups?: string[]; 
  public get allowGroups() {
    return this.getListAttribute('allow_groups');
  }
  public set allowGroups(value: string[]) {
    this._allowGroups = value;
  }
  public resetAllowGroups() {
    this._allowGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowGroupsInput() {
    return this._allowGroups;
  }

  // allow_users - computed: false, optional: true, required: false
  private _allowUsers?: string[]; 
  public get allowUsers() {
    return this.getListAttribute('allow_users');
  }
  public set allowUsers(value: string[]) {
    this._allowUsers = value;
  }
  public resetAllowUsers() {
    this._allowUsers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowUsersInput() {
    return this._allowUsers;
  }

  // deny_groups - computed: false, optional: true, required: false
  private _denyGroups?: string[]; 
  public get denyGroups() {
    return this.getListAttribute('deny_groups');
  }
  public set denyGroups(value: string[]) {
    this._denyGroups = value;
  }
  public resetDenyGroups() {
    this._denyGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyGroupsInput() {
    return this._denyGroups;
  }

  // deny_users - computed: false, optional: true, required: false
  private _denyUsers?: string[]; 
  public get denyUsers() {
    return this.getListAttribute('deny_users');
  }
  public set denyUsers(value: string[]) {
    this._denyUsers = value;
  }
  public resetDenyUsers() {
    this._denyUsers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyUsersInput() {
    return this._denyUsers;
  }
}
