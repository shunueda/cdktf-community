// https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#metadata DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#metadata}
  */
  readonly metadata: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata;
  /**
  * OutputSpec defines the desired state of ClusterOutput
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#spec DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#spec}
  */
  readonly spec?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec;
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#annotations DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadataToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadataToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob {
  /**
  * Azure Storage account name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#account_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#account_name}
  */
  readonly accountName: string;
  /**
  * Creates container if ContainerName is not set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_create_container DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_create_container}
  */
  readonly autoCreateContainer?: string;
  /**
  * Specify the desired blob type. Must be 'appendblob' or 'blockblob'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#blob_type DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#blob_type}
  */
  readonly blobType?: string;
  /**
  * Name of the container that will contain the blobs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#container_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#container_name}
  */
  readonly containerName: string;
  /**
  * Optional toggle to use an Azure emulator
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#emulator_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#emulator_mode}
  */
  readonly emulatorMode?: string;
  /**
  * HTTP Service of the endpoint (if using EmulatorMode)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking;
  /**
  * Optional path to store the blobs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#path}
  */
  readonly path?: string;
  /**
  * Specify the Azure Storage Shared Key to authenticate against the storage account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#shared_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#shared_key}
  */
  readonly sharedKey: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey;
  /**
  * Enable/Disable TLS Encryption. Azure services require TLS to be enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_name: cdktf.stringToTerraform(struct!.accountName),
    auto_create_container: cdktf.stringToTerraform(struct!.autoCreateContainer),
    blob_type: cdktf.stringToTerraform(struct!.blobType),
    container_name: cdktf.stringToTerraform(struct!.containerName),
    emulator_mode: cdktf.stringToTerraform(struct!.emulatorMode),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworkingToTerraform(struct!.networking),
    path: cdktf.stringToTerraform(struct!.path),
    shared_key: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyToTerraform(struct!.sharedKey),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsToTerraform(struct!.tls),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_name: {
      value: cdktf.stringToHclTerraform(struct!.accountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_create_container: {
      value: cdktf.stringToHclTerraform(struct!.autoCreateContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    blob_type: {
      value: cdktf.stringToHclTerraform(struct!.blobType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    emulator_mode: {
      value: cdktf.stringToHclTerraform(struct!.emulatorMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shared_key: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyToHclTerraform(struct!.sharedKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountName = this._accountName;
    }
    if (this._autoCreateContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCreateContainer = this._autoCreateContainer;
    }
    if (this._blobType !== undefined) {
      hasAnyValues = true;
      internalValueResult.blobType = this._blobType;
    }
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._emulatorMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.emulatorMode = this._emulatorMode;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._sharedKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedKey = this._sharedKey?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountName = undefined;
      this._autoCreateContainer = undefined;
      this._blobType = undefined;
      this._containerName = undefined;
      this._emulatorMode = undefined;
      this._endpoint = undefined;
      this._networking.internalValue = undefined;
      this._path = undefined;
      this._sharedKey.internalValue = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountName = value.accountName;
      this._autoCreateContainer = value.autoCreateContainer;
      this._blobType = value.blobType;
      this._containerName = value.containerName;
      this._emulatorMode = value.emulatorMode;
      this._endpoint = value.endpoint;
      this._networking.internalValue = value.networking;
      this._path = value.path;
      this._sharedKey.internalValue = value.sharedKey;
      this._tls.internalValue = value.tls;
    }
  }

  // account_name - computed: false, optional: false, required: true
  private _accountName?: string; 
  public get accountName() {
    return this.getStringAttribute('account_name');
  }
  public set accountName(value: string) {
    this._accountName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountNameInput() {
    return this._accountName;
  }

  // auto_create_container - computed: false, optional: true, required: false
  private _autoCreateContainer?: string; 
  public get autoCreateContainer() {
    return this.getStringAttribute('auto_create_container');
  }
  public set autoCreateContainer(value: string) {
    this._autoCreateContainer = value;
  }
  public resetAutoCreateContainer() {
    this._autoCreateContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCreateContainerInput() {
    return this._autoCreateContainer;
  }

  // blob_type - computed: false, optional: true, required: false
  private _blobType?: string; 
  public get blobType() {
    return this.getStringAttribute('blob_type');
  }
  public set blobType(value: string) {
    this._blobType = value;
  }
  public resetBlobType() {
    this._blobType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blobTypeInput() {
    return this._blobType;
  }

  // container_name - computed: false, optional: false, required: true
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // emulator_mode - computed: false, optional: true, required: false
  private _emulatorMode?: string; 
  public get emulatorMode() {
    return this.getStringAttribute('emulator_mode');
  }
  public set emulatorMode(value: string) {
    this._emulatorMode = value;
  }
  public resetEmulatorMode() {
    this._emulatorMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emulatorModeInput() {
    return this._emulatorMode;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // shared_key - computed: false, optional: false, required: true
  private _sharedKey = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKeyOutputReference(this, "shared_key");
  public get sharedKey() {
    return this._sharedKey;
  }
  public putSharedKey(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobSharedKey) {
    this._sharedKey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedKeyInput() {
    return this._sharedKey.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics {
  /**
  * Customer ID or Workspace ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#customer_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#customer_id}
  */
  readonly customerId: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId;
  /**
  * Name of the event type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_type DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_type}
  */
  readonly logType?: string;
  /**
  * Set a record key that will populate 'logtype'. If the key is found, it will have precedence
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_type_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_type_key}
  */
  readonly logTypeKey?: string;
  /**
  * Specify the primary or the secondary client authentication key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#shared_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#shared_key}
  */
  readonly sharedKey: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey;
  /**
  * If set, overrides the timeKey value with the 'time-generated-field' HTTP header value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_generated DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_generated}
  */
  readonly timeGenerated?: boolean | cdktf.IResolvable;
  /**
  * Specify the name of the key where the timestamp is stored.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key}
  */
  readonly timeKey?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    customer_id: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdToTerraform(struct!.customerId),
    log_type: cdktf.stringToTerraform(struct!.logType),
    log_type_key: cdktf.stringToTerraform(struct!.logTypeKey),
    shared_key: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyToTerraform(struct!.sharedKey),
    time_generated: cdktf.booleanToTerraform(struct!.timeGenerated),
    time_key: cdktf.stringToTerraform(struct!.timeKey),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    customer_id: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdToHclTerraform(struct!.customerId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type_key: {
      value: cdktf.stringToHclTerraform(struct!.logTypeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shared_key: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyToHclTerraform(struct!.sharedKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey",
    },
    time_generated: {
      value: cdktf.booleanToHclTerraform(struct!.timeGenerated),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    time_key: {
      value: cdktf.stringToHclTerraform(struct!.timeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customerId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customerId = this._customerId?.internalValue;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._logTypeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logTypeKey = this._logTypeKey;
    }
    if (this._sharedKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedKey = this._sharedKey?.internalValue;
    }
    if (this._timeGenerated !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeGenerated = this._timeGenerated;
    }
    if (this._timeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKey = this._timeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customerId.internalValue = undefined;
      this._logType = undefined;
      this._logTypeKey = undefined;
      this._sharedKey.internalValue = undefined;
      this._timeGenerated = undefined;
      this._timeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customerId.internalValue = value.customerId;
      this._logType = value.logType;
      this._logTypeKey = value.logTypeKey;
      this._sharedKey.internalValue = value.sharedKey;
      this._timeGenerated = value.timeGenerated;
      this._timeKey = value.timeKey;
    }
  }

  // customer_id - computed: false, optional: false, required: true
  private _customerId = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerIdOutputReference(this, "customer_id");
  public get customerId() {
    return this._customerId;
  }
  public putCustomerId(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsCustomerId) {
    this._customerId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get customerIdInput() {
    return this._customerId.internalValue;
  }

  // log_type - computed: false, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // log_type_key - computed: false, optional: true, required: false
  private _logTypeKey?: string; 
  public get logTypeKey() {
    return this.getStringAttribute('log_type_key');
  }
  public set logTypeKey(value: string) {
    this._logTypeKey = value;
  }
  public resetLogTypeKey() {
    this._logTypeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeKeyInput() {
    return this._logTypeKey;
  }

  // shared_key - computed: false, optional: false, required: true
  private _sharedKey = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKeyOutputReference(this, "shared_key");
  public get sharedKey() {
    return this._sharedKey;
  }
  public putSharedKey(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsSharedKey) {
    this._sharedKey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedKeyInput() {
    return this._sharedKey.internalValue;
  }

  // time_generated - computed: false, optional: true, required: false
  private _timeGenerated?: boolean | cdktf.IResolvable; 
  public get timeGenerated() {
    return this.getBooleanAttribute('time_generated');
  }
  public set timeGenerated(value: boolean | cdktf.IResolvable) {
    this._timeGenerated = value;
  }
  public resetTimeGenerated() {
    this._timeGenerated = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeGeneratedInput() {
    return this._timeGenerated;
  }

  // time_key - computed: false, optional: true, required: false
  private _timeKey?: string; 
  public get timeKey() {
    return this.getStringAttribute('time_key');
  }
  public set timeKey(value: string) {
    this._timeKey = value;
  }
  public resetTimeKey() {
    this._timeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyInput() {
    return this._timeKey;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch {
  /**
  * Automatically create the log group. Defaults to False.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_create_group DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_create_group}
  */
  readonly autoCreateGroup?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry failed requests to CloudWatch once. Defaults to True.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_retry_requests DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_retry_requests}
  */
  readonly autoRetryRequests?: boolean | cdktf.IResolvable;
  /**
  * Custom endpoint for CloudWatch logs API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Specify an external ID for the STS API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#external_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * Optional parameter to tell CloudWatch the format of the data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_format}
  */
  readonly logFormat?: string;
  /**
  * Name of Cloudwatch Log Group to send log records to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_group_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_group_name}
  */
  readonly logGroupName?: string;
  /**
  * Template for Log Group name, overrides LogGroupName if set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_group_template DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_group_template}
  */
  readonly logGroupTemplate?: string;
  /**
  * If set, only the value of the key will be sent to CloudWatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_key}
  */
  readonly logKey?: string;
  /**
  * Number of days logs are retained for
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_retention_days DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_retention_days}
  */
  readonly logRetentionDays?: number;
  /**
  * The name of the CloudWatch Log Stream to send log records to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_stream_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_stream_name}
  */
  readonly logStreamName?: string;
  /**
  * Prefix for the Log Stream name. Not compatible with LogStreamName setting
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_stream_prefix DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_stream_prefix}
  */
  readonly logStreamPrefix?: string;
  /**
  * Template for Log Stream name. Overrides LogStreamPrefix and LogStreamName if set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_stream_template DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_stream_template}
  */
  readonly logStreamTemplate?: string;
  /**
  * Optional lists of lists for dimension keys to be added to all metrics. Use comma separated strings for one list of dimensions and semicolon separated strings for list of lists dimensions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#metric_dimensions DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#metric_dimensions}
  */
  readonly metricDimensions?: string;
  /**
  * Optional string to represent the CloudWatch namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#metric_namespace DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#metric_namespace}
  */
  readonly metricNamespace?: string;
  /**
  * AWS Region
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#region DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#region}
  */
  readonly region: string;
  /**
  * Role ARN to use for cross-account access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#role_arn DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Specify a custom STS endpoint for the AWS STS API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#sts_endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#sts_endpoint}
  */
  readonly stsEndpoint?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatchToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_create_group: cdktf.booleanToTerraform(struct!.autoCreateGroup),
    auto_retry_requests: cdktf.booleanToTerraform(struct!.autoRetryRequests),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    external_id: cdktf.stringToTerraform(struct!.externalId),
    log_format: cdktf.stringToTerraform(struct!.logFormat),
    log_group_name: cdktf.stringToTerraform(struct!.logGroupName),
    log_group_template: cdktf.stringToTerraform(struct!.logGroupTemplate),
    log_key: cdktf.stringToTerraform(struct!.logKey),
    log_retention_days: cdktf.numberToTerraform(struct!.logRetentionDays),
    log_stream_name: cdktf.stringToTerraform(struct!.logStreamName),
    log_stream_prefix: cdktf.stringToTerraform(struct!.logStreamPrefix),
    log_stream_template: cdktf.stringToTerraform(struct!.logStreamTemplate),
    metric_dimensions: cdktf.stringToTerraform(struct!.metricDimensions),
    metric_namespace: cdktf.stringToTerraform(struct!.metricNamespace),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    sts_endpoint: cdktf.stringToTerraform(struct!.stsEndpoint),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatchToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_create_group: {
      value: cdktf.booleanToHclTerraform(struct!.autoCreateGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auto_retry_requests: {
      value: cdktf.booleanToHclTerraform(struct!.autoRetryRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format: {
      value: cdktf.stringToHclTerraform(struct!.logFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_group_name: {
      value: cdktf.stringToHclTerraform(struct!.logGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_group_template: {
      value: cdktf.stringToHclTerraform(struct!.logGroupTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_key: {
      value: cdktf.stringToHclTerraform(struct!.logKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_retention_days: {
      value: cdktf.numberToHclTerraform(struct!.logRetentionDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_stream_name: {
      value: cdktf.stringToHclTerraform(struct!.logStreamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_stream_prefix: {
      value: cdktf.stringToHclTerraform(struct!.logStreamPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_stream_template: {
      value: cdktf.stringToHclTerraform(struct!.logStreamTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_dimensions: {
      value: cdktf.stringToHclTerraform(struct!.metricDimensions),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metricNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sts_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.stsEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoCreateGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCreateGroup = this._autoCreateGroup;
    }
    if (this._autoRetryRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoRetryRequests = this._autoRetryRequests;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._logFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormat = this._logFormat;
    }
    if (this._logGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logGroupName = this._logGroupName;
    }
    if (this._logGroupTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.logGroupTemplate = this._logGroupTemplate;
    }
    if (this._logKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logKey = this._logKey;
    }
    if (this._logRetentionDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.logRetentionDays = this._logRetentionDays;
    }
    if (this._logStreamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logStreamName = this._logStreamName;
    }
    if (this._logStreamPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.logStreamPrefix = this._logStreamPrefix;
    }
    if (this._logStreamTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.logStreamTemplate = this._logStreamTemplate;
    }
    if (this._metricDimensions !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricDimensions = this._metricDimensions;
    }
    if (this._metricNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricNamespace = this._metricNamespace;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._stsEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.stsEndpoint = this._stsEndpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoCreateGroup = undefined;
      this._autoRetryRequests = undefined;
      this._endpoint = undefined;
      this._externalId = undefined;
      this._logFormat = undefined;
      this._logGroupName = undefined;
      this._logGroupTemplate = undefined;
      this._logKey = undefined;
      this._logRetentionDays = undefined;
      this._logStreamName = undefined;
      this._logStreamPrefix = undefined;
      this._logStreamTemplate = undefined;
      this._metricDimensions = undefined;
      this._metricNamespace = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._stsEndpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoCreateGroup = value.autoCreateGroup;
      this._autoRetryRequests = value.autoRetryRequests;
      this._endpoint = value.endpoint;
      this._externalId = value.externalId;
      this._logFormat = value.logFormat;
      this._logGroupName = value.logGroupName;
      this._logGroupTemplate = value.logGroupTemplate;
      this._logKey = value.logKey;
      this._logRetentionDays = value.logRetentionDays;
      this._logStreamName = value.logStreamName;
      this._logStreamPrefix = value.logStreamPrefix;
      this._logStreamTemplate = value.logStreamTemplate;
      this._metricDimensions = value.metricDimensions;
      this._metricNamespace = value.metricNamespace;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._stsEndpoint = value.stsEndpoint;
    }
  }

  // auto_create_group - computed: false, optional: true, required: false
  private _autoCreateGroup?: boolean | cdktf.IResolvable; 
  public get autoCreateGroup() {
    return this.getBooleanAttribute('auto_create_group');
  }
  public set autoCreateGroup(value: boolean | cdktf.IResolvable) {
    this._autoCreateGroup = value;
  }
  public resetAutoCreateGroup() {
    this._autoCreateGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCreateGroupInput() {
    return this._autoCreateGroup;
  }

  // auto_retry_requests - computed: false, optional: true, required: false
  private _autoRetryRequests?: boolean | cdktf.IResolvable; 
  public get autoRetryRequests() {
    return this.getBooleanAttribute('auto_retry_requests');
  }
  public set autoRetryRequests(value: boolean | cdktf.IResolvable) {
    this._autoRetryRequests = value;
  }
  public resetAutoRetryRequests() {
    this._autoRetryRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoRetryRequestsInput() {
    return this._autoRetryRequests;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // log_format - computed: false, optional: true, required: false
  private _logFormat?: string; 
  public get logFormat() {
    return this.getStringAttribute('log_format');
  }
  public set logFormat(value: string) {
    this._logFormat = value;
  }
  public resetLogFormat() {
    this._logFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatInput() {
    return this._logFormat;
  }

  // log_group_name - computed: false, optional: true, required: false
  private _logGroupName?: string; 
  public get logGroupName() {
    return this.getStringAttribute('log_group_name');
  }
  public set logGroupName(value: string) {
    this._logGroupName = value;
  }
  public resetLogGroupName() {
    this._logGroupName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logGroupNameInput() {
    return this._logGroupName;
  }

  // log_group_template - computed: false, optional: true, required: false
  private _logGroupTemplate?: string; 
  public get logGroupTemplate() {
    return this.getStringAttribute('log_group_template');
  }
  public set logGroupTemplate(value: string) {
    this._logGroupTemplate = value;
  }
  public resetLogGroupTemplate() {
    this._logGroupTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logGroupTemplateInput() {
    return this._logGroupTemplate;
  }

  // log_key - computed: false, optional: true, required: false
  private _logKey?: string; 
  public get logKey() {
    return this.getStringAttribute('log_key');
  }
  public set logKey(value: string) {
    this._logKey = value;
  }
  public resetLogKey() {
    this._logKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logKeyInput() {
    return this._logKey;
  }

  // log_retention_days - computed: false, optional: true, required: false
  private _logRetentionDays?: number; 
  public get logRetentionDays() {
    return this.getNumberAttribute('log_retention_days');
  }
  public set logRetentionDays(value: number) {
    this._logRetentionDays = value;
  }
  public resetLogRetentionDays() {
    this._logRetentionDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logRetentionDaysInput() {
    return this._logRetentionDays;
  }

  // log_stream_name - computed: false, optional: true, required: false
  private _logStreamName?: string; 
  public get logStreamName() {
    return this.getStringAttribute('log_stream_name');
  }
  public set logStreamName(value: string) {
    this._logStreamName = value;
  }
  public resetLogStreamName() {
    this._logStreamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logStreamNameInput() {
    return this._logStreamName;
  }

  // log_stream_prefix - computed: false, optional: true, required: false
  private _logStreamPrefix?: string; 
  public get logStreamPrefix() {
    return this.getStringAttribute('log_stream_prefix');
  }
  public set logStreamPrefix(value: string) {
    this._logStreamPrefix = value;
  }
  public resetLogStreamPrefix() {
    this._logStreamPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logStreamPrefixInput() {
    return this._logStreamPrefix;
  }

  // log_stream_template - computed: false, optional: true, required: false
  private _logStreamTemplate?: string; 
  public get logStreamTemplate() {
    return this.getStringAttribute('log_stream_template');
  }
  public set logStreamTemplate(value: string) {
    this._logStreamTemplate = value;
  }
  public resetLogStreamTemplate() {
    this._logStreamTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logStreamTemplateInput() {
    return this._logStreamTemplate;
  }

  // metric_dimensions - computed: false, optional: true, required: false
  private _metricDimensions?: string; 
  public get metricDimensions() {
    return this.getStringAttribute('metric_dimensions');
  }
  public set metricDimensions(value: string) {
    this._metricDimensions = value;
  }
  public resetMetricDimensions() {
    this._metricDimensions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricDimensionsInput() {
    return this._metricDimensions;
  }

  // metric_namespace - computed: false, optional: true, required: false
  private _metricNamespace?: string; 
  public get metricNamespace() {
    return this.getStringAttribute('metric_namespace');
  }
  public set metricNamespace(value: string) {
    this._metricNamespace = value;
  }
  public resetMetricNamespace() {
    this._metricNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricNamespaceInput() {
    return this._metricNamespace;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // sts_endpoint - computed: false, optional: true, required: false
  private _stsEndpoint?: string; 
  public get stsEndpoint() {
    return this.getStringAttribute('sts_endpoint');
  }
  public set stsEndpoint(value: string) {
    this._stsEndpoint = value;
  }
  public resetStsEndpoint() {
    this._stsEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stsEndpointInput() {
    return this._stsEndpoint;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin {
  /**
  * Config holds any unsupported plugins classic configurations, if ConfigFileFormat is set to yaml, this filed will be ignored
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#config DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#config}
  */
  readonly config?: string;
  /**
  * YamlConfig holds the unsupported plugins yaml configurations, it only works when the ConfigFileFormat is yaml
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#yaml_config DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#yaml_config}
  */
  readonly yamlConfig?: { [key: string]: string };
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPluginToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config: cdktf.stringToTerraform(struct!.config),
    yaml_config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.yamlConfig),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPluginToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config: {
      value: cdktf.stringToHclTerraform(struct!.config),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    yaml_config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.yamlConfig),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._yamlConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.yamlConfig = this._yamlConfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._config = undefined;
      this._yamlConfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._config = value.config;
      this._yamlConfig = value.yamlConfig;
    }
  }

  // config - computed: false, optional: true, required: false
  private _config?: string; 
  public get config() {
    return this.getStringAttribute('config');
  }
  public set config(value: string) {
    this._config = value;
  }
  public resetConfig() {
    this._config = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // yaml_config - computed: false, optional: true, required: false
  private _yamlConfig?: { [key: string]: string }; 
  public get yamlConfig() {
    return this.getStringMapAttribute('yaml_config');
  }
  public set yamlConfig(value: { [key: string]: string }) {
    this._yamlConfig = value;
  }
  public resetYamlConfig() {
    this._yamlConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get yamlConfigInput() {
    return this._yamlConfig;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog {
  /**
  * Your Datadog API key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#apikey DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#apikey}
  */
  readonly apikey?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey;
  /**
  * Compress the payload in GZIP format. Datadog supports and recommends setting this to gzip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compress DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compress}
  */
  readonly compress?: string;
  /**
  * By default, the plugin searches for the key 'log' and remap the value to the key 'message'. If the property is set, the plugin will search the property name key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dd_message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dd_message_key}
  */
  readonly ddMessageKey?: string;
  /**
  * The human readable name for your service generating the logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dd_service DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dd_service}
  */
  readonly ddService?: string;
  /**
  * A human readable name for the underlying technology of your service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dd_source DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dd_source}
  */
  readonly ddSource?: string;
  /**
  * The tags you want to assign to your logs in Datadog.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dd_tags DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dd_tags}
  */
  readonly ddTags?: string;
  /**
  * Host is the Datadog server where you are sending your logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * If enabled, a tag is appended to output. The key name is used tag_key property.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#include_tag_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#include_tag_key}
  */
  readonly includeTagKey?: boolean | cdktf.IResolvable;
  /**
  * Date key name for output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_key}
  */
  readonly jsonDateKey?: string;
  /**
  * To activate the remapping, specify configuration flag provider.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#provider DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#provider}
  */
  readonly provider?: string;
  /**
  * Specify an HTTP Proxy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#proxy DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#proxy}
  */
  readonly proxy?: string;
  /**
  * The key name of tag. If include_tag_key is false, This property is ignored.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag_key}
  */
  readonly tagKey?: string;
  /**
  * TLS controls whether to use end-to-end security communications security protocol. Datadog recommends setting this to on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apikey: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyToTerraform(struct!.apikey),
    compress: cdktf.stringToTerraform(struct!.compress),
    dd_message_key: cdktf.stringToTerraform(struct!.ddMessageKey),
    dd_service: cdktf.stringToTerraform(struct!.ddService),
    dd_source: cdktf.stringToTerraform(struct!.ddSource),
    dd_tags: cdktf.stringToTerraform(struct!.ddTags),
    host: cdktf.stringToTerraform(struct!.host),
    include_tag_key: cdktf.booleanToTerraform(struct!.includeTagKey),
    json_date_key: cdktf.stringToTerraform(struct!.jsonDateKey),
    provider: cdktf.stringToTerraform(struct!.provider),
    proxy: cdktf.stringToTerraform(struct!.proxy),
    tag_key: cdktf.stringToTerraform(struct!.tagKey),
    tls: cdktf.booleanToTerraform(struct!.tls),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apikey: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyToHclTerraform(struct!.apikey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dd_message_key: {
      value: cdktf.stringToHclTerraform(struct!.ddMessageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dd_service: {
      value: cdktf.stringToHclTerraform(struct!.ddService),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dd_source: {
      value: cdktf.stringToHclTerraform(struct!.ddSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dd_tags: {
      value: cdktf.stringToHclTerraform(struct!.ddTags),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_tag_key: {
      value: cdktf.booleanToHclTerraform(struct!.includeTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    json_date_key: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    provider: {
      value: cdktf.stringToHclTerraform(struct!.provider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy: {
      value: cdktf.stringToHclTerraform(struct!.proxy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag_key: {
      value: cdktf.stringToHclTerraform(struct!.tagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.booleanToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apikey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apikey = this._apikey?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._ddMessageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.ddMessageKey = this._ddMessageKey;
    }
    if (this._ddService !== undefined) {
      hasAnyValues = true;
      internalValueResult.ddService = this._ddService;
    }
    if (this._ddSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.ddSource = this._ddSource;
    }
    if (this._ddTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.ddTags = this._ddTags;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._includeTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeTagKey = this._includeTagKey;
    }
    if (this._jsonDateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateKey = this._jsonDateKey;
    }
    if (this._provider !== undefined) {
      hasAnyValues = true;
      internalValueResult.provider = this._provider;
    }
    if (this._proxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy = this._proxy;
    }
    if (this._tagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagKey = this._tagKey;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apikey.internalValue = undefined;
      this._compress = undefined;
      this._ddMessageKey = undefined;
      this._ddService = undefined;
      this._ddSource = undefined;
      this._ddTags = undefined;
      this._host = undefined;
      this._includeTagKey = undefined;
      this._jsonDateKey = undefined;
      this._provider = undefined;
      this._proxy = undefined;
      this._tagKey = undefined;
      this._tls = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apikey.internalValue = value.apikey;
      this._compress = value.compress;
      this._ddMessageKey = value.ddMessageKey;
      this._ddService = value.ddService;
      this._ddSource = value.ddSource;
      this._ddTags = value.ddTags;
      this._host = value.host;
      this._includeTagKey = value.includeTagKey;
      this._jsonDateKey = value.jsonDateKey;
      this._provider = value.provider;
      this._proxy = value.proxy;
      this._tagKey = value.tagKey;
      this._tls = value.tls;
    }
  }

  // apikey - computed: false, optional: true, required: false
  private _apikey = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikeyOutputReference(this, "apikey");
  public get apikey() {
    return this._apikey;
  }
  public putApikey(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogApikey) {
    this._apikey.internalValue = value;
  }
  public resetApikey() {
    this._apikey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apikeyInput() {
    return this._apikey.internalValue;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dd_message_key - computed: false, optional: true, required: false
  private _ddMessageKey?: string; 
  public get ddMessageKey() {
    return this.getStringAttribute('dd_message_key');
  }
  public set ddMessageKey(value: string) {
    this._ddMessageKey = value;
  }
  public resetDdMessageKey() {
    this._ddMessageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ddMessageKeyInput() {
    return this._ddMessageKey;
  }

  // dd_service - computed: false, optional: true, required: false
  private _ddService?: string; 
  public get ddService() {
    return this.getStringAttribute('dd_service');
  }
  public set ddService(value: string) {
    this._ddService = value;
  }
  public resetDdService() {
    this._ddService = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ddServiceInput() {
    return this._ddService;
  }

  // dd_source - computed: false, optional: true, required: false
  private _ddSource?: string; 
  public get ddSource() {
    return this.getStringAttribute('dd_source');
  }
  public set ddSource(value: string) {
    this._ddSource = value;
  }
  public resetDdSource() {
    this._ddSource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ddSourceInput() {
    return this._ddSource;
  }

  // dd_tags - computed: false, optional: true, required: false
  private _ddTags?: string; 
  public get ddTags() {
    return this.getStringAttribute('dd_tags');
  }
  public set ddTags(value: string) {
    this._ddTags = value;
  }
  public resetDdTags() {
    this._ddTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ddTagsInput() {
    return this._ddTags;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // include_tag_key - computed: false, optional: true, required: false
  private _includeTagKey?: boolean | cdktf.IResolvable; 
  public get includeTagKey() {
    return this.getBooleanAttribute('include_tag_key');
  }
  public set includeTagKey(value: boolean | cdktf.IResolvable) {
    this._includeTagKey = value;
  }
  public resetIncludeTagKey() {
    this._includeTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeTagKeyInput() {
    return this._includeTagKey;
  }

  // json_date_key - computed: false, optional: true, required: false
  private _jsonDateKey?: string; 
  public get jsonDateKey() {
    return this.getStringAttribute('json_date_key');
  }
  public set jsonDateKey(value: string) {
    this._jsonDateKey = value;
  }
  public resetJsonDateKey() {
    this._jsonDateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateKeyInput() {
    return this._jsonDateKey;
  }

  // provider - computed: false, optional: true, required: false
  private _provider?: string; 
  public get provider() {
    return this.getStringAttribute('provider');
  }
  public set provider(value: string) {
    this._provider = value;
  }
  public resetProvider() {
    this._provider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerInput() {
    return this._provider;
  }

  // proxy - computed: false, optional: true, required: false
  private _proxy?: string; 
  public get proxy() {
    return this.getStringAttribute('proxy');
  }
  public set proxy(value: string) {
    this._proxy = value;
  }
  public resetProxy() {
    this._proxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyInput() {
    return this._proxy;
  }

  // tag_key - computed: false, optional: true, required: false
  private _tagKey?: string; 
  public get tagKey() {
    return this.getStringAttribute('tag_key');
  }
  public set tagKey(value: string) {
    this._tagKey = value;
  }
  public resetTagKey() {
    this._tagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagKeyInput() {
    return this._tagKey;
  }

  // tls - computed: false, optional: true, required: false
  private _tls?: boolean | cdktf.IResolvable; 
  public get tls() {
    return this.getBooleanAttribute('tls');
  }
  public set tls(value: boolean | cdktf.IResolvable) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs {
  /**
  * Enable AWS Sigv4 Authentication for Amazon ElasticSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_auth DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_auth}
  */
  readonly awsAuth?: string;
  /**
  * AWSAuthSecret Enable AWS Sigv4 Authentication for Amazon ElasticSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_auth_secret DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_auth_secret}
  */
  readonly awsAuthSecret?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret;
  /**
  * External ID for the AWS IAM Role specified with aws_role_arn.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_external_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_external_id}
  */
  readonly awsExternalId?: string;
  /**
  * Specify the AWS region for Amazon ElasticSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_region DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_region}
  */
  readonly awsRegion?: string;
  /**
  * AWS IAM Role to assume to put records to your Amazon ES cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_role_arn DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_role_arn}
  */
  readonly awsRoleArn?: string;
  /**
  * Specify the custom sts endpoint to be used with STS API for Amazon ElasticSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_sts_endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_sts_endpoint}
  */
  readonly awsStsEndpoint?: string;
  /**
  * Specify the buffer size used to read the response from the Elasticsearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted. To set an unlimited amount of memory set this value to False, otherwise the value must be according to the Unit Size specification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#buffer_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#buffer_size}
  */
  readonly bufferSize?: string;
  /**
  * Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#cloud_auth DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#cloud_auth}
  */
  readonly cloudAuth?: string;
  /**
  * CloudAuthSecret Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#cloud_auth_secret DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#cloud_auth_secret}
  */
  readonly cloudAuthSecret?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret;
  /**
  * If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#cloud_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#cloud_id}
  */
  readonly cloudId?: string;
  /**
  * Set payload compression mechanism. Option available is 'gzip'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compress DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compress}
  */
  readonly compress?: string;
  /**
  * Use current time for index generation instead of message record
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#current_time_index DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#current_time_index}
  */
  readonly currentTimeIndex?: boolean | cdktf.IResolvable;
  /**
  * When enabled, generate _id for outgoing records. This prevents duplicate records when retrying ES.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#generate_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#generate_id}
  */
  readonly generateId?: boolean | cdktf.IResolvable;
  /**
  * IP address or hostname of the target Elasticsearch instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Password for user defined in HTTP_User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword;
  /**
  * Optional username credential for Elastic X-Pack access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser;
  /**
  * If set, _id will be the value of the key from incoming record and Generate_ID option is ignored.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#id_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#id_key}
  */
  readonly idKey?: string;
  /**
  * When enabled, it append the Tag name to the record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#include_tag_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#include_tag_key}
  */
  readonly includeTagKey?: boolean | cdktf.IResolvable;
  /**
  * Index name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#index DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#index}
  */
  readonly index?: string;
  /**
  * Time format (based on strftime) to generate the second part of the Index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_date_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_date_format}
  */
  readonly logstashDateFormat?: string;
  /**
  * Enable Logstash format compatibility. This option takes a boolean value: True/False, On/Off
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_format}
  */
  readonly logstashFormat?: boolean | cdktf.IResolvable;
  /**
  * When Logstash_Format is enabled, the Index name is composed using a prefix and the date, e.g: If Logstash_Prefix is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_prefix DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_prefix}
  */
  readonly logstashPrefix?: string;
  /**
  * Prefix keys with this string
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_prefix_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_prefix_key}
  */
  readonly logstashPrefixKey?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking;
  /**
  * Elasticsearch accepts new data on HTTP query path '/_bulk'. But it is also possible to serve Elasticsearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#path}
  */
  readonly path?: string;
  /**
  * Newer versions of Elasticsearch allows setting up filters called pipelines. This option allows defining which pipeline the database should use. For performance reasons is strongly suggested parsing and filtering on Fluent Bit side, avoid pipelines.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#pipeline DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#pipeline}
  */
  readonly pipeline?: string;
  /**
  * TCP port of the target Elasticsearch instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * When enabled, replace field name dots with underscore, required by Elasticsearch 2.0-2.3.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#replace_dots DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#replace_dots}
  */
  readonly replaceDots?: boolean | cdktf.IResolvable;
  /**
  * When enabled, mapping types is removed and Type option is ignored. Types are deprecated in APIs in v7.0. This options is for v7.0 or later.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#suppress_type_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#suppress_type_name}
  */
  readonly suppressTypeName?: string;
  /**
  * When Include_Tag_Key is enabled, this property defines the key name for the tag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag_key}
  */
  readonly tagKey?: string;
  /**
  * When Logstash_Format is enabled, each record will get a new timestamp field. The Time_Key property defines the name of that field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key}
  */
  readonly timeKey?: string;
  /**
  * When Logstash_Format is enabled, this property defines the format of the timestamp.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key_format}
  */
  readonly timeKeyFormat?: string;
  /**
  * When Logstash_Format is enabled, enabling this property sends nanosecond precision timestamps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key_nanos DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key_nanos}
  */
  readonly timeKeyNanos?: boolean | cdktf.IResolvable;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls;
  /**
  * Limit the maximum number of Chunks in the filesystem for the current output logical destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#total_limit_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#total_limit_size}
  */
  readonly totalLimitSize?: string;
  /**
  * When enabled print the elasticsearch API calls to stdout when elasticsearch returns an error
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#trace_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#trace_error}
  */
  readonly traceError?: boolean | cdktf.IResolvable;
  /**
  * When enabled print the elasticsearch API calls to stdout (for diag only)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#trace_output DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#trace_output}
  */
  readonly traceOutput?: boolean | cdktf.IResolvable;
  /**
  * Type name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#type DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#type}
  */
  readonly type?: string;
  /**
  * Operation to use to write in bulk requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#write_operation DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#write_operation}
  */
  readonly writeOperation?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_auth: cdktf.stringToTerraform(struct!.awsAuth),
    aws_auth_secret: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretToTerraform(struct!.awsAuthSecret),
    aws_external_id: cdktf.stringToTerraform(struct!.awsExternalId),
    aws_region: cdktf.stringToTerraform(struct!.awsRegion),
    aws_role_arn: cdktf.stringToTerraform(struct!.awsRoleArn),
    aws_sts_endpoint: cdktf.stringToTerraform(struct!.awsStsEndpoint),
    buffer_size: cdktf.stringToTerraform(struct!.bufferSize),
    cloud_auth: cdktf.stringToTerraform(struct!.cloudAuth),
    cloud_auth_secret: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretToTerraform(struct!.cloudAuthSecret),
    cloud_id: cdktf.stringToTerraform(struct!.cloudId),
    compress: cdktf.stringToTerraform(struct!.compress),
    current_time_index: cdktf.booleanToTerraform(struct!.currentTimeIndex),
    generate_id: cdktf.booleanToTerraform(struct!.generateId),
    host: cdktf.stringToTerraform(struct!.host),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordToTerraform(struct!.httpPassword),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserToTerraform(struct!.httpUser),
    id_key: cdktf.stringToTerraform(struct!.idKey),
    include_tag_key: cdktf.booleanToTerraform(struct!.includeTagKey),
    index: cdktf.stringToTerraform(struct!.index),
    logstash_date_format: cdktf.stringToTerraform(struct!.logstashDateFormat),
    logstash_format: cdktf.booleanToTerraform(struct!.logstashFormat),
    logstash_prefix: cdktf.stringToTerraform(struct!.logstashPrefix),
    logstash_prefix_key: cdktf.stringToTerraform(struct!.logstashPrefixKey),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworkingToTerraform(struct!.networking),
    path: cdktf.stringToTerraform(struct!.path),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    replace_dots: cdktf.booleanToTerraform(struct!.replaceDots),
    suppress_type_name: cdktf.stringToTerraform(struct!.suppressTypeName),
    tag_key: cdktf.stringToTerraform(struct!.tagKey),
    time_key: cdktf.stringToTerraform(struct!.timeKey),
    time_key_format: cdktf.stringToTerraform(struct!.timeKeyFormat),
    time_key_nanos: cdktf.booleanToTerraform(struct!.timeKeyNanos),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsToTerraform(struct!.tls),
    total_limit_size: cdktf.stringToTerraform(struct!.totalLimitSize),
    trace_error: cdktf.booleanToTerraform(struct!.traceError),
    trace_output: cdktf.booleanToTerraform(struct!.traceOutput),
    type: cdktf.stringToTerraform(struct!.type),
    write_operation: cdktf.stringToTerraform(struct!.writeOperation),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_auth: {
      value: cdktf.stringToHclTerraform(struct!.awsAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_auth_secret: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretToHclTerraform(struct!.awsAuthSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret",
    },
    aws_external_id: {
      value: cdktf.stringToHclTerraform(struct!.awsExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_region: {
      value: cdktf.stringToHclTerraform(struct!.awsRegion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.awsRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_sts_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.awsStsEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    buffer_size: {
      value: cdktf.stringToHclTerraform(struct!.bufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_auth: {
      value: cdktf.stringToHclTerraform(struct!.cloudAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cloud_auth_secret: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretToHclTerraform(struct!.cloudAuthSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret",
    },
    cloud_id: {
      value: cdktf.stringToHclTerraform(struct!.cloudId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    current_time_index: {
      value: cdktf.booleanToHclTerraform(struct!.currentTimeIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    generate_id: {
      value: cdktf.booleanToHclTerraform(struct!.generateId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser",
    },
    id_key: {
      value: cdktf.stringToHclTerraform(struct!.idKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_tag_key: {
      value: cdktf.booleanToHclTerraform(struct!.includeTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logstash_date_format: {
      value: cdktf.stringToHclTerraform(struct!.logstashDateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logstash_format: {
      value: cdktf.booleanToHclTerraform(struct!.logstashFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    logstash_prefix: {
      value: cdktf.stringToHclTerraform(struct!.logstashPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logstash_prefix_key: {
      value: cdktf.stringToHclTerraform(struct!.logstashPrefixKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replace_dots: {
      value: cdktf.booleanToHclTerraform(struct!.replaceDots),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    suppress_type_name: {
      value: cdktf.stringToHclTerraform(struct!.suppressTypeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag_key: {
      value: cdktf.stringToHclTerraform(struct!.tagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key: {
      value: cdktf.stringToHclTerraform(struct!.timeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key_format: {
      value: cdktf.stringToHclTerraform(struct!.timeKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key_nanos: {
      value: cdktf.booleanToHclTerraform(struct!.timeKeyNanos),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls",
    },
    total_limit_size: {
      value: cdktf.stringToHclTerraform(struct!.totalLimitSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trace_error: {
      value: cdktf.booleanToHclTerraform(struct!.traceError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    trace_output: {
      value: cdktf.booleanToHclTerraform(struct!.traceOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_operation: {
      value: cdktf.stringToHclTerraform(struct!.writeOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuth = this._awsAuth;
    }
    if (this._awsAuthSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthSecret = this._awsAuthSecret?.internalValue;
    }
    if (this._awsExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsExternalId = this._awsExternalId;
    }
    if (this._awsRegion !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsRegion = this._awsRegion;
    }
    if (this._awsRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsRoleArn = this._awsRoleArn;
    }
    if (this._awsStsEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsStsEndpoint = this._awsStsEndpoint;
    }
    if (this._bufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferSize = this._bufferSize;
    }
    if (this._cloudAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudAuth = this._cloudAuth;
    }
    if (this._cloudAuthSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudAuthSecret = this._cloudAuthSecret?.internalValue;
    }
    if (this._cloudId !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudId = this._cloudId;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._currentTimeIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.currentTimeIndex = this._currentTimeIndex;
    }
    if (this._generateId !== undefined) {
      hasAnyValues = true;
      internalValueResult.generateId = this._generateId;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._idKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.idKey = this._idKey;
    }
    if (this._includeTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeTagKey = this._includeTagKey;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._logstashDateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashDateFormat = this._logstashDateFormat;
    }
    if (this._logstashFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashFormat = this._logstashFormat;
    }
    if (this._logstashPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashPrefix = this._logstashPrefix;
    }
    if (this._logstashPrefixKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashPrefixKey = this._logstashPrefixKey;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replaceDots !== undefined) {
      hasAnyValues = true;
      internalValueResult.replaceDots = this._replaceDots;
    }
    if (this._suppressTypeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressTypeName = this._suppressTypeName;
    }
    if (this._tagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagKey = this._tagKey;
    }
    if (this._timeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKey = this._timeKey;
    }
    if (this._timeKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKeyFormat = this._timeKeyFormat;
    }
    if (this._timeKeyNanos !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKeyNanos = this._timeKeyNanos;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._totalLimitSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalLimitSize = this._totalLimitSize;
    }
    if (this._traceError !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceError = this._traceError;
    }
    if (this._traceOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceOutput = this._traceOutput;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeOperation = this._writeOperation;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAuth = undefined;
      this._awsAuthSecret.internalValue = undefined;
      this._awsExternalId = undefined;
      this._awsRegion = undefined;
      this._awsRoleArn = undefined;
      this._awsStsEndpoint = undefined;
      this._bufferSize = undefined;
      this._cloudAuth = undefined;
      this._cloudAuthSecret.internalValue = undefined;
      this._cloudId = undefined;
      this._compress = undefined;
      this._currentTimeIndex = undefined;
      this._generateId = undefined;
      this._host = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._idKey = undefined;
      this._includeTagKey = undefined;
      this._index = undefined;
      this._logstashDateFormat = undefined;
      this._logstashFormat = undefined;
      this._logstashPrefix = undefined;
      this._logstashPrefixKey = undefined;
      this._networking.internalValue = undefined;
      this._path = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._replaceDots = undefined;
      this._suppressTypeName = undefined;
      this._tagKey = undefined;
      this._timeKey = undefined;
      this._timeKeyFormat = undefined;
      this._timeKeyNanos = undefined;
      this._tls.internalValue = undefined;
      this._totalLimitSize = undefined;
      this._traceError = undefined;
      this._traceOutput = undefined;
      this._type = undefined;
      this._writeOperation = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAuth = value.awsAuth;
      this._awsAuthSecret.internalValue = value.awsAuthSecret;
      this._awsExternalId = value.awsExternalId;
      this._awsRegion = value.awsRegion;
      this._awsRoleArn = value.awsRoleArn;
      this._awsStsEndpoint = value.awsStsEndpoint;
      this._bufferSize = value.bufferSize;
      this._cloudAuth = value.cloudAuth;
      this._cloudAuthSecret.internalValue = value.cloudAuthSecret;
      this._cloudId = value.cloudId;
      this._compress = value.compress;
      this._currentTimeIndex = value.currentTimeIndex;
      this._generateId = value.generateId;
      this._host = value.host;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpUser.internalValue = value.httpUser;
      this._idKey = value.idKey;
      this._includeTagKey = value.includeTagKey;
      this._index = value.index;
      this._logstashDateFormat = value.logstashDateFormat;
      this._logstashFormat = value.logstashFormat;
      this._logstashPrefix = value.logstashPrefix;
      this._logstashPrefixKey = value.logstashPrefixKey;
      this._networking.internalValue = value.networking;
      this._path = value.path;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._replaceDots = value.replaceDots;
      this._suppressTypeName = value.suppressTypeName;
      this._tagKey = value.tagKey;
      this._timeKey = value.timeKey;
      this._timeKeyFormat = value.timeKeyFormat;
      this._timeKeyNanos = value.timeKeyNanos;
      this._tls.internalValue = value.tls;
      this._totalLimitSize = value.totalLimitSize;
      this._traceError = value.traceError;
      this._traceOutput = value.traceOutput;
      this._type = value.type;
      this._writeOperation = value.writeOperation;
    }
  }

  // aws_auth - computed: false, optional: true, required: false
  private _awsAuth?: string; 
  public get awsAuth() {
    return this.getStringAttribute('aws_auth');
  }
  public set awsAuth(value: string) {
    this._awsAuth = value;
  }
  public resetAwsAuth() {
    this._awsAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthInput() {
    return this._awsAuth;
  }

  // aws_auth_secret - computed: false, optional: true, required: false
  private _awsAuthSecret = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecretOutputReference(this, "aws_auth_secret");
  public get awsAuthSecret() {
    return this._awsAuthSecret;
  }
  public putAwsAuthSecret(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsAwsAuthSecret) {
    this._awsAuthSecret.internalValue = value;
  }
  public resetAwsAuthSecret() {
    this._awsAuthSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthSecretInput() {
    return this._awsAuthSecret.internalValue;
  }

  // aws_external_id - computed: false, optional: true, required: false
  private _awsExternalId?: string; 
  public get awsExternalId() {
    return this.getStringAttribute('aws_external_id');
  }
  public set awsExternalId(value: string) {
    this._awsExternalId = value;
  }
  public resetAwsExternalId() {
    this._awsExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsExternalIdInput() {
    return this._awsExternalId;
  }

  // aws_region - computed: false, optional: true, required: false
  private _awsRegion?: string; 
  public get awsRegion() {
    return this.getStringAttribute('aws_region');
  }
  public set awsRegion(value: string) {
    this._awsRegion = value;
  }
  public resetAwsRegion() {
    this._awsRegion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsRegionInput() {
    return this._awsRegion;
  }

  // aws_role_arn - computed: false, optional: true, required: false
  private _awsRoleArn?: string; 
  public get awsRoleArn() {
    return this.getStringAttribute('aws_role_arn');
  }
  public set awsRoleArn(value: string) {
    this._awsRoleArn = value;
  }
  public resetAwsRoleArn() {
    this._awsRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsRoleArnInput() {
    return this._awsRoleArn;
  }

  // aws_sts_endpoint - computed: false, optional: true, required: false
  private _awsStsEndpoint?: string; 
  public get awsStsEndpoint() {
    return this.getStringAttribute('aws_sts_endpoint');
  }
  public set awsStsEndpoint(value: string) {
    this._awsStsEndpoint = value;
  }
  public resetAwsStsEndpoint() {
    this._awsStsEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsStsEndpointInput() {
    return this._awsStsEndpoint;
  }

  // buffer_size - computed: false, optional: true, required: false
  private _bufferSize?: string; 
  public get bufferSize() {
    return this.getStringAttribute('buffer_size');
  }
  public set bufferSize(value: string) {
    this._bufferSize = value;
  }
  public resetBufferSize() {
    this._bufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferSizeInput() {
    return this._bufferSize;
  }

  // cloud_auth - computed: false, optional: true, required: false
  private _cloudAuth?: string; 
  public get cloudAuth() {
    return this.getStringAttribute('cloud_auth');
  }
  public set cloudAuth(value: string) {
    this._cloudAuth = value;
  }
  public resetCloudAuth() {
    this._cloudAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudAuthInput() {
    return this._cloudAuth;
  }

  // cloud_auth_secret - computed: false, optional: true, required: false
  private _cloudAuthSecret = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecretOutputReference(this, "cloud_auth_secret");
  public get cloudAuthSecret() {
    return this._cloudAuthSecret;
  }
  public putCloudAuthSecret(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsCloudAuthSecret) {
    this._cloudAuthSecret.internalValue = value;
  }
  public resetCloudAuthSecret() {
    this._cloudAuthSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudAuthSecretInput() {
    return this._cloudAuthSecret.internalValue;
  }

  // cloud_id - computed: false, optional: true, required: false
  private _cloudId?: string; 
  public get cloudId() {
    return this.getStringAttribute('cloud_id');
  }
  public set cloudId(value: string) {
    this._cloudId = value;
  }
  public resetCloudId() {
    this._cloudId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudIdInput() {
    return this._cloudId;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // current_time_index - computed: false, optional: true, required: false
  private _currentTimeIndex?: boolean | cdktf.IResolvable; 
  public get currentTimeIndex() {
    return this.getBooleanAttribute('current_time_index');
  }
  public set currentTimeIndex(value: boolean | cdktf.IResolvable) {
    this._currentTimeIndex = value;
  }
  public resetCurrentTimeIndex() {
    this._currentTimeIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get currentTimeIndexInput() {
    return this._currentTimeIndex;
  }

  // generate_id - computed: false, optional: true, required: false
  private _generateId?: boolean | cdktf.IResolvable; 
  public get generateId() {
    return this.getBooleanAttribute('generate_id');
  }
  public set generateId(value: boolean | cdktf.IResolvable) {
    this._generateId = value;
  }
  public resetGenerateId() {
    this._generateId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get generateIdInput() {
    return this._generateId;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // id_key - computed: false, optional: true, required: false
  private _idKey?: string; 
  public get idKey() {
    return this.getStringAttribute('id_key');
  }
  public set idKey(value: string) {
    this._idKey = value;
  }
  public resetIdKey() {
    this._idKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idKeyInput() {
    return this._idKey;
  }

  // include_tag_key - computed: false, optional: true, required: false
  private _includeTagKey?: boolean | cdktf.IResolvable; 
  public get includeTagKey() {
    return this.getBooleanAttribute('include_tag_key');
  }
  public set includeTagKey(value: boolean | cdktf.IResolvable) {
    this._includeTagKey = value;
  }
  public resetIncludeTagKey() {
    this._includeTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeTagKeyInput() {
    return this._includeTagKey;
  }

  // index - computed: false, optional: true, required: false
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // logstash_date_format - computed: false, optional: true, required: false
  private _logstashDateFormat?: string; 
  public get logstashDateFormat() {
    return this.getStringAttribute('logstash_date_format');
  }
  public set logstashDateFormat(value: string) {
    this._logstashDateFormat = value;
  }
  public resetLogstashDateFormat() {
    this._logstashDateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashDateFormatInput() {
    return this._logstashDateFormat;
  }

  // logstash_format - computed: false, optional: true, required: false
  private _logstashFormat?: boolean | cdktf.IResolvable; 
  public get logstashFormat() {
    return this.getBooleanAttribute('logstash_format');
  }
  public set logstashFormat(value: boolean | cdktf.IResolvable) {
    this._logstashFormat = value;
  }
  public resetLogstashFormat() {
    this._logstashFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashFormatInput() {
    return this._logstashFormat;
  }

  // logstash_prefix - computed: false, optional: true, required: false
  private _logstashPrefix?: string; 
  public get logstashPrefix() {
    return this.getStringAttribute('logstash_prefix');
  }
  public set logstashPrefix(value: string) {
    this._logstashPrefix = value;
  }
  public resetLogstashPrefix() {
    this._logstashPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashPrefixInput() {
    return this._logstashPrefix;
  }

  // logstash_prefix_key - computed: false, optional: true, required: false
  private _logstashPrefixKey?: string; 
  public get logstashPrefixKey() {
    return this.getStringAttribute('logstash_prefix_key');
  }
  public set logstashPrefixKey(value: string) {
    this._logstashPrefixKey = value;
  }
  public resetLogstashPrefixKey() {
    this._logstashPrefixKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashPrefixKeyInput() {
    return this._logstashPrefixKey;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replace_dots - computed: false, optional: true, required: false
  private _replaceDots?: boolean | cdktf.IResolvable; 
  public get replaceDots() {
    return this.getBooleanAttribute('replace_dots');
  }
  public set replaceDots(value: boolean | cdktf.IResolvable) {
    this._replaceDots = value;
  }
  public resetReplaceDots() {
    this._replaceDots = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replaceDotsInput() {
    return this._replaceDots;
  }

  // suppress_type_name - computed: false, optional: true, required: false
  private _suppressTypeName?: string; 
  public get suppressTypeName() {
    return this.getStringAttribute('suppress_type_name');
  }
  public set suppressTypeName(value: string) {
    this._suppressTypeName = value;
  }
  public resetSuppressTypeName() {
    this._suppressTypeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressTypeNameInput() {
    return this._suppressTypeName;
  }

  // tag_key - computed: false, optional: true, required: false
  private _tagKey?: string; 
  public get tagKey() {
    return this.getStringAttribute('tag_key');
  }
  public set tagKey(value: string) {
    this._tagKey = value;
  }
  public resetTagKey() {
    this._tagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagKeyInput() {
    return this._tagKey;
  }

  // time_key - computed: false, optional: true, required: false
  private _timeKey?: string; 
  public get timeKey() {
    return this.getStringAttribute('time_key');
  }
  public set timeKey(value: string) {
    this._timeKey = value;
  }
  public resetTimeKey() {
    this._timeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyInput() {
    return this._timeKey;
  }

  // time_key_format - computed: false, optional: true, required: false
  private _timeKeyFormat?: string; 
  public get timeKeyFormat() {
    return this.getStringAttribute('time_key_format');
  }
  public set timeKeyFormat(value: string) {
    this._timeKeyFormat = value;
  }
  public resetTimeKeyFormat() {
    this._timeKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyFormatInput() {
    return this._timeKeyFormat;
  }

  // time_key_nanos - computed: false, optional: true, required: false
  private _timeKeyNanos?: boolean | cdktf.IResolvable; 
  public get timeKeyNanos() {
    return this.getBooleanAttribute('time_key_nanos');
  }
  public set timeKeyNanos(value: boolean | cdktf.IResolvable) {
    this._timeKeyNanos = value;
  }
  public resetTimeKeyNanos() {
    this._timeKeyNanos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyNanosInput() {
    return this._timeKeyNanos;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // total_limit_size - computed: false, optional: true, required: false
  private _totalLimitSize?: string; 
  public get totalLimitSize() {
    return this.getStringAttribute('total_limit_size');
  }
  public set totalLimitSize(value: string) {
    this._totalLimitSize = value;
  }
  public resetTotalLimitSize() {
    this._totalLimitSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalLimitSizeInput() {
    return this._totalLimitSize;
  }

  // trace_error - computed: false, optional: true, required: false
  private _traceError?: boolean | cdktf.IResolvable; 
  public get traceError() {
    return this.getBooleanAttribute('trace_error');
  }
  public set traceError(value: boolean | cdktf.IResolvable) {
    this._traceError = value;
  }
  public resetTraceError() {
    this._traceError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceErrorInput() {
    return this._traceError;
  }

  // trace_output - computed: false, optional: true, required: false
  private _traceOutput?: boolean | cdktf.IResolvable; 
  public get traceOutput() {
    return this.getBooleanAttribute('trace_output');
  }
  public set traceOutput(value: boolean | cdktf.IResolvable) {
    this._traceOutput = value;
  }
  public resetTraceOutput() {
    this._traceOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceOutputInput() {
    return this._traceOutput;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_operation - computed: false, optional: true, required: false
  private _writeOperation?: string; 
  public get writeOperation() {
    return this.getStringAttribute('write_operation');
  }
  public set writeOperation(value: string) {
    this._writeOperation = value;
  }
  public resetWriteOperation() {
    this._writeOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeOperationInput() {
    return this._writeOperation;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile {
  /**
  * The character to separate each pair. Applicable only if format is csv or ltsv.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#delimiter DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#delimiter}
  */
  readonly delimiter?: string;
  /**
  * Set file name to store the records. If not set, the file name will be the tag associated with the records.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#file}
  */
  readonly file?: string;
  /**
  * The format of the file content. See also Format section. Default: out_file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#format}
  */
  readonly format?: string;
  /**
  * The character to separate each pair. Applicable only if format is ltsv.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#label_delimiter DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#label_delimiter}
  */
  readonly labelDelimiter?: string;
  /**
  * Absolute directory path to store files. If not set, Fluent Bit will write the files on it's own positioned directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#path}
  */
  readonly path?: string;
  /**
  * The format string. Applicable only if format is template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#template DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#template}
  */
  readonly template?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFileToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delimiter: cdktf.stringToTerraform(struct!.delimiter),
    file: cdktf.stringToTerraform(struct!.file),
    format: cdktf.stringToTerraform(struct!.format),
    label_delimiter: cdktf.stringToTerraform(struct!.labelDelimiter),
    path: cdktf.stringToTerraform(struct!.path),
    template: cdktf.stringToTerraform(struct!.template),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFileToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delimiter: {
      value: cdktf.stringToHclTerraform(struct!.delimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_delimiter: {
      value: cdktf.stringToHclTerraform(struct!.labelDelimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    template: {
      value: cdktf.stringToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.delimiter = this._delimiter;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._labelDelimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelDelimiter = this._labelDelimiter;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delimiter = undefined;
      this._file = undefined;
      this._format = undefined;
      this._labelDelimiter = undefined;
      this._path = undefined;
      this._template = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delimiter = value.delimiter;
      this._file = value.file;
      this._format = value.format;
      this._labelDelimiter = value.labelDelimiter;
      this._path = value.path;
      this._template = value.template;
    }
  }

  // delimiter - computed: false, optional: true, required: false
  private _delimiter?: string; 
  public get delimiter() {
    return this.getStringAttribute('delimiter');
  }
  public set delimiter(value: string) {
    this._delimiter = value;
  }
  public resetDelimiter() {
    this._delimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delimiterInput() {
    return this._delimiter;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // label_delimiter - computed: false, optional: true, required: false
  private _labelDelimiter?: string; 
  public get labelDelimiter() {
    return this.getStringAttribute('label_delimiter');
  }
  public set labelDelimiter(value: string) {
    this._labelDelimiter = value;
  }
  public resetLabelDelimiter() {
    this._labelDelimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelDelimiterInput() {
    return this._labelDelimiter;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // template - computed: false, optional: true, required: false
  private _template?: string; 
  public get template() {
    return this.getStringAttribute('template');
  }
  public set template(value: string) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose {
  /**
  * Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_retry_requests DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_retry_requests}
  */
  readonly autoRetryRequests?: boolean | cdktf.IResolvable;
  /**
  * By default, the whole log record will be sent to Kinesis. If you specify a key name(s) with this option, then only those keys and values will be sent to Kinesis. For example, if you are using the Fluentd Docker log driver, you can specify data_keys log and only the log message will be sent to Kinesis. If you specify multiple keys, they should be comma delimited.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#data_keys DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#data_keys}
  */
  readonly dataKeys?: string;
  /**
  * The name of the Kinesis Firehose Delivery stream that you want log records sent to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#delivery_stream DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#delivery_stream}
  */
  readonly deliveryStream: string;
  /**
  * Specify a custom endpoint for the Kinesis Firehose API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose. For example, if you are using the Fluentd Docker log driver, you can specify log_key log and only the log message will be sent to Firehose.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_key}
  */
  readonly logKey?: string;
  /**
  * The AWS region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#region DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#region}
  */
  readonly region: string;
  /**
  * ARN of an IAM role to assume (for cross account access).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#role_arn DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Specify a custom endpoint for the STS API; used to assume your custom role provided with role_arn.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#sts_endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#sts_endpoint}
  */
  readonly stsEndpoint?: string;
  /**
  * Add the timestamp to the record under this key. By default, the timestamp from Fluent Bit will not be added to records sent to Kinesis.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key}
  */
  readonly timeKey?: string;
  /**
  * strftime compliant format string for the timestamp; for example, %Y-%m-%dT%H *string This option is used with time_key. You can also use %L for milliseconds and %f for microseconds. If you are using ECS FireLens, make sure you are running Amazon ECS Container Agent v1.42.0 or later, otherwise the timestamps associated with your container logs will only have second precision.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key_format}
  */
  readonly timeKeyFormat?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehoseToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_retry_requests: cdktf.booleanToTerraform(struct!.autoRetryRequests),
    data_keys: cdktf.stringToTerraform(struct!.dataKeys),
    delivery_stream: cdktf.stringToTerraform(struct!.deliveryStream),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    log_key: cdktf.stringToTerraform(struct!.logKey),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    sts_endpoint: cdktf.stringToTerraform(struct!.stsEndpoint),
    time_key: cdktf.stringToTerraform(struct!.timeKey),
    time_key_format: cdktf.stringToTerraform(struct!.timeKeyFormat),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehoseToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_retry_requests: {
      value: cdktf.booleanToHclTerraform(struct!.autoRetryRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    data_keys: {
      value: cdktf.stringToHclTerraform(struct!.dataKeys),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delivery_stream: {
      value: cdktf.stringToHclTerraform(struct!.deliveryStream),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_key: {
      value: cdktf.stringToHclTerraform(struct!.logKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sts_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.stsEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key: {
      value: cdktf.stringToHclTerraform(struct!.timeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key_format: {
      value: cdktf.stringToHclTerraform(struct!.timeKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehoseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoRetryRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoRetryRequests = this._autoRetryRequests;
    }
    if (this._dataKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataKeys = this._dataKeys;
    }
    if (this._deliveryStream !== undefined) {
      hasAnyValues = true;
      internalValueResult.deliveryStream = this._deliveryStream;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._logKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logKey = this._logKey;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._stsEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.stsEndpoint = this._stsEndpoint;
    }
    if (this._timeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKey = this._timeKey;
    }
    if (this._timeKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKeyFormat = this._timeKeyFormat;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoRetryRequests = undefined;
      this._dataKeys = undefined;
      this._deliveryStream = undefined;
      this._endpoint = undefined;
      this._logKey = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._stsEndpoint = undefined;
      this._timeKey = undefined;
      this._timeKeyFormat = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoRetryRequests = value.autoRetryRequests;
      this._dataKeys = value.dataKeys;
      this._deliveryStream = value.deliveryStream;
      this._endpoint = value.endpoint;
      this._logKey = value.logKey;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._stsEndpoint = value.stsEndpoint;
      this._timeKey = value.timeKey;
      this._timeKeyFormat = value.timeKeyFormat;
    }
  }

  // auto_retry_requests - computed: false, optional: true, required: false
  private _autoRetryRequests?: boolean | cdktf.IResolvable; 
  public get autoRetryRequests() {
    return this.getBooleanAttribute('auto_retry_requests');
  }
  public set autoRetryRequests(value: boolean | cdktf.IResolvable) {
    this._autoRetryRequests = value;
  }
  public resetAutoRetryRequests() {
    this._autoRetryRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoRetryRequestsInput() {
    return this._autoRetryRequests;
  }

  // data_keys - computed: false, optional: true, required: false
  private _dataKeys?: string; 
  public get dataKeys() {
    return this.getStringAttribute('data_keys');
  }
  public set dataKeys(value: string) {
    this._dataKeys = value;
  }
  public resetDataKeys() {
    this._dataKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataKeysInput() {
    return this._dataKeys;
  }

  // delivery_stream - computed: false, optional: false, required: true
  private _deliveryStream?: string; 
  public get deliveryStream() {
    return this.getStringAttribute('delivery_stream');
  }
  public set deliveryStream(value: string) {
    this._deliveryStream = value;
  }
  // Temporarily expose input value. Use with caution.
  public get deliveryStreamInput() {
    return this._deliveryStream;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // log_key - computed: false, optional: true, required: false
  private _logKey?: string; 
  public get logKey() {
    return this.getStringAttribute('log_key');
  }
  public set logKey(value: string) {
    this._logKey = value;
  }
  public resetLogKey() {
    this._logKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logKeyInput() {
    return this._logKey;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // sts_endpoint - computed: false, optional: true, required: false
  private _stsEndpoint?: string; 
  public get stsEndpoint() {
    return this.getStringAttribute('sts_endpoint');
  }
  public set stsEndpoint(value: string) {
    this._stsEndpoint = value;
  }
  public resetStsEndpoint() {
    this._stsEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stsEndpointInput() {
    return this._stsEndpoint;
  }

  // time_key - computed: false, optional: true, required: false
  private _timeKey?: string; 
  public get timeKey() {
    return this.getStringAttribute('time_key');
  }
  public set timeKey(value: string) {
    this._timeKey = value;
  }
  public resetTimeKey() {
    this._timeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyInput() {
    return this._timeKey;
  }

  // time_key_format - computed: false, optional: true, required: false
  private _timeKeyFormat?: string; 
  public get timeKeyFormat() {
    return this.getStringAttribute('time_key_format');
  }
  public set timeKeyFormat(value: string) {
    this._timeKeyFormat = value;
  }
  public resetTimeKeyFormat() {
    this._timeKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyFormatInput() {
    return this._timeKeyFormat;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward {
  /**
  * Use this option to connect to Fluentd with a zero-length secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#empty_shared_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#empty_shared_key}
  */
  readonly emptySharedKey?: boolean | cdktf.IResolvable;
  /**
  * Target host where Fluent-Bit or Fluentd are listening for Forward messages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking;
  /**
  * Specify the password corresponding to the username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#password}
  */
  readonly password?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword;
  /**
  * TCP Port of the target service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Send 'chunk'-option and wait for 'ack' response from server. Enables at-least-once and receiving server can control rate of traffic. (Requires Fluentd v0.14.0+ server)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#require_ack_response DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#require_ack_response}
  */
  readonly requireAckResponse?: boolean | cdktf.IResolvable;
  /**
  * Default value of the auto-generated certificate common name (CN).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#self_hostname DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#self_hostname}
  */
  readonly selfHostname?: string;
  /**
  * Always send options (with 'size'=count of messages)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#send_options DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#send_options}
  */
  readonly sendOptions?: boolean | cdktf.IResolvable;
  /**
  * A key string known by the remote Fluentd used for authorization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#shared_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#shared_key}
  */
  readonly sharedKey?: string;
  /**
  * Overwrite the tag as we transmit. This allows the receiving pipeline start fresh, or to attribute source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag}
  */
  readonly tag?: string;
  /**
  * Set timestamps in integer format, it enable compatibility mode for Fluentd v0.12 series.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_as_integer DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_as_integer}
  */
  readonly timeAsInteger?: boolean | cdktf.IResolvable;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls;
  /**
  * Specify the username to present to a Fluentd server that enables user_auth.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#username DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#username}
  */
  readonly username?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    empty_shared_key: cdktf.booleanToTerraform(struct!.emptySharedKey),
    host: cdktf.stringToTerraform(struct!.host),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworkingToTerraform(struct!.networking),
    password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    require_ack_response: cdktf.booleanToTerraform(struct!.requireAckResponse),
    self_hostname: cdktf.stringToTerraform(struct!.selfHostname),
    send_options: cdktf.booleanToTerraform(struct!.sendOptions),
    shared_key: cdktf.stringToTerraform(struct!.sharedKey),
    tag: cdktf.stringToTerraform(struct!.tag),
    time_as_integer: cdktf.booleanToTerraform(struct!.timeAsInteger),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsToTerraform(struct!.tls),
    username: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameToTerraform(struct!.username),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    empty_shared_key: {
      value: cdktf.booleanToHclTerraform(struct!.emptySharedKey),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking",
    },
    password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordToHclTerraform(struct!.password),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    require_ack_response: {
      value: cdktf.booleanToHclTerraform(struct!.requireAckResponse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    self_hostname: {
      value: cdktf.stringToHclTerraform(struct!.selfHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_options: {
      value: cdktf.booleanToHclTerraform(struct!.sendOptions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    shared_key: {
      value: cdktf.stringToHclTerraform(struct!.sharedKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.stringToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_as_integer: {
      value: cdktf.booleanToHclTerraform(struct!.timeAsInteger),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls",
    },
    username: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameToHclTerraform(struct!.username),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._emptySharedKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptySharedKey = this._emptySharedKey;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._password?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._requireAckResponse !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireAckResponse = this._requireAckResponse;
    }
    if (this._selfHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.selfHostname = this._selfHostname;
    }
    if (this._sendOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendOptions = this._sendOptions;
    }
    if (this._sharedKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedKey = this._sharedKey;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._timeAsInteger !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeAsInteger = this._timeAsInteger;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._username?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._emptySharedKey = undefined;
      this._host = undefined;
      this._networking.internalValue = undefined;
      this._password.internalValue = undefined;
      this._port = undefined;
      this._requireAckResponse = undefined;
      this._selfHostname = undefined;
      this._sendOptions = undefined;
      this._sharedKey = undefined;
      this._tag = undefined;
      this._timeAsInteger = undefined;
      this._tls.internalValue = undefined;
      this._username.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._emptySharedKey = value.emptySharedKey;
      this._host = value.host;
      this._networking.internalValue = value.networking;
      this._password.internalValue = value.password;
      this._port = value.port;
      this._requireAckResponse = value.requireAckResponse;
      this._selfHostname = value.selfHostname;
      this._sendOptions = value.sendOptions;
      this._sharedKey = value.sharedKey;
      this._tag = value.tag;
      this._timeAsInteger = value.timeAsInteger;
      this._tls.internalValue = value.tls;
      this._username.internalValue = value.username;
    }
  }

  // empty_shared_key - computed: false, optional: true, required: false
  private _emptySharedKey?: boolean | cdktf.IResolvable; 
  public get emptySharedKey() {
    return this.getBooleanAttribute('empty_shared_key');
  }
  public set emptySharedKey(value: boolean | cdktf.IResolvable) {
    this._emptySharedKey = value;
  }
  public resetEmptySharedKey() {
    this._emptySharedKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptySharedKeyInput() {
    return this._emptySharedKey;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPasswordOutputReference(this, "password");
  public get password() {
    return this._password;
  }
  public putPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardPassword) {
    this._password.internalValue = value;
  }
  public resetPassword() {
    this._password.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // require_ack_response - computed: false, optional: true, required: false
  private _requireAckResponse?: boolean | cdktf.IResolvable; 
  public get requireAckResponse() {
    return this.getBooleanAttribute('require_ack_response');
  }
  public set requireAckResponse(value: boolean | cdktf.IResolvable) {
    this._requireAckResponse = value;
  }
  public resetRequireAckResponse() {
    this._requireAckResponse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireAckResponseInput() {
    return this._requireAckResponse;
  }

  // self_hostname - computed: false, optional: true, required: false
  private _selfHostname?: string; 
  public get selfHostname() {
    return this.getStringAttribute('self_hostname');
  }
  public set selfHostname(value: string) {
    this._selfHostname = value;
  }
  public resetSelfHostname() {
    this._selfHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selfHostnameInput() {
    return this._selfHostname;
  }

  // send_options - computed: false, optional: true, required: false
  private _sendOptions?: boolean | cdktf.IResolvable; 
  public get sendOptions() {
    return this.getBooleanAttribute('send_options');
  }
  public set sendOptions(value: boolean | cdktf.IResolvable) {
    this._sendOptions = value;
  }
  public resetSendOptions() {
    this._sendOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendOptionsInput() {
    return this._sendOptions;
  }

  // shared_key - computed: false, optional: true, required: false
  private _sharedKey?: string; 
  public get sharedKey() {
    return this.getStringAttribute('shared_key');
  }
  public set sharedKey(value: string) {
    this._sharedKey = value;
  }
  public resetSharedKey() {
    this._sharedKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedKeyInput() {
    return this._sharedKey;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: string; 
  public get tag() {
    return this.getStringAttribute('tag');
  }
  public set tag(value: string) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // time_as_integer - computed: false, optional: true, required: false
  private _timeAsInteger?: boolean | cdktf.IResolvable; 
  public get timeAsInteger() {
    return this.getBooleanAttribute('time_as_integer');
  }
  public set timeAsInteger(value: boolean | cdktf.IResolvable) {
    this._timeAsInteger = value;
  }
  public resetTimeAsInteger() {
    this._timeAsInteger = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeAsIntegerInput() {
    return this._timeAsInteger;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // username - computed: false, optional: true, required: false
  private _username = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsernameOutputReference(this, "username");
  public get username() {
    return this._username;
  }
  public putUsername(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardUsername) {
    this._username.internalValue = value;
  }
  public resetUsername() {
    this._username.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf {
  /**
  * If transport protocol is udp, it defines if UDP packets should be compressed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compress DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * FullMessageKey is the key to use as the long message that can i.e. contain a backtrace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#full_message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#full_message_key}
  */
  readonly fullMessageKey?: string;
  /**
  * IP address or hostname of the target Graylog server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * HostKey is the key which its value is used as the name of the host, source or application that sent this message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host_key}
  */
  readonly hostKey?: string;
  /**
  * LevelKey is the key to be used as the log level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#level_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#level_key}
  */
  readonly levelKey?: string;
  /**
  * The protocol to use (tls, tcp or udp).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking;
  /**
  * If transport protocol is udp, it sets the size of packets to be sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#packet_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#packet_size}
  */
  readonly packetSize?: number;
  /**
  * The port that the target Graylog server is listening on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * ShortMessageKey is the key to use as the short message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#short_message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#short_message_key}
  */
  readonly shortMessageKey?: string;
  /**
  * TimestampKey is the key which its value is used as the timestamp of the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#timestamp_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#timestamp_key}
  */
  readonly timestampKey?: string;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    full_message_key: cdktf.stringToTerraform(struct!.fullMessageKey),
    host: cdktf.stringToTerraform(struct!.host),
    host_key: cdktf.stringToTerraform(struct!.hostKey),
    level_key: cdktf.stringToTerraform(struct!.levelKey),
    mode: cdktf.stringToTerraform(struct!.mode),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworkingToTerraform(struct!.networking),
    packet_size: cdktf.numberToTerraform(struct!.packetSize),
    port: cdktf.numberToTerraform(struct!.port),
    short_message_key: cdktf.stringToTerraform(struct!.shortMessageKey),
    timestamp_key: cdktf.stringToTerraform(struct!.timestampKey),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsToTerraform(struct!.tls),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    full_message_key: {
      value: cdktf.stringToHclTerraform(struct!.fullMessageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_key: {
      value: cdktf.stringToHclTerraform(struct!.hostKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    level_key: {
      value: cdktf.stringToHclTerraform(struct!.levelKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking",
    },
    packet_size: {
      value: cdktf.numberToHclTerraform(struct!.packetSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    short_message_key: {
      value: cdktf.stringToHclTerraform(struct!.shortMessageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timestamp_key: {
      value: cdktf.stringToHclTerraform(struct!.timestampKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._fullMessageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.fullMessageKey = this._fullMessageKey;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._hostKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostKey = this._hostKey;
    }
    if (this._levelKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.levelKey = this._levelKey;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._packetSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.packetSize = this._packetSize;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._shortMessageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.shortMessageKey = this._shortMessageKey;
    }
    if (this._timestampKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampKey = this._timestampKey;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._fullMessageKey = undefined;
      this._host = undefined;
      this._hostKey = undefined;
      this._levelKey = undefined;
      this._mode = undefined;
      this._networking.internalValue = undefined;
      this._packetSize = undefined;
      this._port = undefined;
      this._shortMessageKey = undefined;
      this._timestampKey = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._fullMessageKey = value.fullMessageKey;
      this._host = value.host;
      this._hostKey = value.hostKey;
      this._levelKey = value.levelKey;
      this._mode = value.mode;
      this._networking.internalValue = value.networking;
      this._packetSize = value.packetSize;
      this._port = value.port;
      this._shortMessageKey = value.shortMessageKey;
      this._timestampKey = value.timestampKey;
      this._tls.internalValue = value.tls;
    }
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // full_message_key - computed: false, optional: true, required: false
  private _fullMessageKey?: string; 
  public get fullMessageKey() {
    return this.getStringAttribute('full_message_key');
  }
  public set fullMessageKey(value: string) {
    this._fullMessageKey = value;
  }
  public resetFullMessageKey() {
    this._fullMessageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fullMessageKeyInput() {
    return this._fullMessageKey;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // host_key - computed: false, optional: true, required: false
  private _hostKey?: string; 
  public get hostKey() {
    return this.getStringAttribute('host_key');
  }
  public set hostKey(value: string) {
    this._hostKey = value;
  }
  public resetHostKey() {
    this._hostKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostKeyInput() {
    return this._hostKey;
  }

  // level_key - computed: false, optional: true, required: false
  private _levelKey?: string; 
  public get levelKey() {
    return this.getStringAttribute('level_key');
  }
  public set levelKey(value: string) {
    this._levelKey = value;
  }
  public resetLevelKey() {
    this._levelKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelKeyInput() {
    return this._levelKey;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // packet_size - computed: false, optional: true, required: false
  private _packetSize?: number; 
  public get packetSize() {
    return this.getNumberAttribute('packet_size');
  }
  public set packetSize(value: number) {
    this._packetSize = value;
  }
  public resetPacketSize() {
    this._packetSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packetSizeInput() {
    return this._packetSize;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // short_message_key - computed: false, optional: true, required: false
  private _shortMessageKey?: string; 
  public get shortMessageKey() {
    return this.getStringAttribute('short_message_key');
  }
  public set shortMessageKey(value: string) {
    this._shortMessageKey = value;
  }
  public resetShortMessageKey() {
    this._shortMessageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shortMessageKeyInput() {
    return this._shortMessageKey;
  }

  // timestamp_key - computed: false, optional: true, required: false
  private _timestampKey?: string; 
  public get timestampKey() {
    return this.getStringAttribute('timestamp_key');
  }
  public set timestampKey(value: string) {
    this._timestampKey = value;
  }
  public resetTimestampKey() {
    this._timestampKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampKeyInput() {
    return this._timestampKey;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp {
  /**
  * Specify if duplicated headers are allowed. If a duplicated header is found, the latest key/value set is preserved.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#allow_duplicated_headers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#allow_duplicated_headers}
  */
  readonly allowDuplicatedHeaders?: boolean | cdktf.IResolvable;
  /**
  * Set payload compression mechanism. Option available is 'gzip'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compress DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compress}
  */
  readonly compress?: string;
  /**
  * Specify the data format to be used in the HTTP request body, by default it uses msgpack. Other supported formats are json, json_stream and json_lines and gelf.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#format}
  */
  readonly format?: string;
  /**
  * Specify the key to use for the full message in gelf format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#gelf_full_message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#gelf_full_message_key}
  */
  readonly gelfFullMessageKey?: string;
  /**
  * Specify the key to use for the host in gelf format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#gelf_host_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#gelf_host_key}
  */
  readonly gelfHostKey?: string;
  /**
  * Specify the key to use for the level in gelf format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#gelf_level_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#gelf_level_key}
  */
  readonly gelfLevelKey?: string;
  /**
  * Specify the key to use as the short message in gelf format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#gelf_short_message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#gelf_short_message_key}
  */
  readonly gelfShortMessageKey?: string;
  /**
  * Specify the key to use for timestamp in gelf format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#gelf_timestamp_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#gelf_timestamp_key}
  */
  readonly gelfTimestampKey?: string;
  /**
  * Specify an optional HTTP header field for the original message tag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#header_tag DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#header_tag}
  */
  readonly headerTag?: string;
  /**
  * Add a HTTP header key/value pair. Multiple headers can be set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#headers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * IP address or hostname of the target HTTP Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Basic Auth Password. Requires HTTP_User to be set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword;
  /**
  * Basic Auth Username
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser;
  /**
  * Specify the format of the date. Supported formats are double, epoch and iso8601 (eg: 2018-05-30T09:39:52.000681Z)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_format}
  */
  readonly jsonDateFormat?: string;
  /**
  * Specify the name of the time key in the output record. To disable the time key just set the value to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_key}
  */
  readonly jsonDateKey?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking;
  /**
  * TCP port of the target HTTP Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Specify an HTTP Proxy. The expected format of this value is http://host:port. Note that https is not supported yet.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#proxy DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#proxy}
  */
  readonly proxy?: string;
  /**
  * HTTP output plugin supports TTL/SSL, for more details about the properties available and general configuration, please refer to the TLS/SSL section.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls;
  /**
  * Specify an optional HTTP URI for the target web server, e.g: /something
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#uri DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_duplicated_headers: cdktf.booleanToTerraform(struct!.allowDuplicatedHeaders),
    compress: cdktf.stringToTerraform(struct!.compress),
    format: cdktf.stringToTerraform(struct!.format),
    gelf_full_message_key: cdktf.stringToTerraform(struct!.gelfFullMessageKey),
    gelf_host_key: cdktf.stringToTerraform(struct!.gelfHostKey),
    gelf_level_key: cdktf.stringToTerraform(struct!.gelfLevelKey),
    gelf_short_message_key: cdktf.stringToTerraform(struct!.gelfShortMessageKey),
    gelf_timestamp_key: cdktf.stringToTerraform(struct!.gelfTimestampKey),
    header_tag: cdktf.stringToTerraform(struct!.headerTag),
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    host: cdktf.stringToTerraform(struct!.host),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordToTerraform(struct!.httpPassword),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserToTerraform(struct!.httpUser),
    json_date_format: cdktf.stringToTerraform(struct!.jsonDateFormat),
    json_date_key: cdktf.stringToTerraform(struct!.jsonDateKey),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    proxy: cdktf.stringToTerraform(struct!.proxy),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsToTerraform(struct!.tls),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_duplicated_headers: {
      value: cdktf.booleanToHclTerraform(struct!.allowDuplicatedHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gelf_full_message_key: {
      value: cdktf.stringToHclTerraform(struct!.gelfFullMessageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gelf_host_key: {
      value: cdktf.stringToHclTerraform(struct!.gelfHostKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gelf_level_key: {
      value: cdktf.stringToHclTerraform(struct!.gelfLevelKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gelf_short_message_key: {
      value: cdktf.stringToHclTerraform(struct!.gelfShortMessageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gelf_timestamp_key: {
      value: cdktf.stringToHclTerraform(struct!.gelfTimestampKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_tag: {
      value: cdktf.stringToHclTerraform(struct!.headerTag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser",
    },
    json_date_format: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_key: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy: {
      value: cdktf.stringToHclTerraform(struct!.proxy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDuplicatedHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDuplicatedHeaders = this._allowDuplicatedHeaders;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._gelfFullMessageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.gelfFullMessageKey = this._gelfFullMessageKey;
    }
    if (this._gelfHostKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.gelfHostKey = this._gelfHostKey;
    }
    if (this._gelfLevelKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.gelfLevelKey = this._gelfLevelKey;
    }
    if (this._gelfShortMessageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.gelfShortMessageKey = this._gelfShortMessageKey;
    }
    if (this._gelfTimestampKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.gelfTimestampKey = this._gelfTimestampKey;
    }
    if (this._headerTag !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerTag = this._headerTag;
    }
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._jsonDateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateFormat = this._jsonDateFormat;
    }
    if (this._jsonDateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateKey = this._jsonDateKey;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._proxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy = this._proxy;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowDuplicatedHeaders = undefined;
      this._compress = undefined;
      this._format = undefined;
      this._gelfFullMessageKey = undefined;
      this._gelfHostKey = undefined;
      this._gelfLevelKey = undefined;
      this._gelfShortMessageKey = undefined;
      this._gelfTimestampKey = undefined;
      this._headerTag = undefined;
      this._headers = undefined;
      this._host = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._jsonDateFormat = undefined;
      this._jsonDateKey = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._proxy = undefined;
      this._tls.internalValue = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowDuplicatedHeaders = value.allowDuplicatedHeaders;
      this._compress = value.compress;
      this._format = value.format;
      this._gelfFullMessageKey = value.gelfFullMessageKey;
      this._gelfHostKey = value.gelfHostKey;
      this._gelfLevelKey = value.gelfLevelKey;
      this._gelfShortMessageKey = value.gelfShortMessageKey;
      this._gelfTimestampKey = value.gelfTimestampKey;
      this._headerTag = value.headerTag;
      this._headers = value.headers;
      this._host = value.host;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpUser.internalValue = value.httpUser;
      this._jsonDateFormat = value.jsonDateFormat;
      this._jsonDateKey = value.jsonDateKey;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._proxy = value.proxy;
      this._tls.internalValue = value.tls;
      this._uri = value.uri;
    }
  }

  // allow_duplicated_headers - computed: false, optional: true, required: false
  private _allowDuplicatedHeaders?: boolean | cdktf.IResolvable; 
  public get allowDuplicatedHeaders() {
    return this.getBooleanAttribute('allow_duplicated_headers');
  }
  public set allowDuplicatedHeaders(value: boolean | cdktf.IResolvable) {
    this._allowDuplicatedHeaders = value;
  }
  public resetAllowDuplicatedHeaders() {
    this._allowDuplicatedHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDuplicatedHeadersInput() {
    return this._allowDuplicatedHeaders;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // gelf_full_message_key - computed: false, optional: true, required: false
  private _gelfFullMessageKey?: string; 
  public get gelfFullMessageKey() {
    return this.getStringAttribute('gelf_full_message_key');
  }
  public set gelfFullMessageKey(value: string) {
    this._gelfFullMessageKey = value;
  }
  public resetGelfFullMessageKey() {
    this._gelfFullMessageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gelfFullMessageKeyInput() {
    return this._gelfFullMessageKey;
  }

  // gelf_host_key - computed: false, optional: true, required: false
  private _gelfHostKey?: string; 
  public get gelfHostKey() {
    return this.getStringAttribute('gelf_host_key');
  }
  public set gelfHostKey(value: string) {
    this._gelfHostKey = value;
  }
  public resetGelfHostKey() {
    this._gelfHostKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gelfHostKeyInput() {
    return this._gelfHostKey;
  }

  // gelf_level_key - computed: false, optional: true, required: false
  private _gelfLevelKey?: string; 
  public get gelfLevelKey() {
    return this.getStringAttribute('gelf_level_key');
  }
  public set gelfLevelKey(value: string) {
    this._gelfLevelKey = value;
  }
  public resetGelfLevelKey() {
    this._gelfLevelKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gelfLevelKeyInput() {
    return this._gelfLevelKey;
  }

  // gelf_short_message_key - computed: false, optional: true, required: false
  private _gelfShortMessageKey?: string; 
  public get gelfShortMessageKey() {
    return this.getStringAttribute('gelf_short_message_key');
  }
  public set gelfShortMessageKey(value: string) {
    this._gelfShortMessageKey = value;
  }
  public resetGelfShortMessageKey() {
    this._gelfShortMessageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gelfShortMessageKeyInput() {
    return this._gelfShortMessageKey;
  }

  // gelf_timestamp_key - computed: false, optional: true, required: false
  private _gelfTimestampKey?: string; 
  public get gelfTimestampKey() {
    return this.getStringAttribute('gelf_timestamp_key');
  }
  public set gelfTimestampKey(value: string) {
    this._gelfTimestampKey = value;
  }
  public resetGelfTimestampKey() {
    this._gelfTimestampKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gelfTimestampKeyInput() {
    return this._gelfTimestampKey;
  }

  // header_tag - computed: false, optional: true, required: false
  private _headerTag?: string; 
  public get headerTag() {
    return this.getStringAttribute('header_tag');
  }
  public set headerTag(value: string) {
    this._headerTag = value;
  }
  public resetHeaderTag() {
    this._headerTag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerTagInput() {
    return this._headerTag;
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // json_date_format - computed: false, optional: true, required: false
  private _jsonDateFormat?: string; 
  public get jsonDateFormat() {
    return this.getStringAttribute('json_date_format');
  }
  public set jsonDateFormat(value: string) {
    this._jsonDateFormat = value;
  }
  public resetJsonDateFormat() {
    this._jsonDateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateFormatInput() {
    return this._jsonDateFormat;
  }

  // json_date_key - computed: false, optional: true, required: false
  private _jsonDateKey?: string; 
  public get jsonDateKey() {
    return this.getStringAttribute('json_date_key');
  }
  public set jsonDateKey(value: string) {
    this._jsonDateKey = value;
  }
  public resetJsonDateKey() {
    this._jsonDateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateKeyInput() {
    return this._jsonDateKey;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // proxy - computed: false, optional: true, required: false
  private _proxy?: string; 
  public get proxy() {
    return this.getStringAttribute('proxy');
  }
  public set proxy(value: string) {
    this._proxy = value;
  }
  public resetProxy() {
    this._proxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyInput() {
    return this._proxy;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb {
  /**
  * Automatically tag keys where value is string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_tags DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_tags}
  */
  readonly autoTags?: boolean | cdktf.IResolvable;
  /**
  * InfluxDB bucket name where records will be inserted - if specified, database is ignored and v2 of API is used
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#bucket DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#bucket}
  */
  readonly bucket?: string;
  /**
  * InfluxDB database name where records will be inserted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#database DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#database}
  */
  readonly database?: string;
  /**
  * IP address or hostname of the target InfluxDB service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host: string;
  /**
  * Password for user defined in HTTP_User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword;
  /**
  * Authentication token used with InfluxDB v2 - if specified, both HTTPUser and HTTPPasswd are ignored
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_token DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_token}
  */
  readonly httpToken?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken;
  /**
  * Optional username for HTTP Basic Authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking;
  /**
  * InfluxDB organization name where the bucket is (v2 only)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#org DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#org}
  */
  readonly org?: string;
  /**
  * TCP port of the target InfluxDB service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * The name of the tag whose value is incremented for the consecutive simultaneous events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#sequence_tag DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#sequence_tag}
  */
  readonly sequenceTag?: string;
  /**
  * List of keys that needs to be tagged
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag_keys DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag_keys}
  */
  readonly tagKeys?: string[];
  /**
  * Key of the string array optionally contained within each log record that contains tag keys for that record
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag_list_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag_list_key}
  */
  readonly tagListKey?: string;
  /**
  * Dynamically tag keys which are in the string array at Tags_List_Key key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tags_list_enabled DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tags_list_enabled}
  */
  readonly tagsListEnabled?: boolean | cdktf.IResolvable;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_tags: cdktf.booleanToTerraform(struct!.autoTags),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.stringToTerraform(struct!.host),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordToTerraform(struct!.httpPassword),
    http_token: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenToTerraform(struct!.httpToken),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserToTerraform(struct!.httpUser),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworkingToTerraform(struct!.networking),
    org: cdktf.stringToTerraform(struct!.org),
    port: cdktf.numberToTerraform(struct!.port),
    sequence_tag: cdktf.stringToTerraform(struct!.sequenceTag),
    tag_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tagKeys),
    tag_list_key: cdktf.stringToTerraform(struct!.tagListKey),
    tags_list_enabled: cdktf.booleanToTerraform(struct!.tagsListEnabled),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsToTerraform(struct!.tls),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_tags: {
      value: cdktf.booleanToHclTerraform(struct!.autoTags),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword",
    },
    http_token: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenToHclTerraform(struct!.httpToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking",
    },
    org: {
      value: cdktf.stringToHclTerraform(struct!.org),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sequence_tag: {
      value: cdktf.stringToHclTerraform(struct!.sequenceTag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tagKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_list_key: {
      value: cdktf.stringToHclTerraform(struct!.tagListKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags_list_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.tagsListEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoTags = this._autoTags;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpToken = this._httpToken?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._org !== undefined) {
      hasAnyValues = true;
      internalValueResult.org = this._org;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._sequenceTag !== undefined) {
      hasAnyValues = true;
      internalValueResult.sequenceTag = this._sequenceTag;
    }
    if (this._tagKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagKeys = this._tagKeys;
    }
    if (this._tagListKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagListKey = this._tagListKey;
    }
    if (this._tagsListEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagsListEnabled = this._tagsListEnabled;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoTags = undefined;
      this._bucket = undefined;
      this._database = undefined;
      this._host = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpToken.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._networking.internalValue = undefined;
      this._org = undefined;
      this._port = undefined;
      this._sequenceTag = undefined;
      this._tagKeys = undefined;
      this._tagListKey = undefined;
      this._tagsListEnabled = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoTags = value.autoTags;
      this._bucket = value.bucket;
      this._database = value.database;
      this._host = value.host;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpToken.internalValue = value.httpToken;
      this._httpUser.internalValue = value.httpUser;
      this._networking.internalValue = value.networking;
      this._org = value.org;
      this._port = value.port;
      this._sequenceTag = value.sequenceTag;
      this._tagKeys = value.tagKeys;
      this._tagListKey = value.tagListKey;
      this._tagsListEnabled = value.tagsListEnabled;
      this._tls.internalValue = value.tls;
    }
  }

  // auto_tags - computed: false, optional: true, required: false
  private _autoTags?: boolean | cdktf.IResolvable; 
  public get autoTags() {
    return this.getBooleanAttribute('auto_tags');
  }
  public set autoTags(value: boolean | cdktf.IResolvable) {
    this._autoTags = value;
  }
  public resetAutoTags() {
    this._autoTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoTagsInput() {
    return this._autoTags;
  }

  // bucket - computed: false, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_token - computed: false, optional: true, required: false
  private _httpToken = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpTokenOutputReference(this, "http_token");
  public get httpToken() {
    return this._httpToken;
  }
  public putHttpToken(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpToken) {
    this._httpToken.internalValue = value;
  }
  public resetHttpToken() {
    this._httpToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTokenInput() {
    return this._httpToken.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // org - computed: false, optional: true, required: false
  private _org?: string; 
  public get org() {
    return this.getStringAttribute('org');
  }
  public set org(value: string) {
    this._org = value;
  }
  public resetOrg() {
    this._org = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orgInput() {
    return this._org;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // sequence_tag - computed: false, optional: true, required: false
  private _sequenceTag?: string; 
  public get sequenceTag() {
    return this.getStringAttribute('sequence_tag');
  }
  public set sequenceTag(value: string) {
    this._sequenceTag = value;
  }
  public resetSequenceTag() {
    this._sequenceTag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sequenceTagInput() {
    return this._sequenceTag;
  }

  // tag_keys - computed: false, optional: true, required: false
  private _tagKeys?: string[]; 
  public get tagKeys() {
    return this.getListAttribute('tag_keys');
  }
  public set tagKeys(value: string[]) {
    this._tagKeys = value;
  }
  public resetTagKeys() {
    this._tagKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagKeysInput() {
    return this._tagKeys;
  }

  // tag_list_key - computed: false, optional: true, required: false
  private _tagListKey?: string; 
  public get tagListKey() {
    return this.getStringAttribute('tag_list_key');
  }
  public set tagListKey(value: string) {
    this._tagListKey = value;
  }
  public resetTagListKey() {
    this._tagListKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagListKeyInput() {
    return this._tagListKey;
  }

  // tags_list_enabled - computed: false, optional: true, required: false
  private _tagsListEnabled?: boolean | cdktf.IResolvable; 
  public get tagsListEnabled() {
    return this.getBooleanAttribute('tags_list_enabled');
  }
  public set tagsListEnabled(value: boolean | cdktf.IResolvable) {
    this._tagsListEnabled = value;
  }
  public resetTagsListEnabled() {
    this._tagsListEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsListEnabledInput() {
    return this._tagsListEnabled;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka {
  /**
  * Single of multiple list of Kafka Brokers, e.g: 192.168.1.3:9092, 192.168.1.4:9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#brokers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#brokers}
  */
  readonly brokers?: string;
  /**
  * adds unknown topics (found in Topic_Key) to Topics. So in Topics only a default topic needs to be configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dynamic_topic DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dynamic_topic}
  */
  readonly dynamicTopic?: boolean | cdktf.IResolvable;
  /**
  * Specify data format, options available: json, msgpack.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#format}
  */
  readonly format?: string;
  /**
  * Optional key to store the message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#message_key}
  */
  readonly messageKey?: string;
  /**
  * If set, the value of Message_Key_Field in the record will indicate the message key. If not set nor found in the record, Message_Key will be used (if set).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#message_key_field DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#message_key_field}
  */
  readonly messageKeyField?: string;
  /**
  * Fluent Bit queues data into rdkafka library, if for some reason the underlying library cannot flush the records the queue might fills up blocking new addition of records. The queue_full_retries option set the number of local retries to enqueue the data. The default value is 10 times, the interval between each retry is 1 second. Setting the queue_full_retries value to 0 set's an unlimited number of retries.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#queue_full_retries DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#queue_full_retries}
  */
  readonly queueFullRetries?: number;
  /**
  * {property} can be any librdkafka properties
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#rdkafka DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#rdkafka}
  */
  readonly rdkafka?: { [key: string]: string };
  /**
  * iso8601 or double
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#timestamp_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#timestamp_format}
  */
  readonly timestampFormat?: string;
  /**
  * Set the key to store the record timestamp
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#timestamp_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#timestamp_key}
  */
  readonly timestampKey?: string;
  /**
  * If multiple Topics exists, the value of Topic_Key in the record will indicate the topic to use. E.g: if Topic_Key is router and the record is {'key1': 123, 'router': 'route_2'}, Fluent Bit will use topic route_2. Note that if the value of Topic_Key is not present in Topics, then by default the first topic in the Topics list will indicate the topic to be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#topic_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#topic_key}
  */
  readonly topicKey?: string;
  /**
  * Single entry or list of topics separated by comma (,) that Fluent Bit will use to send messages to Kafka. If only one topic is set, that one will be used for all records. Instead if multiple topics exists, the one set in the record by Topic_Key will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#topics DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#topics}
  */
  readonly topics?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafkaToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    brokers: cdktf.stringToTerraform(struct!.brokers),
    dynamic_topic: cdktf.booleanToTerraform(struct!.dynamicTopic),
    format: cdktf.stringToTerraform(struct!.format),
    message_key: cdktf.stringToTerraform(struct!.messageKey),
    message_key_field: cdktf.stringToTerraform(struct!.messageKeyField),
    queue_full_retries: cdktf.numberToTerraform(struct!.queueFullRetries),
    rdkafka: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.rdkafka),
    timestamp_format: cdktf.stringToTerraform(struct!.timestampFormat),
    timestamp_key: cdktf.stringToTerraform(struct!.timestampKey),
    topic_key: cdktf.stringToTerraform(struct!.topicKey),
    topics: cdktf.stringToTerraform(struct!.topics),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafkaToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    brokers: {
      value: cdktf.stringToHclTerraform(struct!.brokers),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dynamic_topic: {
      value: cdktf.booleanToHclTerraform(struct!.dynamicTopic),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_key: {
      value: cdktf.stringToHclTerraform(struct!.messageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_key_field: {
      value: cdktf.stringToHclTerraform(struct!.messageKeyField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_full_retries: {
      value: cdktf.numberToHclTerraform(struct!.queueFullRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rdkafka: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.rdkafka),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    timestamp_format: {
      value: cdktf.stringToHclTerraform(struct!.timestampFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timestamp_key: {
      value: cdktf.stringToHclTerraform(struct!.timestampKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topic_key: {
      value: cdktf.stringToHclTerraform(struct!.topicKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topics: {
      value: cdktf.stringToHclTerraform(struct!.topics),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafkaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._dynamicTopic !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicTopic = this._dynamicTopic;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._messageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageKey = this._messageKey;
    }
    if (this._messageKeyField !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageKeyField = this._messageKeyField;
    }
    if (this._queueFullRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueFullRetries = this._queueFullRetries;
    }
    if (this._rdkafka !== undefined) {
      hasAnyValues = true;
      internalValueResult.rdkafka = this._rdkafka;
    }
    if (this._timestampFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampFormat = this._timestampFormat;
    }
    if (this._timestampKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampKey = this._timestampKey;
    }
    if (this._topicKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicKey = this._topicKey;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._brokers = undefined;
      this._dynamicTopic = undefined;
      this._format = undefined;
      this._messageKey = undefined;
      this._messageKeyField = undefined;
      this._queueFullRetries = undefined;
      this._rdkafka = undefined;
      this._timestampFormat = undefined;
      this._timestampKey = undefined;
      this._topicKey = undefined;
      this._topics = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._brokers = value.brokers;
      this._dynamicTopic = value.dynamicTopic;
      this._format = value.format;
      this._messageKey = value.messageKey;
      this._messageKeyField = value.messageKeyField;
      this._queueFullRetries = value.queueFullRetries;
      this._rdkafka = value.rdkafka;
      this._timestampFormat = value.timestampFormat;
      this._timestampKey = value.timestampKey;
      this._topicKey = value.topicKey;
      this._topics = value.topics;
    }
  }

  // brokers - computed: false, optional: true, required: false
  private _brokers?: string; 
  public get brokers() {
    return this.getStringAttribute('brokers');
  }
  public set brokers(value: string) {
    this._brokers = value;
  }
  public resetBrokers() {
    this._brokers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // dynamic_topic - computed: false, optional: true, required: false
  private _dynamicTopic?: boolean | cdktf.IResolvable; 
  public get dynamicTopic() {
    return this.getBooleanAttribute('dynamic_topic');
  }
  public set dynamicTopic(value: boolean | cdktf.IResolvable) {
    this._dynamicTopic = value;
  }
  public resetDynamicTopic() {
    this._dynamicTopic = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicTopicInput() {
    return this._dynamicTopic;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // message_key - computed: false, optional: true, required: false
  private _messageKey?: string; 
  public get messageKey() {
    return this.getStringAttribute('message_key');
  }
  public set messageKey(value: string) {
    this._messageKey = value;
  }
  public resetMessageKey() {
    this._messageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageKeyInput() {
    return this._messageKey;
  }

  // message_key_field - computed: false, optional: true, required: false
  private _messageKeyField?: string; 
  public get messageKeyField() {
    return this.getStringAttribute('message_key_field');
  }
  public set messageKeyField(value: string) {
    this._messageKeyField = value;
  }
  public resetMessageKeyField() {
    this._messageKeyField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageKeyFieldInput() {
    return this._messageKeyField;
  }

  // queue_full_retries - computed: false, optional: true, required: false
  private _queueFullRetries?: number; 
  public get queueFullRetries() {
    return this.getNumberAttribute('queue_full_retries');
  }
  public set queueFullRetries(value: number) {
    this._queueFullRetries = value;
  }
  public resetQueueFullRetries() {
    this._queueFullRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueFullRetriesInput() {
    return this._queueFullRetries;
  }

  // rdkafka - computed: false, optional: true, required: false
  private _rdkafka?: { [key: string]: string }; 
  public get rdkafka() {
    return this.getStringMapAttribute('rdkafka');
  }
  public set rdkafka(value: { [key: string]: string }) {
    this._rdkafka = value;
  }
  public resetRdkafka() {
    this._rdkafka = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rdkafkaInput() {
    return this._rdkafka;
  }

  // timestamp_format - computed: false, optional: true, required: false
  private _timestampFormat?: string; 
  public get timestampFormat() {
    return this.getStringAttribute('timestamp_format');
  }
  public set timestampFormat(value: string) {
    this._timestampFormat = value;
  }
  public resetTimestampFormat() {
    this._timestampFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFormatInput() {
    return this._timestampFormat;
  }

  // timestamp_key - computed: false, optional: true, required: false
  private _timestampKey?: string; 
  public get timestampKey() {
    return this.getStringAttribute('timestamp_key');
  }
  public set timestampKey(value: string) {
    this._timestampKey = value;
  }
  public resetTimestampKey() {
    this._timestampKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampKeyInput() {
    return this._timestampKey;
  }

  // topic_key - computed: false, optional: true, required: false
  private _topicKey?: string; 
  public get topicKey() {
    return this.getStringAttribute('topic_key');
  }
  public set topicKey(value: string) {
    this._topicKey = value;
  }
  public resetTopicKey() {
    this._topicKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicKeyInput() {
    return this._topicKey;
  }

  // topics - computed: false, optional: true, required: false
  private _topics?: string; 
  public get topics() {
    return this.getStringAttribute('topics');
  }
  public set topics(value: string) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis {
  /**
  * Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. This option defaults to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_retry_requests DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_retry_requests}
  */
  readonly autoRetryRequests?: boolean | cdktf.IResolvable;
  /**
  * Specify a custom endpoint for the Kinesis API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Specify an external ID for the STS API, can be used with the role_arn parameter if your role requires an external ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#external_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * By default, the whole log record will be sent to Kinesis. If you specify a key name with this option, then only the value of that key will be sent to Kinesis. For example, if you are using the Fluentd Docker log driver, you can specify log_key log and only the log message will be sent to Kinesis.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_key}
  */
  readonly logKey?: string;
  /**
  * The AWS region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#region DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#region}
  */
  readonly region: string;
  /**
  * ARN of an IAM role to assume (for cross account access).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#role_arn DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The name of the Kinesis Streams Delivery stream that you want log records sent to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#stream DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#stream}
  */
  readonly stream: string;
  /**
  * Custom endpoint for the STS API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#sts_endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#sts_endpoint}
  */
  readonly stsEndpoint?: string;
  /**
  * Add the timestamp to the record under this key. By default the timestamp from Fluent Bit will not be added to records sent to Kinesis.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key}
  */
  readonly timeKey?: string;
  /**
  * strftime compliant format string for the timestamp; for example, the default is '%Y-%m-%dT%H:%M:%S'. Supports millisecond precision with '%3N' and supports nanosecond precision with '%9N' and '%L'; for example, adding '%3N' to support millisecond '%Y-%m-%dT%H:%M:%S.%3N'. This option is used with time_key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key_format}
  */
  readonly timeKeyFormat?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesisToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_retry_requests: cdktf.booleanToTerraform(struct!.autoRetryRequests),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    external_id: cdktf.stringToTerraform(struct!.externalId),
    log_key: cdktf.stringToTerraform(struct!.logKey),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    stream: cdktf.stringToTerraform(struct!.stream),
    sts_endpoint: cdktf.stringToTerraform(struct!.stsEndpoint),
    time_key: cdktf.stringToTerraform(struct!.timeKey),
    time_key_format: cdktf.stringToTerraform(struct!.timeKeyFormat),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesisToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_retry_requests: {
      value: cdktf.booleanToHclTerraform(struct!.autoRetryRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_key: {
      value: cdktf.stringToHclTerraform(struct!.logKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream: {
      value: cdktf.stringToHclTerraform(struct!.stream),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sts_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.stsEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key: {
      value: cdktf.stringToHclTerraform(struct!.timeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key_format: {
      value: cdktf.stringToHclTerraform(struct!.timeKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoRetryRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoRetryRequests = this._autoRetryRequests;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._logKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logKey = this._logKey;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._stream !== undefined) {
      hasAnyValues = true;
      internalValueResult.stream = this._stream;
    }
    if (this._stsEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.stsEndpoint = this._stsEndpoint;
    }
    if (this._timeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKey = this._timeKey;
    }
    if (this._timeKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKeyFormat = this._timeKeyFormat;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoRetryRequests = undefined;
      this._endpoint = undefined;
      this._externalId = undefined;
      this._logKey = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._stream = undefined;
      this._stsEndpoint = undefined;
      this._timeKey = undefined;
      this._timeKeyFormat = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoRetryRequests = value.autoRetryRequests;
      this._endpoint = value.endpoint;
      this._externalId = value.externalId;
      this._logKey = value.logKey;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._stream = value.stream;
      this._stsEndpoint = value.stsEndpoint;
      this._timeKey = value.timeKey;
      this._timeKeyFormat = value.timeKeyFormat;
    }
  }

  // auto_retry_requests - computed: false, optional: true, required: false
  private _autoRetryRequests?: boolean | cdktf.IResolvable; 
  public get autoRetryRequests() {
    return this.getBooleanAttribute('auto_retry_requests');
  }
  public set autoRetryRequests(value: boolean | cdktf.IResolvable) {
    this._autoRetryRequests = value;
  }
  public resetAutoRetryRequests() {
    this._autoRetryRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoRetryRequestsInput() {
    return this._autoRetryRequests;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // log_key - computed: false, optional: true, required: false
  private _logKey?: string; 
  public get logKey() {
    return this.getStringAttribute('log_key');
  }
  public set logKey(value: string) {
    this._logKey = value;
  }
  public resetLogKey() {
    this._logKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logKeyInput() {
    return this._logKey;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // stream - computed: false, optional: false, required: true
  private _stream?: string; 
  public get stream() {
    return this.getStringAttribute('stream');
  }
  public set stream(value: string) {
    this._stream = value;
  }
  // Temporarily expose input value. Use with caution.
  public get streamInput() {
    return this._stream;
  }

  // sts_endpoint - computed: false, optional: true, required: false
  private _stsEndpoint?: string; 
  public get stsEndpoint() {
    return this.getStringAttribute('sts_endpoint');
  }
  public set stsEndpoint(value: string) {
    this._stsEndpoint = value;
  }
  public resetStsEndpoint() {
    this._stsEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stsEndpointInput() {
    return this._stsEndpoint;
  }

  // time_key - computed: false, optional: true, required: false
  private _timeKey?: string; 
  public get timeKey() {
    return this.getStringAttribute('time_key');
  }
  public set timeKey(value: string) {
    this._timeKey = value;
  }
  public resetTimeKey() {
    this._timeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyInput() {
    return this._timeKey;
  }

  // time_key_format - computed: false, optional: true, required: false
  private _timeKeyFormat?: string; 
  public get timeKeyFormat() {
    return this.getStringAttribute('time_key_format');
  }
  public set timeKeyFormat(value: string) {
    this._timeKeyFormat = value;
  }
  public resetTimeKeyFormat() {
    this._timeKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyFormatInput() {
    return this._timeKeyFormat;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki {
  /**
  * If set to true, it will add all Kubernetes labels to the Stream labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_kubernetes_labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_kubernetes_labels}
  */
  readonly autoKubernetesLabels?: string;
  /**
  * Set bearer token authentication token value. Can be used as alterntative to HTTP basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#bearer_token DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#bearer_token}
  */
  readonly bearerToken?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken;
  /**
  * If set to true and after extracting labels only a single key remains, the log line sent to Loki will be the value of that key in line_format.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#drop_single_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#drop_single_key}
  */
  readonly dropSingleKey?: string;
  /**
  * Loki hostname or IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host: string;
  /**
  * Password for user defined in HTTP_User Set HTTP basic authentication password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword;
  /**
  * Set HTTP basic authentication user name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser;
  /**
  * Optional list of record keys that will be placed as stream labels. This configuration property is for records key only.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#label_keys DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#label_keys}
  */
  readonly labelKeys?: string[];
  /**
  * Specify the label map file path. The file defines how to extract labels from each record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#label_map_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#label_map_path}
  */
  readonly labelMapPath?: string;
  /**
  * Stream labels for API request. It can be multiple comma separated of strings specifying key=value pairs. In addition to fixed parameters, it also allows to add custom record keys (similar to label_keys property).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#labels}
  */
  readonly labels?: string[];
  /**
  * Format to use when flattening the record to a log line. Valid values are json or key_value. If set to json, the log line sent to Loki will be the Fluent Bit record dumped as JSON. If set to key_value, the log line will be each item in the record concatenated together (separated by a single space) in the format.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#line_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#line_format}
  */
  readonly lineFormat?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking;
  /**
  * Loki TCP port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Optional list of keys to remove.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#remove_keys DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#remove_keys}
  */
  readonly removeKeys?: string[];
  /**
  * Tenant ID used by default to push logs to Loki. If omitted or empty it assumes Loki is running in single-tenant mode and no X-Scope-OrgID header is sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tenant_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tenant_id}
  */
  readonly tenantId?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId;
  /**
  * Specify the name of the key from the original record that contains the Tenant ID. The value of the key is set as X-Scope-OrgID of HTTP header. It is useful to set Tenant ID dynamically.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tenant_id_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tenant_id_key}
  */
  readonly tenantIdKey?: string;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls;
  /**
  * Specify a custom HTTP URI. It must start with forward slash.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#uri DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_kubernetes_labels: cdktf.stringToTerraform(struct!.autoKubernetesLabels),
    bearer_token: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenToTerraform(struct!.bearerToken),
    drop_single_key: cdktf.stringToTerraform(struct!.dropSingleKey),
    host: cdktf.stringToTerraform(struct!.host),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordToTerraform(struct!.httpPassword),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserToTerraform(struct!.httpUser),
    label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.labelKeys),
    label_map_path: cdktf.stringToTerraform(struct!.labelMapPath),
    labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.labels),
    line_format: cdktf.stringToTerraform(struct!.lineFormat),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    remove_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.removeKeys),
    tenant_id: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdToTerraform(struct!.tenantId),
    tenant_id_key: cdktf.stringToTerraform(struct!.tenantIdKey),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsToTerraform(struct!.tls),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_kubernetes_labels: {
      value: cdktf.stringToHclTerraform(struct!.autoKubernetesLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bearer_token: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenToHclTerraform(struct!.bearerToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken",
    },
    drop_single_key: {
      value: cdktf.stringToHclTerraform(struct!.dropSingleKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser",
    },
    label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.labelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    label_map_path: {
      value: cdktf.stringToHclTerraform(struct!.labelMapPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.labels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    line_format: {
      value: cdktf.stringToHclTerraform(struct!.lineFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.removeKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdToHclTerraform(struct!.tenantId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId",
    },
    tenant_id_key: {
      value: cdktf.stringToHclTerraform(struct!.tenantIdKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoKubernetesLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoKubernetesLabels = this._autoKubernetesLabels;
    }
    if (this._bearerToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken?.internalValue;
    }
    if (this._dropSingleKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.dropSingleKey = this._dropSingleKey;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._labelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelKeys = this._labelKeys;
    }
    if (this._labelMapPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelMapPath = this._labelMapPath;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._lineFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.lineFormat = this._lineFormat;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._removeKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeKeys = this._removeKeys;
    }
    if (this._tenantId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId?.internalValue;
    }
    if (this._tenantIdKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantIdKey = this._tenantIdKey;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoKubernetesLabels = undefined;
      this._bearerToken.internalValue = undefined;
      this._dropSingleKey = undefined;
      this._host = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._labelKeys = undefined;
      this._labelMapPath = undefined;
      this._labels = undefined;
      this._lineFormat = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._removeKeys = undefined;
      this._tenantId.internalValue = undefined;
      this._tenantIdKey = undefined;
      this._tls.internalValue = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoKubernetesLabels = value.autoKubernetesLabels;
      this._bearerToken.internalValue = value.bearerToken;
      this._dropSingleKey = value.dropSingleKey;
      this._host = value.host;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpUser.internalValue = value.httpUser;
      this._labelKeys = value.labelKeys;
      this._labelMapPath = value.labelMapPath;
      this._labels = value.labels;
      this._lineFormat = value.lineFormat;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._removeKeys = value.removeKeys;
      this._tenantId.internalValue = value.tenantId;
      this._tenantIdKey = value.tenantIdKey;
      this._tls.internalValue = value.tls;
      this._uri = value.uri;
    }
  }

  // auto_kubernetes_labels - computed: false, optional: true, required: false
  private _autoKubernetesLabels?: string; 
  public get autoKubernetesLabels() {
    return this.getStringAttribute('auto_kubernetes_labels');
  }
  public set autoKubernetesLabels(value: string) {
    this._autoKubernetesLabels = value;
  }
  public resetAutoKubernetesLabels() {
    this._autoKubernetesLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoKubernetesLabelsInput() {
    return this._autoKubernetesLabels;
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerTokenOutputReference(this, "bearer_token");
  public get bearerToken() {
    return this._bearerToken;
  }
  public putBearerToken(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiBearerToken) {
    this._bearerToken.internalValue = value;
  }
  public resetBearerToken() {
    this._bearerToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken.internalValue;
  }

  // drop_single_key - computed: false, optional: true, required: false
  private _dropSingleKey?: string; 
  public get dropSingleKey() {
    return this.getStringAttribute('drop_single_key');
  }
  public set dropSingleKey(value: string) {
    this._dropSingleKey = value;
  }
  public resetDropSingleKey() {
    this._dropSingleKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropSingleKeyInput() {
    return this._dropSingleKey;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // label_keys - computed: false, optional: true, required: false
  private _labelKeys?: string[]; 
  public get labelKeys() {
    return this.getListAttribute('label_keys');
  }
  public set labelKeys(value: string[]) {
    this._labelKeys = value;
  }
  public resetLabelKeys() {
    this._labelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelKeysInput() {
    return this._labelKeys;
  }

  // label_map_path - computed: false, optional: true, required: false
  private _labelMapPath?: string; 
  public get labelMapPath() {
    return this.getStringAttribute('label_map_path');
  }
  public set labelMapPath(value: string) {
    this._labelMapPath = value;
  }
  public resetLabelMapPath() {
    this._labelMapPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelMapPathInput() {
    return this._labelMapPath;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string[]; 
  public get labels() {
    return this.getListAttribute('labels');
  }
  public set labels(value: string[]) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // line_format - computed: false, optional: true, required: false
  private _lineFormat?: string; 
  public get lineFormat() {
    return this.getStringAttribute('line_format');
  }
  public set lineFormat(value: string) {
    this._lineFormat = value;
  }
  public resetLineFormat() {
    this._lineFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lineFormatInput() {
    return this._lineFormat;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // remove_keys - computed: false, optional: true, required: false
  private _removeKeys?: string[]; 
  public get removeKeys() {
    return this.getListAttribute('remove_keys');
  }
  public set removeKeys(value: string[]) {
    this._removeKeys = value;
  }
  public resetRemoveKeys() {
    this._removeKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeKeysInput() {
    return this._removeKeys;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantIdOutputReference(this, "tenant_id");
  public get tenantId() {
    return this._tenantId;
  }
  public putTenantId(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTenantId) {
    this._tenantId.internalValue = value;
  }
  public resetTenantId() {
    this._tenantId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId.internalValue;
  }

  // tenant_id_key - computed: false, optional: true, required: false
  private _tenantIdKey?: string; 
  public get tenantIdKey() {
    return this.getStringAttribute('tenant_id_key');
  }
  public set tenantIdKey(value: string) {
    this._tenantIdKey = value;
  }
  public resetTenantIdKey() {
    this._tenantIdKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdKeyInput() {
    return this._tenantIdKey;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch {
  /**
  * Enable AWS Sigv4 Authentication for Amazon OpenSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_auth DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_auth}
  */
  readonly awsAuth?: string;
  /**
  * External ID for the AWS IAM Role specified with aws_role_arn.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_external_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_external_id}
  */
  readonly awsExternalId?: string;
  /**
  * Specify the AWS region for Amazon OpenSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_region DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_region}
  */
  readonly awsRegion?: string;
  /**
  * AWS IAM Role to assume to put records to your Amazon cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_role_arn DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_role_arn}
  */
  readonly awsRoleArn?: string;
  /**
  * Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#aws_sts_endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#aws_sts_endpoint}
  */
  readonly awsStsEndpoint?: string;
  /**
  * Specify the buffer size used to read the response from the OpenSearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted. To set an unlimited amount of memory set this value to False, otherwise the value must be according to the Unit Size specification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#buffer_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#buffer_size}
  */
  readonly bufferSize?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compress DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compress}
  */
  readonly compress?: string;
  /**
  * Use current time for index generation instead of message record
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#current_time_index DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#current_time_index}
  */
  readonly currentTimeIndex?: boolean | cdktf.IResolvable;
  /**
  * When enabled, generate _id for outgoing records. This prevents duplicate records when retrying OpenSearch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#generate_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#generate_id}
  */
  readonly generateId?: boolean | cdktf.IResolvable;
  /**
  * IP address or hostname of the target OpenSearch instance, default '127.0.0.1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Password for user defined in HTTP_User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword;
  /**
  * Optional username credential for access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser;
  /**
  * If set, _id will be the value of the key from incoming record and Generate_ID option is ignored.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#id_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#id_key}
  */
  readonly idKey?: string;
  /**
  * When enabled, it append the Tag name to the record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#include_tag_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#include_tag_key}
  */
  readonly includeTagKey?: boolean | cdktf.IResolvable;
  /**
  * Index name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#index DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#index}
  */
  readonly index?: string;
  /**
  * Time format (based on strftime) to generate the second part of the Index name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_date_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_date_format}
  */
  readonly logstashDateFormat?: string;
  /**
  * Enable Logstash format compatibility. This option takes a boolean value: True/False, On/Off
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_format}
  */
  readonly logstashFormat?: boolean | cdktf.IResolvable;
  /**
  * When Logstash_Format is enabled, the Index name is composed using a prefix and the date, e.g: If Logstash_Prefix is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_prefix DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_prefix}
  */
  readonly logstashPrefix?: string;
  /**
  * Prefix keys with this string
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logstash_prefix_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logstash_prefix_key}
  */
  readonly logstashPrefixKey?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking;
  /**
  * OpenSearch accepts new data on HTTP query path '/_bulk'. But it is also possible to serve OpenSearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#path}
  */
  readonly path?: string;
  /**
  * OpenSearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use. For performance reasons is strongly suggested to do parsing and filtering on Fluent Bit side, avoid pipelines.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#pipeline DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#pipeline}
  */
  readonly pipeline?: string;
  /**
  * TCP port of the target OpenSearch instance, default '9200'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * When enabled, replace field name dots with underscore, required by Elasticsearch 2.0-2.3.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#replace_dots DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#replace_dots}
  */
  readonly replaceDots?: boolean | cdktf.IResolvable;
  /**
  * When enabled, mapping types is removed and Type option is ignored. Types are deprecated in APIs in v7.0. This options is for v7.0 or later.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#suppress_type_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#suppress_type_name}
  */
  readonly suppressTypeName?: boolean | cdktf.IResolvable;
  /**
  * When Include_Tag_Key is enabled, this property defines the key name for the tag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag_key}
  */
  readonly tagKey?: string;
  /**
  * When Logstash_Format is enabled, each record will get a new timestamp field. The Time_Key property defines the name of that field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key}
  */
  readonly timeKey?: string;
  /**
  * When Logstash_Format is enabled, this property defines the format of the timestamp.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key_format}
  */
  readonly timeKeyFormat?: string;
  /**
  * When Logstash_Format is enabled, enabling this property sends nanosecond precision timestamps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#time_key_nanos DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#time_key_nanos}
  */
  readonly timeKeyNanos?: boolean | cdktf.IResolvable;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls;
  /**
  * Limit the maximum number of Chunks in the filesystem for the current output logical destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#total_limit_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#total_limit_size}
  */
  readonly totalLimitSize?: string;
  /**
  * When enabled print the elasticsearch API calls to stdout when elasticsearch returns an error
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#trace_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#trace_error}
  */
  readonly traceError?: boolean | cdktf.IResolvable;
  /**
  * When enabled print the elasticsearch API calls to stdout (for diag only)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#trace_output DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#trace_output}
  */
  readonly traceOutput?: boolean | cdktf.IResolvable;
  /**
  * Type name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#type DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#type}
  */
  readonly type?: string;
  /**
  * Enables dedicated thread(s) for this output. Default value is set since version 1.8.13. For previous versions is 0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#workers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#workers}
  */
  readonly workers?: number;
  /**
  * Operation to use to write in bulk requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#write_operation DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#write_operation}
  */
  readonly writeOperation?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_auth: cdktf.stringToTerraform(struct!.awsAuth),
    aws_external_id: cdktf.stringToTerraform(struct!.awsExternalId),
    aws_region: cdktf.stringToTerraform(struct!.awsRegion),
    aws_role_arn: cdktf.stringToTerraform(struct!.awsRoleArn),
    aws_sts_endpoint: cdktf.stringToTerraform(struct!.awsStsEndpoint),
    buffer_size: cdktf.stringToTerraform(struct!.bufferSize),
    compress: cdktf.stringToTerraform(struct!.compress),
    current_time_index: cdktf.booleanToTerraform(struct!.currentTimeIndex),
    generate_id: cdktf.booleanToTerraform(struct!.generateId),
    host: cdktf.stringToTerraform(struct!.host),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordToTerraform(struct!.httpPassword),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserToTerraform(struct!.httpUser),
    id_key: cdktf.stringToTerraform(struct!.idKey),
    include_tag_key: cdktf.booleanToTerraform(struct!.includeTagKey),
    index: cdktf.stringToTerraform(struct!.index),
    logstash_date_format: cdktf.stringToTerraform(struct!.logstashDateFormat),
    logstash_format: cdktf.booleanToTerraform(struct!.logstashFormat),
    logstash_prefix: cdktf.stringToTerraform(struct!.logstashPrefix),
    logstash_prefix_key: cdktf.stringToTerraform(struct!.logstashPrefixKey),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworkingToTerraform(struct!.networking),
    path: cdktf.stringToTerraform(struct!.path),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    replace_dots: cdktf.booleanToTerraform(struct!.replaceDots),
    suppress_type_name: cdktf.booleanToTerraform(struct!.suppressTypeName),
    tag_key: cdktf.stringToTerraform(struct!.tagKey),
    time_key: cdktf.stringToTerraform(struct!.timeKey),
    time_key_format: cdktf.stringToTerraform(struct!.timeKeyFormat),
    time_key_nanos: cdktf.booleanToTerraform(struct!.timeKeyNanos),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsToTerraform(struct!.tls),
    total_limit_size: cdktf.stringToTerraform(struct!.totalLimitSize),
    trace_error: cdktf.booleanToTerraform(struct!.traceError),
    trace_output: cdktf.booleanToTerraform(struct!.traceOutput),
    type: cdktf.stringToTerraform(struct!.type),
    workers: cdktf.numberToTerraform(struct!.workers),
    write_operation: cdktf.stringToTerraform(struct!.writeOperation),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_auth: {
      value: cdktf.stringToHclTerraform(struct!.awsAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_external_id: {
      value: cdktf.stringToHclTerraform(struct!.awsExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_region: {
      value: cdktf.stringToHclTerraform(struct!.awsRegion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.awsRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_sts_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.awsStsEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    buffer_size: {
      value: cdktf.stringToHclTerraform(struct!.bufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    current_time_index: {
      value: cdktf.booleanToHclTerraform(struct!.currentTimeIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    generate_id: {
      value: cdktf.booleanToHclTerraform(struct!.generateId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser",
    },
    id_key: {
      value: cdktf.stringToHclTerraform(struct!.idKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_tag_key: {
      value: cdktf.booleanToHclTerraform(struct!.includeTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logstash_date_format: {
      value: cdktf.stringToHclTerraform(struct!.logstashDateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logstash_format: {
      value: cdktf.booleanToHclTerraform(struct!.logstashFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    logstash_prefix: {
      value: cdktf.stringToHclTerraform(struct!.logstashPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logstash_prefix_key: {
      value: cdktf.stringToHclTerraform(struct!.logstashPrefixKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    replace_dots: {
      value: cdktf.booleanToHclTerraform(struct!.replaceDots),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    suppress_type_name: {
      value: cdktf.booleanToHclTerraform(struct!.suppressTypeName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tag_key: {
      value: cdktf.stringToHclTerraform(struct!.tagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key: {
      value: cdktf.stringToHclTerraform(struct!.timeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key_format: {
      value: cdktf.stringToHclTerraform(struct!.timeKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_key_nanos: {
      value: cdktf.booleanToHclTerraform(struct!.timeKeyNanos),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls",
    },
    total_limit_size: {
      value: cdktf.stringToHclTerraform(struct!.totalLimitSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trace_error: {
      value: cdktf.booleanToHclTerraform(struct!.traceError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    trace_output: {
      value: cdktf.booleanToHclTerraform(struct!.traceOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workers: {
      value: cdktf.numberToHclTerraform(struct!.workers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_operation: {
      value: cdktf.stringToHclTerraform(struct!.writeOperation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuth = this._awsAuth;
    }
    if (this._awsExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsExternalId = this._awsExternalId;
    }
    if (this._awsRegion !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsRegion = this._awsRegion;
    }
    if (this._awsRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsRoleArn = this._awsRoleArn;
    }
    if (this._awsStsEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsStsEndpoint = this._awsStsEndpoint;
    }
    if (this._bufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.bufferSize = this._bufferSize;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._currentTimeIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.currentTimeIndex = this._currentTimeIndex;
    }
    if (this._generateId !== undefined) {
      hasAnyValues = true;
      internalValueResult.generateId = this._generateId;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._idKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.idKey = this._idKey;
    }
    if (this._includeTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeTagKey = this._includeTagKey;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._logstashDateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashDateFormat = this._logstashDateFormat;
    }
    if (this._logstashFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashFormat = this._logstashFormat;
    }
    if (this._logstashPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashPrefix = this._logstashPrefix;
    }
    if (this._logstashPrefixKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logstashPrefixKey = this._logstashPrefixKey;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._replaceDots !== undefined) {
      hasAnyValues = true;
      internalValueResult.replaceDots = this._replaceDots;
    }
    if (this._suppressTypeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressTypeName = this._suppressTypeName;
    }
    if (this._tagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagKey = this._tagKey;
    }
    if (this._timeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKey = this._timeKey;
    }
    if (this._timeKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKeyFormat = this._timeKeyFormat;
    }
    if (this._timeKeyNanos !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeKeyNanos = this._timeKeyNanos;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._totalLimitSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalLimitSize = this._totalLimitSize;
    }
    if (this._traceError !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceError = this._traceError;
    }
    if (this._traceOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceOutput = this._traceOutput;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._workers !== undefined) {
      hasAnyValues = true;
      internalValueResult.workers = this._workers;
    }
    if (this._writeOperation !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeOperation = this._writeOperation;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAuth = undefined;
      this._awsExternalId = undefined;
      this._awsRegion = undefined;
      this._awsRoleArn = undefined;
      this._awsStsEndpoint = undefined;
      this._bufferSize = undefined;
      this._compress = undefined;
      this._currentTimeIndex = undefined;
      this._generateId = undefined;
      this._host = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._idKey = undefined;
      this._includeTagKey = undefined;
      this._index = undefined;
      this._logstashDateFormat = undefined;
      this._logstashFormat = undefined;
      this._logstashPrefix = undefined;
      this._logstashPrefixKey = undefined;
      this._networking.internalValue = undefined;
      this._path = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._replaceDots = undefined;
      this._suppressTypeName = undefined;
      this._tagKey = undefined;
      this._timeKey = undefined;
      this._timeKeyFormat = undefined;
      this._timeKeyNanos = undefined;
      this._tls.internalValue = undefined;
      this._totalLimitSize = undefined;
      this._traceError = undefined;
      this._traceOutput = undefined;
      this._type = undefined;
      this._workers = undefined;
      this._writeOperation = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAuth = value.awsAuth;
      this._awsExternalId = value.awsExternalId;
      this._awsRegion = value.awsRegion;
      this._awsRoleArn = value.awsRoleArn;
      this._awsStsEndpoint = value.awsStsEndpoint;
      this._bufferSize = value.bufferSize;
      this._compress = value.compress;
      this._currentTimeIndex = value.currentTimeIndex;
      this._generateId = value.generateId;
      this._host = value.host;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpUser.internalValue = value.httpUser;
      this._idKey = value.idKey;
      this._includeTagKey = value.includeTagKey;
      this._index = value.index;
      this._logstashDateFormat = value.logstashDateFormat;
      this._logstashFormat = value.logstashFormat;
      this._logstashPrefix = value.logstashPrefix;
      this._logstashPrefixKey = value.logstashPrefixKey;
      this._networking.internalValue = value.networking;
      this._path = value.path;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._replaceDots = value.replaceDots;
      this._suppressTypeName = value.suppressTypeName;
      this._tagKey = value.tagKey;
      this._timeKey = value.timeKey;
      this._timeKeyFormat = value.timeKeyFormat;
      this._timeKeyNanos = value.timeKeyNanos;
      this._tls.internalValue = value.tls;
      this._totalLimitSize = value.totalLimitSize;
      this._traceError = value.traceError;
      this._traceOutput = value.traceOutput;
      this._type = value.type;
      this._workers = value.workers;
      this._writeOperation = value.writeOperation;
    }
  }

  // aws_auth - computed: false, optional: true, required: false
  private _awsAuth?: string; 
  public get awsAuth() {
    return this.getStringAttribute('aws_auth');
  }
  public set awsAuth(value: string) {
    this._awsAuth = value;
  }
  public resetAwsAuth() {
    this._awsAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthInput() {
    return this._awsAuth;
  }

  // aws_external_id - computed: false, optional: true, required: false
  private _awsExternalId?: string; 
  public get awsExternalId() {
    return this.getStringAttribute('aws_external_id');
  }
  public set awsExternalId(value: string) {
    this._awsExternalId = value;
  }
  public resetAwsExternalId() {
    this._awsExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsExternalIdInput() {
    return this._awsExternalId;
  }

  // aws_region - computed: false, optional: true, required: false
  private _awsRegion?: string; 
  public get awsRegion() {
    return this.getStringAttribute('aws_region');
  }
  public set awsRegion(value: string) {
    this._awsRegion = value;
  }
  public resetAwsRegion() {
    this._awsRegion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsRegionInput() {
    return this._awsRegion;
  }

  // aws_role_arn - computed: false, optional: true, required: false
  private _awsRoleArn?: string; 
  public get awsRoleArn() {
    return this.getStringAttribute('aws_role_arn');
  }
  public set awsRoleArn(value: string) {
    this._awsRoleArn = value;
  }
  public resetAwsRoleArn() {
    this._awsRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsRoleArnInput() {
    return this._awsRoleArn;
  }

  // aws_sts_endpoint - computed: false, optional: true, required: false
  private _awsStsEndpoint?: string; 
  public get awsStsEndpoint() {
    return this.getStringAttribute('aws_sts_endpoint');
  }
  public set awsStsEndpoint(value: string) {
    this._awsStsEndpoint = value;
  }
  public resetAwsStsEndpoint() {
    this._awsStsEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsStsEndpointInput() {
    return this._awsStsEndpoint;
  }

  // buffer_size - computed: false, optional: true, required: false
  private _bufferSize?: string; 
  public get bufferSize() {
    return this.getStringAttribute('buffer_size');
  }
  public set bufferSize(value: string) {
    this._bufferSize = value;
  }
  public resetBufferSize() {
    this._bufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferSizeInput() {
    return this._bufferSize;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // current_time_index - computed: false, optional: true, required: false
  private _currentTimeIndex?: boolean | cdktf.IResolvable; 
  public get currentTimeIndex() {
    return this.getBooleanAttribute('current_time_index');
  }
  public set currentTimeIndex(value: boolean | cdktf.IResolvable) {
    this._currentTimeIndex = value;
  }
  public resetCurrentTimeIndex() {
    this._currentTimeIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get currentTimeIndexInput() {
    return this._currentTimeIndex;
  }

  // generate_id - computed: false, optional: true, required: false
  private _generateId?: boolean | cdktf.IResolvable; 
  public get generateId() {
    return this.getBooleanAttribute('generate_id');
  }
  public set generateId(value: boolean | cdktf.IResolvable) {
    this._generateId = value;
  }
  public resetGenerateId() {
    this._generateId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get generateIdInput() {
    return this._generateId;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // id_key - computed: false, optional: true, required: false
  private _idKey?: string; 
  public get idKey() {
    return this.getStringAttribute('id_key');
  }
  public set idKey(value: string) {
    this._idKey = value;
  }
  public resetIdKey() {
    this._idKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idKeyInput() {
    return this._idKey;
  }

  // include_tag_key - computed: false, optional: true, required: false
  private _includeTagKey?: boolean | cdktf.IResolvable; 
  public get includeTagKey() {
    return this.getBooleanAttribute('include_tag_key');
  }
  public set includeTagKey(value: boolean | cdktf.IResolvable) {
    this._includeTagKey = value;
  }
  public resetIncludeTagKey() {
    this._includeTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeTagKeyInput() {
    return this._includeTagKey;
  }

  // index - computed: false, optional: true, required: false
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // logstash_date_format - computed: false, optional: true, required: false
  private _logstashDateFormat?: string; 
  public get logstashDateFormat() {
    return this.getStringAttribute('logstash_date_format');
  }
  public set logstashDateFormat(value: string) {
    this._logstashDateFormat = value;
  }
  public resetLogstashDateFormat() {
    this._logstashDateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashDateFormatInput() {
    return this._logstashDateFormat;
  }

  // logstash_format - computed: false, optional: true, required: false
  private _logstashFormat?: boolean | cdktf.IResolvable; 
  public get logstashFormat() {
    return this.getBooleanAttribute('logstash_format');
  }
  public set logstashFormat(value: boolean | cdktf.IResolvable) {
    this._logstashFormat = value;
  }
  public resetLogstashFormat() {
    this._logstashFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashFormatInput() {
    return this._logstashFormat;
  }

  // logstash_prefix - computed: false, optional: true, required: false
  private _logstashPrefix?: string; 
  public get logstashPrefix() {
    return this.getStringAttribute('logstash_prefix');
  }
  public set logstashPrefix(value: string) {
    this._logstashPrefix = value;
  }
  public resetLogstashPrefix() {
    this._logstashPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashPrefixInput() {
    return this._logstashPrefix;
  }

  // logstash_prefix_key - computed: false, optional: true, required: false
  private _logstashPrefixKey?: string; 
  public get logstashPrefixKey() {
    return this.getStringAttribute('logstash_prefix_key');
  }
  public set logstashPrefixKey(value: string) {
    this._logstashPrefixKey = value;
  }
  public resetLogstashPrefixKey() {
    this._logstashPrefixKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logstashPrefixKeyInput() {
    return this._logstashPrefixKey;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // replace_dots - computed: false, optional: true, required: false
  private _replaceDots?: boolean | cdktf.IResolvable; 
  public get replaceDots() {
    return this.getBooleanAttribute('replace_dots');
  }
  public set replaceDots(value: boolean | cdktf.IResolvable) {
    this._replaceDots = value;
  }
  public resetReplaceDots() {
    this._replaceDots = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replaceDotsInput() {
    return this._replaceDots;
  }

  // suppress_type_name - computed: false, optional: true, required: false
  private _suppressTypeName?: boolean | cdktf.IResolvable; 
  public get suppressTypeName() {
    return this.getBooleanAttribute('suppress_type_name');
  }
  public set suppressTypeName(value: boolean | cdktf.IResolvable) {
    this._suppressTypeName = value;
  }
  public resetSuppressTypeName() {
    this._suppressTypeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressTypeNameInput() {
    return this._suppressTypeName;
  }

  // tag_key - computed: false, optional: true, required: false
  private _tagKey?: string; 
  public get tagKey() {
    return this.getStringAttribute('tag_key');
  }
  public set tagKey(value: string) {
    this._tagKey = value;
  }
  public resetTagKey() {
    this._tagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagKeyInput() {
    return this._tagKey;
  }

  // time_key - computed: false, optional: true, required: false
  private _timeKey?: string; 
  public get timeKey() {
    return this.getStringAttribute('time_key');
  }
  public set timeKey(value: string) {
    this._timeKey = value;
  }
  public resetTimeKey() {
    this._timeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyInput() {
    return this._timeKey;
  }

  // time_key_format - computed: false, optional: true, required: false
  private _timeKeyFormat?: string; 
  public get timeKeyFormat() {
    return this.getStringAttribute('time_key_format');
  }
  public set timeKeyFormat(value: string) {
    this._timeKeyFormat = value;
  }
  public resetTimeKeyFormat() {
    this._timeKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyFormatInput() {
    return this._timeKeyFormat;
  }

  // time_key_nanos - computed: false, optional: true, required: false
  private _timeKeyNanos?: boolean | cdktf.IResolvable; 
  public get timeKeyNanos() {
    return this.getBooleanAttribute('time_key_nanos');
  }
  public set timeKeyNanos(value: boolean | cdktf.IResolvable) {
    this._timeKeyNanos = value;
  }
  public resetTimeKeyNanos() {
    this._timeKeyNanos = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeKeyNanosInput() {
    return this._timeKeyNanos;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // total_limit_size - computed: false, optional: true, required: false
  private _totalLimitSize?: string; 
  public get totalLimitSize() {
    return this.getStringAttribute('total_limit_size');
  }
  public set totalLimitSize(value: string) {
    this._totalLimitSize = value;
  }
  public resetTotalLimitSize() {
    this._totalLimitSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalLimitSizeInput() {
    return this._totalLimitSize;
  }

  // trace_error - computed: false, optional: true, required: false
  private _traceError?: boolean | cdktf.IResolvable; 
  public get traceError() {
    return this.getBooleanAttribute('trace_error');
  }
  public set traceError(value: boolean | cdktf.IResolvable) {
    this._traceError = value;
  }
  public resetTraceError() {
    this._traceError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceErrorInput() {
    return this._traceError;
  }

  // trace_output - computed: false, optional: true, required: false
  private _traceOutput?: boolean | cdktf.IResolvable; 
  public get traceOutput() {
    return this.getBooleanAttribute('trace_output');
  }
  public set traceOutput(value: boolean | cdktf.IResolvable) {
    this._traceOutput = value;
  }
  public resetTraceOutput() {
    this._traceOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceOutputInput() {
    return this._traceOutput;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // workers - computed: false, optional: true, required: false
  private _workers?: number; 
  public get workers() {
    return this.getNumberAttribute('workers');
  }
  public set workers(value: number) {
    this._workers = value;
  }
  public resetWorkers() {
    this._workers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workersInput() {
    return this._workers;
  }

  // write_operation - computed: false, optional: true, required: false
  private _writeOperation?: string; 
  public get writeOperation() {
    return this.getStringAttribute('write_operation');
  }
  public set writeOperation(value: string) {
    this._writeOperation = value;
  }
  public resetWriteOperation() {
    this._writeOperation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeOperationInput() {
    return this._writeOperation;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry {
  /**
  * This allows you to add custom labels to all metrics exposed through the OpenTelemetry exporter. You may have multiple of these fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#add_label DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#add_label}
  */
  readonly addLabel?: { [key: string]: string };
  /**
  * Add a HTTP header key/value pair. Multiple headers can be set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#header DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#header}
  */
  readonly header?: { [key: string]: string };
  /**
  * IP address or hostname of the target HTTP Server, default '127.0.0.1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Password for user defined in HTTP_User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword;
  /**
  * Optional username credential for access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser;
  /**
  * Log the response payload within the Fluent Bit log.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_response_payload DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_response_payload}
  */
  readonly logResponsePayload?: boolean | cdktf.IResolvable;
  /**
  * If true, remaining unmatched keys are added as attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logs_body_key_attributes DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logs_body_key_attributes}
  */
  readonly logsBodyKeyAttributes?: boolean | cdktf.IResolvable;
  /**
  * Specify an optional HTTP URI for the target web server listening for logs, e.g: /v1/logs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#logs_uri DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#logs_uri}
  */
  readonly logsUri?: string;
  /**
  * Specify an optional HTTP URI for the target web server listening for metrics, e.g: /v1/metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#metrics_uri DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#metrics_uri}
  */
  readonly metricsUri?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking;
  /**
  * TCP port of the target OpenSearch instance, default '80'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Specify an HTTP Proxy. The expected format of this value is http://HOST:PORT. Note that HTTPS is not currently supported. It is recommended not to set this and to configure the HTTP proxy environment variables instead as they support both HTTP and HTTPS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#proxy DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#proxy}
  */
  readonly proxy?: string;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls;
  /**
  * Specify an optional HTTP URI for the target web server listening for traces, e.g: /v1/traces
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#traces_uri DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#traces_uri}
  */
  readonly tracesUri?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_label: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.addLabel),
    header: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.header),
    host: cdktf.stringToTerraform(struct!.host),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordToTerraform(struct!.httpPassword),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserToTerraform(struct!.httpUser),
    log_response_payload: cdktf.booleanToTerraform(struct!.logResponsePayload),
    logs_body_key_attributes: cdktf.booleanToTerraform(struct!.logsBodyKeyAttributes),
    logs_uri: cdktf.stringToTerraform(struct!.logsUri),
    metrics_uri: cdktf.stringToTerraform(struct!.metricsUri),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    proxy: cdktf.stringToTerraform(struct!.proxy),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsToTerraform(struct!.tls),
    traces_uri: cdktf.stringToTerraform(struct!.tracesUri),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_label: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.addLabel),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.header),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser",
    },
    log_response_payload: {
      value: cdktf.booleanToHclTerraform(struct!.logResponsePayload),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    logs_body_key_attributes: {
      value: cdktf.booleanToHclTerraform(struct!.logsBodyKeyAttributes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    logs_uri: {
      value: cdktf.stringToHclTerraform(struct!.logsUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_uri: {
      value: cdktf.stringToHclTerraform(struct!.metricsUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy: {
      value: cdktf.stringToHclTerraform(struct!.proxy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls",
    },
    traces_uri: {
      value: cdktf.stringToHclTerraform(struct!.tracesUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.addLabel = this._addLabel;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._logResponsePayload !== undefined) {
      hasAnyValues = true;
      internalValueResult.logResponsePayload = this._logResponsePayload;
    }
    if (this._logsBodyKeyAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.logsBodyKeyAttributes = this._logsBodyKeyAttributes;
    }
    if (this._logsUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.logsUri = this._logsUri;
    }
    if (this._metricsUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUri = this._metricsUri;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._proxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy = this._proxy;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tracesUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracesUri = this._tracesUri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addLabel = undefined;
      this._header = undefined;
      this._host = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._logResponsePayload = undefined;
      this._logsBodyKeyAttributes = undefined;
      this._logsUri = undefined;
      this._metricsUri = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._proxy = undefined;
      this._tls.internalValue = undefined;
      this._tracesUri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addLabel = value.addLabel;
      this._header = value.header;
      this._host = value.host;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpUser.internalValue = value.httpUser;
      this._logResponsePayload = value.logResponsePayload;
      this._logsBodyKeyAttributes = value.logsBodyKeyAttributes;
      this._logsUri = value.logsUri;
      this._metricsUri = value.metricsUri;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._proxy = value.proxy;
      this._tls.internalValue = value.tls;
      this._tracesUri = value.tracesUri;
    }
  }

  // add_label - computed: false, optional: true, required: false
  private _addLabel?: { [key: string]: string }; 
  public get addLabel() {
    return this.getStringMapAttribute('add_label');
  }
  public set addLabel(value: { [key: string]: string }) {
    this._addLabel = value;
  }
  public resetAddLabel() {
    this._addLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addLabelInput() {
    return this._addLabel;
  }

  // header - computed: false, optional: true, required: false
  private _header?: { [key: string]: string }; 
  public get header() {
    return this.getStringMapAttribute('header');
  }
  public set header(value: { [key: string]: string }) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // log_response_payload - computed: false, optional: true, required: false
  private _logResponsePayload?: boolean | cdktf.IResolvable; 
  public get logResponsePayload() {
    return this.getBooleanAttribute('log_response_payload');
  }
  public set logResponsePayload(value: boolean | cdktf.IResolvable) {
    this._logResponsePayload = value;
  }
  public resetLogResponsePayload() {
    this._logResponsePayload = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logResponsePayloadInput() {
    return this._logResponsePayload;
  }

  // logs_body_key_attributes - computed: false, optional: true, required: false
  private _logsBodyKeyAttributes?: boolean | cdktf.IResolvable; 
  public get logsBodyKeyAttributes() {
    return this.getBooleanAttribute('logs_body_key_attributes');
  }
  public set logsBodyKeyAttributes(value: boolean | cdktf.IResolvable) {
    this._logsBodyKeyAttributes = value;
  }
  public resetLogsBodyKeyAttributes() {
    this._logsBodyKeyAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsBodyKeyAttributesInput() {
    return this._logsBodyKeyAttributes;
  }

  // logs_uri - computed: false, optional: true, required: false
  private _logsUri?: string; 
  public get logsUri() {
    return this.getStringAttribute('logs_uri');
  }
  public set logsUri(value: string) {
    this._logsUri = value;
  }
  public resetLogsUri() {
    this._logsUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logsUriInput() {
    return this._logsUri;
  }

  // metrics_uri - computed: false, optional: true, required: false
  private _metricsUri?: string; 
  public get metricsUri() {
    return this.getStringAttribute('metrics_uri');
  }
  public set metricsUri(value: string) {
    this._metricsUri = value;
  }
  public resetMetricsUri() {
    this._metricsUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUriInput() {
    return this._metricsUri;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // proxy - computed: false, optional: true, required: false
  private _proxy?: string; 
  public get proxy() {
    return this.getStringAttribute('proxy');
  }
  public set proxy(value: string) {
    this._proxy = value;
  }
  public resetProxy() {
    this._proxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyInput() {
    return this._proxy;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // traces_uri - computed: false, optional: true, required: false
  private _tracesUri?: string; 
  public get tracesUri() {
    return this.getStringAttribute('traces_uri');
  }
  public set tracesUri(value: string) {
    this._tracesUri = value;
  }
  public resetTracesUri() {
    this._tracesUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracesUriInput() {
    return this._tracesUri;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter {
  /**
  * This allows you to add custom labels to all metrics exposed through the prometheus exporter. You may have multiple of these fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#add_labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#add_labels}
  */
  readonly addLabels?: { [key: string]: string };
  /**
  * IP address or hostname of the target HTTP Server, default: 0.0.0.0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host: string;
  /**
  * This is the port Fluent Bit will bind to when hosting prometheus metrics.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporterToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.addLabels),
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporterToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.addLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.addLabels = this._addLabels;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addLabels = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addLabels = value.addLabels;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // add_labels - computed: false, optional: true, required: false
  private _addLabels?: { [key: string]: string }; 
  public get addLabels() {
    return this.getStringMapAttribute('add_labels');
  }
  public set addLabels(value: { [key: string]: string }) {
    this._addLabels = value;
  }
  public resetAddLabels() {
    this._addLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addLabelsInput() {
    return this._addLabels;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite {
  /**
  * This allows you to add custom labels to all metrics exposed through the prometheus exporter. You may have multiple of these fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#add_labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#add_labels}
  */
  readonly addLabels?: { [key: string]: string };
  /**
  * Add a HTTP header key/value pair. Multiple headers can be set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#headers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * IP address or hostname of the target HTTP Server, default: 127.0.0.1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host: string;
  /**
  * Basic Auth Password. Requires HTTP_user to be se
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_passwd DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_passwd}
  */
  readonly httpPasswd?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd;
  /**
  * Basic Auth Username
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser;
  /**
  * Log the response payload within the Fluent Bit log,default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_response_payload DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_response_payload}
  */
  readonly logResponsePayload?: boolean | cdktf.IResolvable;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking;
  /**
  * TCP port of the target HTTP Serveri, default:80
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Specify an HTTP Proxy. The expected format of this value is http://HOST:PORT.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#proxy DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#proxy}
  */
  readonly proxy?: string;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls;
  /**
  * Specify an optional HTTP URI for the target web server, e.g: /something ,default: /
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#uri DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#uri}
  */
  readonly uri?: string;
  /**
  * Enables dedicated thread(s) for this output. Default value is set since version 1.8.13. For previous versions is 0,default : 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#workers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#workers}
  */
  readonly workers?: number;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.addLabels),
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    host: cdktf.stringToTerraform(struct!.host),
    http_passwd: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdToTerraform(struct!.httpPasswd),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserToTerraform(struct!.httpUser),
    log_response_payload: cdktf.booleanToTerraform(struct!.logResponsePayload),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    proxy: cdktf.stringToTerraform(struct!.proxy),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsToTerraform(struct!.tls),
    uri: cdktf.stringToTerraform(struct!.uri),
    workers: cdktf.numberToTerraform(struct!.workers),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.addLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_passwd: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdToHclTerraform(struct!.httpPasswd),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser",
    },
    log_response_payload: {
      value: cdktf.booleanToHclTerraform(struct!.logResponsePayload),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy: {
      value: cdktf.stringToHclTerraform(struct!.proxy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workers: {
      value: cdktf.numberToHclTerraform(struct!.workers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.addLabels = this._addLabels;
    }
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPasswd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPasswd = this._httpPasswd?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._logResponsePayload !== undefined) {
      hasAnyValues = true;
      internalValueResult.logResponsePayload = this._logResponsePayload;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._proxy !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy = this._proxy;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    if (this._workers !== undefined) {
      hasAnyValues = true;
      internalValueResult.workers = this._workers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addLabels = undefined;
      this._headers = undefined;
      this._host = undefined;
      this._httpPasswd.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._logResponsePayload = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._proxy = undefined;
      this._tls.internalValue = undefined;
      this._uri = undefined;
      this._workers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addLabels = value.addLabels;
      this._headers = value.headers;
      this._host = value.host;
      this._httpPasswd.internalValue = value.httpPasswd;
      this._httpUser.internalValue = value.httpUser;
      this._logResponsePayload = value.logResponsePayload;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._proxy = value.proxy;
      this._tls.internalValue = value.tls;
      this._uri = value.uri;
      this._workers = value.workers;
    }
  }

  // add_labels - computed: false, optional: true, required: false
  private _addLabels?: { [key: string]: string }; 
  public get addLabels() {
    return this.getStringMapAttribute('add_labels');
  }
  public set addLabels(value: { [key: string]: string }) {
    this._addLabels = value;
  }
  public resetAddLabels() {
    this._addLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addLabelsInput() {
    return this._addLabels;
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_passwd - computed: false, optional: true, required: false
  private _httpPasswd = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswdOutputReference(this, "http_passwd");
  public get httpPasswd() {
    return this._httpPasswd;
  }
  public putHttpPasswd(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpPasswd) {
    this._httpPasswd.internalValue = value;
  }
  public resetHttpPasswd() {
    this._httpPasswd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswdInput() {
    return this._httpPasswd.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // log_response_payload - computed: false, optional: true, required: false
  private _logResponsePayload?: boolean | cdktf.IResolvable; 
  public get logResponsePayload() {
    return this.getBooleanAttribute('log_response_payload');
  }
  public set logResponsePayload(value: boolean | cdktf.IResolvable) {
    this._logResponsePayload = value;
  }
  public resetLogResponsePayload() {
    this._logResponsePayload = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logResponsePayloadInput() {
    return this._logResponsePayload;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // proxy - computed: false, optional: true, required: false
  private _proxy?: string; 
  public get proxy() {
    return this.getStringAttribute('proxy');
  }
  public set proxy(value: string) {
    this._proxy = value;
  }
  public resetProxy() {
    this._proxy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyInput() {
    return this._proxy;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }

  // workers - computed: false, optional: true, required: false
  private _workers?: number; 
  public get workers() {
    return this.getNumberAttribute('workers');
  }
  public set workers(value: number) {
    this._workers = value;
  }
  public resetWorkers() {
    this._workers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workersInput() {
    return this._workers;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3 {
  /**
  * Immediately retry failed requests to AWS services once.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#auto_retry_requests DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#auto_retry_requests}
  */
  readonly autoRetryRequests?: boolean | cdktf.IResolvable;
  /**
  * S3 Bucket name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#bucket DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#bucket}
  */
  readonly bucket: string;
  /**
  * Predefined Canned ACL Policy for S3 objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#canned_acl DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#canned_acl}
  */
  readonly cannedAcl?: string;
  /**
  * Compression type for S3 objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compression DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compression}
  */
  readonly compression?: string;
  /**
  * A standard MIME type for the S3 object; this will be set as the Content-Type HTTP header.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#content_type DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#content_type}
  */
  readonly contentType?: string;
  /**
  * Custom endpoint for the S3 API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Specify an external ID for the STS API, can be used with the role_arn parameter if your role requires an external ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#external_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * Specify the format of the date. Supported formats are double, epoch, iso8601 (eg: 2018-05-30T09:39:52.000681Z) and java_sql_timestamp (eg: 2018-05-30 09:39:52.000681)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_format}
  */
  readonly jsonDateFormat?: string;
  /**
  * Specify the name of the time key in the output record. To disable the time key just set the value to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_key}
  */
  readonly jsonDateKey?: string;
  /**
  * By default, the whole log record will be sent to S3. If you specify a key name with this option, then only the value of that key will be sent to S3.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_key}
  */
  readonly logKey?: string;
  /**
  * Normally, when an upload request fails, there is a high chance for the last received chunk to be swapped with a later chunk, resulting in data shuffling. This feature prevents this shuffling by using a queue logic for uploads.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#preserve_data_ordering DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#preserve_data_ordering}
  */
  readonly preserveDataOrdering?: boolean | cdktf.IResolvable;
  /**
  * Option to specify an AWS Profile for credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#profile DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#profile}
  */
  readonly profile?: string;
  /**
  * The AWS region of your S3 bucket
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#region DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#region}
  */
  readonly region: string;
  /**
  * Integer value to set the maximum number of retries allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#retry_limit DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#retry_limit}
  */
  readonly retryLimit?: number;
  /**
  * ARN of an IAM role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#role_arn DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Format string for keys in S3.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#s3_key_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#s3_key_format}
  */
  readonly s3KeyFormat?: string;
  /**
  * A series of characters which will be used to split the tag into 'parts' for use with the s3_key_format option.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#s3_key_format_tag_delimiters DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#s3_key_format_tag_delimiters}
  */
  readonly s3KeyFormatTagDelimiters?: string;
  /**
  * Send the Content-MD5 header with PutObject and UploadPart requests, as is required when Object Lock is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#send_content_md5 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#send_content_md5}
  */
  readonly sendContentMd5?: boolean | cdktf.IResolvable;
  /**
  * Disables behavior where UUID string is automatically appended to end of S3 key name when $UUID is not provided in s3_key_format. $UUID, time formatters, $TAG, and other dynamic key formatters all work as expected while this feature is set to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#static_file_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#static_file_path}
  */
  readonly staticFilePath?: boolean | cdktf.IResolvable;
  /**
  * Specify the storage class for S3 objects. If this option is not specified, objects will be stored with the default 'STANDARD' storage class.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#storage_class DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Directory to locally buffer data before sending.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#store_dir DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#store_dir}
  */
  readonly storeDir?: string;
  /**
  * The size of the limitation for disk usage in S3.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#store_dir_limit_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#store_dir_limit_size}
  */
  readonly storeDirLimitSize?: string;
  /**
  * Custom endpoint for the STS API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#sts_endpoint DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#sts_endpoint}
  */
  readonly stsEndpoint?: string;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls;
  /**
  * Specifies the size of files in S3. Minimum size is 1M. With use_put_object On the maximum size is 1G. With multipart upload mode, the maximum size is 50G.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#total_file_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#total_file_size}
  */
  readonly totalFileSize?: string;
  /**
  * The size of each 'part' for multipart uploads. Max: 50M
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#upload_chunk_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#upload_chunk_size}
  */
  readonly uploadChunkSize?: string;
  /**
  * Whenever this amount of time has elapsed, Fluent Bit will complete an upload and create a new file in S3. For example, set this value to 60m and you will get a new file every hour.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#upload_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#upload_timeout}
  */
  readonly uploadTimeout?: string;
  /**
  * Use the S3 PutObject API, instead of the multipart upload API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#use_put_object DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#use_put_object}
  */
  readonly usePutObject?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3ToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_retry_requests: cdktf.booleanToTerraform(struct!.autoRetryRequests),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    canned_acl: cdktf.stringToTerraform(struct!.cannedAcl),
    compression: cdktf.stringToTerraform(struct!.compression),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    external_id: cdktf.stringToTerraform(struct!.externalId),
    json_date_format: cdktf.stringToTerraform(struct!.jsonDateFormat),
    json_date_key: cdktf.stringToTerraform(struct!.jsonDateKey),
    log_key: cdktf.stringToTerraform(struct!.logKey),
    preserve_data_ordering: cdktf.booleanToTerraform(struct!.preserveDataOrdering),
    profile: cdktf.stringToTerraform(struct!.profile),
    region: cdktf.stringToTerraform(struct!.region),
    retry_limit: cdktf.numberToTerraform(struct!.retryLimit),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    s3_key_format: cdktf.stringToTerraform(struct!.s3KeyFormat),
    s3_key_format_tag_delimiters: cdktf.stringToTerraform(struct!.s3KeyFormatTagDelimiters),
    send_content_md5: cdktf.booleanToTerraform(struct!.sendContentMd5),
    static_file_path: cdktf.booleanToTerraform(struct!.staticFilePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    store_dir: cdktf.stringToTerraform(struct!.storeDir),
    store_dir_limit_size: cdktf.stringToTerraform(struct!.storeDirLimitSize),
    sts_endpoint: cdktf.stringToTerraform(struct!.stsEndpoint),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsToTerraform(struct!.tls),
    total_file_size: cdktf.stringToTerraform(struct!.totalFileSize),
    upload_chunk_size: cdktf.stringToTerraform(struct!.uploadChunkSize),
    upload_timeout: cdktf.stringToTerraform(struct!.uploadTimeout),
    use_put_object: cdktf.booleanToTerraform(struct!.usePutObject),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3ToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_retry_requests: {
      value: cdktf.booleanToHclTerraform(struct!.autoRetryRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    canned_acl: {
      value: cdktf.stringToHclTerraform(struct!.cannedAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_format: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_key: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_key: {
      value: cdktf.stringToHclTerraform(struct!.logKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preserve_data_ordering: {
      value: cdktf.booleanToHclTerraform(struct!.preserveDataOrdering),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_limit: {
      value: cdktf.numberToHclTerraform(struct!.retryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    s3_key_format: {
      value: cdktf.stringToHclTerraform(struct!.s3KeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    s3_key_format_tag_delimiters: {
      value: cdktf.stringToHclTerraform(struct!.s3KeyFormatTagDelimiters),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_content_md5: {
      value: cdktf.booleanToHclTerraform(struct!.sendContentMd5),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    static_file_path: {
      value: cdktf.booleanToHclTerraform(struct!.staticFilePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    store_dir: {
      value: cdktf.stringToHclTerraform(struct!.storeDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    store_dir_limit_size: {
      value: cdktf.stringToHclTerraform(struct!.storeDirLimitSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sts_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.stsEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls",
    },
    total_file_size: {
      value: cdktf.stringToHclTerraform(struct!.totalFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upload_chunk_size: {
      value: cdktf.stringToHclTerraform(struct!.uploadChunkSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upload_timeout: {
      value: cdktf.stringToHclTerraform(struct!.uploadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_put_object: {
      value: cdktf.booleanToHclTerraform(struct!.usePutObject),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoRetryRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoRetryRequests = this._autoRetryRequests;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._cannedAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.cannedAcl = this._cannedAcl;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._jsonDateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateFormat = this._jsonDateFormat;
    }
    if (this._jsonDateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateKey = this._jsonDateKey;
    }
    if (this._logKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logKey = this._logKey;
    }
    if (this._preserveDataOrdering !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveDataOrdering = this._preserveDataOrdering;
    }
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._retryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryLimit = this._retryLimit;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._s3KeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3KeyFormat = this._s3KeyFormat;
    }
    if (this._s3KeyFormatTagDelimiters !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3KeyFormatTagDelimiters = this._s3KeyFormatTagDelimiters;
    }
    if (this._sendContentMd5 !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendContentMd5 = this._sendContentMd5;
    }
    if (this._staticFilePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.staticFilePath = this._staticFilePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._storeDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.storeDir = this._storeDir;
    }
    if (this._storeDirLimitSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.storeDirLimitSize = this._storeDirLimitSize;
    }
    if (this._stsEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.stsEndpoint = this._stsEndpoint;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._totalFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalFileSize = this._totalFileSize;
    }
    if (this._uploadChunkSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.uploadChunkSize = this._uploadChunkSize;
    }
    if (this._uploadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.uploadTimeout = this._uploadTimeout;
    }
    if (this._usePutObject !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePutObject = this._usePutObject;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoRetryRequests = undefined;
      this._bucket = undefined;
      this._cannedAcl = undefined;
      this._compression = undefined;
      this._contentType = undefined;
      this._endpoint = undefined;
      this._externalId = undefined;
      this._jsonDateFormat = undefined;
      this._jsonDateKey = undefined;
      this._logKey = undefined;
      this._preserveDataOrdering = undefined;
      this._profile = undefined;
      this._region = undefined;
      this._retryLimit = undefined;
      this._roleArn = undefined;
      this._s3KeyFormat = undefined;
      this._s3KeyFormatTagDelimiters = undefined;
      this._sendContentMd5 = undefined;
      this._staticFilePath = undefined;
      this._storageClass = undefined;
      this._storeDir = undefined;
      this._storeDirLimitSize = undefined;
      this._stsEndpoint = undefined;
      this._tls.internalValue = undefined;
      this._totalFileSize = undefined;
      this._uploadChunkSize = undefined;
      this._uploadTimeout = undefined;
      this._usePutObject = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoRetryRequests = value.autoRetryRequests;
      this._bucket = value.bucket;
      this._cannedAcl = value.cannedAcl;
      this._compression = value.compression;
      this._contentType = value.contentType;
      this._endpoint = value.endpoint;
      this._externalId = value.externalId;
      this._jsonDateFormat = value.jsonDateFormat;
      this._jsonDateKey = value.jsonDateKey;
      this._logKey = value.logKey;
      this._preserveDataOrdering = value.preserveDataOrdering;
      this._profile = value.profile;
      this._region = value.region;
      this._retryLimit = value.retryLimit;
      this._roleArn = value.roleArn;
      this._s3KeyFormat = value.s3KeyFormat;
      this._s3KeyFormatTagDelimiters = value.s3KeyFormatTagDelimiters;
      this._sendContentMd5 = value.sendContentMd5;
      this._staticFilePath = value.staticFilePath;
      this._storageClass = value.storageClass;
      this._storeDir = value.storeDir;
      this._storeDirLimitSize = value.storeDirLimitSize;
      this._stsEndpoint = value.stsEndpoint;
      this._tls.internalValue = value.tls;
      this._totalFileSize = value.totalFileSize;
      this._uploadChunkSize = value.uploadChunkSize;
      this._uploadTimeout = value.uploadTimeout;
      this._usePutObject = value.usePutObject;
    }
  }

  // auto_retry_requests - computed: false, optional: true, required: false
  private _autoRetryRequests?: boolean | cdktf.IResolvable; 
  public get autoRetryRequests() {
    return this.getBooleanAttribute('auto_retry_requests');
  }
  public set autoRetryRequests(value: boolean | cdktf.IResolvable) {
    this._autoRetryRequests = value;
  }
  public resetAutoRetryRequests() {
    this._autoRetryRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoRetryRequestsInput() {
    return this._autoRetryRequests;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // canned_acl - computed: false, optional: true, required: false
  private _cannedAcl?: string; 
  public get cannedAcl() {
    return this.getStringAttribute('canned_acl');
  }
  public set cannedAcl(value: string) {
    this._cannedAcl = value;
  }
  public resetCannedAcl() {
    this._cannedAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cannedAclInput() {
    return this._cannedAcl;
  }

  // compression - computed: false, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // json_date_format - computed: false, optional: true, required: false
  private _jsonDateFormat?: string; 
  public get jsonDateFormat() {
    return this.getStringAttribute('json_date_format');
  }
  public set jsonDateFormat(value: string) {
    this._jsonDateFormat = value;
  }
  public resetJsonDateFormat() {
    this._jsonDateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateFormatInput() {
    return this._jsonDateFormat;
  }

  // json_date_key - computed: false, optional: true, required: false
  private _jsonDateKey?: string; 
  public get jsonDateKey() {
    return this.getStringAttribute('json_date_key');
  }
  public set jsonDateKey(value: string) {
    this._jsonDateKey = value;
  }
  public resetJsonDateKey() {
    this._jsonDateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateKeyInput() {
    return this._jsonDateKey;
  }

  // log_key - computed: false, optional: true, required: false
  private _logKey?: string; 
  public get logKey() {
    return this.getStringAttribute('log_key');
  }
  public set logKey(value: string) {
    this._logKey = value;
  }
  public resetLogKey() {
    this._logKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logKeyInput() {
    return this._logKey;
  }

  // preserve_data_ordering - computed: false, optional: true, required: false
  private _preserveDataOrdering?: boolean | cdktf.IResolvable; 
  public get preserveDataOrdering() {
    return this.getBooleanAttribute('preserve_data_ordering');
  }
  public set preserveDataOrdering(value: boolean | cdktf.IResolvable) {
    this._preserveDataOrdering = value;
  }
  public resetPreserveDataOrdering() {
    this._preserveDataOrdering = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveDataOrderingInput() {
    return this._preserveDataOrdering;
  }

  // profile - computed: false, optional: true, required: false
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  public resetProfile() {
    this._profile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // retry_limit - computed: false, optional: true, required: false
  private _retryLimit?: number; 
  public get retryLimit() {
    return this.getNumberAttribute('retry_limit');
  }
  public set retryLimit(value: number) {
    this._retryLimit = value;
  }
  public resetRetryLimit() {
    this._retryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryLimitInput() {
    return this._retryLimit;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // s3_key_format - computed: false, optional: true, required: false
  private _s3KeyFormat?: string; 
  public get s3KeyFormat() {
    return this.getStringAttribute('s3_key_format');
  }
  public set s3KeyFormat(value: string) {
    this._s3KeyFormat = value;
  }
  public resetS3KeyFormat() {
    this._s3KeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3KeyFormatInput() {
    return this._s3KeyFormat;
  }

  // s3_key_format_tag_delimiters - computed: false, optional: true, required: false
  private _s3KeyFormatTagDelimiters?: string; 
  public get s3KeyFormatTagDelimiters() {
    return this.getStringAttribute('s3_key_format_tag_delimiters');
  }
  public set s3KeyFormatTagDelimiters(value: string) {
    this._s3KeyFormatTagDelimiters = value;
  }
  public resetS3KeyFormatTagDelimiters() {
    this._s3KeyFormatTagDelimiters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3KeyFormatTagDelimitersInput() {
    return this._s3KeyFormatTagDelimiters;
  }

  // send_content_md5 - computed: false, optional: true, required: false
  private _sendContentMd5?: boolean | cdktf.IResolvable; 
  public get sendContentMd5() {
    return this.getBooleanAttribute('send_content_md5');
  }
  public set sendContentMd5(value: boolean | cdktf.IResolvable) {
    this._sendContentMd5 = value;
  }
  public resetSendContentMd5() {
    this._sendContentMd5 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendContentMd5Input() {
    return this._sendContentMd5;
  }

  // static_file_path - computed: false, optional: true, required: false
  private _staticFilePath?: boolean | cdktf.IResolvable; 
  public get staticFilePath() {
    return this.getBooleanAttribute('static_file_path');
  }
  public set staticFilePath(value: boolean | cdktf.IResolvable) {
    this._staticFilePath = value;
  }
  public resetStaticFilePath() {
    this._staticFilePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staticFilePathInput() {
    return this._staticFilePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // store_dir - computed: false, optional: true, required: false
  private _storeDir?: string; 
  public get storeDir() {
    return this.getStringAttribute('store_dir');
  }
  public set storeDir(value: string) {
    this._storeDir = value;
  }
  public resetStoreDir() {
    this._storeDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storeDirInput() {
    return this._storeDir;
  }

  // store_dir_limit_size - computed: false, optional: true, required: false
  private _storeDirLimitSize?: string; 
  public get storeDirLimitSize() {
    return this.getStringAttribute('store_dir_limit_size');
  }
  public set storeDirLimitSize(value: string) {
    this._storeDirLimitSize = value;
  }
  public resetStoreDirLimitSize() {
    this._storeDirLimitSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storeDirLimitSizeInput() {
    return this._storeDirLimitSize;
  }

  // sts_endpoint - computed: false, optional: true, required: false
  private _stsEndpoint?: string; 
  public get stsEndpoint() {
    return this.getStringAttribute('sts_endpoint');
  }
  public set stsEndpoint(value: string) {
    this._stsEndpoint = value;
  }
  public resetStsEndpoint() {
    this._stsEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stsEndpointInput() {
    return this._stsEndpoint;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // total_file_size - computed: false, optional: true, required: false
  private _totalFileSize?: string; 
  public get totalFileSize() {
    return this.getStringAttribute('total_file_size');
  }
  public set totalFileSize(value: string) {
    this._totalFileSize = value;
  }
  public resetTotalFileSize() {
    this._totalFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalFileSizeInput() {
    return this._totalFileSize;
  }

  // upload_chunk_size - computed: false, optional: true, required: false
  private _uploadChunkSize?: string; 
  public get uploadChunkSize() {
    return this.getStringAttribute('upload_chunk_size');
  }
  public set uploadChunkSize(value: string) {
    this._uploadChunkSize = value;
  }
  public resetUploadChunkSize() {
    this._uploadChunkSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uploadChunkSizeInput() {
    return this._uploadChunkSize;
  }

  // upload_timeout - computed: false, optional: true, required: false
  private _uploadTimeout?: string; 
  public get uploadTimeout() {
    return this.getStringAttribute('upload_timeout');
  }
  public set uploadTimeout(value: string) {
    this._uploadTimeout = value;
  }
  public resetUploadTimeout() {
    this._uploadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uploadTimeoutInput() {
    return this._uploadTimeout;
  }

  // use_put_object - computed: false, optional: true, required: false
  private _usePutObject?: boolean | cdktf.IResolvable; 
  public get usePutObject() {
    return this.getBooleanAttribute('use_put_object');
  }
  public set usePutObject(value: boolean | cdktf.IResolvable) {
    this._usePutObject = value;
  }
  public resetUsePutObject() {
    this._usePutObject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePutObjectInput() {
    return this._usePutObject;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk {
  /**
  * Specify X-Splunk-Request-Channel Header for the HTTP Event Collector interface.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#channel DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#channel}
  */
  readonly channel?: string;
  /**
  * Set payload compression mechanism. The only available option is gzip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#compress DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#compress}
  */
  readonly compress?: string;
  /**
  * Set event fields for the record. This option is an array and the format is 'key_name record_accessor_pattern'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_fields DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_fields}
  */
  readonly eventFields?: string[];
  /**
  * Specify the key name that contains the host value. This option allows a record accessors pattern.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_host}
  */
  readonly eventHost?: string;
  /**
  * The name of the index by which the event data is to be indexed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_index DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_index}
  */
  readonly eventIndex?: string;
  /**
  * Set a record key that will populate the index field. If the key is found, it will have precedence over the value set in event_index.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_index_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_index_key}
  */
  readonly eventIndexKey?: string;
  /**
  * Specify the key name that will be used to send a single value as part of the record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_key}
  */
  readonly eventKey?: string;
  /**
  * Set the source value to assign to the event data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_source DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_source}
  */
  readonly eventSource?: string;
  /**
  * Set the sourcetype value to assign to the event data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_sourcetype DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_sourcetype}
  */
  readonly eventSourcetype?: string;
  /**
  * Set a record key that will populate 'sourcetype'. If the key is found, it will have precedence over the value set in event_sourcetype.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#event_sourcetype_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#event_sourcetype_key}
  */
  readonly eventSourcetypeKey?: string;
  /**
  * IP address or hostname of the target OpenSearch instance, default '127.0.0.1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Buffer size used to receive Splunk HTTP responses: Default '2M'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_buffer_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_buffer_size}
  */
  readonly httpBufferSize?: string;
  /**
  * If the HTTP server response code is 400 (bad request) and this flag is enabled, it will print the full HTTP request and response to the stdout interface. This feature is available for debugging purposes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_debug_bad_request DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_debug_bad_request}
  */
  readonly httpDebugBadRequest?: boolean | cdktf.IResolvable;
  /**
  * Password for user defined in HTTP_User
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_password}
  */
  readonly httpPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword;
  /**
  * Optional username credential for access
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http_user DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http_user}
  */
  readonly httpUser?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking;
  /**
  * TCP port of the target Splunk instance, default '8088'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * When enabled, the record keys and values are set in the top level of the map instead of under the event key. Refer to the Sending Raw Events section from the docs more details to make this option work properly.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#splunk_send_raw DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#splunk_send_raw}
  */
  readonly splunkSendRaw?: boolean | cdktf.IResolvable;
  /**
  * Specify the Authentication Token for the HTTP Event Collector interface.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#splunk_token DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#splunk_token}
  */
  readonly splunkToken?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls;
  /**
  * Enables dedicated thread(s) for this output. Default value '2' is set since version 1.8.13. For previous versions is 0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#workers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#workers}
  */
  readonly workers?: number;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    channel: cdktf.stringToTerraform(struct!.channel),
    compress: cdktf.stringToTerraform(struct!.compress),
    event_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.eventFields),
    event_host: cdktf.stringToTerraform(struct!.eventHost),
    event_index: cdktf.stringToTerraform(struct!.eventIndex),
    event_index_key: cdktf.stringToTerraform(struct!.eventIndexKey),
    event_key: cdktf.stringToTerraform(struct!.eventKey),
    event_source: cdktf.stringToTerraform(struct!.eventSource),
    event_sourcetype: cdktf.stringToTerraform(struct!.eventSourcetype),
    event_sourcetype_key: cdktf.stringToTerraform(struct!.eventSourcetypeKey),
    host: cdktf.stringToTerraform(struct!.host),
    http_buffer_size: cdktf.stringToTerraform(struct!.httpBufferSize),
    http_debug_bad_request: cdktf.booleanToTerraform(struct!.httpDebugBadRequest),
    http_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordToTerraform(struct!.httpPassword),
    http_user: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserToTerraform(struct!.httpUser),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    splunk_send_raw: cdktf.booleanToTerraform(struct!.splunkSendRaw),
    splunk_token: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenToTerraform(struct!.splunkToken),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsToTerraform(struct!.tls),
    workers: cdktf.numberToTerraform(struct!.workers),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    channel: {
      value: cdktf.stringToHclTerraform(struct!.channel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.eventFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    event_host: {
      value: cdktf.stringToHclTerraform(struct!.eventHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_index: {
      value: cdktf.stringToHclTerraform(struct!.eventIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_index_key: {
      value: cdktf.stringToHclTerraform(struct!.eventIndexKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_key: {
      value: cdktf.stringToHclTerraform(struct!.eventKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_source: {
      value: cdktf.stringToHclTerraform(struct!.eventSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_sourcetype: {
      value: cdktf.stringToHclTerraform(struct!.eventSourcetype),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_sourcetype_key: {
      value: cdktf.stringToHclTerraform(struct!.eventSourcetypeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_buffer_size: {
      value: cdktf.stringToHclTerraform(struct!.httpBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_debug_bad_request: {
      value: cdktf.booleanToHclTerraform(struct!.httpDebugBadRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordToHclTerraform(struct!.httpPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword",
    },
    http_user: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserToHclTerraform(struct!.httpUser),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    splunk_send_raw: {
      value: cdktf.booleanToHclTerraform(struct!.splunkSendRaw),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    splunk_token: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenToHclTerraform(struct!.splunkToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls",
    },
    workers: {
      value: cdktf.numberToHclTerraform(struct!.workers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._channel !== undefined) {
      hasAnyValues = true;
      internalValueResult.channel = this._channel;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._eventFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventFields = this._eventFields;
    }
    if (this._eventHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventHost = this._eventHost;
    }
    if (this._eventIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventIndex = this._eventIndex;
    }
    if (this._eventIndexKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventIndexKey = this._eventIndexKey;
    }
    if (this._eventKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventKey = this._eventKey;
    }
    if (this._eventSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventSource = this._eventSource;
    }
    if (this._eventSourcetype !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventSourcetype = this._eventSourcetype;
    }
    if (this._eventSourcetypeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventSourcetypeKey = this._eventSourcetypeKey;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpBufferSize = this._httpBufferSize;
    }
    if (this._httpDebugBadRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpDebugBadRequest = this._httpDebugBadRequest;
    }
    if (this._httpPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPassword = this._httpPassword?.internalValue;
    }
    if (this._httpUser?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpUser = this._httpUser?.internalValue;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._splunkSendRaw !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkSendRaw = this._splunkSendRaw;
    }
    if (this._splunkToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkToken = this._splunkToken?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._workers !== undefined) {
      hasAnyValues = true;
      internalValueResult.workers = this._workers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._channel = undefined;
      this._compress = undefined;
      this._eventFields = undefined;
      this._eventHost = undefined;
      this._eventIndex = undefined;
      this._eventIndexKey = undefined;
      this._eventKey = undefined;
      this._eventSource = undefined;
      this._eventSourcetype = undefined;
      this._eventSourcetypeKey = undefined;
      this._host = undefined;
      this._httpBufferSize = undefined;
      this._httpDebugBadRequest = undefined;
      this._httpPassword.internalValue = undefined;
      this._httpUser.internalValue = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._splunkSendRaw = undefined;
      this._splunkToken.internalValue = undefined;
      this._tls.internalValue = undefined;
      this._workers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._channel = value.channel;
      this._compress = value.compress;
      this._eventFields = value.eventFields;
      this._eventHost = value.eventHost;
      this._eventIndex = value.eventIndex;
      this._eventIndexKey = value.eventIndexKey;
      this._eventKey = value.eventKey;
      this._eventSource = value.eventSource;
      this._eventSourcetype = value.eventSourcetype;
      this._eventSourcetypeKey = value.eventSourcetypeKey;
      this._host = value.host;
      this._httpBufferSize = value.httpBufferSize;
      this._httpDebugBadRequest = value.httpDebugBadRequest;
      this._httpPassword.internalValue = value.httpPassword;
      this._httpUser.internalValue = value.httpUser;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._splunkSendRaw = value.splunkSendRaw;
      this._splunkToken.internalValue = value.splunkToken;
      this._tls.internalValue = value.tls;
      this._workers = value.workers;
    }
  }

  // channel - computed: false, optional: true, required: false
  private _channel?: string; 
  public get channel() {
    return this.getStringAttribute('channel');
  }
  public set channel(value: string) {
    this._channel = value;
  }
  public resetChannel() {
    this._channel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get channelInput() {
    return this._channel;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // event_fields - computed: false, optional: true, required: false
  private _eventFields?: string[]; 
  public get eventFields() {
    return this.getListAttribute('event_fields');
  }
  public set eventFields(value: string[]) {
    this._eventFields = value;
  }
  public resetEventFields() {
    this._eventFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventFieldsInput() {
    return this._eventFields;
  }

  // event_host - computed: false, optional: true, required: false
  private _eventHost?: string; 
  public get eventHost() {
    return this.getStringAttribute('event_host');
  }
  public set eventHost(value: string) {
    this._eventHost = value;
  }
  public resetEventHost() {
    this._eventHost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventHostInput() {
    return this._eventHost;
  }

  // event_index - computed: false, optional: true, required: false
  private _eventIndex?: string; 
  public get eventIndex() {
    return this.getStringAttribute('event_index');
  }
  public set eventIndex(value: string) {
    this._eventIndex = value;
  }
  public resetEventIndex() {
    this._eventIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventIndexInput() {
    return this._eventIndex;
  }

  // event_index_key - computed: false, optional: true, required: false
  private _eventIndexKey?: string; 
  public get eventIndexKey() {
    return this.getStringAttribute('event_index_key');
  }
  public set eventIndexKey(value: string) {
    this._eventIndexKey = value;
  }
  public resetEventIndexKey() {
    this._eventIndexKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventIndexKeyInput() {
    return this._eventIndexKey;
  }

  // event_key - computed: false, optional: true, required: false
  private _eventKey?: string; 
  public get eventKey() {
    return this.getStringAttribute('event_key');
  }
  public set eventKey(value: string) {
    this._eventKey = value;
  }
  public resetEventKey() {
    this._eventKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventKeyInput() {
    return this._eventKey;
  }

  // event_source - computed: false, optional: true, required: false
  private _eventSource?: string; 
  public get eventSource() {
    return this.getStringAttribute('event_source');
  }
  public set eventSource(value: string) {
    this._eventSource = value;
  }
  public resetEventSource() {
    this._eventSource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventSourceInput() {
    return this._eventSource;
  }

  // event_sourcetype - computed: false, optional: true, required: false
  private _eventSourcetype?: string; 
  public get eventSourcetype() {
    return this.getStringAttribute('event_sourcetype');
  }
  public set eventSourcetype(value: string) {
    this._eventSourcetype = value;
  }
  public resetEventSourcetype() {
    this._eventSourcetype = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventSourcetypeInput() {
    return this._eventSourcetype;
  }

  // event_sourcetype_key - computed: false, optional: true, required: false
  private _eventSourcetypeKey?: string; 
  public get eventSourcetypeKey() {
    return this.getStringAttribute('event_sourcetype_key');
  }
  public set eventSourcetypeKey(value: string) {
    this._eventSourcetypeKey = value;
  }
  public resetEventSourcetypeKey() {
    this._eventSourcetypeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventSourcetypeKeyInput() {
    return this._eventSourcetypeKey;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_buffer_size - computed: false, optional: true, required: false
  private _httpBufferSize?: string; 
  public get httpBufferSize() {
    return this.getStringAttribute('http_buffer_size');
  }
  public set httpBufferSize(value: string) {
    this._httpBufferSize = value;
  }
  public resetHttpBufferSize() {
    this._httpBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpBufferSizeInput() {
    return this._httpBufferSize;
  }

  // http_debug_bad_request - computed: false, optional: true, required: false
  private _httpDebugBadRequest?: boolean | cdktf.IResolvable; 
  public get httpDebugBadRequest() {
    return this.getBooleanAttribute('http_debug_bad_request');
  }
  public set httpDebugBadRequest(value: boolean | cdktf.IResolvable) {
    this._httpDebugBadRequest = value;
  }
  public resetHttpDebugBadRequest() {
    this._httpDebugBadRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpDebugBadRequestInput() {
    return this._httpDebugBadRequest;
  }

  // http_password - computed: false, optional: true, required: false
  private _httpPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPasswordOutputReference(this, "http_password");
  public get httpPassword() {
    return this._httpPassword;
  }
  public putHttpPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpPassword) {
    this._httpPassword.internalValue = value;
  }
  public resetHttpPassword() {
    this._httpPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPasswordInput() {
    return this._httpPassword.internalValue;
  }

  // http_user - computed: false, optional: true, required: false
  private _httpUser = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUserOutputReference(this, "http_user");
  public get httpUser() {
    return this._httpUser;
  }
  public putHttpUser(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkHttpUser) {
    this._httpUser.internalValue = value;
  }
  public resetHttpUser() {
    this._httpUser.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpUserInput() {
    return this._httpUser.internalValue;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // splunk_send_raw - computed: false, optional: true, required: false
  private _splunkSendRaw?: boolean | cdktf.IResolvable; 
  public get splunkSendRaw() {
    return this.getBooleanAttribute('splunk_send_raw');
  }
  public set splunkSendRaw(value: boolean | cdktf.IResolvable) {
    this._splunkSendRaw = value;
  }
  public resetSplunkSendRaw() {
    this._splunkSendRaw = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkSendRawInput() {
    return this._splunkSendRaw;
  }

  // splunk_token - computed: false, optional: true, required: false
  private _splunkToken = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkTokenOutputReference(this, "splunk_token");
  public get splunkToken() {
    return this._splunkToken;
  }
  public putSplunkToken(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkSplunkToken) {
    this._splunkToken.internalValue = value;
  }
  public resetSplunkToken() {
    this._splunkToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkTokenInput() {
    return this._splunkToken.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // workers - computed: false, optional: true, required: false
  private _workers?: number; 
  public get workers() {
    return this.getNumberAttribute('workers');
  }
  public set workers(value: number) {
    this._workers = value;
  }
  public resetWorkers() {
    this._workers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workersInput() {
    return this._workers;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver {
  /**
  * Rewrite the trace field to be formatted for use with GCP Cloud Trace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#autoformat_stackdriver_trace DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#autoformat_stackdriver_trace}
  */
  readonly autoformatStackdriverTrace?: boolean | cdktf.IResolvable;
  /**
  * A custom regex to extract fields from the local_resource_id of the logs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#custom_k8s_regex DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#custom_k8s_regex}
  */
  readonly customK8SRegex?: string;
  /**
  * The GCP Project that should receive the logs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#export_to_project_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#export_to_project_id}
  */
  readonly exportToProjectId?: string;
  /**
  * Path to GCP Credentials JSON file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#google_service_credentials DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#google_service_credentials}
  */
  readonly googleServiceCredentials?: string;
  /**
  * Identifier for a grouping of tasks. Required if Resource is generic_task
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#job DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#job}
  */
  readonly job?: string;
  /**
  * Location of the cluster that contains the pods/nodes. Required if Resource is k8s_container, k8s_node, or k8s_pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#k8s_cluster_location DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#k8s_cluster_location}
  */
  readonly k8SClusterLocation?: string;
  /**
  * Name of the cluster that the pod is running in. Required if Resource is k8s_container, k8s_node, or k8s_pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#k8s_cluster_name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#k8s_cluster_name}
  */
  readonly k8SClusterName?: string;
  /**
  * Optional list of comma separated of strings for key/value pairs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#labels}
  */
  readonly labels?: string[];
  /**
  * Used by Stackdriver to find related labels and extract them to LogEntry Labels
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#labels_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#labels_key}
  */
  readonly labelsKey?: string;
  /**
  * GCP/AWS region to store data. Required if Resource is generic_node or generic_task
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#location DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#location}
  */
  readonly location?: string;
  /**
  * The value of this field is set as the logName field in Stackdriver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_name_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_name_key}
  */
  readonly logNameKey?: string;
  /**
  * Metadata Server Prefix
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#metadata_server DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#metadata_server}
  */
  readonly metadataServer?: string;
  /**
  * Namespace identifier. Required if Resource is generic_node or generic_task
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#namespace DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Node identifier within the namespace. Required if Resource is generic_node or generic_task
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#node_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#node_id}
  */
  readonly nodeId?: string;
  /**
  * Set resource types of data
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#resource DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#resource}
  */
  readonly resource?: string;
  /**
  * Optional list of comma seperated strings. Setting these fields overrides the Stackdriver monitored resource API values
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#resource_labels DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#resource_labels}
  */
  readonly resourceLabels?: string[];
  /**
  * Email associated with the service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#service_account_email DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#service_account_email}
  */
  readonly serviceAccountEmail?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail;
  /**
  * Private Key associated with the service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#service_account_secret DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#service_account_secret}
  */
  readonly serviceAccountSecret?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret;
  /**
  * Specify the key that contains the severity information for the logs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#severity_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#severity_key}
  */
  readonly severityKey?: string;
  /**
  * Used to validate the tags of logs that when the Resource is k8s_container, k8s_node, or k8s_pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tag_prefix DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tag_prefix}
  */
  readonly tagPrefix?: string;
  /**
  * Identifier for a task within a namespace. Required if Resource is generic_task
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#task_id DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#task_id}
  */
  readonly taskId?: string;
  /**
  * Number of dedicated threads for the Stackdriver Output Plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#workers DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#workers}
  */
  readonly workers?: number;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    autoformat_stackdriver_trace: cdktf.booleanToTerraform(struct!.autoformatStackdriverTrace),
    custom_k8s_regex: cdktf.stringToTerraform(struct!.customK8SRegex),
    export_to_project_id: cdktf.stringToTerraform(struct!.exportToProjectId),
    google_service_credentials: cdktf.stringToTerraform(struct!.googleServiceCredentials),
    job: cdktf.stringToTerraform(struct!.job),
    k8s_cluster_location: cdktf.stringToTerraform(struct!.k8SClusterLocation),
    k8s_cluster_name: cdktf.stringToTerraform(struct!.k8SClusterName),
    labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.labels),
    labels_key: cdktf.stringToTerraform(struct!.labelsKey),
    location: cdktf.stringToTerraform(struct!.location),
    log_name_key: cdktf.stringToTerraform(struct!.logNameKey),
    metadata_server: cdktf.stringToTerraform(struct!.metadataServer),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    node_id: cdktf.stringToTerraform(struct!.nodeId),
    resource: cdktf.stringToTerraform(struct!.resource),
    resource_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.resourceLabels),
    service_account_email: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailToTerraform(struct!.serviceAccountEmail),
    service_account_secret: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretToTerraform(struct!.serviceAccountSecret),
    severity_key: cdktf.stringToTerraform(struct!.severityKey),
    tag_prefix: cdktf.stringToTerraform(struct!.tagPrefix),
    task_id: cdktf.stringToTerraform(struct!.taskId),
    workers: cdktf.numberToTerraform(struct!.workers),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    autoformat_stackdriver_trace: {
      value: cdktf.booleanToHclTerraform(struct!.autoformatStackdriverTrace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    custom_k8s_regex: {
      value: cdktf.stringToHclTerraform(struct!.customK8SRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    export_to_project_id: {
      value: cdktf.stringToHclTerraform(struct!.exportToProjectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    google_service_credentials: {
      value: cdktf.stringToHclTerraform(struct!.googleServiceCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    job: {
      value: cdktf.stringToHclTerraform(struct!.job),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    k8s_cluster_location: {
      value: cdktf.stringToHclTerraform(struct!.k8SClusterLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    k8s_cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.k8SClusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.labels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    labels_key: {
      value: cdktf.stringToHclTerraform(struct!.labelsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_name_key: {
      value: cdktf.stringToHclTerraform(struct!.logNameKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_server: {
      value: cdktf.stringToHclTerraform(struct!.metadataServer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_id: {
      value: cdktf.stringToHclTerraform(struct!.nodeId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.resourceLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_account_email: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailToHclTerraform(struct!.serviceAccountEmail),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail",
    },
    service_account_secret: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretToHclTerraform(struct!.serviceAccountSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret",
    },
    severity_key: {
      value: cdktf.stringToHclTerraform(struct!.severityKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag_prefix: {
      value: cdktf.stringToHclTerraform(struct!.tagPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_id: {
      value: cdktf.stringToHclTerraform(struct!.taskId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workers: {
      value: cdktf.numberToHclTerraform(struct!.workers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoformatStackdriverTrace !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoformatStackdriverTrace = this._autoformatStackdriverTrace;
    }
    if (this._customK8SRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.customK8SRegex = this._customK8SRegex;
    }
    if (this._exportToProjectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.exportToProjectId = this._exportToProjectId;
    }
    if (this._googleServiceCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleServiceCredentials = this._googleServiceCredentials;
    }
    if (this._job !== undefined) {
      hasAnyValues = true;
      internalValueResult.job = this._job;
    }
    if (this._k8SClusterLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.k8SClusterLocation = this._k8SClusterLocation;
    }
    if (this._k8SClusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.k8SClusterName = this._k8SClusterName;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._labelsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelsKey = this._labelsKey;
    }
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    if (this._logNameKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.logNameKey = this._logNameKey;
    }
    if (this._metadataServer !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataServer = this._metadataServer;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._nodeId !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeId = this._nodeId;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    if (this._resourceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceLabels = this._resourceLabels;
    }
    if (this._serviceAccountEmail?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountEmail = this._serviceAccountEmail?.internalValue;
    }
    if (this._serviceAccountSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountSecret = this._serviceAccountSecret?.internalValue;
    }
    if (this._severityKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.severityKey = this._severityKey;
    }
    if (this._tagPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagPrefix = this._tagPrefix;
    }
    if (this._taskId !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskId = this._taskId;
    }
    if (this._workers !== undefined) {
      hasAnyValues = true;
      internalValueResult.workers = this._workers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoformatStackdriverTrace = undefined;
      this._customK8SRegex = undefined;
      this._exportToProjectId = undefined;
      this._googleServiceCredentials = undefined;
      this._job = undefined;
      this._k8SClusterLocation = undefined;
      this._k8SClusterName = undefined;
      this._labels = undefined;
      this._labelsKey = undefined;
      this._location = undefined;
      this._logNameKey = undefined;
      this._metadataServer = undefined;
      this._namespace = undefined;
      this._nodeId = undefined;
      this._resource = undefined;
      this._resourceLabels = undefined;
      this._serviceAccountEmail.internalValue = undefined;
      this._serviceAccountSecret.internalValue = undefined;
      this._severityKey = undefined;
      this._tagPrefix = undefined;
      this._taskId = undefined;
      this._workers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoformatStackdriverTrace = value.autoformatStackdriverTrace;
      this._customK8SRegex = value.customK8SRegex;
      this._exportToProjectId = value.exportToProjectId;
      this._googleServiceCredentials = value.googleServiceCredentials;
      this._job = value.job;
      this._k8SClusterLocation = value.k8SClusterLocation;
      this._k8SClusterName = value.k8SClusterName;
      this._labels = value.labels;
      this._labelsKey = value.labelsKey;
      this._location = value.location;
      this._logNameKey = value.logNameKey;
      this._metadataServer = value.metadataServer;
      this._namespace = value.namespace;
      this._nodeId = value.nodeId;
      this._resource = value.resource;
      this._resourceLabels = value.resourceLabels;
      this._serviceAccountEmail.internalValue = value.serviceAccountEmail;
      this._serviceAccountSecret.internalValue = value.serviceAccountSecret;
      this._severityKey = value.severityKey;
      this._tagPrefix = value.tagPrefix;
      this._taskId = value.taskId;
      this._workers = value.workers;
    }
  }

  // autoformat_stackdriver_trace - computed: false, optional: true, required: false
  private _autoformatStackdriverTrace?: boolean | cdktf.IResolvable; 
  public get autoformatStackdriverTrace() {
    return this.getBooleanAttribute('autoformat_stackdriver_trace');
  }
  public set autoformatStackdriverTrace(value: boolean | cdktf.IResolvable) {
    this._autoformatStackdriverTrace = value;
  }
  public resetAutoformatStackdriverTrace() {
    this._autoformatStackdriverTrace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoformatStackdriverTraceInput() {
    return this._autoformatStackdriverTrace;
  }

  // custom_k8s_regex - computed: false, optional: true, required: false
  private _customK8SRegex?: string; 
  public get customK8SRegex() {
    return this.getStringAttribute('custom_k8s_regex');
  }
  public set customK8SRegex(value: string) {
    this._customK8SRegex = value;
  }
  public resetCustomK8SRegex() {
    this._customK8SRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customK8SRegexInput() {
    return this._customK8SRegex;
  }

  // export_to_project_id - computed: false, optional: true, required: false
  private _exportToProjectId?: string; 
  public get exportToProjectId() {
    return this.getStringAttribute('export_to_project_id');
  }
  public set exportToProjectId(value: string) {
    this._exportToProjectId = value;
  }
  public resetExportToProjectId() {
    this._exportToProjectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exportToProjectIdInput() {
    return this._exportToProjectId;
  }

  // google_service_credentials - computed: false, optional: true, required: false
  private _googleServiceCredentials?: string; 
  public get googleServiceCredentials() {
    return this.getStringAttribute('google_service_credentials');
  }
  public set googleServiceCredentials(value: string) {
    this._googleServiceCredentials = value;
  }
  public resetGoogleServiceCredentials() {
    this._googleServiceCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleServiceCredentialsInput() {
    return this._googleServiceCredentials;
  }

  // job - computed: false, optional: true, required: false
  private _job?: string; 
  public get job() {
    return this.getStringAttribute('job');
  }
  public set job(value: string) {
    this._job = value;
  }
  public resetJob() {
    this._job = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobInput() {
    return this._job;
  }

  // k8s_cluster_location - computed: false, optional: true, required: false
  private _k8SClusterLocation?: string; 
  public get k8SClusterLocation() {
    return this.getStringAttribute('k8s_cluster_location');
  }
  public set k8SClusterLocation(value: string) {
    this._k8SClusterLocation = value;
  }
  public resetK8SClusterLocation() {
    this._k8SClusterLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get k8SClusterLocationInput() {
    return this._k8SClusterLocation;
  }

  // k8s_cluster_name - computed: false, optional: true, required: false
  private _k8SClusterName?: string; 
  public get k8SClusterName() {
    return this.getStringAttribute('k8s_cluster_name');
  }
  public set k8SClusterName(value: string) {
    this._k8SClusterName = value;
  }
  public resetK8SClusterName() {
    this._k8SClusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get k8SClusterNameInput() {
    return this._k8SClusterName;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string[]; 
  public get labels() {
    return this.getListAttribute('labels');
  }
  public set labels(value: string[]) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // labels_key - computed: false, optional: true, required: false
  private _labelsKey?: string; 
  public get labelsKey() {
    return this.getStringAttribute('labels_key');
  }
  public set labelsKey(value: string) {
    this._labelsKey = value;
  }
  public resetLabelsKey() {
    this._labelsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsKeyInput() {
    return this._labelsKey;
  }

  // location - computed: false, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }

  // log_name_key - computed: false, optional: true, required: false
  private _logNameKey?: string; 
  public get logNameKey() {
    return this.getStringAttribute('log_name_key');
  }
  public set logNameKey(value: string) {
    this._logNameKey = value;
  }
  public resetLogNameKey() {
    this._logNameKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logNameKeyInput() {
    return this._logNameKey;
  }

  // metadata_server - computed: false, optional: true, required: false
  private _metadataServer?: string; 
  public get metadataServer() {
    return this.getStringAttribute('metadata_server');
  }
  public set metadataServer(value: string) {
    this._metadataServer = value;
  }
  public resetMetadataServer() {
    this._metadataServer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataServerInput() {
    return this._metadataServer;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // node_id - computed: false, optional: true, required: false
  private _nodeId?: string; 
  public get nodeId() {
    return this.getStringAttribute('node_id');
  }
  public set nodeId(value: string) {
    this._nodeId = value;
  }
  public resetNodeId() {
    this._nodeId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeIdInput() {
    return this._nodeId;
  }

  // resource - computed: false, optional: true, required: false
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }

  // resource_labels - computed: false, optional: true, required: false
  private _resourceLabels?: string[]; 
  public get resourceLabels() {
    return this.getListAttribute('resource_labels');
  }
  public set resourceLabels(value: string[]) {
    this._resourceLabels = value;
  }
  public resetResourceLabels() {
    this._resourceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceLabelsInput() {
    return this._resourceLabels;
  }

  // service_account_email - computed: false, optional: true, required: false
  private _serviceAccountEmail = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmailOutputReference(this, "service_account_email");
  public get serviceAccountEmail() {
    return this._serviceAccountEmail;
  }
  public putServiceAccountEmail(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountEmail) {
    this._serviceAccountEmail.internalValue = value;
  }
  public resetServiceAccountEmail() {
    this._serviceAccountEmail.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountEmailInput() {
    return this._serviceAccountEmail.internalValue;
  }

  // service_account_secret - computed: false, optional: true, required: false
  private _serviceAccountSecret = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecretOutputReference(this, "service_account_secret");
  public get serviceAccountSecret() {
    return this._serviceAccountSecret;
  }
  public putServiceAccountSecret(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverServiceAccountSecret) {
    this._serviceAccountSecret.internalValue = value;
  }
  public resetServiceAccountSecret() {
    this._serviceAccountSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountSecretInput() {
    return this._serviceAccountSecret.internalValue;
  }

  // severity_key - computed: false, optional: true, required: false
  private _severityKey?: string; 
  public get severityKey() {
    return this.getStringAttribute('severity_key');
  }
  public set severityKey(value: string) {
    this._severityKey = value;
  }
  public resetSeverityKey() {
    this._severityKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityKeyInput() {
    return this._severityKey;
  }

  // tag_prefix - computed: false, optional: true, required: false
  private _tagPrefix?: string; 
  public get tagPrefix() {
    return this.getStringAttribute('tag_prefix');
  }
  public set tagPrefix(value: string) {
    this._tagPrefix = value;
  }
  public resetTagPrefix() {
    this._tagPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagPrefixInput() {
    return this._tagPrefix;
  }

  // task_id - computed: false, optional: true, required: false
  private _taskId?: string; 
  public get taskId() {
    return this.getStringAttribute('task_id');
  }
  public set taskId(value: string) {
    this._taskId = value;
  }
  public resetTaskId() {
    this._taskId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskIdInput() {
    return this._taskId;
  }

  // workers - computed: false, optional: true, required: false
  private _workers?: number; 
  public get workers() {
    return this.getNumberAttribute('workers');
  }
  public set workers(value: number) {
    this._workers = value;
  }
  public resetWorkers() {
    this._workers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workersInput() {
    return this._workers;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout {
  /**
  * Specify the data format to be printed. Supported formats are msgpack json, json_lines and json_stream.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#format}
  */
  readonly format?: string;
  /**
  * Specify the format of the date. Supported formats are double, iso8601 (eg: 2018-05-30T09:39:52.000681Z) and epoch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_format}
  */
  readonly jsonDateFormat?: string;
  /**
  * Specify the name of the date field in output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_key}
  */
  readonly jsonDateKey?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdoutToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: cdktf.stringToTerraform(struct!.format),
    json_date_format: cdktf.stringToTerraform(struct!.jsonDateFormat),
    json_date_key: cdktf.stringToTerraform(struct!.jsonDateKey),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdoutToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_format: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_key: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdoutOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._jsonDateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateFormat = this._jsonDateFormat;
    }
    if (this._jsonDateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateKey = this._jsonDateKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format = undefined;
      this._jsonDateFormat = undefined;
      this._jsonDateKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format = value.format;
      this._jsonDateFormat = value.jsonDateFormat;
      this._jsonDateKey = value.jsonDateKey;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // json_date_format - computed: false, optional: true, required: false
  private _jsonDateFormat?: string; 
  public get jsonDateFormat() {
    return this.getStringAttribute('json_date_format');
  }
  public set jsonDateFormat(value: string) {
    this._jsonDateFormat = value;
  }
  public resetJsonDateFormat() {
    this._jsonDateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateFormatInput() {
    return this._jsonDateFormat;
  }

  // json_date_key - computed: false, optional: true, required: false
  private _jsonDateKey?: string; 
  public get jsonDateKey() {
    return this.getStringAttribute('json_date_key');
  }
  public set jsonDateKey(value: string) {
    this._jsonDateKey = value;
  }
  public resetJsonDateKey() {
    this._jsonDateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateKeyInput() {
    return this._jsonDateKey;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog {
  /**
  * Host domain or IP address of the remote Syslog server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Mode of the desired transport type, the available options are tcp, tls and udp.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking;
  /**
  * TCP or UDP port of the remote Syslog server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Key name from the original record that contains the application name that generated the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_appname_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_appname_key}
  */
  readonly syslogAppnameKey?: string;
  /**
  * Key from the original record that contains the Syslog facility number.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_facility_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_facility_key}
  */
  readonly syslogFacilityKey?: string;
  /**
  * Syslog protocol format to use, the available options are rfc3164 and rfc5424.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_format}
  */
  readonly syslogFormat?: string;
  /**
  * Key name from the original record that contains the hostname that generated the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_hostname_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_hostname_key}
  */
  readonly syslogHostnameKey?: string;
  /**
  * Maximum size allowed per message, in bytes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_max_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_max_size}
  */
  readonly syslogMaxSize?: number;
  /**
  * Key name from the original record that contains the Message ID associated to the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_message_id_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_message_id_key}
  */
  readonly syslogMessageIdKey?: string;
  /**
  * Key key name that contains the message to deliver.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_message_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_message_key}
  */
  readonly syslogMessageKey?: string;
  /**
  * Key name from the original record that contains the Process ID that generated the message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_process_id_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_process_id_key}
  */
  readonly syslogProcessIdKey?: string;
  /**
  * Key name from the original record that contains the Structured Data (SD) content.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_sd_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_sd_key}
  */
  readonly syslogSdKey?: string;
  /**
  * Key from the original record that contains the Syslog severity number.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog_severity_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog_severity_key}
  */
  readonly syslogSeverityKey?: string;
  /**
  * Syslog output plugin supports TTL/SSL, for more details about the properties available and general configuration, please refer to the TLS/SSL section.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls;
  /**
  * Limit the maximum number of Chunks in the filesystem for the current output logical destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#total_limit_size DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#total_limit_size}
  */
  readonly totalLimitSize?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    mode: cdktf.stringToTerraform(struct!.mode),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    syslog_appname_key: cdktf.stringToTerraform(struct!.syslogAppnameKey),
    syslog_facility_key: cdktf.stringToTerraform(struct!.syslogFacilityKey),
    syslog_format: cdktf.stringToTerraform(struct!.syslogFormat),
    syslog_hostname_key: cdktf.stringToTerraform(struct!.syslogHostnameKey),
    syslog_max_size: cdktf.numberToTerraform(struct!.syslogMaxSize),
    syslog_message_id_key: cdktf.stringToTerraform(struct!.syslogMessageIdKey),
    syslog_message_key: cdktf.stringToTerraform(struct!.syslogMessageKey),
    syslog_process_id_key: cdktf.stringToTerraform(struct!.syslogProcessIdKey),
    syslog_sd_key: cdktf.stringToTerraform(struct!.syslogSdKey),
    syslog_severity_key: cdktf.stringToTerraform(struct!.syslogSeverityKey),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsToTerraform(struct!.tls),
    total_limit_size: cdktf.stringToTerraform(struct!.totalLimitSize),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    syslog_appname_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogAppnameKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_facility_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogFacilityKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_format: {
      value: cdktf.stringToHclTerraform(struct!.syslogFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_hostname_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogHostnameKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_max_size: {
      value: cdktf.numberToHclTerraform(struct!.syslogMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    syslog_message_id_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogMessageIdKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_message_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogMessageKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_process_id_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogProcessIdKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_sd_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogSdKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    syslog_severity_key: {
      value: cdktf.stringToHclTerraform(struct!.syslogSeverityKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls",
    },
    total_limit_size: {
      value: cdktf.stringToHclTerraform(struct!.totalLimitSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._syslogAppnameKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogAppnameKey = this._syslogAppnameKey;
    }
    if (this._syslogFacilityKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogFacilityKey = this._syslogFacilityKey;
    }
    if (this._syslogFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogFormat = this._syslogFormat;
    }
    if (this._syslogHostnameKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogHostnameKey = this._syslogHostnameKey;
    }
    if (this._syslogMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogMaxSize = this._syslogMaxSize;
    }
    if (this._syslogMessageIdKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogMessageIdKey = this._syslogMessageIdKey;
    }
    if (this._syslogMessageKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogMessageKey = this._syslogMessageKey;
    }
    if (this._syslogProcessIdKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogProcessIdKey = this._syslogProcessIdKey;
    }
    if (this._syslogSdKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogSdKey = this._syslogSdKey;
    }
    if (this._syslogSeverityKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslogSeverityKey = this._syslogSeverityKey;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._totalLimitSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalLimitSize = this._totalLimitSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._mode = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._syslogAppnameKey = undefined;
      this._syslogFacilityKey = undefined;
      this._syslogFormat = undefined;
      this._syslogHostnameKey = undefined;
      this._syslogMaxSize = undefined;
      this._syslogMessageIdKey = undefined;
      this._syslogMessageKey = undefined;
      this._syslogProcessIdKey = undefined;
      this._syslogSdKey = undefined;
      this._syslogSeverityKey = undefined;
      this._tls.internalValue = undefined;
      this._totalLimitSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._mode = value.mode;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._syslogAppnameKey = value.syslogAppnameKey;
      this._syslogFacilityKey = value.syslogFacilityKey;
      this._syslogFormat = value.syslogFormat;
      this._syslogHostnameKey = value.syslogHostnameKey;
      this._syslogMaxSize = value.syslogMaxSize;
      this._syslogMessageIdKey = value.syslogMessageIdKey;
      this._syslogMessageKey = value.syslogMessageKey;
      this._syslogProcessIdKey = value.syslogProcessIdKey;
      this._syslogSdKey = value.syslogSdKey;
      this._syslogSeverityKey = value.syslogSeverityKey;
      this._tls.internalValue = value.tls;
      this._totalLimitSize = value.totalLimitSize;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // syslog_appname_key - computed: false, optional: true, required: false
  private _syslogAppnameKey?: string; 
  public get syslogAppnameKey() {
    return this.getStringAttribute('syslog_appname_key');
  }
  public set syslogAppnameKey(value: string) {
    this._syslogAppnameKey = value;
  }
  public resetSyslogAppnameKey() {
    this._syslogAppnameKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogAppnameKeyInput() {
    return this._syslogAppnameKey;
  }

  // syslog_facility_key - computed: false, optional: true, required: false
  private _syslogFacilityKey?: string; 
  public get syslogFacilityKey() {
    return this.getStringAttribute('syslog_facility_key');
  }
  public set syslogFacilityKey(value: string) {
    this._syslogFacilityKey = value;
  }
  public resetSyslogFacilityKey() {
    this._syslogFacilityKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogFacilityKeyInput() {
    return this._syslogFacilityKey;
  }

  // syslog_format - computed: false, optional: true, required: false
  private _syslogFormat?: string; 
  public get syslogFormat() {
    return this.getStringAttribute('syslog_format');
  }
  public set syslogFormat(value: string) {
    this._syslogFormat = value;
  }
  public resetSyslogFormat() {
    this._syslogFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogFormatInput() {
    return this._syslogFormat;
  }

  // syslog_hostname_key - computed: false, optional: true, required: false
  private _syslogHostnameKey?: string; 
  public get syslogHostnameKey() {
    return this.getStringAttribute('syslog_hostname_key');
  }
  public set syslogHostnameKey(value: string) {
    this._syslogHostnameKey = value;
  }
  public resetSyslogHostnameKey() {
    this._syslogHostnameKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogHostnameKeyInput() {
    return this._syslogHostnameKey;
  }

  // syslog_max_size - computed: false, optional: true, required: false
  private _syslogMaxSize?: number; 
  public get syslogMaxSize() {
    return this.getNumberAttribute('syslog_max_size');
  }
  public set syslogMaxSize(value: number) {
    this._syslogMaxSize = value;
  }
  public resetSyslogMaxSize() {
    this._syslogMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogMaxSizeInput() {
    return this._syslogMaxSize;
  }

  // syslog_message_id_key - computed: false, optional: true, required: false
  private _syslogMessageIdKey?: string; 
  public get syslogMessageIdKey() {
    return this.getStringAttribute('syslog_message_id_key');
  }
  public set syslogMessageIdKey(value: string) {
    this._syslogMessageIdKey = value;
  }
  public resetSyslogMessageIdKey() {
    this._syslogMessageIdKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogMessageIdKeyInput() {
    return this._syslogMessageIdKey;
  }

  // syslog_message_key - computed: false, optional: true, required: false
  private _syslogMessageKey?: string; 
  public get syslogMessageKey() {
    return this.getStringAttribute('syslog_message_key');
  }
  public set syslogMessageKey(value: string) {
    this._syslogMessageKey = value;
  }
  public resetSyslogMessageKey() {
    this._syslogMessageKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogMessageKeyInput() {
    return this._syslogMessageKey;
  }

  // syslog_process_id_key - computed: false, optional: true, required: false
  private _syslogProcessIdKey?: string; 
  public get syslogProcessIdKey() {
    return this.getStringAttribute('syslog_process_id_key');
  }
  public set syslogProcessIdKey(value: string) {
    this._syslogProcessIdKey = value;
  }
  public resetSyslogProcessIdKey() {
    this._syslogProcessIdKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogProcessIdKeyInput() {
    return this._syslogProcessIdKey;
  }

  // syslog_sd_key - computed: false, optional: true, required: false
  private _syslogSdKey?: string; 
  public get syslogSdKey() {
    return this.getStringAttribute('syslog_sd_key');
  }
  public set syslogSdKey(value: string) {
    this._syslogSdKey = value;
  }
  public resetSyslogSdKey() {
    this._syslogSdKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogSdKeyInput() {
    return this._syslogSdKey;
  }

  // syslog_severity_key - computed: false, optional: true, required: false
  private _syslogSeverityKey?: string; 
  public get syslogSeverityKey() {
    return this.getStringAttribute('syslog_severity_key');
  }
  public set syslogSeverityKey(value: string) {
    this._syslogSeverityKey = value;
  }
  public resetSyslogSeverityKey() {
    this._syslogSeverityKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogSeverityKeyInput() {
    return this._syslogSeverityKey;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // total_limit_size - computed: false, optional: true, required: false
  private _totalLimitSize?: string; 
  public get totalLimitSize() {
    return this.getStringAttribute('total_limit_size');
  }
  public set totalLimitSize(value: string) {
    this._totalLimitSize = value;
  }
  public resetTotalLimitSize() {
    this._totalLimitSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalLimitSizeInput() {
    return this._totalLimitSize;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking {
  /**
  * Set maximum time expressed in seconds to wait for a TCP connection to be established, this include the TLS handshake time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout}
  */
  readonly connectTimeout?: number;
  /**
  * On connection timeout, specify if it should log an error. When disabled, the timeout is logged as a debug message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#connect_timeout_log_error DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#connect_timeout_log_error}
  */
  readonly connectTimeoutLogError?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS connection type (TCP or UDP).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_mode DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_mode}
  */
  readonly dnsMode?: string;
  /**
  * Prioritize IPv4 DNS results when trying to establish a connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_prefer_i_pv4 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_prefer_i_pv4}
  */
  readonly dnsPreferIPv4?: boolean | cdktf.IResolvable;
  /**
  * Select the primary DNS resolver type (LEGACY or ASYNC).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#dns_resolver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#dns_resolver}
  */
  readonly dnsResolver?: string;
  /**
  * Enable or disable connection keepalive support. Accepts a boolean value: on / off.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive}
  */
  readonly keepalive?: string;
  /**
  * Set maximum time expressed in seconds for an idle keepalive connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_idle_timeout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_idle_timeout}
  */
  readonly keepaliveIdleTimeout?: number;
  /**
  * Set maximum number of times a keepalive connection can be used before it is retired.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#keepalive_max_recycle DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#keepalive_max_recycle}
  */
  readonly keepaliveMaxRecycle?: number;
  /**
  * Set maximum number of TCP connections that can be established per worker.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#max_worker_connections DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#max_worker_connections}
  */
  readonly maxWorkerConnections?: number;
  /**
  * Specify network address to bind for data traffic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#source_address DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#source_address}
  */
  readonly sourceAddress?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworkingToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_timeout: cdktf.numberToTerraform(struct!.connectTimeout),
    connect_timeout_log_error: cdktf.booleanToTerraform(struct!.connectTimeoutLogError),
    dns_mode: cdktf.stringToTerraform(struct!.dnsMode),
    dns_prefer_i_pv4: cdktf.booleanToTerraform(struct!.dnsPreferIPv4),
    dns_resolver: cdktf.stringToTerraform(struct!.dnsResolver),
    keepalive: cdktf.stringToTerraform(struct!.keepalive),
    keepalive_idle_timeout: cdktf.numberToTerraform(struct!.keepaliveIdleTimeout),
    keepalive_max_recycle: cdktf.numberToTerraform(struct!.keepaliveMaxRecycle),
    max_worker_connections: cdktf.numberToTerraform(struct!.maxWorkerConnections),
    source_address: cdktf.stringToTerraform(struct!.sourceAddress),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworkingToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connect_timeout_log_error: {
      value: cdktf.booleanToHclTerraform(struct!.connectTimeoutLogError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_mode: {
      value: cdktf.stringToHclTerraform(struct!.dnsMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_prefer_i_pv4: {
      value: cdktf.booleanToHclTerraform(struct!.dnsPreferIPv4),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns_resolver: {
      value: cdktf.stringToHclTerraform(struct!.dnsResolver),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive: {
      value: cdktf.stringToHclTerraform(struct!.keepalive),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_max_recycle: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveMaxRecycle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    source_address: {
      value: cdktf.stringToHclTerraform(struct!.sourceAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworkingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._connectTimeoutLogError !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeoutLogError = this._connectTimeoutLogError;
    }
    if (this._dnsMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsMode = this._dnsMode;
    }
    if (this._dnsPreferIPv4 !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPreferIPv4 = this._dnsPreferIPv4;
    }
    if (this._dnsResolver !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolver = this._dnsResolver;
    }
    if (this._keepalive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepalive = this._keepalive;
    }
    if (this._keepaliveIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveIdleTimeout = this._keepaliveIdleTimeout;
    }
    if (this._keepaliveMaxRecycle !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveMaxRecycle = this._keepaliveMaxRecycle;
    }
    if (this._maxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxWorkerConnections = this._maxWorkerConnections;
    }
    if (this._sourceAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceAddress = this._sourceAddress;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTimeout = undefined;
      this._connectTimeoutLogError = undefined;
      this._dnsMode = undefined;
      this._dnsPreferIPv4 = undefined;
      this._dnsResolver = undefined;
      this._keepalive = undefined;
      this._keepaliveIdleTimeout = undefined;
      this._keepaliveMaxRecycle = undefined;
      this._maxWorkerConnections = undefined;
      this._sourceAddress = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTimeout = value.connectTimeout;
      this._connectTimeoutLogError = value.connectTimeoutLogError;
      this._dnsMode = value.dnsMode;
      this._dnsPreferIPv4 = value.dnsPreferIPv4;
      this._dnsResolver = value.dnsResolver;
      this._keepalive = value.keepalive;
      this._keepaliveIdleTimeout = value.keepaliveIdleTimeout;
      this._keepaliveMaxRecycle = value.keepaliveMaxRecycle;
      this._maxWorkerConnections = value.maxWorkerConnections;
      this._sourceAddress = value.sourceAddress;
    }
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: number; 
  public get connectTimeout() {
    return this.getNumberAttribute('connect_timeout');
  }
  public set connectTimeout(value: number) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // connect_timeout_log_error - computed: false, optional: true, required: false
  private _connectTimeoutLogError?: boolean | cdktf.IResolvable; 
  public get connectTimeoutLogError() {
    return this.getBooleanAttribute('connect_timeout_log_error');
  }
  public set connectTimeoutLogError(value: boolean | cdktf.IResolvable) {
    this._connectTimeoutLogError = value;
  }
  public resetConnectTimeoutLogError() {
    this._connectTimeoutLogError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutLogErrorInput() {
    return this._connectTimeoutLogError;
  }

  // dns_mode - computed: false, optional: true, required: false
  private _dnsMode?: string; 
  public get dnsMode() {
    return this.getStringAttribute('dns_mode');
  }
  public set dnsMode(value: string) {
    this._dnsMode = value;
  }
  public resetDnsMode() {
    this._dnsMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsModeInput() {
    return this._dnsMode;
  }

  // dns_prefer_i_pv4 - computed: false, optional: true, required: false
  private _dnsPreferIPv4?: boolean | cdktf.IResolvable; 
  public get dnsPreferIPv4() {
    return this.getBooleanAttribute('dns_prefer_i_pv4');
  }
  public set dnsPreferIPv4(value: boolean | cdktf.IResolvable) {
    this._dnsPreferIPv4 = value;
  }
  public resetDnsPreferIPv4() {
    this._dnsPreferIPv4 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPreferIPv4Input() {
    return this._dnsPreferIPv4;
  }

  // dns_resolver - computed: false, optional: true, required: false
  private _dnsResolver?: string; 
  public get dnsResolver() {
    return this.getStringAttribute('dns_resolver');
  }
  public set dnsResolver(value: string) {
    this._dnsResolver = value;
  }
  public resetDnsResolver() {
    this._dnsResolver = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverInput() {
    return this._dnsResolver;
  }

  // keepalive - computed: false, optional: true, required: false
  private _keepalive?: string; 
  public get keepalive() {
    return this.getStringAttribute('keepalive');
  }
  public set keepalive(value: string) {
    this._keepalive = value;
  }
  public resetKeepalive() {
    this._keepalive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveInput() {
    return this._keepalive;
  }

  // keepalive_idle_timeout - computed: false, optional: true, required: false
  private _keepaliveIdleTimeout?: number; 
  public get keepaliveIdleTimeout() {
    return this.getNumberAttribute('keepalive_idle_timeout');
  }
  public set keepaliveIdleTimeout(value: number) {
    this._keepaliveIdleTimeout = value;
  }
  public resetKeepaliveIdleTimeout() {
    this._keepaliveIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIdleTimeoutInput() {
    return this._keepaliveIdleTimeout;
  }

  // keepalive_max_recycle - computed: false, optional: true, required: false
  private _keepaliveMaxRecycle?: number; 
  public get keepaliveMaxRecycle() {
    return this.getNumberAttribute('keepalive_max_recycle');
  }
  public set keepaliveMaxRecycle(value: number) {
    this._keepaliveMaxRecycle = value;
  }
  public resetKeepaliveMaxRecycle() {
    this._keepaliveMaxRecycle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveMaxRecycleInput() {
    return this._keepaliveMaxRecycle;
  }

  // max_worker_connections - computed: false, optional: true, required: false
  private _maxWorkerConnections?: number; 
  public get maxWorkerConnections() {
    return this.getNumberAttribute('max_worker_connections');
  }
  public set maxWorkerConnections(value: number) {
    this._maxWorkerConnections = value;
  }
  public resetMaxWorkerConnections() {
    this._maxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxWorkerConnectionsInput() {
    return this._maxWorkerConnections;
  }

  // source_address - computed: false, optional: true, required: false
  private _sourceAddress?: string; 
  public get sourceAddress() {
    return this.getStringAttribute('source_address');
  }
  public set sourceAddress(value: string) {
    this._sourceAddress = value;
  }
  public resetSourceAddress() {
    this._sourceAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceAddressInput() {
    return this._sourceAddress;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#name DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#optional DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom {
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#secret_key_ref DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_key_ref: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_key_ref: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword {
  /**
  * ValueSource defines how to find a value's key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#value_from DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#value_from}
  */
  readonly valueFrom?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value_from: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value_from: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls {
  /**
  * Absolute path to CA certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_file}
  */
  readonly caFile?: string;
  /**
  * Absolute path to scan for certificate files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#ca_path DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#ca_path}
  */
  readonly caPath?: string;
  /**
  * Absolute path to Certificate file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#crt_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#crt_file}
  */
  readonly crtFile?: string;
  /**
  * Set TLS debug verbosity level. It accept the following values: 0 (No debug), 1 (Error), 2 (State change), 3 (Informational) and 4 Verbose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#debug DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#debug}
  */
  readonly debug?: number;
  /**
  * Absolute path to private Key file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_file}
  */
  readonly keyFile?: string;
  /**
  * Optional password for tls.key_file file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#key_password DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#key_password}
  */
  readonly keyPassword?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword;
  /**
  * Force certificate validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#verify DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#verify}
  */
  readonly verify?: boolean | cdktf.IResolvable;
  /**
  * Hostname to be used for TLS SNI extension
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#vhost DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#vhost}
  */
  readonly vhost?: string;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_file: cdktf.stringToTerraform(struct!.caFile),
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    crt_file: cdktf.stringToTerraform(struct!.crtFile),
    debug: cdktf.numberToTerraform(struct!.debug),
    key_file: cdktf.stringToTerraform(struct!.keyFile),
    key_password: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordToTerraform(struct!.keyPassword),
    verify: cdktf.booleanToTerraform(struct!.verify),
    vhost: cdktf.stringToTerraform(struct!.vhost),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_file: {
      value: cdktf.stringToHclTerraform(struct!.caFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    crt_file: {
      value: cdktf.stringToHclTerraform(struct!.crtFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    debug: {
      value: cdktf.numberToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    key_file: {
      value: cdktf.stringToHclTerraform(struct!.keyFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_password: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordToHclTerraform(struct!.keyPassword),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword",
    },
    verify: {
      value: cdktf.booleanToHclTerraform(struct!.verify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    vhost: {
      value: cdktf.stringToHclTerraform(struct!.vhost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFile = this._caFile;
    }
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._crtFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.crtFile = this._crtFile;
    }
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._keyFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyFile = this._keyFile;
    }
    if (this._keyPassword?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyPassword = this._keyPassword?.internalValue;
    }
    if (this._verify !== undefined) {
      hasAnyValues = true;
      internalValueResult.verify = this._verify;
    }
    if (this._vhost !== undefined) {
      hasAnyValues = true;
      internalValueResult.vhost = this._vhost;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caFile = undefined;
      this._caPath = undefined;
      this._crtFile = undefined;
      this._debug = undefined;
      this._keyFile = undefined;
      this._keyPassword.internalValue = undefined;
      this._verify = undefined;
      this._vhost = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caFile = value.caFile;
      this._caPath = value.caPath;
      this._crtFile = value.crtFile;
      this._debug = value.debug;
      this._keyFile = value.keyFile;
      this._keyPassword.internalValue = value.keyPassword;
      this._verify = value.verify;
      this._vhost = value.vhost;
    }
  }

  // ca_file - computed: false, optional: true, required: false
  private _caFile?: string; 
  public get caFile() {
    return this.getStringAttribute('ca_file');
  }
  public set caFile(value: string) {
    this._caFile = value;
  }
  public resetCaFile() {
    this._caFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFileInput() {
    return this._caFile;
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // crt_file - computed: false, optional: true, required: false
  private _crtFile?: string; 
  public get crtFile() {
    return this.getStringAttribute('crt_file');
  }
  public set crtFile(value: string) {
    this._crtFile = value;
  }
  public resetCrtFile() {
    this._crtFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get crtFileInput() {
    return this._crtFile;
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: number; 
  public get debug() {
    return this.getNumberAttribute('debug');
  }
  public set debug(value: number) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // key_file - computed: false, optional: true, required: false
  private _keyFile?: string; 
  public get keyFile() {
    return this.getStringAttribute('key_file');
  }
  public set keyFile(value: string) {
    this._keyFile = value;
  }
  public resetKeyFile() {
    this._keyFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyFileInput() {
    return this._keyFile;
  }

  // key_password - computed: false, optional: true, required: false
  private _keyPassword = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPasswordOutputReference(this, "key_password");
  public get keyPassword() {
    return this._keyPassword;
  }
  public putKeyPassword(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsKeyPassword) {
    this._keyPassword.internalValue = value;
  }
  public resetKeyPassword() {
    this._keyPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyPasswordInput() {
    return this._keyPassword.internalValue;
  }

  // verify - computed: false, optional: true, required: false
  private _verify?: boolean | cdktf.IResolvable; 
  public get verify() {
    return this.getBooleanAttribute('verify');
  }
  public set verify(value: boolean | cdktf.IResolvable) {
    this._verify = value;
  }
  public resetVerify() {
    this._verify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyInput() {
    return this._verify;
  }

  // vhost - computed: false, optional: true, required: false
  private _vhost?: string; 
  public get vhost() {
    return this.getStringAttribute('vhost');
  }
  public set vhost(value: string) {
    this._vhost = value;
  }
  public resetVhost() {
    this._vhost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vhostInput() {
    return this._vhost;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp {
  /**
  * Specify the data format to be printed. Supported formats are msgpack json, json_lines and json_stream.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#format}
  */
  readonly format?: string;
  /**
  * Target host where Fluent-Bit or Fluentd are listening for Forward messages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#host DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#host}
  */
  readonly host?: string;
  /**
  * Specify the format of the date. Supported formats are double, epoch and iso8601 (eg: 2018-05-30T09:39:52.000681Z)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_format DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_format}
  */
  readonly jsonDateFormat?: string;
  /**
  * TSpecify the name of the time key in the output record. To disable the time key just set the value to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#json_date_key DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#json_date_key}
  */
  readonly jsonDateKey?: string;
  /**
  * Include fluentbit networking options for this output-plugin
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#networking DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#networking}
  */
  readonly networking?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking;
  /**
  * TCP Port of the target service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#port DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#port}
  */
  readonly port?: number;
  /**
  * Fluent Bit provides integrated support for Transport Layer Security (TLS) and it predecessor Secure Sockets Layer (SSL) respectively.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tls DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tls}
  */
  readonly tls?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    format: cdktf.stringToTerraform(struct!.format),
    host: cdktf.stringToTerraform(struct!.host),
    json_date_format: cdktf.stringToTerraform(struct!.jsonDateFormat),
    json_date_key: cdktf.stringToTerraform(struct!.jsonDateKey),
    networking: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworkingToTerraform(struct!.networking),
    port: cdktf.numberToTerraform(struct!.port),
    tls: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsToTerraform(struct!.tls),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_format: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    json_date_key: {
      value: cdktf.stringToHclTerraform(struct!.jsonDateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    networking: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworkingToHclTerraform(struct!.networking),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._jsonDateFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateFormat = this._jsonDateFormat;
    }
    if (this._jsonDateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonDateKey = this._jsonDateKey;
    }
    if (this._networking?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networking = this._networking?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._format = undefined;
      this._host = undefined;
      this._jsonDateFormat = undefined;
      this._jsonDateKey = undefined;
      this._networking.internalValue = undefined;
      this._port = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._format = value.format;
      this._host = value.host;
      this._jsonDateFormat = value.jsonDateFormat;
      this._jsonDateKey = value.jsonDateKey;
      this._networking.internalValue = value.networking;
      this._port = value.port;
      this._tls.internalValue = value.tls;
    }
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // json_date_format - computed: false, optional: true, required: false
  private _jsonDateFormat?: string; 
  public get jsonDateFormat() {
    return this.getStringAttribute('json_date_format');
  }
  public set jsonDateFormat(value: string) {
    this._jsonDateFormat = value;
  }
  public resetJsonDateFormat() {
    this._jsonDateFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateFormatInput() {
    return this._jsonDateFormat;
  }

  // json_date_key - computed: false, optional: true, required: false
  private _jsonDateKey?: string; 
  public get jsonDateKey() {
    return this.getStringAttribute('json_date_key');
  }
  public set jsonDateKey(value: string) {
    this._jsonDateKey = value;
  }
  public resetJsonDateKey() {
    this._jsonDateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonDateKeyInput() {
    return this._jsonDateKey;
  }

  // networking - computed: false, optional: true, required: false
  private _networking = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworkingOutputReference(this, "networking");
  public get networking() {
    return this._networking;
  }
  public putNetworking(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpNetworking) {
    this._networking.internalValue = value;
  }
  public resetNetworking() {
    this._networking.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkingInput() {
    return this._networking.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec {
  /**
  * A user friendly alias name for this output plugin. Used in metrics for distinction of each configured output.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#alias DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#alias}
  */
  readonly alias?: string;
  /**
  * AzureBlob defines AzureBlob Output Configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#azure_blob DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#azure_blob}
  */
  readonly azureBlob?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob;
  /**
  * AzureLogAnalytics defines AzureLogAnalytics Output Configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#azure_log_analytics DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#azure_log_analytics}
  */
  readonly azureLogAnalytics?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics;
  /**
  * CloudWatch defines CloudWatch Output Configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#cloud_watch DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#cloud_watch}
  */
  readonly cloudWatch?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch;
  /**
  * CustomPlugin defines Custom Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#custom_plugin DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#custom_plugin}
  */
  readonly customPlugin?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin;
  /**
  * DataDog defines DataDog Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#datadog DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#datadog}
  */
  readonly datadog?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog;
  /**
  * Elasticsearch defines Elasticsearch Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#es DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#es}
  */
  readonly es?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs;
  /**
  * File defines File Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#file DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#file}
  */
  readonly file?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile;
  /**
  * Firehose defines Firehose Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#firehose DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#firehose}
  */
  readonly firehose?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose;
  /**
  * Forward defines Forward Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#forward DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#forward}
  */
  readonly forward?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward;
  /**
  * Gelf defines GELF Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#gelf DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#gelf}
  */
  readonly gelf?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf;
  /**
  * HTTP defines HTTP Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#http DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#http}
  */
  readonly http?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp;
  /**
  * InfluxDB defines InfluxDB Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#influx_db DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#influx_db}
  */
  readonly influxDb?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb;
  /**
  * Kafka defines Kafka Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#kafka DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#kafka}
  */
  readonly kafka?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka;
  /**
  * Kinesis defines Kinesis Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#kinesis DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#kinesis}
  */
  readonly kinesis?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis;
  /**
  * Set the plugin's logging verbosity level. Allowed values are: off, error, warn, info, debug and trace, Defaults to the SERVICE section's Log_Level
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#log_level DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#log_level}
  */
  readonly logLevel?: string;
  /**
  * Loki defines Loki Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#loki DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#loki}
  */
  readonly loki?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki;
  /**
  * A pattern to match against the tags of incoming records. It's case sensitive and support the star (*) character as a wildcard.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#match DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#match}
  */
  readonly match?: string;
  /**
  * A regular expression to match against the tags of incoming records. Use this option if you want to use the full regex syntax.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#match_regex DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#match_regex}
  */
  readonly matchRegex?: string;
  /**
  * Null defines Null Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#null DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#null}
  */
  readonly null?: { [key: string]: string };
  /**
  * OpenSearch defines OpenSearch Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#opensearch DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#opensearch}
  */
  readonly opensearch?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch;
  /**
  * OpenTelemetry defines OpenTelemetry Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#opentelemetry DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#opentelemetry}
  */
  readonly opentelemetry?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry;
  /**
  * Processors defines the processors configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#processors DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#processors}
  */
  readonly processors?: { [key: string]: string };
  /**
  * PrometheusExporter_types defines Prometheus exporter configuration to expose metrics from Fluent Bit.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#prometheus_exporter DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#prometheus_exporter}
  */
  readonly prometheusExporter?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter;
  /**
  * PrometheusRemoteWrite_types defines Prometheus Remote Write configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#prometheus_remote_write DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#prometheus_remote_write}
  */
  readonly prometheusRemoteWrite?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite;
  /**
  * RetryLimit represents configuration for the scheduler which can be set independently on each output section. This option allows to disable retries or impose a limit to try N times and then discard the data after reaching that limit.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#retry_limit DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#retry_limit}
  */
  readonly retryLimit?: string;
  /**
  * S3 defines S3 Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#s3 DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#s3}
  */
  readonly s3?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3;
  /**
  * Splunk defines Splunk Output Configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#splunk DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#splunk}
  */
  readonly splunk?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk;
  /**
  * Stackdriver defines Stackdriver Output Configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#stackdriver DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#stackdriver}
  */
  readonly stackdriver?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver;
  /**
  * Stdout defines Stdout Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#stdout DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#stdout}
  */
  readonly stdout?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout;
  /**
  * Syslog defines Syslog Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#syslog DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#syslog}
  */
  readonly syslog?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog;
  /**
  * TCP defines TCP Output configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#tcp DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest#tcp}
  */
  readonly tcp?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp;
}

export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecToTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alias: cdktf.stringToTerraform(struct!.alias),
    azure_blob: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobToTerraform(struct!.azureBlob),
    azure_log_analytics: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsToTerraform(struct!.azureLogAnalytics),
    cloud_watch: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatchToTerraform(struct!.cloudWatch),
    custom_plugin: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPluginToTerraform(struct!.customPlugin),
    datadog: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogToTerraform(struct!.datadog),
    es: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsToTerraform(struct!.es),
    file: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFileToTerraform(struct!.file),
    firehose: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehoseToTerraform(struct!.firehose),
    forward: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardToTerraform(struct!.forward),
    gelf: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfToTerraform(struct!.gelf),
    http: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpToTerraform(struct!.http),
    influx_db: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbToTerraform(struct!.influxDb),
    kafka: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafkaToTerraform(struct!.kafka),
    kinesis: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesisToTerraform(struct!.kinesis),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    loki: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiToTerraform(struct!.loki),
    match: cdktf.stringToTerraform(struct!.match),
    match_regex: cdktf.stringToTerraform(struct!.matchRegex),
    null: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.null),
    opensearch: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchToTerraform(struct!.opensearch),
    opentelemetry: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryToTerraform(struct!.opentelemetry),
    processors: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.processors),
    prometheus_exporter: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporterToTerraform(struct!.prometheusExporter),
    prometheus_remote_write: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteToTerraform(struct!.prometheusRemoteWrite),
    retry_limit: cdktf.stringToTerraform(struct!.retryLimit),
    s3: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3ToTerraform(struct!.s3),
    splunk: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkToTerraform(struct!.splunk),
    stackdriver: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverToTerraform(struct!.stackdriver),
    stdout: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdoutToTerraform(struct!.stdout),
    syslog: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogToTerraform(struct!.syslog),
    tcp: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpToTerraform(struct!.tcp),
  }
}


export function dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecToHclTerraform(struct?: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alias: {
      value: cdktf.stringToHclTerraform(struct!.alias),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    azure_blob: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobToHclTerraform(struct!.azureBlob),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob",
    },
    azure_log_analytics: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsToHclTerraform(struct!.azureLogAnalytics),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics",
    },
    cloud_watch: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatchToHclTerraform(struct!.cloudWatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch",
    },
    custom_plugin: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPluginToHclTerraform(struct!.customPlugin),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin",
    },
    datadog: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogToHclTerraform(struct!.datadog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog",
    },
    es: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsToHclTerraform(struct!.es),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs",
    },
    file: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFileToHclTerraform(struct!.file),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile",
    },
    firehose: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehoseToHclTerraform(struct!.firehose),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose",
    },
    forward: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardToHclTerraform(struct!.forward),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward",
    },
    gelf: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfToHclTerraform(struct!.gelf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf",
    },
    http: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp",
    },
    influx_db: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbToHclTerraform(struct!.influxDb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb",
    },
    kafka: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafkaToHclTerraform(struct!.kafka),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka",
    },
    kinesis: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesisToHclTerraform(struct!.kinesis),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loki: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiToHclTerraform(struct!.loki),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki",
    },
    match: {
      value: cdktf.stringToHclTerraform(struct!.match),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match_regex: {
      value: cdktf.stringToHclTerraform(struct!.matchRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    null: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.null),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    opensearch: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchToHclTerraform(struct!.opensearch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch",
    },
    opentelemetry: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryToHclTerraform(struct!.opentelemetry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry",
    },
    processors: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.processors),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    prometheus_exporter: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporterToHclTerraform(struct!.prometheusExporter),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter",
    },
    prometheus_remote_write: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteToHclTerraform(struct!.prometheusRemoteWrite),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite",
    },
    retry_limit: {
      value: cdktf.stringToHclTerraform(struct!.retryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    s3: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3ToHclTerraform(struct!.s3),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3",
    },
    splunk: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkToHclTerraform(struct!.splunk),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk",
    },
    stackdriver: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverToHclTerraform(struct!.stackdriver),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver",
    },
    stdout: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdoutToHclTerraform(struct!.stdout),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout",
    },
    syslog: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogToHclTerraform(struct!.syslog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog",
    },
    tcp: {
      value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpToHclTerraform(struct!.tcp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alias !== undefined) {
      hasAnyValues = true;
      internalValueResult.alias = this._alias;
    }
    if (this._azureBlob?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureBlob = this._azureBlob?.internalValue;
    }
    if (this._azureLogAnalytics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureLogAnalytics = this._azureLogAnalytics?.internalValue;
    }
    if (this._cloudWatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudWatch = this._cloudWatch?.internalValue;
    }
    if (this._customPlugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customPlugin = this._customPlugin?.internalValue;
    }
    if (this._datadog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datadog = this._datadog?.internalValue;
    }
    if (this._es?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.es = this._es?.internalValue;
    }
    if (this._file?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file?.internalValue;
    }
    if (this._firehose?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.firehose = this._firehose?.internalValue;
    }
    if (this._forward?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.forward = this._forward?.internalValue;
    }
    if (this._gelf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gelf = this._gelf?.internalValue;
    }
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._influxDb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.influxDb = this._influxDb?.internalValue;
    }
    if (this._kafka?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafka = this._kafka?.internalValue;
    }
    if (this._kinesis?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinesis = this._kinesis?.internalValue;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._loki?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.loki = this._loki?.internalValue;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._matchRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchRegex = this._matchRegex;
    }
    if (this._null !== undefined) {
      hasAnyValues = true;
      internalValueResult.null = this._null;
    }
    if (this._opensearch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opensearch = this._opensearch?.internalValue;
    }
    if (this._opentelemetry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opentelemetry = this._opentelemetry?.internalValue;
    }
    if (this._processors !== undefined) {
      hasAnyValues = true;
      internalValueResult.processors = this._processors;
    }
    if (this._prometheusExporter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusExporter = this._prometheusExporter?.internalValue;
    }
    if (this._prometheusRemoteWrite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusRemoteWrite = this._prometheusRemoteWrite?.internalValue;
    }
    if (this._retryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryLimit = this._retryLimit;
    }
    if (this._s3?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.s3 = this._s3?.internalValue;
    }
    if (this._splunk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunk = this._splunk?.internalValue;
    }
    if (this._stackdriver?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stackdriver = this._stackdriver?.internalValue;
    }
    if (this._stdout?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.stdout = this._stdout?.internalValue;
    }
    if (this._syslog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.syslog = this._syslog?.internalValue;
    }
    if (this._tcp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcp = this._tcp?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alias = undefined;
      this._azureBlob.internalValue = undefined;
      this._azureLogAnalytics.internalValue = undefined;
      this._cloudWatch.internalValue = undefined;
      this._customPlugin.internalValue = undefined;
      this._datadog.internalValue = undefined;
      this._es.internalValue = undefined;
      this._file.internalValue = undefined;
      this._firehose.internalValue = undefined;
      this._forward.internalValue = undefined;
      this._gelf.internalValue = undefined;
      this._http.internalValue = undefined;
      this._influxDb.internalValue = undefined;
      this._kafka.internalValue = undefined;
      this._kinesis.internalValue = undefined;
      this._logLevel = undefined;
      this._loki.internalValue = undefined;
      this._match = undefined;
      this._matchRegex = undefined;
      this._null = undefined;
      this._opensearch.internalValue = undefined;
      this._opentelemetry.internalValue = undefined;
      this._processors = undefined;
      this._prometheusExporter.internalValue = undefined;
      this._prometheusRemoteWrite.internalValue = undefined;
      this._retryLimit = undefined;
      this._s3.internalValue = undefined;
      this._splunk.internalValue = undefined;
      this._stackdriver.internalValue = undefined;
      this._stdout.internalValue = undefined;
      this._syslog.internalValue = undefined;
      this._tcp.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alias = value.alias;
      this._azureBlob.internalValue = value.azureBlob;
      this._azureLogAnalytics.internalValue = value.azureLogAnalytics;
      this._cloudWatch.internalValue = value.cloudWatch;
      this._customPlugin.internalValue = value.customPlugin;
      this._datadog.internalValue = value.datadog;
      this._es.internalValue = value.es;
      this._file.internalValue = value.file;
      this._firehose.internalValue = value.firehose;
      this._forward.internalValue = value.forward;
      this._gelf.internalValue = value.gelf;
      this._http.internalValue = value.http;
      this._influxDb.internalValue = value.influxDb;
      this._kafka.internalValue = value.kafka;
      this._kinesis.internalValue = value.kinesis;
      this._logLevel = value.logLevel;
      this._loki.internalValue = value.loki;
      this._match = value.match;
      this._matchRegex = value.matchRegex;
      this._null = value.null;
      this._opensearch.internalValue = value.opensearch;
      this._opentelemetry.internalValue = value.opentelemetry;
      this._processors = value.processors;
      this._prometheusExporter.internalValue = value.prometheusExporter;
      this._prometheusRemoteWrite.internalValue = value.prometheusRemoteWrite;
      this._retryLimit = value.retryLimit;
      this._s3.internalValue = value.s3;
      this._splunk.internalValue = value.splunk;
      this._stackdriver.internalValue = value.stackdriver;
      this._stdout.internalValue = value.stdout;
      this._syslog.internalValue = value.syslog;
      this._tcp.internalValue = value.tcp;
    }
  }

  // alias - computed: false, optional: true, required: false
  private _alias?: string; 
  public get alias() {
    return this.getStringAttribute('alias');
  }
  public set alias(value: string) {
    this._alias = value;
  }
  public resetAlias() {
    this._alias = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aliasInput() {
    return this._alias;
  }

  // azure_blob - computed: false, optional: true, required: false
  private _azureBlob = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlobOutputReference(this, "azure_blob");
  public get azureBlob() {
    return this._azureBlob;
  }
  public putAzureBlob(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureBlob) {
    this._azureBlob.internalValue = value;
  }
  public resetAzureBlob() {
    this._azureBlob.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureBlobInput() {
    return this._azureBlob.internalValue;
  }

  // azure_log_analytics - computed: false, optional: true, required: false
  private _azureLogAnalytics = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalyticsOutputReference(this, "azure_log_analytics");
  public get azureLogAnalytics() {
    return this._azureLogAnalytics;
  }
  public putAzureLogAnalytics(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecAzureLogAnalytics) {
    this._azureLogAnalytics.internalValue = value;
  }
  public resetAzureLogAnalytics() {
    this._azureLogAnalytics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureLogAnalyticsInput() {
    return this._azureLogAnalytics.internalValue;
  }

  // cloud_watch - computed: false, optional: true, required: false
  private _cloudWatch = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatchOutputReference(this, "cloud_watch");
  public get cloudWatch() {
    return this._cloudWatch;
  }
  public putCloudWatch(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCloudWatch) {
    this._cloudWatch.internalValue = value;
  }
  public resetCloudWatch() {
    this._cloudWatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudWatchInput() {
    return this._cloudWatch.internalValue;
  }

  // custom_plugin - computed: false, optional: true, required: false
  private _customPlugin = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPluginOutputReference(this, "custom_plugin");
  public get customPlugin() {
    return this._customPlugin;
  }
  public putCustomPlugin(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecCustomPlugin) {
    this._customPlugin.internalValue = value;
  }
  public resetCustomPlugin() {
    this._customPlugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customPluginInput() {
    return this._customPlugin.internalValue;
  }

  // datadog - computed: false, optional: true, required: false
  private _datadog = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadogOutputReference(this, "datadog");
  public get datadog() {
    return this._datadog;
  }
  public putDatadog(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecDatadog) {
    this._datadog.internalValue = value;
  }
  public resetDatadog() {
    this._datadog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datadogInput() {
    return this._datadog.internalValue;
  }

  // es - computed: false, optional: true, required: false
  private _es = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEsOutputReference(this, "es");
  public get es() {
    return this._es;
  }
  public putEs(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecEs) {
    this._es.internalValue = value;
  }
  public resetEs() {
    this._es.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get esInput() {
    return this._es.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFileOutputReference(this, "file");
  public get file() {
    return this._file;
  }
  public putFile(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFile) {
    this._file.internalValue = value;
  }
  public resetFile() {
    this._file.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file.internalValue;
  }

  // firehose - computed: false, optional: true, required: false
  private _firehose = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehoseOutputReference(this, "firehose");
  public get firehose() {
    return this._firehose;
  }
  public putFirehose(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecFirehose) {
    this._firehose.internalValue = value;
  }
  public resetFirehose() {
    this._firehose.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firehoseInput() {
    return this._firehose.internalValue;
  }

  // forward - computed: false, optional: true, required: false
  private _forward = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForwardOutputReference(this, "forward");
  public get forward() {
    return this._forward;
  }
  public putForward(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecForward) {
    this._forward.internalValue = value;
  }
  public resetForward() {
    this._forward.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardInput() {
    return this._forward.internalValue;
  }

  // gelf - computed: false, optional: true, required: false
  private _gelf = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelfOutputReference(this, "gelf");
  public get gelf() {
    return this._gelf;
  }
  public putGelf(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecGelf) {
    this._gelf.internalValue = value;
  }
  public resetGelf() {
    this._gelf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gelfInput() {
    return this._gelf.internalValue;
  }

  // http - computed: false, optional: true, required: false
  private _http = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecHttp) {
    this._http.internalValue = value;
  }
  public resetHttp() {
    this._http.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // influx_db - computed: false, optional: true, required: false
  private _influxDb = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDbOutputReference(this, "influx_db");
  public get influxDb() {
    return this._influxDb;
  }
  public putInfluxDb(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecInfluxDb) {
    this._influxDb.internalValue = value;
  }
  public resetInfluxDb() {
    this._influxDb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get influxDbInput() {
    return this._influxDb.internalValue;
  }

  // kafka - computed: false, optional: true, required: false
  private _kafka = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafkaOutputReference(this, "kafka");
  public get kafka() {
    return this._kafka;
  }
  public putKafka(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKafka) {
    this._kafka.internalValue = value;
  }
  public resetKafka() {
    this._kafka.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaInput() {
    return this._kafka.internalValue;
  }

  // kinesis - computed: false, optional: true, required: false
  private _kinesis = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesisOutputReference(this, "kinesis");
  public get kinesis() {
    return this._kinesis;
  }
  public putKinesis(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecKinesis) {
    this._kinesis.internalValue = value;
  }
  public resetKinesis() {
    this._kinesis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kinesisInput() {
    return this._kinesis.internalValue;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // loki - computed: false, optional: true, required: false
  private _loki = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLokiOutputReference(this, "loki");
  public get loki() {
    return this._loki;
  }
  public putLoki(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecLoki) {
    this._loki.internalValue = value;
  }
  public resetLoki() {
    this._loki.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiInput() {
    return this._loki.internalValue;
  }

  // match - computed: false, optional: true, required: false
  private _match?: string; 
  public get match() {
    return this.getStringAttribute('match');
  }
  public set match(value: string) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // match_regex - computed: false, optional: true, required: false
  private _matchRegex?: string; 
  public get matchRegex() {
    return this.getStringAttribute('match_regex');
  }
  public set matchRegex(value: string) {
    this._matchRegex = value;
  }
  public resetMatchRegex() {
    this._matchRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchRegexInput() {
    return this._matchRegex;
  }

  // null - computed: false, optional: true, required: false
  private _null?: { [key: string]: string }; 
  public get null() {
    return this.getStringMapAttribute('null');
  }
  public set null(value: { [key: string]: string }) {
    this._null = value;
  }
  public resetNull() {
    this._null = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nullInput() {
    return this._null;
  }

  // opensearch - computed: false, optional: true, required: false
  private _opensearch = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearchOutputReference(this, "opensearch");
  public get opensearch() {
    return this._opensearch;
  }
  public putOpensearch(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpensearch) {
    this._opensearch.internalValue = value;
  }
  public resetOpensearch() {
    this._opensearch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opensearchInput() {
    return this._opensearch.internalValue;
  }

  // opentelemetry - computed: false, optional: true, required: false
  private _opentelemetry = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetryOutputReference(this, "opentelemetry");
  public get opentelemetry() {
    return this._opentelemetry;
  }
  public putOpentelemetry(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOpentelemetry) {
    this._opentelemetry.internalValue = value;
  }
  public resetOpentelemetry() {
    this._opentelemetry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opentelemetryInput() {
    return this._opentelemetry.internalValue;
  }

  // processors - computed: false, optional: true, required: false
  private _processors?: { [key: string]: string }; 
  public get processors() {
    return this.getStringMapAttribute('processors');
  }
  public set processors(value: { [key: string]: string }) {
    this._processors = value;
  }
  public resetProcessors() {
    this._processors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processorsInput() {
    return this._processors;
  }

  // prometheus_exporter - computed: false, optional: true, required: false
  private _prometheusExporter = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporterOutputReference(this, "prometheus_exporter");
  public get prometheusExporter() {
    return this._prometheusExporter;
  }
  public putPrometheusExporter(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusExporter) {
    this._prometheusExporter.internalValue = value;
  }
  public resetPrometheusExporter() {
    this._prometheusExporter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusExporterInput() {
    return this._prometheusExporter.internalValue;
  }

  // prometheus_remote_write - computed: false, optional: true, required: false
  private _prometheusRemoteWrite = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWriteOutputReference(this, "prometheus_remote_write");
  public get prometheusRemoteWrite() {
    return this._prometheusRemoteWrite;
  }
  public putPrometheusRemoteWrite(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecPrometheusRemoteWrite) {
    this._prometheusRemoteWrite.internalValue = value;
  }
  public resetPrometheusRemoteWrite() {
    this._prometheusRemoteWrite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusRemoteWriteInput() {
    return this._prometheusRemoteWrite.internalValue;
  }

  // retry_limit - computed: false, optional: true, required: false
  private _retryLimit?: string; 
  public get retryLimit() {
    return this.getStringAttribute('retry_limit');
  }
  public set retryLimit(value: string) {
    this._retryLimit = value;
  }
  public resetRetryLimit() {
    this._retryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryLimitInput() {
    return this._retryLimit;
  }

  // s3 - computed: false, optional: true, required: false
  private _s3 = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3OutputReference(this, "s3");
  public get s3() {
    return this._s3;
  }
  public putS3(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecS3) {
    this._s3.internalValue = value;
  }
  public resetS3() {
    this._s3.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get s3Input() {
    return this._s3.internalValue;
  }

  // splunk - computed: false, optional: true, required: false
  private _splunk = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunkOutputReference(this, "splunk");
  public get splunk() {
    return this._splunk;
  }
  public putSplunk(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSplunk) {
    this._splunk.internalValue = value;
  }
  public resetSplunk() {
    this._splunk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkInput() {
    return this._splunk.internalValue;
  }

  // stackdriver - computed: false, optional: true, required: false
  private _stackdriver = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriverOutputReference(this, "stackdriver");
  public get stackdriver() {
    return this._stackdriver;
  }
  public putStackdriver(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStackdriver) {
    this._stackdriver.internalValue = value;
  }
  public resetStackdriver() {
    this._stackdriver.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stackdriverInput() {
    return this._stackdriver.internalValue;
  }

  // stdout - computed: false, optional: true, required: false
  private _stdout = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdoutOutputReference(this, "stdout");
  public get stdout() {
    return this._stdout;
  }
  public putStdout(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecStdout) {
    this._stdout.internalValue = value;
  }
  public resetStdout() {
    this._stdout.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stdoutInput() {
    return this._stdout.internalValue;
  }

  // syslog - computed: false, optional: true, required: false
  private _syslog = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslogOutputReference(this, "syslog");
  public get syslog() {
    return this._syslog;
  }
  public putSyslog(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecSyslog) {
    this._syslog.internalValue = value;
  }
  public resetSyslog() {
    this._syslog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syslogInput() {
    return this._syslog.internalValue;
  }

  // tcp - computed: false, optional: true, required: false
  private _tcp = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcpOutputReference(this, "tcp");
  public get tcp() {
    return this._tcp;
  }
  public putTcp(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecTcp) {
    this._tcp.internalValue = value;
  }
  public resetTcp() {
    this._tcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpInput() {
    return this._tcp.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest k8s_fluentbit_fluent_io_cluster_output_v1alpha2_manifest}
*/
export class DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_fluentbit_fluent_io_cluster_output_v1alpha2_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest to import
  * @param importFromId The id of the existing DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8SFluentbitFluentIoClusterOutputV1Alpha2Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_fluentbit_fluent_io_cluster_output_v1alpha2_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/fluentbit_fluent_io_cluster_output_v1alpha2_manifest k8s_fluentbit_fluent_io_cluster_output_v1alpha2_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_fluentbit_fluent_io_cluster_output_v1alpha2_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.10.20'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestMetadata",
      },
      spec: {
        value: dataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SFluentbitFluentIoClusterOutputV1Alpha2ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
