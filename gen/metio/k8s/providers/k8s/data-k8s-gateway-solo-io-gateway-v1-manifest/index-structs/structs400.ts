import * as cdktf from 'cdktf';
import { DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParameters,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParametersToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParametersToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParametersOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSds,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSdsToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSdsToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSdsOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettings,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettingsToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettingsToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettingsOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRef,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRefToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRefToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRefOutputReference,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelector,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelectorToTerraform,
dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelectorToHclTerraform,
DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelectorOutputReference } from './structs0'
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ocsp_staple DataK8SGatewaySoloIoGatewayV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#root_ca DataK8SGatewaySoloIoGatewayV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tls_cert DataK8SGatewaySoloIoGatewayV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tls_key DataK8SGatewaySoloIoGatewayV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFilesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFilesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#alpn_protocols DataK8SGatewaySoloIoGatewayV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable_tls_session_resumption DataK8SGatewaySoloIoGatewayV1Manifest#disable_tls_session_resumption}
  */
  readonly disableTlsSessionResumption?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ocsp_staple_policy DataK8SGatewaySoloIoGatewayV1Manifest#ocsp_staple_policy}
  */
  readonly ocspStaplePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#one_way_tls DataK8SGatewaySoloIoGatewayV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parameters DataK8SGatewaySoloIoGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sds DataK8SGatewaySoloIoGatewayV1Manifest#sds}
  */
  readonly sds?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#secret_ref DataK8SGatewaySoloIoGatewayV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sni_domains DataK8SGatewaySoloIoGatewayV1Manifest#sni_domains}
  */
  readonly sniDomains?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ssl_files DataK8SGatewaySoloIoGatewayV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transport_socket_connect_timeout DataK8SGatewaySoloIoGatewayV1Manifest#transport_socket_connect_timeout}
  */
  readonly transportSocketConnectTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#verify_subject_alt_name DataK8SGatewaySoloIoGatewayV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    disable_tls_session_resumption: cdktf.booleanToTerraform(struct!.disableTlsSessionResumption),
    ocsp_staple_policy: cdktf.stringToTerraform(struct!.ocspStaplePolicy),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRefToTerraform(struct!.secretRef),
    sni_domains: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sniDomains),
    ssl_files: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFilesToTerraform(struct!.sslFiles),
    transport_socket_connect_timeout: cdktf.stringToTerraform(struct!.transportSocketConnectTimeout),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_tls_session_resumption: {
      value: cdktf.booleanToHclTerraform(struct!.disableTlsSessionResumption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ocsp_staple_policy: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaplePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParameters",
    },
    sds: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSds",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef",
    },
    sni_domains: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sniDomains),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ssl_files: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles",
    },
    transport_socket_connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.transportSocketConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._disableTlsSessionResumption !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTlsSessionResumption = this._disableTlsSessionResumption;
    }
    if (this._ocspStaplePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaplePolicy = this._ocspStaplePolicy;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sniDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.sniDomains = this._sniDomains;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._transportSocketConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.transportSocketConnectTimeout = this._transportSocketConnectTimeout;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alpnProtocols = undefined;
      this._disableTlsSessionResumption = undefined;
      this._ocspStaplePolicy = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sniDomains = undefined;
      this._sslFiles.internalValue = undefined;
      this._transportSocketConnectTimeout = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alpnProtocols = value.alpnProtocols;
      this._disableTlsSessionResumption = value.disableTlsSessionResumption;
      this._ocspStaplePolicy = value.ocspStaplePolicy;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sniDomains = value.sniDomains;
      this._sslFiles.internalValue = value.sslFiles;
      this._transportSocketConnectTimeout = value.transportSocketConnectTimeout;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // disable_tls_session_resumption - computed: false, optional: true, required: false
  private _disableTlsSessionResumption?: boolean | cdktf.IResolvable; 
  public get disableTlsSessionResumption() {
    return this.getBooleanAttribute('disable_tls_session_resumption');
  }
  public set disableTlsSessionResumption(value: boolean | cdktf.IResolvable) {
    this._disableTlsSessionResumption = value;
  }
  public resetDisableTlsSessionResumption() {
    this._disableTlsSessionResumption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTlsSessionResumptionInput() {
    return this._disableTlsSessionResumption;
  }

  // ocsp_staple_policy - computed: false, optional: true, required: false
  private _ocspStaplePolicy?: string; 
  public get ocspStaplePolicy() {
    return this.getStringAttribute('ocsp_staple_policy');
  }
  public set ocspStaplePolicy(value: string) {
    this._ocspStaplePolicy = value;
  }
  public resetOcspStaplePolicy() {
    this._ocspStaplePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStaplePolicyInput() {
    return this._ocspStaplePolicy;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni_domains - computed: false, optional: true, required: false
  private _sniDomains?: string[]; 
  public get sniDomains() {
    return this.getListAttribute('sni_domains');
  }
  public set sniDomains(value: string[]) {
    this._sniDomains = value;
  }
  public resetSniDomains() {
    this._sniDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniDomainsInput() {
    return this._sniDomains;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // transport_socket_connect_timeout - computed: false, optional: true, required: false
  private _transportSocketConnectTimeout?: string; 
  public get transportSocketConnectTimeout() {
    return this.getStringAttribute('transport_socket_connect_timeout');
  }
  public set transportSocketConnectTimeout(value: string) {
    this._transportSocketConnectTimeout = value;
  }
  public resetTransportSocketConnectTimeout() {
    this._transportSocketConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportSocketConnectTimeoutInput() {
    return this._transportSocketConnectTimeout;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGateways {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http_connection_manager_settings DataK8SGatewaySoloIoGatewayV1Manifest#http_connection_manager_settings}
  */
  readonly httpConnectionManagerSettings?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettings;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prevent_child_overrides DataK8SGatewaySoloIoGatewayV1Manifest#prevent_child_overrides}
  */
  readonly preventChildOverrides?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ref DataK8SGatewaySoloIoGatewayV1Manifest#ref}
  */
  readonly ref?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#selector DataK8SGatewaySoloIoGatewayV1Manifest#selector}
  */
  readonly selector?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ssl_config DataK8SGatewaySoloIoGatewayV1Manifest#ssl_config}
  */
  readonly sslConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGateways | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_connection_manager_settings: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettingsToTerraform(struct!.httpConnectionManagerSettings),
    prevent_child_overrides: cdktf.booleanToTerraform(struct!.preventChildOverrides),
    ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRefToTerraform(struct!.ref),
    selector: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelectorToTerraform(struct!.selector),
    ssl_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigToTerraform(struct!.sslConfig),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGateways | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_connection_manager_settings: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettingsToHclTerraform(struct!.httpConnectionManagerSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettings",
    },
    prevent_child_overrides: {
      value: cdktf.booleanToHclTerraform(struct!.preventChildOverrides),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRef",
    },
    selector: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelector",
    },
    ssl_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigToHclTerraform(struct!.sslConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGateways | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpConnectionManagerSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConnectionManagerSettings = this._httpConnectionManagerSettings?.internalValue;
    }
    if (this._preventChildOverrides !== undefined) {
      hasAnyValues = true;
      internalValueResult.preventChildOverrides = this._preventChildOverrides;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    if (this._sslConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslConfig = this._sslConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGateways | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpConnectionManagerSettings.internalValue = undefined;
      this._preventChildOverrides = undefined;
      this._ref.internalValue = undefined;
      this._selector.internalValue = undefined;
      this._sslConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpConnectionManagerSettings.internalValue = value.httpConnectionManagerSettings;
      this._preventChildOverrides = value.preventChildOverrides;
      this._ref.internalValue = value.ref;
      this._selector.internalValue = value.selector;
      this._sslConfig.internalValue = value.sslConfig;
    }
  }

  // http_connection_manager_settings - computed: false, optional: true, required: false
  private _httpConnectionManagerSettings = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettingsOutputReference(this, "http_connection_manager_settings");
  public get httpConnectionManagerSettings() {
    return this._httpConnectionManagerSettings;
  }
  public putHttpConnectionManagerSettings(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysHttpConnectionManagerSettings) {
    this._httpConnectionManagerSettings.internalValue = value;
  }
  public resetHttpConnectionManagerSettings() {
    this._httpConnectionManagerSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConnectionManagerSettingsInput() {
    return this._httpConnectionManagerSettings.internalValue;
  }

  // prevent_child_overrides - computed: false, optional: true, required: false
  private _preventChildOverrides?: boolean | cdktf.IResolvable; 
  public get preventChildOverrides() {
    return this.getBooleanAttribute('prevent_child_overrides');
  }
  public set preventChildOverrides(value: boolean | cdktf.IResolvable) {
    this._preventChildOverrides = value;
  }
  public resetPreventChildOverrides() {
    this._preventChildOverrides = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preventChildOverridesInput() {
    return this._preventChildOverrides;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }

  // ssl_config - computed: false, optional: true, required: false
  private _sslConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfigOutputReference(this, "ssl_config");
  public get sslConfig() {
    return this._sslConfig;
  }
  public putSslConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedHttpGatewaysSslConfig) {
    this._sslConfig.internalValue = value;
  }
  public resetSslConfig() {
    this._sslConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslConfigInput() {
    return this._sslConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#operator DataK8SGatewaySoloIoGatewayV1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#values DataK8SGatewaySoloIoGatewayV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#expressions DataK8SGatewaySoloIoGatewayV1Manifest#expressions}
  */
  readonly expressions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#labels DataK8SGatewaySoloIoGatewayV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespaces DataK8SGatewaySoloIoGatewayV1Manifest#namespaces}
  */
  readonly namespaces?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expressions: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsToTerraform, false)(struct!.expressions),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expressions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsToHclTerraform, false)(struct!.expressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsList",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressions = this._expressions?.internalValue;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expressions.internalValue = undefined;
      this._labels = undefined;
      this._namespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expressions.internalValue = value.expressions;
      this._labels = value.labels;
      this._namespaces = value.namespaces;
    }
  }

  // expressions - computed: false, optional: true, required: false
  private _expressions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressionsList(this, "expressions", false);
  public get expressions() {
    return this._expressions;
  }
  public putExpressions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorExpressions[] | cdktf.IResolvable) {
    this._expressions.internalValue = value;
  }
  public resetExpressions() {
    this._expressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionsInput() {
    return this._expressions.internalValue;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGateways {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ref DataK8SGatewaySoloIoGatewayV1Manifest#ref}
  */
  readonly ref?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#selector DataK8SGatewaySoloIoGatewayV1Manifest#selector}
  */
  readonly selector?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGateways | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRefToTerraform(struct!.ref),
    selector: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGateways | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef",
    },
    selector: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGateways | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGateways | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ref.internalValue = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ref.internalValue = value.ref;
      this._selector.internalValue = value.selector;
    }
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayDelegatedTcpGatewaysSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_request_bytes DataK8SGatewaySoloIoGatewayV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBufferToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBufferToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBufferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxRequestBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxRequestBytes = value.maxRequestBytes;
    }
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#suffix DataK8SGatewaySoloIoGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_vary_headers DataK8SGatewaySoloIoGatewayV1Manifest#allowed_vary_headers}
  */
  readonly allowedVaryHeaders?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#caching_service_ref DataK8SGatewaySoloIoGatewayV1Manifest#caching_service_ref}
  */
  readonly cachingServiceRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_payload_size DataK8SGatewaySoloIoGatewayV1Manifest#max_payload_size}
  */
  readonly maxPayloadSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#timeout DataK8SGatewaySoloIoGatewayV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_vary_headers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersToTerraform, false)(struct!.allowedVaryHeaders),
    caching_service_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRefToTerraform(struct!.cachingServiceRef),
    max_payload_size: cdktf.numberToTerraform(struct!.maxPayloadSize),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_vary_headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersToHclTerraform, false)(struct!.allowedVaryHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersList",
    },
    caching_service_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRefToHclTerraform(struct!.cachingServiceRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef",
    },
    max_payload_size: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedVaryHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedVaryHeaders = this._allowedVaryHeaders?.internalValue;
    }
    if (this._cachingServiceRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingServiceRef = this._cachingServiceRef?.internalValue;
    }
    if (this._maxPayloadSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSize = this._maxPayloadSize;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedVaryHeaders.internalValue = undefined;
      this._cachingServiceRef.internalValue = undefined;
      this._maxPayloadSize = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedVaryHeaders.internalValue = value.allowedVaryHeaders;
      this._cachingServiceRef.internalValue = value.cachingServiceRef;
      this._maxPayloadSize = value.maxPayloadSize;
      this._timeout = value.timeout;
    }
  }

  // allowed_vary_headers - computed: false, optional: true, required: false
  private _allowedVaryHeaders = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeadersList(this, "allowed_vary_headers", false);
  public get allowedVaryHeaders() {
    return this._allowedVaryHeaders;
  }
  public putAllowedVaryHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingAllowedVaryHeaders[] | cdktf.IResolvable) {
    this._allowedVaryHeaders.internalValue = value;
  }
  public resetAllowedVaryHeaders() {
    this._allowedVaryHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedVaryHeadersInput() {
    return this._allowedVaryHeaders.internalValue;
  }

  // caching_service_ref - computed: false, optional: true, required: false
  private _cachingServiceRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRefOutputReference(this, "caching_service_ref");
  public get cachingServiceRef() {
    return this._cachingServiceRef;
  }
  public putCachingServiceRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingCachingServiceRef) {
    this._cachingServiceRef.internalValue = value;
  }
  public resetCachingServiceRef() {
    this._cachingServiceRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingServiceRefInput() {
    return this._cachingServiceRef.internalValue;
  }

  // max_payload_size - computed: false, optional: true, required: false
  private _maxPayloadSize?: number; 
  public get maxPayloadSize() {
    return this.getNumberAttribute('max_payload_size');
  }
  public set maxPayloadSize(value: number) {
    this._maxPayloadSize = value;
  }
  public resetMaxPayloadSize() {
    this._maxPayloadSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeInput() {
    return this._maxPayloadSize;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#delay_before_close DataK8SGatewaySoloIoGatewayV1Manifest#delay_before_close}
  */
  readonly delayBeforeClose?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_active_connections DataK8SGatewaySoloIoGatewayV1Manifest#max_active_connections}
  */
  readonly maxActiveConnections?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimitToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay_before_close: cdktf.stringToTerraform(struct!.delayBeforeClose),
    max_active_connections: cdktf.numberToTerraform(struct!.maxActiveConnections),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimitToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay_before_close: {
      value: cdktf.stringToHclTerraform(struct!.delayBeforeClose),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delayBeforeClose !== undefined) {
      hasAnyValues = true;
      internalValueResult.delayBeforeClose = this._delayBeforeClose;
    }
    if (this._maxActiveConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveConnections = this._maxActiveConnections;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delayBeforeClose = undefined;
      this._maxActiveConnections = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delayBeforeClose = value.delayBeforeClose;
      this._maxActiveConnections = value.maxActiveConnections;
    }
  }

  // delay_before_close - computed: false, optional: true, required: false
  private _delayBeforeClose?: string; 
  public get delayBeforeClose() {
    return this.getStringAttribute('delay_before_close');
  }
  public set delayBeforeClose(value: string) {
    this._delayBeforeClose = value;
  }
  public resetDelayBeforeClose() {
    this._delayBeforeClose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayBeforeCloseInput() {
    return this._delayBeforeClose;
  }

  // max_active_connections - computed: false, optional: true, required: false
  private _maxActiveConnections?: number; 
  public get maxActiveConnections() {
    return this.getNumberAttribute('max_active_connections');
  }
  public set maxActiveConnections(value: number) {
    this._maxActiveConnections = value;
  }
  public resetMaxActiveConnections() {
    this._maxActiveConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveConnectionsInput() {
    return this._maxActiveConnections;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#suffix DataK8SGatewaySoloIoGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#denominator DataK8SGatewaySoloIoGatewayV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#numerator DataK8SGatewaySoloIoGatewayV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_value DataK8SGatewaySoloIoGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#runtime_key DataK8SGatewaySoloIoGatewayV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#denominator DataK8SGatewaySoloIoGatewayV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#numerator DataK8SGatewaySoloIoGatewayV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_value DataK8SGatewaySoloIoGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#runtime_key DataK8SGatewaySoloIoGatewayV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#additional_origins DataK8SGatewaySoloIoGatewayV1Manifest#additional_origins}
  */
  readonly additionalOrigins?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#filter_enabled DataK8SGatewaySoloIoGatewayV1Manifest#filter_enabled}
  */
  readonly filterEnabled?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#shadow_enabled DataK8SGatewaySoloIoGatewayV1Manifest#shadow_enabled}
  */
  readonly shadowEnabled?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_origins: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsToTerraform, false)(struct!.additionalOrigins),
    filter_enabled: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledToTerraform(struct!.filterEnabled),
    shadow_enabled: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledToTerraform(struct!.shadowEnabled),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_origins: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsToHclTerraform, false)(struct!.additionalOrigins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsList",
    },
    filter_enabled: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledToHclTerraform(struct!.filterEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled",
    },
    shadow_enabled: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledToHclTerraform(struct!.shadowEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalOrigins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalOrigins = this._additionalOrigins?.internalValue;
    }
    if (this._filterEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterEnabled = this._filterEnabled?.internalValue;
    }
    if (this._shadowEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadowEnabled = this._shadowEnabled?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = undefined;
      this._filterEnabled.internalValue = undefined;
      this._shadowEnabled.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = value.additionalOrigins;
      this._filterEnabled.internalValue = value.filterEnabled;
      this._shadowEnabled.internalValue = value.shadowEnabled;
    }
  }

  // additional_origins - computed: false, optional: true, required: false
  private _additionalOrigins = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOriginsList(this, "additional_origins", false);
  public get additionalOrigins() {
    return this._additionalOrigins;
  }
  public putAdditionalOrigins(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable) {
    this._additionalOrigins.internalValue = value;
  }
  public resetAdditionalOrigins() {
    this._additionalOrigins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalOriginsInput() {
    return this._additionalOrigins.internalValue;
  }

  // filter_enabled - computed: false, optional: true, required: false
  private _filterEnabled = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabledOutputReference(this, "filter_enabled");
  public get filterEnabled() {
    return this._filterEnabled;
  }
  public putFilterEnabled(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfFilterEnabled) {
    this._filterEnabled.internalValue = value;
  }
  public resetFilterEnabled() {
    this._filterEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterEnabledInput() {
    return this._filterEnabled.internalValue;
  }

  // shadow_enabled - computed: false, optional: true, required: false
  private _shadowEnabled = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabledOutputReference(this, "shadow_enabled");
  public get shadowEnabled() {
    return this._shadowEnabled;
  }
  public putShadowEnabled(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfShadowEnabled) {
    this._shadowEnabled.internalValue = value;
  }
  public resetShadowEnabled() {
    this._shadowEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowEnabledInput() {
    return this._shadowEnabled.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
      this._subgroup = value.subgroup;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mask_char DataK8SGatewaySoloIoGatewayV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#percent DataK8SGatewaySoloIoGatewayV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex_actions DataK8SGatewaySoloIoGatewayV1Manifest#regex_actions}
  */
  readonly regexActions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToTerraform(struct!.percent),
    regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regex),
    regex_actions: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToTerraform, false)(struct!.regexActions),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent",
    },
    regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    regex_actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsToHclTerraform, false)(struct!.regexActions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._regexActions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexActions = this._regexActions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
      this._regex = undefined;
      this._regexActions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
      this._regex = value.regex;
      this._regexActions.internalValue = value.regexActions;
    }
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string[]; 
  public get regex() {
    return this.getListAttribute('regex');
  }
  public set regex(value: string[]) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // regex_actions - computed: false, optional: true, required: false
  private _regexActions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActionsList(this, "regex_actions", false);
  public get regexActions() {
    return this._regexActions;
  }
  public putRegexActions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionRegexActions[] | cdktf.IResolvable) {
    this._regexActions.internalValue = value;
  }
  public resetRegexActions() {
    this._regexActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexActionsInput() {
    return this._regexActions.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key_to_mask DataK8SGatewaySoloIoGatewayV1Manifest#key_to_mask}
  */
  readonly keyToMask?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mask_char DataK8SGatewaySoloIoGatewayV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#percent DataK8SGatewaySoloIoGatewayV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key_to_mask: cdktf.stringToTerraform(struct!.keyToMask),
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToTerraform(struct!.percent),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key_to_mask: {
      value: cdktf.stringToHclTerraform(struct!.keyToMask),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keyToMask !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyToMask = this._keyToMask;
    }
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keyToMask = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keyToMask = value.keyToMask;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
    }
  }

  // key_to_mask - computed: false, optional: true, required: false
  private _keyToMask?: string; 
  public get keyToMask() {
    return this.getStringAttribute('key_to_mask');
  }
  public set keyToMask(value: string) {
    this._keyToMask = value;
  }
  public resetKeyToMask() {
    this._keyToMask = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyToMaskInput() {
    return this._keyToMask;
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#action_type DataK8SGatewaySoloIoGatewayV1Manifest#action_type}
  */
  readonly actionType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#custom_action DataK8SGatewaySoloIoGatewayV1Manifest#custom_action}
  */
  readonly customAction?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key_value_action DataK8SGatewaySoloIoGatewayV1Manifest#key_value_action}
  */
  readonly keyValueAction?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#shadow DataK8SGatewaySoloIoGatewayV1Manifest#shadow}
  */
  readonly shadow?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_type: cdktf.stringToTerraform(struct!.actionType),
    custom_action: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionToTerraform(struct!.customAction),
    key_value_action: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToTerraform(struct!.keyValueAction),
    shadow: cdktf.booleanToTerraform(struct!.shadow),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_type: {
      value: cdktf.stringToHclTerraform(struct!.actionType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_action: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionToHclTerraform(struct!.customAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction",
    },
    key_value_action: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionToHclTerraform(struct!.keyValueAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction",
    },
    shadow: {
      value: cdktf.booleanToHclTerraform(struct!.shadow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionType !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionType = this._actionType;
    }
    if (this._customAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAction = this._customAction?.internalValue;
    }
    if (this._keyValueAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueAction = this._keyValueAction?.internalValue;
    }
    if (this._shadow !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadow = this._shadow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionType = undefined;
      this._customAction.internalValue = undefined;
      this._keyValueAction.internalValue = undefined;
      this._shadow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionType = value.actionType;
      this._customAction.internalValue = value.customAction;
      this._keyValueAction.internalValue = value.keyValueAction;
      this._shadow = value.shadow;
    }
  }

  // action_type - computed: false, optional: true, required: false
  private _actionType?: string; 
  public get actionType() {
    return this.getStringAttribute('action_type');
  }
  public set actionType(value: string) {
    this._actionType = value;
  }
  public resetActionType() {
    this._actionType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionTypeInput() {
    return this._actionType;
  }

  // custom_action - computed: false, optional: true, required: false
  private _customAction = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomActionOutputReference(this, "custom_action");
  public get customAction() {
    return this._customAction;
  }
  public putCustomAction(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsCustomAction) {
    this._customAction.internalValue = value;
  }
  public resetCustomAction() {
    this._customAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customActionInput() {
    return this._customAction.internalValue;
  }

  // key_value_action - computed: false, optional: true, required: false
  private _keyValueAction = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueActionOutputReference(this, "key_value_action");
  public get keyValueAction() {
    return this._keyValueAction;
  }
  public putKeyValueAction(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsKeyValueAction) {
    this._keyValueAction.internalValue = value;
  }
  public resetKeyValueAction() {
    this._keyValueAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueActionInput() {
    return this._keyValueAction.internalValue;
  }

  // shadow - computed: false, optional: true, required: false
  private _shadow?: boolean | cdktf.IResolvable; 
  public get shadow() {
    return this.getBooleanAttribute('shadow');
  }
  public set shadow(value: boolean | cdktf.IResolvable) {
    this._shadow = value;
  }
  public resetShadow() {
    this._shadow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowInput() {
    return this._shadow;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invert_match DataK8SGatewaySoloIoGatewayV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#case_sensitive DataK8SGatewaySoloIoGatewayV1Manifest#case_sensitive}
  */
  readonly caseSensitive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connect_matcher DataK8SGatewaySoloIoGatewayV1Manifest#connect_matcher}
  */
  readonly connectMatcher?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#methods DataK8SGatewaySoloIoGatewayV1Manifest#methods}
  */
  readonly methods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#query_parameters DataK8SGatewaySoloIoGatewayV1Manifest#query_parameters}
  */
  readonly queryParameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    case_sensitive: cdktf.booleanToTerraform(struct!.caseSensitive),
    connect_matcher: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectMatcher),
    exact: cdktf.stringToTerraform(struct!.exact),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersToTerraform, false)(struct!.headers),
    methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.methods),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    query_parameters: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToTerraform, false)(struct!.queryParameters),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    case_sensitive: {
      value: cdktf.booleanToHclTerraform(struct!.caseSensitive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connect_matcher: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectMatcher),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersList",
    },
    methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.methods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_parameters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersToHclTerraform, false)(struct!.queryParameters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersList",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caseSensitive !== undefined) {
      hasAnyValues = true;
      internalValueResult.caseSensitive = this._caseSensitive;
    }
    if (this._connectMatcher !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectMatcher = this._connectMatcher;
    }
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._methods !== undefined) {
      hasAnyValues = true;
      internalValueResult.methods = this._methods;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._queryParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParameters = this._queryParameters?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caseSensitive = undefined;
      this._connectMatcher = undefined;
      this._exact = undefined;
      this._headers.internalValue = undefined;
      this._methods = undefined;
      this._prefix = undefined;
      this._queryParameters.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caseSensitive = value.caseSensitive;
      this._connectMatcher = value.connectMatcher;
      this._exact = value.exact;
      this._headers.internalValue = value.headers;
      this._methods = value.methods;
      this._prefix = value.prefix;
      this._queryParameters.internalValue = value.queryParameters;
      this._regex = value.regex;
    }
  }

  // case_sensitive - computed: false, optional: true, required: false
  private _caseSensitive?: boolean | cdktf.IResolvable; 
  public get caseSensitive() {
    return this.getBooleanAttribute('case_sensitive');
  }
  public set caseSensitive(value: boolean | cdktf.IResolvable) {
    this._caseSensitive = value;
  }
  public resetCaseSensitive() {
    this._caseSensitive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caseSensitiveInput() {
    return this._caseSensitive;
  }

  // connect_matcher - computed: false, optional: true, required: false
  private _connectMatcher?: { [key: string]: string }; 
  public get connectMatcher() {
    return this.getStringMapAttribute('connect_matcher');
  }
  public set connectMatcher(value: { [key: string]: string }) {
    this._connectMatcher = value;
  }
  public resetConnectMatcher() {
    this._connectMatcher = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectMatcherInput() {
    return this._connectMatcher;
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // methods - computed: false, optional: true, required: false
  private _methods?: string[]; 
  public get methods() {
    return this.getListAttribute('methods');
  }
  public set methods(value: string[]) {
    this._methods = value;
  }
  public resetMethods() {
    this._methods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodsInput() {
    return this._methods;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // query_parameters - computed: false, optional: true, required: false
  private _queryParameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParametersList(this, "query_parameters", false);
  public get queryParameters() {
    return this._queryParameters;
  }
  public putQueryParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherQueryParameters[] | cdktf.IResolvable) {
    this._queryParameters.internalValue = value;
  }
  public resetQueryParameters() {
    this._queryParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParametersInput() {
    return this._queryParameters.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#actions DataK8SGatewaySoloIoGatewayV1Manifest#actions}
  */
  readonly actions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#matcher DataK8SGatewaySoloIoGatewayV1Manifest#matcher}
  */
  readonly matcher?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsToTerraform, false)(struct!.actions),
    matcher: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherToTerraform(struct!.matcher),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsToHclTerraform, false)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsList",
    },
    matcher: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherToHclTerraform(struct!.matcher),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._matcher?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matcher = this._matcher?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions.internalValue = undefined;
      this._matcher.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions.internalValue = value.actions;
      this._matcher.internalValue = value.matcher;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // matcher - computed: false, optional: true, required: false
  private _matcher = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcherOutputReference(this, "matcher");
  public get matcher() {
    return this._matcher;
  }
  public putMatcher(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesMatcher) {
    this._matcher.internalValue = value;
  }
  public resetMatcher() {
    this._matcher.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matcherInput() {
    return this._matcher.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dlp_rules DataK8SGatewaySoloIoGatewayV1Manifest#dlp_rules}
  */
  readonly dlpRules?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#enabled_for DataK8SGatewaySoloIoGatewayV1Manifest#enabled_for}
  */
  readonly enabledFor?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dlp_rules: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesToTerraform, false)(struct!.dlpRules),
    enabled_for: cdktf.stringToTerraform(struct!.enabledFor),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dlp_rules: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesToHclTerraform, false)(struct!.dlpRules),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesList",
    },
    enabled_for: {
      value: cdktf.stringToHclTerraform(struct!.enabledFor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dlpRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dlpRules = this._dlpRules?.internalValue;
    }
    if (this._enabledFor !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabledFor = this._enabledFor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dlpRules.internalValue = undefined;
      this._enabledFor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dlpRules.internalValue = value.dlpRules;
      this._enabledFor = value.enabledFor;
    }
  }

  // dlp_rules - computed: false, optional: true, required: false
  private _dlpRules = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRulesList(this, "dlp_rules", false);
  public get dlpRules() {
    return this._dlpRules;
  }
  public putDlpRules(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpDlpRules[] | cdktf.IResolvable) {
    this._dlpRules.internalValue = value;
  }
  public resetDlpRules() {
    this._dlpRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dlpRulesInput() {
    return this._dlpRules.internalValue;
  }

  // enabled_for - computed: false, optional: true, required: false
  private _enabledFor?: string; 
  public get enabledFor() {
    return this.getStringAttribute('enabled_for');
  }
  public set enabledFor(value: string) {
    this._enabledFor = value;
  }
  public resetEnabledFor() {
    this._enabledFor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledForInput() {
    return this._enabledFor;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#no_default_search_domain DataK8SGatewaySoloIoGatewayV1Manifest#no_default_search_domain}
  */
  readonly noDefaultSearchDomain?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#use_tcp_for_dns_lookups DataK8SGatewaySoloIoGatewayV1Manifest#use_tcp_for_dns_lookups}
  */
  readonly useTcpForDnsLookups?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    no_default_search_domain: cdktf.booleanToTerraform(struct!.noDefaultSearchDomain),
    use_tcp_for_dns_lookups: cdktf.booleanToTerraform(struct!.useTcpForDnsLookups),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    no_default_search_domain: {
      value: cdktf.booleanToHclTerraform(struct!.noDefaultSearchDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_tcp_for_dns_lookups: {
      value: cdktf.booleanToHclTerraform(struct!.useTcpForDnsLookups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._noDefaultSearchDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.noDefaultSearchDomain = this._noDefaultSearchDomain;
    }
    if (this._useTcpForDnsLookups !== undefined) {
      hasAnyValues = true;
      internalValueResult.useTcpForDnsLookups = this._useTcpForDnsLookups;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._noDefaultSearchDomain = undefined;
      this._useTcpForDnsLookups = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._noDefaultSearchDomain = value.noDefaultSearchDomain;
      this._useTcpForDnsLookups = value.useTcpForDnsLookups;
    }
  }

  // no_default_search_domain - computed: false, optional: true, required: false
  private _noDefaultSearchDomain?: boolean | cdktf.IResolvable; 
  public get noDefaultSearchDomain() {
    return this.getBooleanAttribute('no_default_search_domain');
  }
  public set noDefaultSearchDomain(value: boolean | cdktf.IResolvable) {
    this._noDefaultSearchDomain = value;
  }
  public resetNoDefaultSearchDomain() {
    this._noDefaultSearchDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noDefaultSearchDomainInput() {
    return this._noDefaultSearchDomain;
  }

  // use_tcp_for_dns_lookups - computed: false, optional: true, required: false
  private _useTcpForDnsLookups?: boolean | cdktf.IResolvable; 
  public get useTcpForDnsLookups() {
    return this.getBooleanAttribute('use_tcp_for_dns_lookups');
  }
  public set useTcpForDnsLookups(value: boolean | cdktf.IResolvable) {
    this._useTcpForDnsLookups = value;
  }
  public resetUseTcpForDnsLookups() {
    this._useTcpForDnsLookups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useTcpForDnsLookupsInput() {
    return this._useTcpForDnsLookups;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path DataK8SGatewaySoloIoGatewayV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.numberToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.numberToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: number; 
  public get mode() {
    return this.getNumberAttribute('mode');
  }
  public set mode(value: number) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#address DataK8SGatewaySoloIoGatewayV1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ipv4_compat DataK8SGatewaySoloIoGatewayV1Manifest#ipv4_compat}
  */
  readonly ipv4Compat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#named_port DataK8SGatewaySoloIoGatewayV1Manifest#named_port}
  */
  readonly namedPort?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#port_value DataK8SGatewaySoloIoGatewayV1Manifest#port_value}
  */
  readonly portValue?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#protocol DataK8SGatewaySoloIoGatewayV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#resolver_name DataK8SGatewaySoloIoGatewayV1Manifest#resolver_name}
  */
  readonly resolverName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    ipv4_compat: cdktf.booleanToTerraform(struct!.ipv4Compat),
    named_port: cdktf.stringToTerraform(struct!.namedPort),
    port_value: cdktf.numberToTerraform(struct!.portValue),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    resolver_name: cdktf.stringToTerraform(struct!.resolverName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4_compat: {
      value: cdktf.booleanToHclTerraform(struct!.ipv4Compat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    named_port: {
      value: cdktf.stringToHclTerraform(struct!.namedPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_value: {
      value: cdktf.numberToHclTerraform(struct!.portValue),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resolver_name: {
      value: cdktf.stringToHclTerraform(struct!.resolverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._ipv4Compat !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4Compat = this._ipv4Compat;
    }
    if (this._namedPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.namedPort = this._namedPort;
    }
    if (this._portValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portValue = this._portValue;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._resolverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverName = this._resolverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._ipv4Compat = undefined;
      this._namedPort = undefined;
      this._portValue = undefined;
      this._protocol = undefined;
      this._resolverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._ipv4Compat = value.ipv4Compat;
      this._namedPort = value.namedPort;
      this._portValue = value.portValue;
      this._protocol = value.protocol;
      this._resolverName = value.resolverName;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // ipv4_compat - computed: false, optional: true, required: false
  private _ipv4Compat?: boolean | cdktf.IResolvable; 
  public get ipv4Compat() {
    return this.getBooleanAttribute('ipv4_compat');
  }
  public set ipv4Compat(value: boolean | cdktf.IResolvable) {
    this._ipv4Compat = value;
  }
  public resetIpv4Compat() {
    this._ipv4Compat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4CompatInput() {
    return this._ipv4Compat;
  }

  // named_port - computed: false, optional: true, required: false
  private _namedPort?: string; 
  public get namedPort() {
    return this.getStringAttribute('named_port');
  }
  public set namedPort(value: string) {
    this._namedPort = value;
  }
  public resetNamedPort() {
    this._namedPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namedPortInput() {
    return this._namedPort;
  }

  // port_value - computed: false, optional: true, required: false
  private _portValue?: number; 
  public get portValue() {
    return this.getNumberAttribute('port_value');
  }
  public set portValue(value: number) {
    this._portValue = value;
  }
  public resetPortValue() {
    this._portValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portValueInput() {
    return this._portValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // resolver_name - computed: false, optional: true, required: false
  private _resolverName?: string; 
  public get resolverName() {
    return this.getStringAttribute('resolver_name');
  }
  public set resolverName(value: string) {
    this._resolverName = value;
  }
  public resetResolverName() {
    this._resolverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverNameInput() {
    return this._resolverName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#pipe DataK8SGatewaySoloIoGatewayV1Manifest#pipe}
  */
  readonly pipe?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#socket_address DataK8SGatewaySoloIoGatewayV1Manifest#socket_address}
  */
  readonly socketAddress?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pipe: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToTerraform(struct!.pipe),
    socket_address: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToTerraform(struct!.socketAddress),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pipe: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeToHclTerraform(struct!.pipe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe",
    },
    socket_address: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressToHclTerraform(struct!.socketAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pipe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipe = this._pipe?.internalValue;
    }
    if (this._socketAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketAddress = this._socketAddress?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pipe.internalValue = undefined;
      this._socketAddress.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pipe.internalValue = value.pipe;
      this._socketAddress.internalValue = value.socketAddress;
    }
  }

  // pipe - computed: false, optional: true, required: false
  private _pipe = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipeOutputReference(this, "pipe");
  public get pipe() {
    return this._pipe;
  }
  public putPipe(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversPipe) {
    this._pipe.internalValue = value;
  }
  public resetPipe() {
    this._pipe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipeInput() {
    return this._pipe.internalValue;
  }

  // socket_address - computed: false, optional: true, required: false
  private _socketAddress = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddressOutputReference(this, "socket_address");
  public get socketAddress() {
    return this._socketAddress;
  }
  public putSocketAddress(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversSocketAddress) {
    this._socketAddress.internalValue = value;
  }
  public resetSocketAddress() {
    this._socketAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketAddressInput() {
    return this._socketAddress.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_resolver_options DataK8SGatewaySoloIoGatewayV1Manifest#dns_resolver_options}
  */
  readonly dnsResolverOptions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#resolvers DataK8SGatewaySoloIoGatewayV1Manifest#resolvers}
  */
  readonly resolvers?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dns_resolver_options: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToTerraform(struct!.dnsResolverOptions),
    resolvers: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToTerraform, false)(struct!.resolvers),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dns_resolver_options: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsToHclTerraform(struct!.dnsResolverOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions",
    },
    resolvers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversToHclTerraform, false)(struct!.resolvers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dnsResolverOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolverOptions = this._dnsResolverOptions?.internalValue;
    }
    if (this._resolvers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolvers = this._resolvers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dnsResolverOptions.internalValue = undefined;
      this._resolvers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dnsResolverOptions.internalValue = value.dnsResolverOptions;
      this._resolvers.internalValue = value.resolvers;
    }
  }

  // dns_resolver_options - computed: false, optional: true, required: false
  private _dnsResolverOptions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptionsOutputReference(this, "dns_resolver_options");
  public get dnsResolverOptions() {
    return this._dnsResolverOptions;
  }
  public putDnsResolverOptions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsDnsResolverOptions) {
    this._dnsResolverOptions.internalValue = value;
  }
  public resetDnsResolverOptions() {
    this._dnsResolverOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolverOptionsInput() {
    return this._dnsResolverOptions.internalValue;
  }

  // resolvers - computed: false, optional: true, required: false
  private _resolvers = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolversList(this, "resolvers", false);
  public get resolvers() {
    return this._resolvers;
  }
  public putResolvers(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsResolvers[] | cdktf.IResolvable) {
    this._resolvers.internalValue = value;
  }
  public resetResolvers() {
    this._resolvers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolversInput() {
    return this._resolvers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_pending_requests DataK8SGatewaySoloIoGatewayV1Manifest#max_pending_requests}
  */
  readonly maxPendingRequests?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_pending_requests: cdktf.numberToTerraform(struct!.maxPendingRequests),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_pending_requests: {
      value: cdktf.numberToHclTerraform(struct!.maxPendingRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxPendingRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPendingRequests = this._maxPendingRequests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxPendingRequests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxPendingRequests = value.maxPendingRequests;
    }
  }

  // max_pending_requests - computed: false, optional: true, required: false
  private _maxPendingRequests?: number; 
  public get maxPendingRequests() {
    return this.getNumberAttribute('max_pending_requests');
  }
  public set maxPendingRequests(value: number) {
    this._maxPendingRequests = value;
  }
  public resetMaxPendingRequests() {
    this._maxPendingRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPendingRequestsInput() {
    return this._maxPendingRequests;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#base_interval DataK8SGatewaySoloIoGatewayV1Manifest#base_interval}
  */
  readonly baseInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_interval DataK8SGatewaySoloIoGatewayV1Manifest#max_interval}
  */
  readonly maxInterval?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_interval: cdktf.stringToTerraform(struct!.baseInterval),
    max_interval: cdktf.stringToTerraform(struct!.maxInterval),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_interval: {
      value: cdktf.stringToHclTerraform(struct!.baseInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_interval: {
      value: cdktf.stringToHclTerraform(struct!.maxInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseInterval = this._baseInterval;
    }
    if (this._maxInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInterval = this._maxInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseInterval = undefined;
      this._maxInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseInterval = value.baseInterval;
      this._maxInterval = value.maxInterval;
    }
  }

  // base_interval - computed: false, optional: true, required: false
  private _baseInterval?: string; 
  public get baseInterval() {
    return this.getStringAttribute('base_interval');
  }
  public set baseInterval(value: string) {
    this._baseInterval = value;
  }
  public resetBaseInterval() {
    this._baseInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseIntervalInput() {
    return this._baseInterval;
  }

  // max_interval - computed: false, optional: true, required: false
  private _maxInterval?: string; 
  public get maxInterval() {
    return this.getStringAttribute('max_interval');
  }
  public set maxInterval(value: string) {
    this._maxInterval = value;
  }
  public resetMaxInterval() {
    this._maxInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIntervalInput() {
    return this._maxInterval;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#address DataK8SGatewaySoloIoGatewayV1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ipv4_compat DataK8SGatewaySoloIoGatewayV1Manifest#ipv4_compat}
  */
  readonly ipv4Compat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#named_port DataK8SGatewaySoloIoGatewayV1Manifest#named_port}
  */
  readonly namedPort?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#port_value DataK8SGatewaySoloIoGatewayV1Manifest#port_value}
  */
  readonly portValue?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#protocol DataK8SGatewaySoloIoGatewayV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#resolver_name DataK8SGatewaySoloIoGatewayV1Manifest#resolver_name}
  */
  readonly resolverName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    ipv4_compat: cdktf.booleanToTerraform(struct!.ipv4Compat),
    named_port: cdktf.stringToTerraform(struct!.namedPort),
    port_value: cdktf.numberToTerraform(struct!.portValue),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    resolver_name: cdktf.stringToTerraform(struct!.resolverName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv4_compat: {
      value: cdktf.booleanToHclTerraform(struct!.ipv4Compat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    named_port: {
      value: cdktf.stringToHclTerraform(struct!.namedPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_value: {
      value: cdktf.numberToHclTerraform(struct!.portValue),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resolver_name: {
      value: cdktf.stringToHclTerraform(struct!.resolverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._ipv4Compat !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv4Compat = this._ipv4Compat;
    }
    if (this._namedPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.namedPort = this._namedPort;
    }
    if (this._portValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portValue = this._portValue;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._resolverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverName = this._resolverName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._ipv4Compat = undefined;
      this._namedPort = undefined;
      this._portValue = undefined;
      this._protocol = undefined;
      this._resolverName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._ipv4Compat = value.ipv4Compat;
      this._namedPort = value.namedPort;
      this._portValue = value.portValue;
      this._protocol = value.protocol;
      this._resolverName = value.resolverName;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // ipv4_compat - computed: false, optional: true, required: false
  private _ipv4Compat?: boolean | cdktf.IResolvable; 
  public get ipv4Compat() {
    return this.getBooleanAttribute('ipv4_compat');
  }
  public set ipv4Compat(value: boolean | cdktf.IResolvable) {
    this._ipv4Compat = value;
  }
  public resetIpv4Compat() {
    this._ipv4Compat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv4CompatInput() {
    return this._ipv4Compat;
  }

  // named_port - computed: false, optional: true, required: false
  private _namedPort?: string; 
  public get namedPort() {
    return this.getStringAttribute('named_port');
  }
  public set namedPort(value: string) {
    this._namedPort = value;
  }
  public resetNamedPort() {
    this._namedPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namedPortInput() {
    return this._namedPort;
  }

  // port_value - computed: false, optional: true, required: false
  private _portValue?: number; 
  public get portValue() {
    return this.getNumberAttribute('port_value');
  }
  public set portValue(value: number) {
    this._portValue = value;
  }
  public resetPortValue() {
    this._portValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portValueInput() {
    return this._portValue;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // resolver_name - computed: false, optional: true, required: false
  private _resolverName?: string; 
  public get resolverName() {
    return this.getStringAttribute('resolver_name');
  }
  public set resolverName(value: string) {
    this._resolverName = value;
  }
  public resetResolverName() {
    this._resolverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverNameInput() {
    return this._resolverName;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#apple_dns DataK8SGatewaySoloIoGatewayV1Manifest#apple_dns}
  */
  readonly appleDns?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cares_dns DataK8SGatewaySoloIoGatewayV1Manifest#cares_dns}
  */
  readonly caresDns?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_cache_circuit_breaker DataK8SGatewaySoloIoGatewayV1Manifest#dns_cache_circuit_breaker}
  */
  readonly dnsCacheCircuitBreaker?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_failure_refresh_rate DataK8SGatewaySoloIoGatewayV1Manifest#dns_failure_refresh_rate}
  */
  readonly dnsFailureRefreshRate?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_lookup_family DataK8SGatewaySoloIoGatewayV1Manifest#dns_lookup_family}
  */
  readonly dnsLookupFamily?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_query_timeout DataK8SGatewaySoloIoGatewayV1Manifest#dns_query_timeout}
  */
  readonly dnsQueryTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_refresh_rate DataK8SGatewaySoloIoGatewayV1Manifest#dns_refresh_rate}
  */
  readonly dnsRefreshRate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#host_ttl DataK8SGatewaySoloIoGatewayV1Manifest#host_ttl}
  */
  readonly hostTtl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_hosts DataK8SGatewaySoloIoGatewayV1Manifest#max_hosts}
  */
  readonly maxHosts?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#preresolve_hostnames DataK8SGatewaySoloIoGatewayV1Manifest#preresolve_hostnames}
  */
  readonly preresolveHostnames?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apple_dns: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.appleDns),
    cares_dns: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToTerraform(struct!.caresDns),
    dns_cache_circuit_breaker: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToTerraform(struct!.dnsCacheCircuitBreaker),
    dns_failure_refresh_rate: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToTerraform(struct!.dnsFailureRefreshRate),
    dns_lookup_family: cdktf.stringToTerraform(struct!.dnsLookupFamily),
    dns_query_timeout: cdktf.stringToTerraform(struct!.dnsQueryTimeout),
    dns_refresh_rate: cdktf.stringToTerraform(struct!.dnsRefreshRate),
    host_ttl: cdktf.stringToTerraform(struct!.hostTtl),
    max_hosts: cdktf.numberToTerraform(struct!.maxHosts),
    preresolve_hostnames: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToTerraform, false)(struct!.preresolveHostnames),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apple_dns: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.appleDns),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cares_dns: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsToHclTerraform(struct!.caresDns),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns",
    },
    dns_cache_circuit_breaker: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerToHclTerraform(struct!.dnsCacheCircuitBreaker),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker",
    },
    dns_failure_refresh_rate: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateToHclTerraform(struct!.dnsFailureRefreshRate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate",
    },
    dns_lookup_family: {
      value: cdktf.stringToHclTerraform(struct!.dnsLookupFamily),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_query_timeout: {
      value: cdktf.stringToHclTerraform(struct!.dnsQueryTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_refresh_rate: {
      value: cdktf.stringToHclTerraform(struct!.dnsRefreshRate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_ttl: {
      value: cdktf.stringToHclTerraform(struct!.hostTtl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_hosts: {
      value: cdktf.numberToHclTerraform(struct!.maxHosts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    preresolve_hostnames: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesToHclTerraform, false)(struct!.preresolveHostnames),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appleDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.appleDns = this._appleDns;
    }
    if (this._caresDns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caresDns = this._caresDns?.internalValue;
    }
    if (this._dnsCacheCircuitBreaker?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsCacheCircuitBreaker = this._dnsCacheCircuitBreaker?.internalValue;
    }
    if (this._dnsFailureRefreshRate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsFailureRefreshRate = this._dnsFailureRefreshRate?.internalValue;
    }
    if (this._dnsLookupFamily !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsLookupFamily = this._dnsLookupFamily;
    }
    if (this._dnsQueryTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsQueryTimeout = this._dnsQueryTimeout;
    }
    if (this._dnsRefreshRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsRefreshRate = this._dnsRefreshRate;
    }
    if (this._hostTtl !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostTtl = this._hostTtl;
    }
    if (this._maxHosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxHosts = this._maxHosts;
    }
    if (this._preresolveHostnames?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preresolveHostnames = this._preresolveHostnames?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appleDns = undefined;
      this._caresDns.internalValue = undefined;
      this._dnsCacheCircuitBreaker.internalValue = undefined;
      this._dnsFailureRefreshRate.internalValue = undefined;
      this._dnsLookupFamily = undefined;
      this._dnsQueryTimeout = undefined;
      this._dnsRefreshRate = undefined;
      this._hostTtl = undefined;
      this._maxHosts = undefined;
      this._preresolveHostnames.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appleDns = value.appleDns;
      this._caresDns.internalValue = value.caresDns;
      this._dnsCacheCircuitBreaker.internalValue = value.dnsCacheCircuitBreaker;
      this._dnsFailureRefreshRate.internalValue = value.dnsFailureRefreshRate;
      this._dnsLookupFamily = value.dnsLookupFamily;
      this._dnsQueryTimeout = value.dnsQueryTimeout;
      this._dnsRefreshRate = value.dnsRefreshRate;
      this._hostTtl = value.hostTtl;
      this._maxHosts = value.maxHosts;
      this._preresolveHostnames.internalValue = value.preresolveHostnames;
    }
  }

  // apple_dns - computed: false, optional: true, required: false
  private _appleDns?: { [key: string]: string }; 
  public get appleDns() {
    return this.getStringMapAttribute('apple_dns');
  }
  public set appleDns(value: { [key: string]: string }) {
    this._appleDns = value;
  }
  public resetAppleDns() {
    this._appleDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appleDnsInput() {
    return this._appleDns;
  }

  // cares_dns - computed: false, optional: true, required: false
  private _caresDns = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDnsOutputReference(this, "cares_dns");
  public get caresDns() {
    return this._caresDns;
  }
  public putCaresDns(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigCaresDns) {
    this._caresDns.internalValue = value;
  }
  public resetCaresDns() {
    this._caresDns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caresDnsInput() {
    return this._caresDns.internalValue;
  }

  // dns_cache_circuit_breaker - computed: false, optional: true, required: false
  private _dnsCacheCircuitBreaker = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreakerOutputReference(this, "dns_cache_circuit_breaker");
  public get dnsCacheCircuitBreaker() {
    return this._dnsCacheCircuitBreaker;
  }
  public putDnsCacheCircuitBreaker(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsCacheCircuitBreaker) {
    this._dnsCacheCircuitBreaker.internalValue = value;
  }
  public resetDnsCacheCircuitBreaker() {
    this._dnsCacheCircuitBreaker.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsCacheCircuitBreakerInput() {
    return this._dnsCacheCircuitBreaker.internalValue;
  }

  // dns_failure_refresh_rate - computed: false, optional: true, required: false
  private _dnsFailureRefreshRate = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRateOutputReference(this, "dns_failure_refresh_rate");
  public get dnsFailureRefreshRate() {
    return this._dnsFailureRefreshRate;
  }
  public putDnsFailureRefreshRate(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigDnsFailureRefreshRate) {
    this._dnsFailureRefreshRate.internalValue = value;
  }
  public resetDnsFailureRefreshRate() {
    this._dnsFailureRefreshRate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsFailureRefreshRateInput() {
    return this._dnsFailureRefreshRate.internalValue;
  }

  // dns_lookup_family - computed: false, optional: true, required: false
  private _dnsLookupFamily?: string; 
  public get dnsLookupFamily() {
    return this.getStringAttribute('dns_lookup_family');
  }
  public set dnsLookupFamily(value: string) {
    this._dnsLookupFamily = value;
  }
  public resetDnsLookupFamily() {
    this._dnsLookupFamily = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsLookupFamilyInput() {
    return this._dnsLookupFamily;
  }

  // dns_query_timeout - computed: false, optional: true, required: false
  private _dnsQueryTimeout?: string; 
  public get dnsQueryTimeout() {
    return this.getStringAttribute('dns_query_timeout');
  }
  public set dnsQueryTimeout(value: string) {
    this._dnsQueryTimeout = value;
  }
  public resetDnsQueryTimeout() {
    this._dnsQueryTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsQueryTimeoutInput() {
    return this._dnsQueryTimeout;
  }

  // dns_refresh_rate - computed: false, optional: true, required: false
  private _dnsRefreshRate?: string; 
  public get dnsRefreshRate() {
    return this.getStringAttribute('dns_refresh_rate');
  }
  public set dnsRefreshRate(value: string) {
    this._dnsRefreshRate = value;
  }
  public resetDnsRefreshRate() {
    this._dnsRefreshRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsRefreshRateInput() {
    return this._dnsRefreshRate;
  }

  // host_ttl - computed: false, optional: true, required: false
  private _hostTtl?: string; 
  public get hostTtl() {
    return this.getStringAttribute('host_ttl');
  }
  public set hostTtl(value: string) {
    this._hostTtl = value;
  }
  public resetHostTtl() {
    this._hostTtl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostTtlInput() {
    return this._hostTtl;
  }

  // max_hosts - computed: false, optional: true, required: false
  private _maxHosts?: number; 
  public get maxHosts() {
    return this.getNumberAttribute('max_hosts');
  }
  public set maxHosts(value: number) {
    this._maxHosts = value;
  }
  public resetMaxHosts() {
    this._maxHosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxHostsInput() {
    return this._maxHosts;
  }

  // preresolve_hostnames - computed: false, optional: true, required: false
  private _preresolveHostnames = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnamesList(this, "preresolve_hostnames", false);
  public get preresolveHostnames() {
    return this._preresolveHostnames;
  }
  public putPreresolveHostnames(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigPreresolveHostnames[] | cdktf.IResolvable) {
    this._preresolveHostnames.internalValue = value;
  }
  public resetPreresolveHostnames() {
    this._preresolveHostnames.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preresolveHostnamesInput() {
    return this._preresolveHostnames.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cipher_suites DataK8SGatewaySoloIoGatewayV1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ecdh_curves DataK8SGatewaySoloIoGatewayV1Manifest#ecdh_curves}
  */
  readonly ecdhCurves?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#maximum_protocol_version DataK8SGatewaySoloIoGatewayV1Manifest#maximum_protocol_version}
  */
  readonly maximumProtocolVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#minimum_protocol_version DataK8SGatewaySoloIoGatewayV1Manifest#minimum_protocol_version}
  */
  readonly minimumProtocolVersion?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    ecdh_curves: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ecdhCurves),
    maximum_protocol_version: cdktf.stringToTerraform(struct!.maximumProtocolVersion),
    minimum_protocol_version: cdktf.stringToTerraform(struct!.minimumProtocolVersion),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ecdh_curves: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ecdhCurves),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    maximum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maximumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    minimum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minimumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._ecdhCurves !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecdhCurves = this._ecdhCurves;
    }
    if (this._maximumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumProtocolVersion = this._maximumProtocolVersion;
    }
    if (this._minimumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumProtocolVersion = this._minimumProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cipherSuites = undefined;
      this._ecdhCurves = undefined;
      this._maximumProtocolVersion = undefined;
      this._minimumProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cipherSuites = value.cipherSuites;
      this._ecdhCurves = value.ecdhCurves;
      this._maximumProtocolVersion = value.maximumProtocolVersion;
      this._minimumProtocolVersion = value.minimumProtocolVersion;
    }
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // ecdh_curves - computed: false, optional: true, required: false
  private _ecdhCurves?: string[]; 
  public get ecdhCurves() {
    return this.getListAttribute('ecdh_curves');
  }
  public set ecdhCurves(value: string[]) {
    this._ecdhCurves = value;
  }
  public resetEcdhCurves() {
    this._ecdhCurves = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecdhCurvesInput() {
    return this._ecdhCurves;
  }

  // maximum_protocol_version - computed: false, optional: true, required: false
  private _maximumProtocolVersion?: string; 
  public get maximumProtocolVersion() {
    return this.getStringAttribute('maximum_protocol_version');
  }
  public set maximumProtocolVersion(value: string) {
    this._maximumProtocolVersion = value;
  }
  public resetMaximumProtocolVersion() {
    this._maximumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumProtocolVersionInput() {
    return this._maximumProtocolVersion;
  }

  // minimum_protocol_version - computed: false, optional: true, required: false
  private _minimumProtocolVersion?: string; 
  public get minimumProtocolVersion() {
    return this.getStringAttribute('minimum_protocol_version');
  }
  public set minimumProtocolVersion(value: string) {
    this._minimumProtocolVersion = value;
  }
  public resetMinimumProtocolVersion() {
    this._minimumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumProtocolVersionInput() {
    return this._minimumProtocolVersion;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#token_file_name DataK8SGatewaySoloIoGatewayV1Manifest#token_file_name}
  */
  readonly tokenFileName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    token_file_name: cdktf.stringToTerraform(struct!.tokenFileName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_file_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._tokenFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenFileName = this._tokenFileName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._tokenFileName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._tokenFileName = value.tokenFileName;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // token_file_name - computed: false, optional: true, required: false
  private _tokenFileName?: string; 
  public get tokenFileName() {
    return this.getStringAttribute('token_file_name');
  }
  public set tokenFileName(value: string) {
    this._tokenFileName = value;
  }
  public resetTokenFileName() {
    this._tokenFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenFileNameInput() {
    return this._tokenFileName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#file_credential_source DataK8SGatewaySoloIoGatewayV1Manifest#file_credential_source}
  */
  readonly fileCredentialSource?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file_credential_source: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct!.fileCredentialSource),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file_credential_source: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct!.fileCredentialSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fileCredentialSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileCredentialSource = this._fileCredentialSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = value.fileCredentialSource;
    }
  }

  // file_credential_source - computed: false, optional: true, required: false
  private _fileCredentialSource = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSourceOutputReference(this, "file_credential_source");
  public get fileCredentialSource() {
    return this._fileCredentialSource;
  }
  public putFileCredentialSource(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsFileCredentialSource) {
    this._fileCredentialSource.internalValue = value;
  }
  public resetFileCredentialSource() {
    this._fileCredentialSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileCredentialSourceInput() {
    return this._fileCredentialSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#call_credentials DataK8SGatewaySoloIoGatewayV1Manifest#call_credentials}
  */
  readonly callCredentials?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#certificates_secret_name DataK8SGatewaySoloIoGatewayV1Manifest#certificates_secret_name}
  */
  readonly certificatesSecretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#target_uri DataK8SGatewaySoloIoGatewayV1Manifest#target_uri}
  */
  readonly targetUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#validation_context_name DataK8SGatewaySoloIoGatewayV1Manifest#validation_context_name}
  */
  readonly validationContextName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    call_credentials: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToTerraform(struct!.callCredentials),
    certificates_secret_name: cdktf.stringToTerraform(struct!.certificatesSecretName),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
    validation_context_name: cdktf.stringToTerraform(struct!.validationContextName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    call_credentials: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsToHclTerraform(struct!.callCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials",
    },
    certificates_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.certificatesSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validation_context_name: {
      value: cdktf.stringToHclTerraform(struct!.validationContextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._callCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.callCredentials = this._callCredentials?.internalValue;
    }
    if (this._certificatesSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesSecretName = this._certificatesSecretName;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    if (this._validationContextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationContextName = this._validationContextName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = undefined;
      this._certificatesSecretName = undefined;
      this._clusterName = undefined;
      this._targetUri = undefined;
      this._validationContextName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = value.callCredentials;
      this._certificatesSecretName = value.certificatesSecretName;
      this._clusterName = value.clusterName;
      this._targetUri = value.targetUri;
      this._validationContextName = value.validationContextName;
    }
  }

  // call_credentials - computed: false, optional: true, required: false
  private _callCredentials = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentialsOutputReference(this, "call_credentials");
  public get callCredentials() {
    return this._callCredentials;
  }
  public putCallCredentials(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsCallCredentials) {
    this._callCredentials.internalValue = value;
  }
  public resetCallCredentials() {
    this._callCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callCredentialsInput() {
    return this._callCredentials.internalValue;
  }

  // certificates_secret_name - computed: false, optional: true, required: false
  private _certificatesSecretName?: string; 
  public get certificatesSecretName() {
    return this.getStringAttribute('certificates_secret_name');
  }
  public set certificatesSecretName(value: string) {
    this._certificatesSecretName = value;
  }
  public resetCertificatesSecretName() {
    this._certificatesSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesSecretNameInput() {
    return this._certificatesSecretName;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }

  // validation_context_name - computed: false, optional: true, required: false
  private _validationContextName?: string; 
  public get validationContextName() {
    return this.getStringAttribute('validation_context_name');
  }
  public set validationContextName(value: string) {
    this._validationContextName = value;
  }
  public resetValidationContextName() {
    this._validationContextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationContextNameInput() {
    return this._validationContextName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ocsp_staple DataK8SGatewaySoloIoGatewayV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#root_ca DataK8SGatewaySoloIoGatewayV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tls_cert DataK8SGatewaySoloIoGatewayV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tls_key DataK8SGatewaySoloIoGatewayV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_renegotiation DataK8SGatewaySoloIoGatewayV1Manifest#allow_renegotiation}
  */
  readonly allowRenegotiation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#alpn_protocols DataK8SGatewaySoloIoGatewayV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#one_way_tls DataK8SGatewaySoloIoGatewayV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parameters DataK8SGatewaySoloIoGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sds DataK8SGatewaySoloIoGatewayV1Manifest#sds}
  */
  readonly sds?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#secret_ref DataK8SGatewaySoloIoGatewayV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sni DataK8SGatewaySoloIoGatewayV1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ssl_files DataK8SGatewaySoloIoGatewayV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#verify_subject_alt_name DataK8SGatewaySoloIoGatewayV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_renegotiation: cdktf.booleanToTerraform(struct!.allowRenegotiation),
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToTerraform(struct!.secretRef),
    sni: cdktf.stringToTerraform(struct!.sni),
    ssl_files: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToTerraform(struct!.sslFiles),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_renegotiation: {
      value: cdktf.booleanToHclTerraform(struct!.allowRenegotiation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters",
    },
    sds: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_files: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowRenegotiation !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRenegotiation = this._allowRenegotiation;
    }
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowRenegotiation = undefined;
      this._alpnProtocols = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sni = undefined;
      this._sslFiles.internalValue = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowRenegotiation = value.allowRenegotiation;
      this._alpnProtocols = value.alpnProtocols;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sni = value.sni;
      this._sslFiles.internalValue = value.sslFiles;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // allow_renegotiation - computed: false, optional: true, required: false
  private _allowRenegotiation?: boolean | cdktf.IResolvable; 
  public get allowRenegotiation() {
    return this.getBooleanAttribute('allow_renegotiation');
  }
  public set allowRenegotiation(value: boolean | cdktf.IResolvable) {
    this._allowRenegotiation = value;
  }
  public resetAllowRenegotiation() {
    this._allowRenegotiation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRenegotiationInput() {
    return this._allowRenegotiation;
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns_cache_config DataK8SGatewaySoloIoGatewayV1Manifest#dns_cache_config}
  */
  readonly dnsCacheConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#save_upstream_address DataK8SGatewaySoloIoGatewayV1Manifest#save_upstream_address}
  */
  readonly saveUpstreamAddress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ssl_config DataK8SGatewaySoloIoGatewayV1Manifest#ssl_config}
  */
  readonly sslConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dns_cache_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToTerraform(struct!.dnsCacheConfig),
    save_upstream_address: cdktf.booleanToTerraform(struct!.saveUpstreamAddress),
    ssl_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigToTerraform(struct!.sslConfig),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dns_cache_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigToHclTerraform(struct!.dnsCacheConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig",
    },
    save_upstream_address: {
      value: cdktf.booleanToHclTerraform(struct!.saveUpstreamAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ssl_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigToHclTerraform(struct!.sslConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dnsCacheConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsCacheConfig = this._dnsCacheConfig?.internalValue;
    }
    if (this._saveUpstreamAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.saveUpstreamAddress = this._saveUpstreamAddress;
    }
    if (this._sslConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslConfig = this._sslConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dnsCacheConfig.internalValue = undefined;
      this._saveUpstreamAddress = undefined;
      this._sslConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dnsCacheConfig.internalValue = value.dnsCacheConfig;
      this._saveUpstreamAddress = value.saveUpstreamAddress;
      this._sslConfig.internalValue = value.sslConfig;
    }
  }

  // dns_cache_config - computed: false, optional: true, required: false
  private _dnsCacheConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfigOutputReference(this, "dns_cache_config");
  public get dnsCacheConfig() {
    return this._dnsCacheConfig;
  }
  public putDnsCacheConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyDnsCacheConfig) {
    this._dnsCacheConfig.internalValue = value;
  }
  public resetDnsCacheConfig() {
    this._dnsCacheConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsCacheConfigInput() {
    return this._dnsCacheConfig.internalValue;
  }

  // save_upstream_address - computed: false, optional: true, required: false
  private _saveUpstreamAddress?: boolean | cdktf.IResolvable; 
  public get saveUpstreamAddress() {
    return this.getBooleanAttribute('save_upstream_address');
  }
  public set saveUpstreamAddress(value: boolean | cdktf.IResolvable) {
    this._saveUpstreamAddress = value;
  }
  public resetSaveUpstreamAddress() {
    this._saveUpstreamAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saveUpstreamAddressInput() {
    return this._saveUpstreamAddress;
  }

  // ssl_config - computed: false, optional: true, required: false
  private _sslConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfigOutputReference(this, "ssl_config");
  public get sslConfig() {
    return this._sslConfig;
  }
  public putSslConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxySslConfig) {
    this._sslConfig.internalValue = value;
  }
  public resetSslConfig() {
    this._sslConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslConfigInput() {
    return this._sslConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#predicate DataK8SGatewaySoloIoGatewayV1Manifest#predicate}
  */
  readonly predicate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stage DataK8SGatewaySoloIoGatewayV1Manifest#stage}
  */
  readonly stage?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStageToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    predicate: cdktf.stringToTerraform(struct!.predicate),
    stage: cdktf.stringToTerraform(struct!.stage),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStageToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    predicate: {
      value: cdktf.stringToHclTerraform(struct!.predicate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage: {
      value: cdktf.stringToHclTerraform(struct!.stage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._predicate !== undefined) {
      hasAnyValues = true;
      internalValueResult.predicate = this._predicate;
    }
    if (this._stage !== undefined) {
      hasAnyValues = true;
      internalValueResult.stage = this._stage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._predicate = undefined;
      this._stage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._predicate = value.predicate;
      this._stage = value.stage;
    }
  }

  // predicate - computed: false, optional: true, required: false
  private _predicate?: string; 
  public get predicate() {
    return this.getStringAttribute('predicate');
  }
  public set predicate(value: string) {
    this._predicate = value;
  }
  public resetPredicate() {
    this._predicate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get predicateInput() {
    return this._predicate;
  }

  // stage - computed: false, optional: true, required: false
  private _stage?: string; 
  public get stage() {
    return this.getStringAttribute('stage');
  }
  public set stage(value: string) {
    this._stage = value;
  }
  public resetStage() {
    this._stage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stageInput() {
    return this._stage;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#suffix DataK8SGatewaySoloIoGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#patterns DataK8SGatewaySoloIoGatewayV1Manifest#patterns}
  */
  readonly patterns?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    patterns: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToTerraform, false)(struct!.patterns),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    patterns: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsToHclTerraform, false)(struct!.patterns),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._patterns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patterns = this._patterns?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._patterns.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._patterns.internalValue = value.patterns;
    }
  }

  // patterns - computed: false, optional: true, required: false
  private _patterns = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatternsList(this, "patterns", false);
  public get patterns() {
    return this._patterns;
  }
  public putPatterns(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersPatterns[] | cdktf.IResolvable) {
    this._patterns.internalValue = value;
  }
  public resetPatterns() {
    this._patterns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternsInput() {
    return this._patterns.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#exact DataK8SGatewaySoloIoGatewayV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_case DataK8SGatewaySoloIoGatewayV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix DataK8SGatewaySoloIoGatewayV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#safe_regex DataK8SGatewaySoloIoGatewayV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#suffix DataK8SGatewaySoloIoGatewayV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#patterns DataK8SGatewaySoloIoGatewayV1Manifest#patterns}
  */
  readonly patterns?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    patterns: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToTerraform, false)(struct!.patterns),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    patterns: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsToHclTerraform, false)(struct!.patterns),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._patterns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patterns = this._patterns?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._patterns.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._patterns.internalValue = value.patterns;
    }
  }

  // patterns - computed: false, optional: true, required: false
  private _patterns = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatternsList(this, "patterns", false);
  public get patterns() {
    return this._patterns;
  }
  public putPatterns(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersPatterns[] | cdktf.IResolvable) {
    this._patterns.internalValue = value;
  }
  public resetPatterns() {
    this._patterns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternsInput() {
    return this._patterns.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_headers DataK8SGatewaySoloIoGatewayV1Manifest#allowed_headers}
  */
  readonly allowedHeaders?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disallowed_headers DataK8SGatewaySoloIoGatewayV1Manifest#disallowed_headers}
  */
  readonly disallowedHeaders?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToTerraform(struct!.allowedHeaders),
    disallowed_headers: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToTerraform(struct!.disallowedHeaders),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersToHclTerraform(struct!.allowedHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders",
    },
    disallowed_headers: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersToHclTerraform(struct!.disallowedHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedHeaders = this._allowedHeaders?.internalValue;
    }
    if (this._disallowedHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowedHeaders = this._disallowedHeaders?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedHeaders.internalValue = undefined;
      this._disallowedHeaders.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedHeaders.internalValue = value.allowedHeaders;
      this._disallowedHeaders.internalValue = value.disallowedHeaders;
    }
  }

  // allowed_headers - computed: false, optional: true, required: false
  private _allowedHeaders = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeadersOutputReference(this, "allowed_headers");
  public get allowedHeaders() {
    return this._allowedHeaders;
  }
  public putAllowedHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesAllowedHeaders) {
    this._allowedHeaders.internalValue = value;
  }
  public resetAllowedHeaders() {
    this._allowedHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedHeadersInput() {
    return this._allowedHeaders.internalValue;
  }

  // disallowed_headers - computed: false, optional: true, required: false
  private _disallowedHeaders = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeadersOutputReference(this, "disallowed_headers");
  public get disallowedHeaders() {
    return this._disallowedHeaders;
  }
  public putDisallowedHeaders(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesDisallowedHeaders) {
    this._disallowedHeaders.internalValue = value;
  }
  public resetDisallowedHeaders() {
    this._disallowedHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowedHeadersInput() {
    return this._disallowedHeaders.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#base_interval DataK8SGatewaySoloIoGatewayV1Manifest#base_interval}
  */
  readonly baseInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_interval DataK8SGatewaySoloIoGatewayV1Manifest#max_interval}
  */
  readonly maxInterval?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_interval: cdktf.stringToTerraform(struct!.baseInterval),
    max_interval: cdktf.stringToTerraform(struct!.maxInterval),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_interval: {
      value: cdktf.stringToHclTerraform(struct!.baseInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_interval: {
      value: cdktf.stringToHclTerraform(struct!.maxInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseInterval = this._baseInterval;
    }
    if (this._maxInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInterval = this._maxInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseInterval = undefined;
      this._maxInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseInterval = value.baseInterval;
      this._maxInterval = value.maxInterval;
    }
  }

  // base_interval - computed: false, optional: true, required: false
  private _baseInterval?: string; 
  public get baseInterval() {
    return this.getStringAttribute('base_interval');
  }
  public set baseInterval(value: string) {
    this._baseInterval = value;
  }
  public resetBaseInterval() {
    this._baseInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseIntervalInput() {
    return this._baseInterval;
  }

  // max_interval - computed: false, optional: true, required: false
  private _maxInterval?: string; 
  public get maxInterval() {
    return this.getStringAttribute('max_interval');
  }
  public set maxInterval(value: string) {
    this._maxInterval = value;
  }
  public resetMaxInterval() {
    this._maxInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIntervalInput() {
    return this._maxInterval;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#num_retries DataK8SGatewaySoloIoGatewayV1Manifest#num_retries}
  */
  readonly numRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#retry_back_off DataK8SGatewaySoloIoGatewayV1Manifest#retry_back_off}
  */
  readonly retryBackOff?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    num_retries: cdktf.numberToTerraform(struct!.numRetries),
    retry_back_off: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToTerraform(struct!.retryBackOff),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    num_retries: {
      value: cdktf.numberToHclTerraform(struct!.numRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_back_off: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct!.retryBackOff),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._numRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.numRetries = this._numRetries;
    }
    if (this._retryBackOff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryBackOff = this._retryBackOff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._numRetries = undefined;
      this._retryBackOff.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._numRetries = value.numRetries;
      this._retryBackOff.internalValue = value.retryBackOff;
    }
  }

  // num_retries - computed: false, optional: true, required: false
  private _numRetries?: number; 
  public get numRetries() {
    return this.getNumberAttribute('num_retries');
  }
  public set numRetries(value: number) {
    this._numRetries = value;
  }
  public resetNumRetries() {
    this._numRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numRetriesInput() {
    return this._numRetries;
  }

  // retry_back_off - computed: false, optional: true, required: false
  private _retryBackOff = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOffOutputReference(this, "retry_back_off");
  public get retryBackOff() {
    return this._retryBackOff;
  }
  public putRetryBackOff(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyRetryBackOff) {
    this._retryBackOff.internalValue = value;
  }
  public resetRetryBackOff() {
    this._retryBackOff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryBackOffInput() {
    return this._retryBackOff.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#authority DataK8SGatewaySoloIoGatewayV1Manifest#authority}
  */
  readonly authority?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ext_proc_server_ref DataK8SGatewaySoloIoGatewayV1Manifest#ext_proc_server_ref}
  */
  readonly extProcServerRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#initial_metadata DataK8SGatewaySoloIoGatewayV1Manifest#initial_metadata}
  */
  readonly initialMetadata?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#retry_policy DataK8SGatewaySoloIoGatewayV1Manifest#retry_policy}
  */
  readonly retryPolicy?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#timeout DataK8SGatewaySoloIoGatewayV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
    ext_proc_server_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToTerraform(struct!.extProcServerRef),
    initial_metadata: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToTerraform, false)(struct!.initialMetadata),
    retry_policy: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToTerraform(struct!.retryPolicy),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ext_proc_server_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefToHclTerraform(struct!.extProcServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef",
    },
    initial_metadata: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataToHclTerraform, false)(struct!.initialMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataList",
    },
    retry_policy: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyToHclTerraform(struct!.retryPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    if (this._extProcServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extProcServerRef = this._extProcServerRef?.internalValue;
    }
    if (this._initialMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialMetadata = this._initialMetadata?.internalValue;
    }
    if (this._retryPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryPolicy = this._retryPolicy?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
      this._extProcServerRef.internalValue = undefined;
      this._initialMetadata.internalValue = undefined;
      this._retryPolicy.internalValue = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
      this._extProcServerRef.internalValue = value.extProcServerRef;
      this._initialMetadata.internalValue = value.initialMetadata;
      this._retryPolicy.internalValue = value.retryPolicy;
      this._timeout = value.timeout;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }

  // ext_proc_server_ref - computed: false, optional: true, required: false
  private _extProcServerRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRefOutputReference(this, "ext_proc_server_ref");
  public get extProcServerRef() {
    return this._extProcServerRef;
  }
  public putExtProcServerRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceExtProcServerRef) {
    this._extProcServerRef.internalValue = value;
  }
  public resetExtProcServerRef() {
    this._extProcServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extProcServerRefInput() {
    return this._extProcServerRef.internalValue;
  }

  // initial_metadata - computed: false, optional: true, required: false
  private _initialMetadata = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadataList(this, "initial_metadata", false);
  public get initialMetadata() {
    return this._initialMetadata;
  }
  public putInitialMetadata(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceInitialMetadata[] | cdktf.IResolvable) {
    this._initialMetadata.internalValue = value;
  }
  public resetInitialMetadata() {
    this._initialMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialMetadataInput() {
    return this._initialMetadata.internalValue;
  }

  // retry_policy - computed: false, optional: true, required: false
  private _retryPolicy = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicyOutputReference(this, "retry_policy");
  public get retryPolicy() {
    return this._retryPolicy;
  }
  public putRetryPolicy(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceRetryPolicy) {
    this._retryPolicy.internalValue = value;
  }
  public resetRetryPolicy() {
    this._retryPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryPolicyInput() {
    return this._retryPolicy.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_program_size DataK8SGatewaySoloIoGatewayV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#google_re2 DataK8SGatewaySoloIoGatewayV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_all_routing DataK8SGatewaySoloIoGatewayV1Manifest#allow_all_routing}
  */
  readonly allowAllRouting?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_envoy DataK8SGatewaySoloIoGatewayV1Manifest#allow_envoy}
  */
  readonly allowEnvoy?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_expression DataK8SGatewaySoloIoGatewayV1Manifest#allow_expression}
  */
  readonly allowExpression?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disallow_all DataK8SGatewaySoloIoGatewayV1Manifest#disallow_all}
  */
  readonly disallowAll?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disallow_expression DataK8SGatewaySoloIoGatewayV1Manifest#disallow_expression}
  */
  readonly disallowExpression?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disallow_is_error DataK8SGatewaySoloIoGatewayV1Manifest#disallow_is_error}
  */
  readonly disallowIsError?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disallow_system DataK8SGatewaySoloIoGatewayV1Manifest#disallow_system}
  */
  readonly disallowSystem?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_all_routing: cdktf.booleanToTerraform(struct!.allowAllRouting),
    allow_envoy: cdktf.booleanToTerraform(struct!.allowEnvoy),
    allow_expression: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionToTerraform(struct!.allowExpression),
    disallow_all: cdktf.booleanToTerraform(struct!.disallowAll),
    disallow_expression: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToTerraform(struct!.disallowExpression),
    disallow_is_error: cdktf.booleanToTerraform(struct!.disallowIsError),
    disallow_system: cdktf.booleanToTerraform(struct!.disallowSystem),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_all_routing: {
      value: cdktf.booleanToHclTerraform(struct!.allowAllRouting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_envoy: {
      value: cdktf.booleanToHclTerraform(struct!.allowEnvoy),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_expression: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionToHclTerraform(struct!.allowExpression),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression",
    },
    disallow_all: {
      value: cdktf.booleanToHclTerraform(struct!.disallowAll),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disallow_expression: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionToHclTerraform(struct!.disallowExpression),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression",
    },
    disallow_is_error: {
      value: cdktf.booleanToHclTerraform(struct!.disallowIsError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disallow_system: {
      value: cdktf.booleanToHclTerraform(struct!.disallowSystem),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowAllRouting !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowAllRouting = this._allowAllRouting;
    }
    if (this._allowEnvoy !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowEnvoy = this._allowEnvoy;
    }
    if (this._allowExpression?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowExpression = this._allowExpression?.internalValue;
    }
    if (this._disallowAll !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowAll = this._disallowAll;
    }
    if (this._disallowExpression?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowExpression = this._disallowExpression?.internalValue;
    }
    if (this._disallowIsError !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowIsError = this._disallowIsError;
    }
    if (this._disallowSystem !== undefined) {
      hasAnyValues = true;
      internalValueResult.disallowSystem = this._disallowSystem;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowAllRouting = undefined;
      this._allowEnvoy = undefined;
      this._allowExpression.internalValue = undefined;
      this._disallowAll = undefined;
      this._disallowExpression.internalValue = undefined;
      this._disallowIsError = undefined;
      this._disallowSystem = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowAllRouting = value.allowAllRouting;
      this._allowEnvoy = value.allowEnvoy;
      this._allowExpression.internalValue = value.allowExpression;
      this._disallowAll = value.disallowAll;
      this._disallowExpression.internalValue = value.disallowExpression;
      this._disallowIsError = value.disallowIsError;
      this._disallowSystem = value.disallowSystem;
    }
  }

  // allow_all_routing - computed: false, optional: true, required: false
  private _allowAllRouting?: boolean | cdktf.IResolvable; 
  public get allowAllRouting() {
    return this.getBooleanAttribute('allow_all_routing');
  }
  public set allowAllRouting(value: boolean | cdktf.IResolvable) {
    this._allowAllRouting = value;
  }
  public resetAllowAllRouting() {
    this._allowAllRouting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowAllRoutingInput() {
    return this._allowAllRouting;
  }

  // allow_envoy - computed: false, optional: true, required: false
  private _allowEnvoy?: boolean | cdktf.IResolvable; 
  public get allowEnvoy() {
    return this.getBooleanAttribute('allow_envoy');
  }
  public set allowEnvoy(value: boolean | cdktf.IResolvable) {
    this._allowEnvoy = value;
  }
  public resetAllowEnvoy() {
    this._allowEnvoy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowEnvoyInput() {
    return this._allowEnvoy;
  }

  // allow_expression - computed: false, optional: true, required: false
  private _allowExpression = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpressionOutputReference(this, "allow_expression");
  public get allowExpression() {
    return this._allowExpression;
  }
  public putAllowExpression(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesAllowExpression) {
    this._allowExpression.internalValue = value;
  }
  public resetAllowExpression() {
    this._allowExpression.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowExpressionInput() {
    return this._allowExpression.internalValue;
  }

  // disallow_all - computed: false, optional: true, required: false
  private _disallowAll?: boolean | cdktf.IResolvable; 
  public get disallowAll() {
    return this.getBooleanAttribute('disallow_all');
  }
  public set disallowAll(value: boolean | cdktf.IResolvable) {
    this._disallowAll = value;
  }
  public resetDisallowAll() {
    this._disallowAll = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowAllInput() {
    return this._disallowAll;
  }

  // disallow_expression - computed: false, optional: true, required: false
  private _disallowExpression = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpressionOutputReference(this, "disallow_expression");
  public get disallowExpression() {
    return this._disallowExpression;
  }
  public putDisallowExpression(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesDisallowExpression) {
    this._disallowExpression.internalValue = value;
  }
  public resetDisallowExpression() {
    this._disallowExpression.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowExpressionInput() {
    return this._disallowExpression.internalValue;
  }

  // disallow_is_error - computed: false, optional: true, required: false
  private _disallowIsError?: boolean | cdktf.IResolvable; 
  public get disallowIsError() {
    return this.getBooleanAttribute('disallow_is_error');
  }
  public set disallowIsError(value: boolean | cdktf.IResolvable) {
    this._disallowIsError = value;
  }
  public resetDisallowIsError() {
    this._disallowIsError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowIsErrorInput() {
    return this._disallowIsError;
  }

  // disallow_system - computed: false, optional: true, required: false
  private _disallowSystem?: boolean | cdktf.IResolvable; 
  public get disallowSystem() {
    return this.getBooleanAttribute('disallow_system');
  }
  public set disallowSystem(value: boolean | cdktf.IResolvable) {
    this._disallowSystem = value;
  }
  public resetDisallowSystem() {
    this._disallowSystem = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disallowSystemInput() {
    return this._disallowSystem;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_body_mode DataK8SGatewaySoloIoGatewayV1Manifest#request_body_mode}
  */
  readonly requestBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_header_mode DataK8SGatewaySoloIoGatewayV1Manifest#request_header_mode}
  */
  readonly requestHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_trailer_mode DataK8SGatewaySoloIoGatewayV1Manifest#request_trailer_mode}
  */
  readonly requestTrailerMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_body_mode DataK8SGatewaySoloIoGatewayV1Manifest#response_body_mode}
  */
  readonly responseBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_header_mode DataK8SGatewaySoloIoGatewayV1Manifest#response_header_mode}
  */
  readonly responseHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_trailer_mode DataK8SGatewaySoloIoGatewayV1Manifest#response_trailer_mode}
  */
  readonly responseTrailerMode?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingModeToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_body_mode: cdktf.stringToTerraform(struct!.requestBodyMode),
    request_header_mode: cdktf.stringToTerraform(struct!.requestHeaderMode),
    request_trailer_mode: cdktf.stringToTerraform(struct!.requestTrailerMode),
    response_body_mode: cdktf.stringToTerraform(struct!.responseBodyMode),
    response_header_mode: cdktf.stringToTerraform(struct!.responseHeaderMode),
    response_trailer_mode: cdktf.stringToTerraform(struct!.responseTrailerMode),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingModeToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestBodyMode = this._requestBodyMode;
    }
    if (this._requestHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaderMode = this._requestHeaderMode;
    }
    if (this._requestTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTrailerMode = this._requestTrailerMode;
    }
    if (this._responseBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseBodyMode = this._responseBodyMode;
    }
    if (this._responseHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeaderMode = this._responseHeaderMode;
    }
    if (this._responseTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTrailerMode = this._responseTrailerMode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestBodyMode = undefined;
      this._requestHeaderMode = undefined;
      this._requestTrailerMode = undefined;
      this._responseBodyMode = undefined;
      this._responseHeaderMode = undefined;
      this._responseTrailerMode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestBodyMode = value.requestBodyMode;
      this._requestHeaderMode = value.requestHeaderMode;
      this._requestTrailerMode = value.requestTrailerMode;
      this._responseBodyMode = value.responseBodyMode;
      this._responseHeaderMode = value.responseHeaderMode;
      this._responseTrailerMode = value.responseTrailerMode;
    }
  }

  // request_body_mode - computed: false, optional: true, required: false
  private _requestBodyMode?: string; 
  public get requestBodyMode() {
    return this.getStringAttribute('request_body_mode');
  }
  public set requestBodyMode(value: string) {
    this._requestBodyMode = value;
  }
  public resetRequestBodyMode() {
    this._requestBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestBodyModeInput() {
    return this._requestBodyMode;
  }

  // request_header_mode - computed: false, optional: true, required: false
  private _requestHeaderMode?: string; 
  public get requestHeaderMode() {
    return this.getStringAttribute('request_header_mode');
  }
  public set requestHeaderMode(value: string) {
    this._requestHeaderMode = value;
  }
  public resetRequestHeaderMode() {
    this._requestHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeaderModeInput() {
    return this._requestHeaderMode;
  }

  // request_trailer_mode - computed: false, optional: true, required: false
  private _requestTrailerMode?: string; 
  public get requestTrailerMode() {
    return this.getStringAttribute('request_trailer_mode');
  }
  public set requestTrailerMode(value: string) {
    this._requestTrailerMode = value;
  }
  public resetRequestTrailerMode() {
    this._requestTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTrailerModeInput() {
    return this._requestTrailerMode;
  }

  // response_body_mode - computed: false, optional: true, required: false
  private _responseBodyMode?: string; 
  public get responseBodyMode() {
    return this.getStringAttribute('response_body_mode');
  }
  public set responseBodyMode(value: string) {
    this._responseBodyMode = value;
  }
  public resetResponseBodyMode() {
    this._responseBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseBodyModeInput() {
    return this._responseBodyMode;
  }

  // response_header_mode - computed: false, optional: true, required: false
  private _responseHeaderMode?: string; 
  public get responseHeaderMode() {
    return this.getStringAttribute('response_header_mode');
  }
  public set responseHeaderMode(value: string) {
    this._responseHeaderMode = value;
  }
  public resetResponseHeaderMode() {
    this._responseHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeaderModeInput() {
    return this._responseHeaderMode;
  }

  // response_trailer_mode - computed: false, optional: true, required: false
  private _responseTrailerMode?: string; 
  public get responseTrailerMode() {
    return this.getStringAttribute('response_trailer_mode');
  }
  public set responseTrailerMode(value: string) {
    this._responseTrailerMode = value;
  }
  public resetResponseTrailerMode() {
    this._responseTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTrailerModeInput() {
    return this._responseTrailerMode;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_mode_override DataK8SGatewaySoloIoGatewayV1Manifest#allow_mode_override}
  */
  readonly allowModeOverride?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#async_mode DataK8SGatewaySoloIoGatewayV1Manifest#async_mode}
  */
  readonly asyncMode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable_clear_route_cache DataK8SGatewaySoloIoGatewayV1Manifest#disable_clear_route_cache}
  */
  readonly disableClearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#failure_mode_allow DataK8SGatewaySoloIoGatewayV1Manifest#failure_mode_allow}
  */
  readonly failureModeAllow?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#filter_metadata DataK8SGatewaySoloIoGatewayV1Manifest#filter_metadata}
  */
  readonly filterMetadata?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#filter_stage DataK8SGatewaySoloIoGatewayV1Manifest#filter_stage}
  */
  readonly filterStage?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#forward_rules DataK8SGatewaySoloIoGatewayV1Manifest#forward_rules}
  */
  readonly forwardRules?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_message_timeout DataK8SGatewaySoloIoGatewayV1Manifest#max_message_timeout}
  */
  readonly maxMessageTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#message_timeout DataK8SGatewaySoloIoGatewayV1Manifest#message_timeout}
  */
  readonly messageTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_context_namespaces DataK8SGatewaySoloIoGatewayV1Manifest#metadata_context_namespaces}
  */
  readonly metadataContextNamespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mutation_rules DataK8SGatewaySoloIoGatewayV1Manifest#mutation_rules}
  */
  readonly mutationRules?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#processing_mode DataK8SGatewaySoloIoGatewayV1Manifest#processing_mode}
  */
  readonly processingMode?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_attributes DataK8SGatewaySoloIoGatewayV1Manifest#request_attributes}
  */
  readonly requestAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_attributes DataK8SGatewaySoloIoGatewayV1Manifest#response_attributes}
  */
  readonly responseAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stat_prefix DataK8SGatewaySoloIoGatewayV1Manifest#stat_prefix}
  */
  readonly statPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#typed_metadata_context_namespaces DataK8SGatewaySoloIoGatewayV1Manifest#typed_metadata_context_namespaces}
  */
  readonly typedMetadataContextNamespaces?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_mode_override: cdktf.booleanToTerraform(struct!.allowModeOverride),
    async_mode: cdktf.booleanToTerraform(struct!.asyncMode),
    disable_clear_route_cache: cdktf.booleanToTerraform(struct!.disableClearRouteCache),
    failure_mode_allow: cdktf.booleanToTerraform(struct!.failureModeAllow),
    filter_metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.filterMetadata),
    filter_stage: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStageToTerraform(struct!.filterStage),
    forward_rules: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesToTerraform(struct!.forwardRules),
    grpc_service: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceToTerraform(struct!.grpcService),
    max_message_timeout: cdktf.stringToTerraform(struct!.maxMessageTimeout),
    message_timeout: cdktf.stringToTerraform(struct!.messageTimeout),
    metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metadataContextNamespaces),
    mutation_rules: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesToTerraform(struct!.mutationRules),
    processing_mode: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingModeToTerraform(struct!.processingMode),
    request_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestAttributes),
    response_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseAttributes),
    stat_prefix: cdktf.stringToTerraform(struct!.statPrefix),
    typed_metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.typedMetadataContextNamespaces),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_mode_override: {
      value: cdktf.booleanToHclTerraform(struct!.allowModeOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    async_mode: {
      value: cdktf.booleanToHclTerraform(struct!.asyncMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disable_clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.disableClearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    failure_mode_allow: {
      value: cdktf.booleanToHclTerraform(struct!.failureModeAllow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    filter_metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.filterMetadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    filter_stage: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStageToHclTerraform(struct!.filterStage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage",
    },
    forward_rules: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesToHclTerraform(struct!.forwardRules),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService",
    },
    max_message_timeout: {
      value: cdktf.stringToHclTerraform(struct!.maxMessageTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_timeout: {
      value: cdktf.stringToHclTerraform(struct!.messageTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mutation_rules: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesToHclTerraform(struct!.mutationRules),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules",
    },
    processing_mode: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingModeToHclTerraform(struct!.processingMode),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode",
    },
    request_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    stat_prefix: {
      value: cdktf.stringToHclTerraform(struct!.statPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    typed_metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.typedMetadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowModeOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowModeOverride = this._allowModeOverride;
    }
    if (this._asyncMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncMode = this._asyncMode;
    }
    if (this._disableClearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableClearRouteCache = this._disableClearRouteCache;
    }
    if (this._failureModeAllow !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureModeAllow = this._failureModeAllow;
    }
    if (this._filterMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterMetadata = this._filterMetadata;
    }
    if (this._filterStage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterStage = this._filterStage?.internalValue;
    }
    if (this._forwardRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardRules = this._forwardRules?.internalValue;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._maxMessageTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessageTimeout = this._maxMessageTimeout;
    }
    if (this._messageTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageTimeout = this._messageTimeout;
    }
    if (this._metadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataContextNamespaces = this._metadataContextNamespaces;
    }
    if (this._mutationRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mutationRules = this._mutationRules?.internalValue;
    }
    if (this._processingMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processingMode = this._processingMode?.internalValue;
    }
    if (this._requestAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestAttributes = this._requestAttributes;
    }
    if (this._responseAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseAttributes = this._responseAttributes;
    }
    if (this._statPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.statPrefix = this._statPrefix;
    }
    if (this._typedMetadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.typedMetadataContextNamespaces = this._typedMetadataContextNamespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowModeOverride = undefined;
      this._asyncMode = undefined;
      this._disableClearRouteCache = undefined;
      this._failureModeAllow = undefined;
      this._filterMetadata = undefined;
      this._filterStage.internalValue = undefined;
      this._forwardRules.internalValue = undefined;
      this._grpcService.internalValue = undefined;
      this._maxMessageTimeout = undefined;
      this._messageTimeout = undefined;
      this._metadataContextNamespaces = undefined;
      this._mutationRules.internalValue = undefined;
      this._processingMode.internalValue = undefined;
      this._requestAttributes = undefined;
      this._responseAttributes = undefined;
      this._statPrefix = undefined;
      this._typedMetadataContextNamespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowModeOverride = value.allowModeOverride;
      this._asyncMode = value.asyncMode;
      this._disableClearRouteCache = value.disableClearRouteCache;
      this._failureModeAllow = value.failureModeAllow;
      this._filterMetadata = value.filterMetadata;
      this._filterStage.internalValue = value.filterStage;
      this._forwardRules.internalValue = value.forwardRules;
      this._grpcService.internalValue = value.grpcService;
      this._maxMessageTimeout = value.maxMessageTimeout;
      this._messageTimeout = value.messageTimeout;
      this._metadataContextNamespaces = value.metadataContextNamespaces;
      this._mutationRules.internalValue = value.mutationRules;
      this._processingMode.internalValue = value.processingMode;
      this._requestAttributes = value.requestAttributes;
      this._responseAttributes = value.responseAttributes;
      this._statPrefix = value.statPrefix;
      this._typedMetadataContextNamespaces = value.typedMetadataContextNamespaces;
    }
  }

  // allow_mode_override - computed: false, optional: true, required: false
  private _allowModeOverride?: boolean | cdktf.IResolvable; 
  public get allowModeOverride() {
    return this.getBooleanAttribute('allow_mode_override');
  }
  public set allowModeOverride(value: boolean | cdktf.IResolvable) {
    this._allowModeOverride = value;
  }
  public resetAllowModeOverride() {
    this._allowModeOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowModeOverrideInput() {
    return this._allowModeOverride;
  }

  // async_mode - computed: false, optional: true, required: false
  private _asyncMode?: boolean | cdktf.IResolvable; 
  public get asyncMode() {
    return this.getBooleanAttribute('async_mode');
  }
  public set asyncMode(value: boolean | cdktf.IResolvable) {
    this._asyncMode = value;
  }
  public resetAsyncMode() {
    this._asyncMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncModeInput() {
    return this._asyncMode;
  }

  // disable_clear_route_cache - computed: false, optional: true, required: false
  private _disableClearRouteCache?: boolean | cdktf.IResolvable; 
  public get disableClearRouteCache() {
    return this.getBooleanAttribute('disable_clear_route_cache');
  }
  public set disableClearRouteCache(value: boolean | cdktf.IResolvable) {
    this._disableClearRouteCache = value;
  }
  public resetDisableClearRouteCache() {
    this._disableClearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableClearRouteCacheInput() {
    return this._disableClearRouteCache;
  }

  // failure_mode_allow - computed: false, optional: true, required: false
  private _failureModeAllow?: boolean | cdktf.IResolvable; 
  public get failureModeAllow() {
    return this.getBooleanAttribute('failure_mode_allow');
  }
  public set failureModeAllow(value: boolean | cdktf.IResolvable) {
    this._failureModeAllow = value;
  }
  public resetFailureModeAllow() {
    this._failureModeAllow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureModeAllowInput() {
    return this._failureModeAllow;
  }

  // filter_metadata - computed: false, optional: true, required: false
  private _filterMetadata?: { [key: string]: string }; 
  public get filterMetadata() {
    return this.getStringMapAttribute('filter_metadata');
  }
  public set filterMetadata(value: { [key: string]: string }) {
    this._filterMetadata = value;
  }
  public resetFilterMetadata() {
    this._filterMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterMetadataInput() {
    return this._filterMetadata;
  }

  // filter_stage - computed: false, optional: true, required: false
  private _filterStage = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStageOutputReference(this, "filter_stage");
  public get filterStage() {
    return this._filterStage;
  }
  public putFilterStage(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcFilterStage) {
    this._filterStage.internalValue = value;
  }
  public resetFilterStage() {
    this._filterStage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterStageInput() {
    return this._filterStage.internalValue;
  }

  // forward_rules - computed: false, optional: true, required: false
  private _forwardRules = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRulesOutputReference(this, "forward_rules");
  public get forwardRules() {
    return this._forwardRules;
  }
  public putForwardRules(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcForwardRules) {
    this._forwardRules.internalValue = value;
  }
  public resetForwardRules() {
    this._forwardRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardRulesInput() {
    return this._forwardRules.internalValue;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // max_message_timeout - computed: false, optional: true, required: false
  private _maxMessageTimeout?: string; 
  public get maxMessageTimeout() {
    return this.getStringAttribute('max_message_timeout');
  }
  public set maxMessageTimeout(value: string) {
    this._maxMessageTimeout = value;
  }
  public resetMaxMessageTimeout() {
    this._maxMessageTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessageTimeoutInput() {
    return this._maxMessageTimeout;
  }

  // message_timeout - computed: false, optional: true, required: false
  private _messageTimeout?: string; 
  public get messageTimeout() {
    return this.getStringAttribute('message_timeout');
  }
  public set messageTimeout(value: string) {
    this._messageTimeout = value;
  }
  public resetMessageTimeout() {
    this._messageTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageTimeoutInput() {
    return this._messageTimeout;
  }

  // metadata_context_namespaces - computed: false, optional: true, required: false
  private _metadataContextNamespaces?: string[]; 
  public get metadataContextNamespaces() {
    return this.getListAttribute('metadata_context_namespaces');
  }
  public set metadataContextNamespaces(value: string[]) {
    this._metadataContextNamespaces = value;
  }
  public resetMetadataContextNamespaces() {
    this._metadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataContextNamespacesInput() {
    return this._metadataContextNamespaces;
  }

  // mutation_rules - computed: false, optional: true, required: false
  private _mutationRules = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRulesOutputReference(this, "mutation_rules");
  public get mutationRules() {
    return this._mutationRules;
  }
  public putMutationRules(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcMutationRules) {
    this._mutationRules.internalValue = value;
  }
  public resetMutationRules() {
    this._mutationRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mutationRulesInput() {
    return this._mutationRules.internalValue;
  }

  // processing_mode - computed: false, optional: true, required: false
  private _processingMode = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingModeOutputReference(this, "processing_mode");
  public get processingMode() {
    return this._processingMode;
  }
  public putProcessingMode(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcProcessingMode) {
    this._processingMode.internalValue = value;
  }
  public resetProcessingMode() {
    this._processingMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processingModeInput() {
    return this._processingMode.internalValue;
  }

  // request_attributes - computed: false, optional: true, required: false
  private _requestAttributes?: string[]; 
  public get requestAttributes() {
    return this.getListAttribute('request_attributes');
  }
  public set requestAttributes(value: string[]) {
    this._requestAttributes = value;
  }
  public resetRequestAttributes() {
    this._requestAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestAttributesInput() {
    return this._requestAttributes;
  }

  // response_attributes - computed: false, optional: true, required: false
  private _responseAttributes?: string[]; 
  public get responseAttributes() {
    return this.getListAttribute('response_attributes');
  }
  public set responseAttributes(value: string[]) {
    this._responseAttributes = value;
  }
  public resetResponseAttributes() {
    this._responseAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseAttributesInput() {
    return this._responseAttributes;
  }

  // stat_prefix - computed: false, optional: true, required: false
  private _statPrefix?: string; 
  public get statPrefix() {
    return this.getStringAttribute('stat_prefix');
  }
  public set statPrefix(value: string) {
    this._statPrefix = value;
  }
  public resetStatPrefix() {
    this._statPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statPrefixInput() {
    return this._statPrefix;
  }

  // typed_metadata_context_namespaces - computed: false, optional: true, required: false
  private _typedMetadataContextNamespaces?: string[]; 
  public get typedMetadataContextNamespaces() {
    return this.getListAttribute('typed_metadata_context_namespaces');
  }
  public set typedMetadataContextNamespaces(value: string[]) {
    this._typedMetadataContextNamespaces = value;
  }
  public resetTypedMetadataContextNamespaces() {
    this._typedMetadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typedMetadataContextNamespacesInput() {
    return this._typedMetadataContextNamespaces;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#authority DataK8SGatewaySoloIoGatewayV1Manifest#authority}
  */
  readonly authority?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_headers DataK8SGatewaySoloIoGatewayV1Manifest#allowed_headers}
  */
  readonly allowedHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_headers_regex DataK8SGatewaySoloIoGatewayV1Manifest#allowed_headers_regex}
  */
  readonly allowedHeadersRegex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_add DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_add}
  */
  readonly headersToAdd?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequestToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedHeaders),
    allowed_headers_regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedHeadersRegex),
    headers_to_add: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headersToAdd),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequestToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_headers_regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedHeadersRegex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    headers_to_add: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headersToAdd),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedHeaders = this._allowedHeaders;
    }
    if (this._allowedHeadersRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedHeadersRegex = this._allowedHeadersRegex;
    }
    if (this._headersToAdd !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAdd = this._headersToAdd;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedHeaders = undefined;
      this._allowedHeadersRegex = undefined;
      this._headersToAdd = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedHeaders = value.allowedHeaders;
      this._allowedHeadersRegex = value.allowedHeadersRegex;
      this._headersToAdd = value.headersToAdd;
    }
  }

  // allowed_headers - computed: false, optional: true, required: false
  private _allowedHeaders?: string[]; 
  public get allowedHeaders() {
    return this.getListAttribute('allowed_headers');
  }
  public set allowedHeaders(value: string[]) {
    this._allowedHeaders = value;
  }
  public resetAllowedHeaders() {
    this._allowedHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedHeadersInput() {
    return this._allowedHeaders;
  }

  // allowed_headers_regex - computed: false, optional: true, required: false
  private _allowedHeadersRegex?: string[]; 
  public get allowedHeadersRegex() {
    return this.getListAttribute('allowed_headers_regex');
  }
  public set allowedHeadersRegex(value: string[]) {
    this._allowedHeadersRegex = value;
  }
  public resetAllowedHeadersRegex() {
    this._allowedHeadersRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedHeadersRegexInput() {
    return this._allowedHeadersRegex;
  }

  // headers_to_add - computed: false, optional: true, required: false
  private _headersToAdd?: { [key: string]: string }; 
  public get headersToAdd() {
    return this.getStringMapAttribute('headers_to_add');
  }
  public set headersToAdd(value: { [key: string]: string }) {
    this._headersToAdd = value;
  }
  public resetHeadersToAdd() {
    this._headersToAdd = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAddInput() {
    return this._headersToAdd;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_client_headers DataK8SGatewaySoloIoGatewayV1Manifest#allowed_client_headers}
  */
  readonly allowedClientHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_upstream_headers DataK8SGatewaySoloIoGatewayV1Manifest#allowed_upstream_headers}
  */
  readonly allowedUpstreamHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allowed_upstream_headers_to_append DataK8SGatewaySoloIoGatewayV1Manifest#allowed_upstream_headers_to_append}
  */
  readonly allowedUpstreamHeadersToAppend?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponseToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_client_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedClientHeaders),
    allowed_upstream_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedUpstreamHeaders),
    allowed_upstream_headers_to_append: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedUpstreamHeadersToAppend),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponseToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_client_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedClientHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_upstream_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedUpstreamHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_upstream_headers_to_append: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedUpstreamHeadersToAppend),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedClientHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedClientHeaders = this._allowedClientHeaders;
    }
    if (this._allowedUpstreamHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedUpstreamHeaders = this._allowedUpstreamHeaders;
    }
    if (this._allowedUpstreamHeadersToAppend !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedUpstreamHeadersToAppend = this._allowedUpstreamHeadersToAppend;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedClientHeaders = undefined;
      this._allowedUpstreamHeaders = undefined;
      this._allowedUpstreamHeadersToAppend = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedClientHeaders = value.allowedClientHeaders;
      this._allowedUpstreamHeaders = value.allowedUpstreamHeaders;
      this._allowedUpstreamHeadersToAppend = value.allowedUpstreamHeadersToAppend;
    }
  }

  // allowed_client_headers - computed: false, optional: true, required: false
  private _allowedClientHeaders?: string[]; 
  public get allowedClientHeaders() {
    return this.getListAttribute('allowed_client_headers');
  }
  public set allowedClientHeaders(value: string[]) {
    this._allowedClientHeaders = value;
  }
  public resetAllowedClientHeaders() {
    this._allowedClientHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedClientHeadersInput() {
    return this._allowedClientHeaders;
  }

  // allowed_upstream_headers - computed: false, optional: true, required: false
  private _allowedUpstreamHeaders?: string[]; 
  public get allowedUpstreamHeaders() {
    return this.getListAttribute('allowed_upstream_headers');
  }
  public set allowedUpstreamHeaders(value: string[]) {
    this._allowedUpstreamHeaders = value;
  }
  public resetAllowedUpstreamHeaders() {
    this._allowedUpstreamHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedUpstreamHeadersInput() {
    return this._allowedUpstreamHeaders;
  }

  // allowed_upstream_headers_to_append - computed: false, optional: true, required: false
  private _allowedUpstreamHeadersToAppend?: string[]; 
  public get allowedUpstreamHeadersToAppend() {
    return this.getListAttribute('allowed_upstream_headers_to_append');
  }
  public set allowedUpstreamHeadersToAppend(value: string[]) {
    this._allowedUpstreamHeadersToAppend = value;
  }
  public resetAllowedUpstreamHeadersToAppend() {
    this._allowedUpstreamHeadersToAppend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedUpstreamHeadersToAppendInput() {
    return this._allowedUpstreamHeadersToAppend;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path_prefix DataK8SGatewaySoloIoGatewayV1Manifest#path_prefix}
  */
  readonly pathPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request DataK8SGatewaySoloIoGatewayV1Manifest#request}
  */
  readonly request?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response DataK8SGatewaySoloIoGatewayV1Manifest#response}
  */
  readonly response?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path_prefix: cdktf.stringToTerraform(struct!.pathPrefix),
    request: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequestToTerraform(struct!.request),
    response: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponseToTerraform(struct!.response),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path_prefix: {
      value: cdktf.stringToHclTerraform(struct!.pathPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest",
    },
    response: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponseToHclTerraform(struct!.response),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pathPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathPrefix = this._pathPrefix;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    if (this._response?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.response = this._response?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pathPrefix = undefined;
      this._request.internalValue = undefined;
      this._response.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pathPrefix = value.pathPrefix;
      this._request.internalValue = value.request;
      this._response.internalValue = value.response;
    }
  }

  // path_prefix - computed: false, optional: true, required: false
  private _pathPrefix?: string; 
  public get pathPrefix() {
    return this.getStringAttribute('path_prefix');
  }
  public set pathPrefix(value: string) {
    this._pathPrefix = value;
  }
  public resetPathPrefix() {
    this._pathPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathPrefixInput() {
    return this._pathPrefix;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }

  // response - computed: false, optional: true, required: false
  private _response = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponseOutputReference(this, "response");
  public get response() {
    return this._response;
  }
  public putResponse(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceResponse) {
    this._response.internalValue = value;
  }
  public resetResponse() {
    this._response.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseInput() {
    return this._response.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_partial_message DataK8SGatewaySoloIoGatewayV1Manifest#allow_partial_message}
  */
  readonly allowPartialMessage?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_request_bytes DataK8SGatewaySoloIoGatewayV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#pack_as_bytes DataK8SGatewaySoloIoGatewayV1Manifest#pack_as_bytes}
  */
  readonly packAsBytes?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_partial_message: cdktf.booleanToTerraform(struct!.allowPartialMessage),
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
    pack_as_bytes: cdktf.booleanToTerraform(struct!.packAsBytes),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_partial_message: {
      value: cdktf.booleanToHclTerraform(struct!.allowPartialMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pack_as_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.packAsBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowPartialMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowPartialMessage = this._allowPartialMessage;
    }
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    if (this._packAsBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.packAsBytes = this._packAsBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowPartialMessage = undefined;
      this._maxRequestBytes = undefined;
      this._packAsBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowPartialMessage = value.allowPartialMessage;
      this._maxRequestBytes = value.maxRequestBytes;
      this._packAsBytes = value.packAsBytes;
    }
  }

  // allow_partial_message - computed: false, optional: true, required: false
  private _allowPartialMessage?: boolean | cdktf.IResolvable; 
  public get allowPartialMessage() {
    return this.getBooleanAttribute('allow_partial_message');
  }
  public set allowPartialMessage(value: boolean | cdktf.IResolvable) {
    this._allowPartialMessage = value;
  }
  public resetAllowPartialMessage() {
    this._allowPartialMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowPartialMessageInput() {
    return this._allowPartialMessage;
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }

  // pack_as_bytes - computed: false, optional: true, required: false
  private _packAsBytes?: boolean | cdktf.IResolvable; 
  public get packAsBytes() {
    return this.getBooleanAttribute('pack_as_bytes');
  }
  public set packAsBytes(value: boolean | cdktf.IResolvable) {
    this._packAsBytes = value;
  }
  public resetPackAsBytes() {
    this._packAsBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packAsBytesInput() {
    return this._packAsBytes;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#clear_route_cache DataK8SGatewaySoloIoGatewayV1Manifest#clear_route_cache}
  */
  readonly clearRouteCache?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extauthz_server_ref DataK8SGatewaySoloIoGatewayV1Manifest#extauthz_server_ref}
  */
  readonly extauthzServerRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#failure_mode_allow DataK8SGatewaySoloIoGatewayV1Manifest#failure_mode_allow}
  */
  readonly failureModeAllow?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http_service DataK8SGatewaySoloIoGatewayV1Manifest#http_service}
  */
  readonly httpService?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_body DataK8SGatewaySoloIoGatewayV1Manifest#request_body}
  */
  readonly requestBody?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_timeout DataK8SGatewaySoloIoGatewayV1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stat_prefix DataK8SGatewaySoloIoGatewayV1Manifest#stat_prefix}
  */
  readonly statPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#status_on_error DataK8SGatewaySoloIoGatewayV1Manifest#status_on_error}
  */
  readonly statusOnError?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transport_api_version DataK8SGatewaySoloIoGatewayV1Manifest#transport_api_version}
  */
  readonly transportApiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#user_id_header DataK8SGatewaySoloIoGatewayV1Manifest#user_id_header}
  */
  readonly userIdHeader?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clear_route_cache: cdktf.booleanToTerraform(struct!.clearRouteCache),
    extauthz_server_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRefToTerraform(struct!.extauthzServerRef),
    failure_mode_allow: cdktf.booleanToTerraform(struct!.failureModeAllow),
    grpc_service: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcServiceToTerraform(struct!.grpcService),
    http_service: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceToTerraform(struct!.httpService),
    request_body: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBodyToTerraform(struct!.requestBody),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
    stat_prefix: cdktf.stringToTerraform(struct!.statPrefix),
    status_on_error: cdktf.numberToTerraform(struct!.statusOnError),
    transport_api_version: cdktf.stringToTerraform(struct!.transportApiVersion),
    user_id_header: cdktf.stringToTerraform(struct!.userIdHeader),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clear_route_cache: {
      value: cdktf.booleanToHclTerraform(struct!.clearRouteCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extauthz_server_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRefToHclTerraform(struct!.extauthzServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef",
    },
    failure_mode_allow: {
      value: cdktf.booleanToHclTerraform(struct!.failureModeAllow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService",
    },
    http_service: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceToHclTerraform(struct!.httpService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService",
    },
    request_body: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBodyToHclTerraform(struct!.requestBody),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stat_prefix: {
      value: cdktf.stringToHclTerraform(struct!.statPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_on_error: {
      value: cdktf.numberToHclTerraform(struct!.statusOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    transport_api_version: {
      value: cdktf.stringToHclTerraform(struct!.transportApiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_id_header: {
      value: cdktf.stringToHclTerraform(struct!.userIdHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clearRouteCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.clearRouteCache = this._clearRouteCache;
    }
    if (this._extauthzServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extauthzServerRef = this._extauthzServerRef?.internalValue;
    }
    if (this._failureModeAllow !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureModeAllow = this._failureModeAllow;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._httpService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpService = this._httpService?.internalValue;
    }
    if (this._requestBody?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestBody = this._requestBody?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._statPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.statPrefix = this._statPrefix;
    }
    if (this._statusOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusOnError = this._statusOnError;
    }
    if (this._transportApiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.transportApiVersion = this._transportApiVersion;
    }
    if (this._userIdHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.userIdHeader = this._userIdHeader;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clearRouteCache = undefined;
      this._extauthzServerRef.internalValue = undefined;
      this._failureModeAllow = undefined;
      this._grpcService.internalValue = undefined;
      this._httpService.internalValue = undefined;
      this._requestBody.internalValue = undefined;
      this._requestTimeout = undefined;
      this._statPrefix = undefined;
      this._statusOnError = undefined;
      this._transportApiVersion = undefined;
      this._userIdHeader = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clearRouteCache = value.clearRouteCache;
      this._extauthzServerRef.internalValue = value.extauthzServerRef;
      this._failureModeAllow = value.failureModeAllow;
      this._grpcService.internalValue = value.grpcService;
      this._httpService.internalValue = value.httpService;
      this._requestBody.internalValue = value.requestBody;
      this._requestTimeout = value.requestTimeout;
      this._statPrefix = value.statPrefix;
      this._statusOnError = value.statusOnError;
      this._transportApiVersion = value.transportApiVersion;
      this._userIdHeader = value.userIdHeader;
    }
  }

  // clear_route_cache - computed: false, optional: true, required: false
  private _clearRouteCache?: boolean | cdktf.IResolvable; 
  public get clearRouteCache() {
    return this.getBooleanAttribute('clear_route_cache');
  }
  public set clearRouteCache(value: boolean | cdktf.IResolvable) {
    this._clearRouteCache = value;
  }
  public resetClearRouteCache() {
    this._clearRouteCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clearRouteCacheInput() {
    return this._clearRouteCache;
  }

  // extauthz_server_ref - computed: false, optional: true, required: false
  private _extauthzServerRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRefOutputReference(this, "extauthz_server_ref");
  public get extauthzServerRef() {
    return this._extauthzServerRef;
  }
  public putExtauthzServerRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthExtauthzServerRef) {
    this._extauthzServerRef.internalValue = value;
  }
  public resetExtauthzServerRef() {
    this._extauthzServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extauthzServerRefInput() {
    return this._extauthzServerRef.internalValue;
  }

  // failure_mode_allow - computed: false, optional: true, required: false
  private _failureModeAllow?: boolean | cdktf.IResolvable; 
  public get failureModeAllow() {
    return this.getBooleanAttribute('failure_mode_allow');
  }
  public set failureModeAllow(value: boolean | cdktf.IResolvable) {
    this._failureModeAllow = value;
  }
  public resetFailureModeAllow() {
    this._failureModeAllow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureModeAllowInput() {
    return this._failureModeAllow;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // http_service - computed: false, optional: true, required: false
  private _httpService = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpServiceOutputReference(this, "http_service");
  public get httpService() {
    return this._httpService;
  }
  public putHttpService(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthHttpService) {
    this._httpService.internalValue = value;
  }
  public resetHttpService() {
    this._httpService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpServiceInput() {
    return this._httpService.internalValue;
  }

  // request_body - computed: false, optional: true, required: false
  private _requestBody = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBodyOutputReference(this, "request_body");
  public get requestBody() {
    return this._requestBody;
  }
  public putRequestBody(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthRequestBody) {
    this._requestBody.internalValue = value;
  }
  public resetRequestBody() {
    this._requestBody.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestBodyInput() {
    return this._requestBody.internalValue;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // stat_prefix - computed: false, optional: true, required: false
  private _statPrefix?: string; 
  public get statPrefix() {
    return this.getStringAttribute('stat_prefix');
  }
  public set statPrefix(value: string) {
    this._statPrefix = value;
  }
  public resetStatPrefix() {
    this._statPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statPrefixInput() {
    return this._statPrefix;
  }

  // status_on_error - computed: false, optional: true, required: false
  private _statusOnError?: number; 
  public get statusOnError() {
    return this.getNumberAttribute('status_on_error');
  }
  public set statusOnError(value: number) {
    this._statusOnError = value;
  }
  public resetStatusOnError() {
    this._statusOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusOnErrorInput() {
    return this._statusOnError;
  }

  // transport_api_version - computed: false, optional: true, required: false
  private _transportApiVersion?: string; 
  public get transportApiVersion() {
    return this.getStringAttribute('transport_api_version');
  }
  public set transportApiVersion(value: string) {
    this._transportApiVersion = value;
  }
  public resetTransportApiVersion() {
    this._transportApiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportApiVersionInput() {
    return this._transportApiVersion;
  }

  // user_id_header - computed: false, optional: true, required: false
  private _userIdHeader?: string; 
  public get userIdHeader() {
    return this.getStringAttribute('user_id_header');
  }
  public set userIdHeader(value: string) {
    this._userIdHeader = value;
  }
  public resetUserIdHeader() {
    this._userIdHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userIdHeaderInput() {
    return this._userIdHeader;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#configs DataK8SGatewaySoloIoGatewayV1Manifest#configs}
  */
  readonly configs?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configs: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.configs),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configs: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.configs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configs !== undefined) {
      hasAnyValues = true;
      internalValueResult.configs = this._configs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configs = value.configs;
    }
  }

  // configs - computed: false, optional: true, required: false
  private _configs?: { [key: string]: string }; 
  public get configs() {
    return this.getStringMapAttribute('configs');
  }
  public set configs(value: { [key: string]: string }) {
    this._configs = value;
  }
  public resetConfigs() {
    this._configs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configsInput() {
    return this._configs;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#add_whitespace DataK8SGatewaySoloIoGatewayV1Manifest#add_whitespace}
  */
  readonly addWhitespace?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#always_print_enums_as_ints DataK8SGatewaySoloIoGatewayV1Manifest#always_print_enums_as_ints}
  */
  readonly alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#always_print_primitive_fields DataK8SGatewaySoloIoGatewayV1Manifest#always_print_primitive_fields}
  */
  readonly alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#preserve_proto_field_names DataK8SGatewaySoloIoGatewayV1Manifest#preserve_proto_field_names}
  */
  readonly preserveProtoFieldNames?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_whitespace: cdktf.booleanToTerraform(struct!.addWhitespace),
    always_print_enums_as_ints: cdktf.booleanToTerraform(struct!.alwaysPrintEnumsAsInts),
    always_print_primitive_fields: cdktf.booleanToTerraform(struct!.alwaysPrintPrimitiveFields),
    preserve_proto_field_names: cdktf.booleanToTerraform(struct!.preserveProtoFieldNames),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_whitespace: {
      value: cdktf.booleanToHclTerraform(struct!.addWhitespace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_enums_as_ints: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintEnumsAsInts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_primitive_fields: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintPrimitiveFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_proto_field_names: {
      value: cdktf.booleanToHclTerraform(struct!.preserveProtoFieldNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addWhitespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.addWhitespace = this._addWhitespace;
    }
    if (this._alwaysPrintEnumsAsInts !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintEnumsAsInts = this._alwaysPrintEnumsAsInts;
    }
    if (this._alwaysPrintPrimitiveFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintPrimitiveFields = this._alwaysPrintPrimitiveFields;
    }
    if (this._preserveProtoFieldNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveProtoFieldNames = this._preserveProtoFieldNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addWhitespace = undefined;
      this._alwaysPrintEnumsAsInts = undefined;
      this._alwaysPrintPrimitiveFields = undefined;
      this._preserveProtoFieldNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addWhitespace = value.addWhitespace;
      this._alwaysPrintEnumsAsInts = value.alwaysPrintEnumsAsInts;
      this._alwaysPrintPrimitiveFields = value.alwaysPrintPrimitiveFields;
      this._preserveProtoFieldNames = value.preserveProtoFieldNames;
    }
  }

  // add_whitespace - computed: false, optional: true, required: false
  private _addWhitespace?: boolean | cdktf.IResolvable; 
  public get addWhitespace() {
    return this.getBooleanAttribute('add_whitespace');
  }
  public set addWhitespace(value: boolean | cdktf.IResolvable) {
    this._addWhitespace = value;
  }
  public resetAddWhitespace() {
    this._addWhitespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addWhitespaceInput() {
    return this._addWhitespace;
  }

  // always_print_enums_as_ints - computed: false, optional: true, required: false
  private _alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable; 
  public get alwaysPrintEnumsAsInts() {
    return this.getBooleanAttribute('always_print_enums_as_ints');
  }
  public set alwaysPrintEnumsAsInts(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintEnumsAsInts = value;
  }
  public resetAlwaysPrintEnumsAsInts() {
    this._alwaysPrintEnumsAsInts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintEnumsAsIntsInput() {
    return this._alwaysPrintEnumsAsInts;
  }

  // always_print_primitive_fields - computed: false, optional: true, required: false
  private _alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable; 
  public get alwaysPrintPrimitiveFields() {
    return this.getBooleanAttribute('always_print_primitive_fields');
  }
  public set alwaysPrintPrimitiveFields(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintPrimitiveFields = value;
  }
  public resetAlwaysPrintPrimitiveFields() {
    this._alwaysPrintPrimitiveFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintPrimitiveFieldsInput() {
    return this._alwaysPrintPrimitiveFields;
  }

  // preserve_proto_field_names - computed: false, optional: true, required: false
  private _preserveProtoFieldNames?: boolean | cdktf.IResolvable; 
  public get preserveProtoFieldNames() {
    return this.getBooleanAttribute('preserve_proto_field_names');
  }
  public set preserveProtoFieldNames(value: boolean | cdktf.IResolvable) {
    this._preserveProtoFieldNames = value;
  }
  public resetPreserveProtoFieldNames() {
    this._preserveProtoFieldNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveProtoFieldNamesInput() {
    return this._preserveProtoFieldNames;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#config_map_ref DataK8SGatewaySoloIoGatewayV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct!.configMapRef),
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._key = value.key;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#auto_mapping DataK8SGatewaySoloIoGatewayV1Manifest#auto_mapping}
  */
  readonly autoMapping?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#convert_grpc_status DataK8SGatewaySoloIoGatewayV1Manifest#convert_grpc_status}
  */
  readonly convertGrpcStatus?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignore_unknown_query_parameters DataK8SGatewaySoloIoGatewayV1Manifest#ignore_unknown_query_parameters}
  */
  readonly ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ignored_query_parameters DataK8SGatewaySoloIoGatewayV1Manifest#ignored_query_parameters}
  */
  readonly ignoredQueryParameters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#match_incoming_request_route DataK8SGatewaySoloIoGatewayV1Manifest#match_incoming_request_route}
  */
  readonly matchIncomingRequestRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#print_options DataK8SGatewaySoloIoGatewayV1Manifest#print_options}
  */
  readonly printOptions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#proto_descriptor DataK8SGatewaySoloIoGatewayV1Manifest#proto_descriptor}
  */
  readonly protoDescriptor?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#proto_descriptor_bin DataK8SGatewaySoloIoGatewayV1Manifest#proto_descriptor_bin}
  */
  readonly protoDescriptorBin?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#proto_descriptor_config_map DataK8SGatewaySoloIoGatewayV1Manifest#proto_descriptor_config_map}
  */
  readonly protoDescriptorConfigMap?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#services DataK8SGatewaySoloIoGatewayV1Manifest#services}
  */
  readonly services?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_mapping: cdktf.booleanToTerraform(struct!.autoMapping),
    convert_grpc_status: cdktf.booleanToTerraform(struct!.convertGrpcStatus),
    ignore_unknown_query_parameters: cdktf.booleanToTerraform(struct!.ignoreUnknownQueryParameters),
    ignored_query_parameters: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ignoredQueryParameters),
    match_incoming_request_route: cdktf.booleanToTerraform(struct!.matchIncomingRequestRoute),
    print_options: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToTerraform(struct!.printOptions),
    proto_descriptor: cdktf.stringToTerraform(struct!.protoDescriptor),
    proto_descriptor_bin: cdktf.stringToTerraform(struct!.protoDescriptorBin),
    proto_descriptor_config_map: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct!.protoDescriptorConfigMap),
    services: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.services),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_mapping: {
      value: cdktf.booleanToHclTerraform(struct!.autoMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    convert_grpc_status: {
      value: cdktf.booleanToHclTerraform(struct!.convertGrpcStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_unknown_query_parameters: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreUnknownQueryParameters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignored_query_parameters: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ignoredQueryParameters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    match_incoming_request_route: {
      value: cdktf.booleanToHclTerraform(struct!.matchIncomingRequestRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    print_options: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsToHclTerraform(struct!.printOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions",
    },
    proto_descriptor: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_bin: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptorBin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_config_map: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct!.protoDescriptorConfigMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap",
    },
    services: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.services),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoMapping = this._autoMapping;
    }
    if (this._convertGrpcStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.convertGrpcStatus = this._convertGrpcStatus;
    }
    if (this._ignoreUnknownQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreUnknownQueryParameters = this._ignoreUnknownQueryParameters;
    }
    if (this._ignoredQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoredQueryParameters = this._ignoredQueryParameters;
    }
    if (this._matchIncomingRequestRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchIncomingRequestRoute = this._matchIncomingRequestRoute;
    }
    if (this._printOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.printOptions = this._printOptions?.internalValue;
    }
    if (this._protoDescriptor !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptor = this._protoDescriptor;
    }
    if (this._protoDescriptorBin !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorBin = this._protoDescriptorBin;
    }
    if (this._protoDescriptorConfigMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorConfigMap = this._protoDescriptorConfigMap?.internalValue;
    }
    if (this._services !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoMapping = undefined;
      this._convertGrpcStatus = undefined;
      this._ignoreUnknownQueryParameters = undefined;
      this._ignoredQueryParameters = undefined;
      this._matchIncomingRequestRoute = undefined;
      this._printOptions.internalValue = undefined;
      this._protoDescriptor = undefined;
      this._protoDescriptorBin = undefined;
      this._protoDescriptorConfigMap.internalValue = undefined;
      this._services = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoMapping = value.autoMapping;
      this._convertGrpcStatus = value.convertGrpcStatus;
      this._ignoreUnknownQueryParameters = value.ignoreUnknownQueryParameters;
      this._ignoredQueryParameters = value.ignoredQueryParameters;
      this._matchIncomingRequestRoute = value.matchIncomingRequestRoute;
      this._printOptions.internalValue = value.printOptions;
      this._protoDescriptor = value.protoDescriptor;
      this._protoDescriptorBin = value.protoDescriptorBin;
      this._protoDescriptorConfigMap.internalValue = value.protoDescriptorConfigMap;
      this._services = value.services;
    }
  }

  // auto_mapping - computed: false, optional: true, required: false
  private _autoMapping?: boolean | cdktf.IResolvable; 
  public get autoMapping() {
    return this.getBooleanAttribute('auto_mapping');
  }
  public set autoMapping(value: boolean | cdktf.IResolvable) {
    this._autoMapping = value;
  }
  public resetAutoMapping() {
    this._autoMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoMappingInput() {
    return this._autoMapping;
  }

  // convert_grpc_status - computed: false, optional: true, required: false
  private _convertGrpcStatus?: boolean | cdktf.IResolvable; 
  public get convertGrpcStatus() {
    return this.getBooleanAttribute('convert_grpc_status');
  }
  public set convertGrpcStatus(value: boolean | cdktf.IResolvable) {
    this._convertGrpcStatus = value;
  }
  public resetConvertGrpcStatus() {
    this._convertGrpcStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get convertGrpcStatusInput() {
    return this._convertGrpcStatus;
  }

  // ignore_unknown_query_parameters - computed: false, optional: true, required: false
  private _ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable; 
  public get ignoreUnknownQueryParameters() {
    return this.getBooleanAttribute('ignore_unknown_query_parameters');
  }
  public set ignoreUnknownQueryParameters(value: boolean | cdktf.IResolvable) {
    this._ignoreUnknownQueryParameters = value;
  }
  public resetIgnoreUnknownQueryParameters() {
    this._ignoreUnknownQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreUnknownQueryParametersInput() {
    return this._ignoreUnknownQueryParameters;
  }

  // ignored_query_parameters - computed: false, optional: true, required: false
  private _ignoredQueryParameters?: string[]; 
  public get ignoredQueryParameters() {
    return this.getListAttribute('ignored_query_parameters');
  }
  public set ignoredQueryParameters(value: string[]) {
    this._ignoredQueryParameters = value;
  }
  public resetIgnoredQueryParameters() {
    this._ignoredQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoredQueryParametersInput() {
    return this._ignoredQueryParameters;
  }

  // match_incoming_request_route - computed: false, optional: true, required: false
  private _matchIncomingRequestRoute?: boolean | cdktf.IResolvable; 
  public get matchIncomingRequestRoute() {
    return this.getBooleanAttribute('match_incoming_request_route');
  }
  public set matchIncomingRequestRoute(value: boolean | cdktf.IResolvable) {
    this._matchIncomingRequestRoute = value;
  }
  public resetMatchIncomingRequestRoute() {
    this._matchIncomingRequestRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchIncomingRequestRouteInput() {
    return this._matchIncomingRequestRoute;
  }

  // print_options - computed: false, optional: true, required: false
  private _printOptions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptionsOutputReference(this, "print_options");
  public get printOptions() {
    return this._printOptions;
  }
  public putPrintOptions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderPrintOptions) {
    this._printOptions.internalValue = value;
  }
  public resetPrintOptions() {
    this._printOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get printOptionsInput() {
    return this._printOptions.internalValue;
  }

  // proto_descriptor - computed: false, optional: true, required: false
  private _protoDescriptor?: string; 
  public get protoDescriptor() {
    return this.getStringAttribute('proto_descriptor');
  }
  public set protoDescriptor(value: string) {
    this._protoDescriptor = value;
  }
  public resetProtoDescriptor() {
    this._protoDescriptor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorInput() {
    return this._protoDescriptor;
  }

  // proto_descriptor_bin - computed: false, optional: true, required: false
  private _protoDescriptorBin?: string; 
  public get protoDescriptorBin() {
    return this.getStringAttribute('proto_descriptor_bin');
  }
  public set protoDescriptorBin(value: string) {
    this._protoDescriptorBin = value;
  }
  public resetProtoDescriptorBin() {
    this._protoDescriptorBin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorBinInput() {
    return this._protoDescriptorBin;
  }

  // proto_descriptor_config_map - computed: false, optional: true, required: false
  private _protoDescriptorConfigMap = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference(this, "proto_descriptor_config_map");
  public get protoDescriptorConfigMap() {
    return this._protoDescriptorConfigMap;
  }
  public putProtoDescriptorConfigMap(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderProtoDescriptorConfigMap) {
    this._protoDescriptorConfigMap.internalValue = value;
  }
  public resetProtoDescriptorConfigMap() {
    this._protoDescriptorConfigMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorConfigMapInput() {
    return this._protoDescriptorConfigMap.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services?: string[]; 
  public get services() {
    return this.getListAttribute('services');
  }
  public set services(value: string[]) {
    this._services = value;
  }
  public resetServices() {
    this._services = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable DataK8SGatewaySoloIoGatewayV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWebToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWebToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWebOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#compression_level DataK8SGatewaySoloIoGatewayV1Manifest#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#compression_strategy DataK8SGatewaySoloIoGatewayV1Manifest#compression_strategy}
  */
  readonly compressionStrategy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#content_length DataK8SGatewaySoloIoGatewayV1Manifest#content_length}
  */
  readonly contentLength?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#content_type DataK8SGatewaySoloIoGatewayV1Manifest#content_type}
  */
  readonly contentType?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable_on_etag_header DataK8SGatewaySoloIoGatewayV1Manifest#disable_on_etag_header}
  */
  readonly disableOnEtagHeader?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#memory_level DataK8SGatewaySoloIoGatewayV1Manifest#memory_level}
  */
  readonly memoryLevel?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#remove_accept_encoding_header DataK8SGatewaySoloIoGatewayV1Manifest#remove_accept_encoding_header}
  */
  readonly removeAcceptEncodingHeader?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#window_bits DataK8SGatewaySoloIoGatewayV1Manifest#window_bits}
  */
  readonly windowBits?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzipToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    compression_strategy: cdktf.stringToTerraform(struct!.compressionStrategy),
    content_length: cdktf.numberToTerraform(struct!.contentLength),
    content_type: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.contentType),
    disable_on_etag_header: cdktf.booleanToTerraform(struct!.disableOnEtagHeader),
    memory_level: cdktf.numberToTerraform(struct!.memoryLevel),
    remove_accept_encoding_header: cdktf.booleanToTerraform(struct!.removeAcceptEncodingHeader),
    window_bits: cdktf.numberToTerraform(struct!.windowBits),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzipToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_strategy: {
      value: cdktf.stringToHclTerraform(struct!.compressionStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    content_length: {
      value: cdktf.numberToHclTerraform(struct!.contentLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    content_type: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.contentType),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_on_etag_header: {
      value: cdktf.booleanToHclTerraform(struct!.disableOnEtagHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    memory_level: {
      value: cdktf.numberToHclTerraform(struct!.memoryLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    remove_accept_encoding_header: {
      value: cdktf.booleanToHclTerraform(struct!.removeAcceptEncodingHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    window_bits: {
      value: cdktf.numberToHclTerraform(struct!.windowBits),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzipOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._compressionStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionStrategy = this._compressionStrategy;
    }
    if (this._contentLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentLength = this._contentLength;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._disableOnEtagHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableOnEtagHeader = this._disableOnEtagHeader;
    }
    if (this._memoryLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLevel = this._memoryLevel;
    }
    if (this._removeAcceptEncodingHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeAcceptEncodingHeader = this._removeAcceptEncodingHeader;
    }
    if (this._windowBits !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowBits = this._windowBits;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compressionLevel = undefined;
      this._compressionStrategy = undefined;
      this._contentLength = undefined;
      this._contentType = undefined;
      this._disableOnEtagHeader = undefined;
      this._memoryLevel = undefined;
      this._removeAcceptEncodingHeader = undefined;
      this._windowBits = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compressionLevel = value.compressionLevel;
      this._compressionStrategy = value.compressionStrategy;
      this._contentLength = value.contentLength;
      this._contentType = value.contentType;
      this._disableOnEtagHeader = value.disableOnEtagHeader;
      this._memoryLevel = value.memoryLevel;
      this._removeAcceptEncodingHeader = value.removeAcceptEncodingHeader;
      this._windowBits = value.windowBits;
    }
  }

  // compression_level - computed: false, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // compression_strategy - computed: false, optional: true, required: false
  private _compressionStrategy?: string; 
  public get compressionStrategy() {
    return this.getStringAttribute('compression_strategy');
  }
  public set compressionStrategy(value: string) {
    this._compressionStrategy = value;
  }
  public resetCompressionStrategy() {
    this._compressionStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionStrategyInput() {
    return this._compressionStrategy;
  }

  // content_length - computed: false, optional: true, required: false
  private _contentLength?: number; 
  public get contentLength() {
    return this.getNumberAttribute('content_length');
  }
  public set contentLength(value: number) {
    this._contentLength = value;
  }
  public resetContentLength() {
    this._contentLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentLengthInput() {
    return this._contentLength;
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string[]; 
  public get contentType() {
    return this.getListAttribute('content_type');
  }
  public set contentType(value: string[]) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // disable_on_etag_header - computed: false, optional: true, required: false
  private _disableOnEtagHeader?: boolean | cdktf.IResolvable; 
  public get disableOnEtagHeader() {
    return this.getBooleanAttribute('disable_on_etag_header');
  }
  public set disableOnEtagHeader(value: boolean | cdktf.IResolvable) {
    this._disableOnEtagHeader = value;
  }
  public resetDisableOnEtagHeader() {
    this._disableOnEtagHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableOnEtagHeaderInput() {
    return this._disableOnEtagHeader;
  }

  // memory_level - computed: false, optional: true, required: false
  private _memoryLevel?: number; 
  public get memoryLevel() {
    return this.getNumberAttribute('memory_level');
  }
  public set memoryLevel(value: number) {
    this._memoryLevel = value;
  }
  public resetMemoryLevel() {
    this._memoryLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLevelInput() {
    return this._memoryLevel;
  }

  // remove_accept_encoding_header - computed: false, optional: true, required: false
  private _removeAcceptEncodingHeader?: boolean | cdktf.IResolvable; 
  public get removeAcceptEncodingHeader() {
    return this.getBooleanAttribute('remove_accept_encoding_header');
  }
  public set removeAcceptEncodingHeader(value: boolean | cdktf.IResolvable) {
    this._removeAcceptEncodingHeader = value;
  }
  public resetRemoveAcceptEncodingHeader() {
    this._removeAcceptEncodingHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeAcceptEncodingHeaderInput() {
    return this._removeAcceptEncodingHeader;
  }

  // window_bits - computed: false, optional: true, required: false
  private _windowBits?: number; 
  public get windowBits() {
    return this.getNumberAttribute('window_bits');
  }
  public set windowBits(value: number) {
    this._windowBits = value;
  }
  public resetWindowBits() {
    this._windowBits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowBitsInput() {
    return this._windowBits;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable_http1_method_validation DataK8SGatewaySoloIoGatewayV1Manifest#disable_http1_method_validation}
  */
  readonly disableHttp1MethodValidation?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettingsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable_http1_method_validation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.disableHttp1MethodValidation),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettingsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable_http1_method_validation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.disableHttp1MethodValidation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disableHttp1MethodValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableHttp1MethodValidation = this._disableHttp1MethodValidation;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disableHttp1MethodValidation = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disableHttp1MethodValidation = value.disableHttp1MethodValidation;
    }
  }

  // disable_http1_method_validation - computed: false, optional: true, required: false
  private _disableHttp1MethodValidation?: { [key: string]: string }; 
  public get disableHttp1MethodValidation() {
    return this.getStringMapAttribute('disable_http1_method_validation');
  }
  public set disableHttp1MethodValidation(value: { [key: string]: string }) {
    this._disableHttp1MethodValidation = value;
  }
  public resetDisableHttp1MethodValidation() {
    this._disableHttp1MethodValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableHttp1MethodValidationInput() {
    return this._disableHttp1MethodValidation;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path DataK8SGatewaySoloIoGatewayV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheckToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheckToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#initial_connection_window_size DataK8SGatewaySoloIoGatewayV1Manifest#initial_connection_window_size}
  */
  readonly initialConnectionWindowSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#initial_stream_window_size DataK8SGatewaySoloIoGatewayV1Manifest#initial_stream_window_size}
  */
  readonly initialStreamWindowSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_concurrent_streams DataK8SGatewaySoloIoGatewayV1Manifest#max_concurrent_streams}
  */
  readonly maxConcurrentStreams?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#override_stream_error_on_invalid_http_message DataK8SGatewaySoloIoGatewayV1Manifest#override_stream_error_on_invalid_http_message}
  */
  readonly overrideStreamErrorOnInvalidHttpMessage?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    initial_connection_window_size: cdktf.numberToTerraform(struct!.initialConnectionWindowSize),
    initial_stream_window_size: cdktf.numberToTerraform(struct!.initialStreamWindowSize),
    max_concurrent_streams: cdktf.numberToTerraform(struct!.maxConcurrentStreams),
    override_stream_error_on_invalid_http_message: cdktf.booleanToTerraform(struct!.overrideStreamErrorOnInvalidHttpMessage),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    initial_connection_window_size: {
      value: cdktf.numberToHclTerraform(struct!.initialConnectionWindowSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_stream_window_size: {
      value: cdktf.numberToHclTerraform(struct!.initialStreamWindowSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_streams: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentStreams),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    override_stream_error_on_invalid_http_message: {
      value: cdktf.booleanToHclTerraform(struct!.overrideStreamErrorOnInvalidHttpMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._initialConnectionWindowSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialConnectionWindowSize = this._initialConnectionWindowSize;
    }
    if (this._initialStreamWindowSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialStreamWindowSize = this._initialStreamWindowSize;
    }
    if (this._maxConcurrentStreams !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentStreams = this._maxConcurrentStreams;
    }
    if (this._overrideStreamErrorOnInvalidHttpMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideStreamErrorOnInvalidHttpMessage = this._overrideStreamErrorOnInvalidHttpMessage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._initialConnectionWindowSize = undefined;
      this._initialStreamWindowSize = undefined;
      this._maxConcurrentStreams = undefined;
      this._overrideStreamErrorOnInvalidHttpMessage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._initialConnectionWindowSize = value.initialConnectionWindowSize;
      this._initialStreamWindowSize = value.initialStreamWindowSize;
      this._maxConcurrentStreams = value.maxConcurrentStreams;
      this._overrideStreamErrorOnInvalidHttpMessage = value.overrideStreamErrorOnInvalidHttpMessage;
    }
  }

  // initial_connection_window_size - computed: false, optional: true, required: false
  private _initialConnectionWindowSize?: number; 
  public get initialConnectionWindowSize() {
    return this.getNumberAttribute('initial_connection_window_size');
  }
  public set initialConnectionWindowSize(value: number) {
    this._initialConnectionWindowSize = value;
  }
  public resetInitialConnectionWindowSize() {
    this._initialConnectionWindowSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialConnectionWindowSizeInput() {
    return this._initialConnectionWindowSize;
  }

  // initial_stream_window_size - computed: false, optional: true, required: false
  private _initialStreamWindowSize?: number; 
  public get initialStreamWindowSize() {
    return this.getNumberAttribute('initial_stream_window_size');
  }
  public set initialStreamWindowSize(value: number) {
    this._initialStreamWindowSize = value;
  }
  public resetInitialStreamWindowSize() {
    this._initialStreamWindowSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialStreamWindowSizeInput() {
    return this._initialStreamWindowSize;
  }

  // max_concurrent_streams - computed: false, optional: true, required: false
  private _maxConcurrentStreams?: number; 
  public get maxConcurrentStreams() {
    return this.getNumberAttribute('max_concurrent_streams');
  }
  public set maxConcurrentStreams(value: number) {
    this._maxConcurrentStreams = value;
  }
  public resetMaxConcurrentStreams() {
    this._maxConcurrentStreams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentStreamsInput() {
    return this._maxConcurrentStreams;
  }

  // override_stream_error_on_invalid_http_message - computed: false, optional: true, required: false
  private _overrideStreamErrorOnInvalidHttpMessage?: boolean | cdktf.IResolvable; 
  public get overrideStreamErrorOnInvalidHttpMessage() {
    return this.getBooleanAttribute('override_stream_error_on_invalid_http_message');
  }
  public set overrideStreamErrorOnInvalidHttpMessage(value: boolean | cdktf.IResolvable) {
    this._overrideStreamErrorOnInvalidHttpMessage = value;
  }
  public resetOverrideStreamErrorOnInvalidHttpMessage() {
    this._overrideStreamErrorOnInvalidHttpMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideStreamErrorOnInvalidHttpMessageInput() {
    return this._overrideStreamErrorOnInvalidHttpMessage;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#address_prefix DataK8SGatewaySoloIoGatewayV1Manifest#address_prefix}
  */
  readonly addressPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix_len DataK8SGatewaySoloIoGatewayV1Manifest#prefix_len}
  */
  readonly prefixLen?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.stringToTerraform(struct!.addressPrefix),
    prefix_len: cdktf.numberToTerraform(struct!.prefixLen),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.stringToHclTerraform(struct!.addressPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_len: {
      value: cdktf.numberToHclTerraform(struct!.prefixLen),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix;
    }
    if (this._prefixLen !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixLen = this._prefixLen;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix = undefined;
      this._prefixLen = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix = value.addressPrefix;
      this._prefixLen = value.prefixLen;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix?: string; 
  public get addressPrefix() {
    return this.getStringAttribute('address_prefix');
  }
  public set addressPrefix(value: string) {
    this._addressPrefix = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix;
  }

  // prefix_len - computed: false, optional: true, required: false
  private _prefixLen?: number; 
  public get prefixLen() {
    return this.getNumberAttribute('prefix_len');
  }
  public set prefixLen(value: number) {
    this._prefixLen = value;
  }
  public resetPrefixLen() {
    this._prefixLen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixLenInput() {
    return this._prefixLen;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cidr_ranges DataK8SGatewaySoloIoGatewayV1Manifest#cidr_ranges}
  */
  readonly cidrRanges?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#unix_sockets DataK8SGatewaySoloIoGatewayV1Manifest#unix_sockets}
  */
  readonly unixSockets?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cidr_ranges: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToTerraform, false)(struct!.cidrRanges),
    unix_sockets: cdktf.booleanToTerraform(struct!.unixSockets),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cidr_ranges: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesToHclTerraform, false)(struct!.cidrRanges),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesList",
    },
    unix_sockets: {
      value: cdktf.booleanToHclTerraform(struct!.unixSockets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cidrRanges?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cidrRanges = this._cidrRanges?.internalValue;
    }
    if (this._unixSockets !== undefined) {
      hasAnyValues = true;
      internalValueResult.unixSockets = this._unixSockets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cidrRanges.internalValue = undefined;
      this._unixSockets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cidrRanges.internalValue = value.cidrRanges;
      this._unixSockets = value.unixSockets;
    }
  }

  // cidr_ranges - computed: false, optional: true, required: false
  private _cidrRanges = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRangesList(this, "cidr_ranges", false);
  public get cidrRanges() {
    return this._cidrRanges;
  }
  public putCidrRanges(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigCidrRanges[] | cdktf.IResolvable) {
    this._cidrRanges.internalValue = value;
  }
  public resetCidrRanges() {
    this._cidrRanges.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cidrRangesInput() {
    return this._cidrRanges.internalValue;
  }

  // unix_sockets - computed: false, optional: true, required: false
  private _unixSockets?: boolean | cdktf.IResolvable; 
  public get unixSockets() {
    return this.getBooleanAttribute('unix_sockets');
  }
  public set unixSockets(value: boolean | cdktf.IResolvable) {
    this._unixSockets = value;
  }
  public resetUnixSockets() {
    this._unixSockets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unixSocketsInput() {
    return this._unixSockets;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cert DataK8SGatewaySoloIoGatewayV1Manifest#cert}
  */
  readonly cert?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#chain DataK8SGatewaySoloIoGatewayV1Manifest#chain}
  */
  readonly chain?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dns DataK8SGatewaySoloIoGatewayV1Manifest#dns}
  */
  readonly dns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subject DataK8SGatewaySoloIoGatewayV1Manifest#subject}
  */
  readonly subject?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#uri DataK8SGatewaySoloIoGatewayV1Manifest#uri}
  */
  readonly uri?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert: cdktf.booleanToTerraform(struct!.cert),
    chain: cdktf.booleanToTerraform(struct!.chain),
    dns: cdktf.booleanToTerraform(struct!.dns),
    subject: cdktf.booleanToTerraform(struct!.subject),
    uri: cdktf.booleanToTerraform(struct!.uri),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert: {
      value: cdktf.booleanToHclTerraform(struct!.cert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    chain: {
      value: cdktf.booleanToHclTerraform(struct!.chain),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dns: {
      value: cdktf.booleanToHclTerraform(struct!.dns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    subject: {
      value: cdktf.booleanToHclTerraform(struct!.subject),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    uri: {
      value: cdktf.booleanToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cert !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert;
    }
    if (this._chain !== undefined) {
      hasAnyValues = true;
      internalValueResult.chain = this._chain;
    }
    if (this._dns !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns;
    }
    if (this._subject !== undefined) {
      hasAnyValues = true;
      internalValueResult.subject = this._subject;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cert = undefined;
      this._chain = undefined;
      this._dns = undefined;
      this._subject = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cert = value.cert;
      this._chain = value.chain;
      this._dns = value.dns;
      this._subject = value.subject;
      this._uri = value.uri;
    }
  }

  // cert - computed: false, optional: true, required: false
  private _cert?: boolean | cdktf.IResolvable; 
  public get cert() {
    return this.getBooleanAttribute('cert');
  }
  public set cert(value: boolean | cdktf.IResolvable) {
    this._cert = value;
  }
  public resetCert() {
    this._cert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert;
  }

  // chain - computed: false, optional: true, required: false
  private _chain?: boolean | cdktf.IResolvable; 
  public get chain() {
    return this.getBooleanAttribute('chain');
  }
  public set chain(value: boolean | cdktf.IResolvable) {
    this._chain = value;
  }
  public resetChain() {
    this._chain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chainInput() {
    return this._chain;
  }

  // dns - computed: false, optional: true, required: false
  private _dns?: boolean | cdktf.IResolvable; 
  public get dns() {
    return this.getBooleanAttribute('dns');
  }
  public set dns(value: boolean | cdktf.IResolvable) {
    this._dns = value;
  }
  public resetDns() {
    this._dns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns;
  }

  // subject - computed: false, optional: true, required: false
  private _subject?: boolean | cdktf.IResolvable; 
  public get subject() {
    return this.getBooleanAttribute('subject');
  }
  public set subject(value: boolean | cdktf.IResolvable) {
    this._subject = value;
  }
  public resetSubject() {
    this._subject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectInput() {
    return this._subject;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: boolean | cdktf.IResolvable; 
  public get uri() {
    return this.getBooleanAttribute('uri');
  }
  public set uri(value: boolean | cdktf.IResolvable) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disabled DataK8SGatewaySoloIoGatewayV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#polling_interval DataK8SGatewaySoloIoGatewayV1Manifest#polling_interval}
  */
  readonly pollingInterval?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    polling_interval: cdktf.stringToTerraform(struct!.pollingInterval),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    polling_interval: {
      value: cdktf.stringToHclTerraform(struct!.pollingInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._pollingInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollingInterval = this._pollingInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._pollingInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._pollingInterval = value.pollingInterval;
    }
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // polling_interval - computed: false, optional: true, required: false
  private _pollingInterval?: string; 
  public get pollingInterval() {
    return this.getStringAttribute('polling_interval');
  }
  public set pollingInterval(value: string) {
    this._pollingInterval = value;
  }
  public resetPollingInterval() {
    this._pollingInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollingIntervalInput() {
    return this._pollingInterval;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#collector_hostname DataK8SGatewaySoloIoGatewayV1Manifest#collector_hostname}
  */
  readonly collectorHostname?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#collector_upstream_ref DataK8SGatewaySoloIoGatewayV1Manifest#collector_upstream_ref}
  */
  readonly collectorUpstreamRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#remote_config DataK8SGatewaySoloIoGatewayV1Manifest#remote_config}
  */
  readonly remoteConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#service_name DataK8SGatewaySoloIoGatewayV1Manifest#service_name}
  */
  readonly serviceName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    collector_hostname: cdktf.stringToTerraform(struct!.collectorHostname),
    collector_upstream_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToTerraform(struct!.collectorUpstreamRef),
    remote_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToTerraform(struct!.remoteConfig),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_hostname: {
      value: cdktf.stringToHclTerraform(struct!.collectorHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_upstream_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefToHclTerraform(struct!.collectorUpstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef",
    },
    remote_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigToHclTerraform(struct!.remoteConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._collectorHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorHostname = this._collectorHostname;
    }
    if (this._collectorUpstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorUpstreamRef = this._collectorUpstreamRef?.internalValue;
    }
    if (this._remoteConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteConfig = this._remoteConfig?.internalValue;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterName = undefined;
      this._collectorHostname = undefined;
      this._collectorUpstreamRef.internalValue = undefined;
      this._remoteConfig.internalValue = undefined;
      this._serviceName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterName = value.clusterName;
      this._collectorHostname = value.collectorHostname;
      this._collectorUpstreamRef.internalValue = value.collectorUpstreamRef;
      this._remoteConfig.internalValue = value.remoteConfig;
      this._serviceName = value.serviceName;
    }
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // collector_hostname - computed: false, optional: true, required: false
  private _collectorHostname?: string; 
  public get collectorHostname() {
    return this.getStringAttribute('collector_hostname');
  }
  public set collectorHostname(value: string) {
    this._collectorHostname = value;
  }
  public resetCollectorHostname() {
    this._collectorHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorHostnameInput() {
    return this._collectorHostname;
  }

  // collector_upstream_ref - computed: false, optional: true, required: false
  private _collectorUpstreamRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRefOutputReference(this, "collector_upstream_ref");
  public get collectorUpstreamRef() {
    return this._collectorUpstreamRef;
  }
  public putCollectorUpstreamRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigCollectorUpstreamRef) {
    this._collectorUpstreamRef.internalValue = value;
  }
  public resetCollectorUpstreamRef() {
    this._collectorUpstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorUpstreamRefInput() {
    return this._collectorUpstreamRef.internalValue;
  }

  // remote_config - computed: false, optional: true, required: false
  private _remoteConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfigOutputReference(this, "remote_config");
  public get remoteConfig() {
    return this._remoteConfig;
  }
  public putRemoteConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigRemoteConfig) {
    this._remoteConfig.internalValue = value;
  }
  public resetRemoteConfig() {
    this._remoteConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteConfigInput() {
    return this._remoteConfig.internalValue;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_value DataK8SGatewaySoloIoGatewayV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tag DataK8SGatewaySoloIoGatewayV1Manifest#tag}
  */
  readonly tag?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    name: cdktf.stringToTerraform(struct!.name),
    tag: cdktf.stringToTerraform(struct!.tag),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tag: {
      value: cdktf.stringToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._name = undefined;
      this._tag = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._name = value.name;
      this._tag = value.tag;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: string; 
  public get tag() {
    return this.getStringAttribute('tag');
  }
  public set tag(value: string) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tag DataK8SGatewaySoloIoGatewayV1Manifest#tag}
  */
  readonly tag?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tag: cdktf.stringToTerraform(struct!.tag),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tag: {
      value: cdktf.stringToHclTerraform(struct!.tag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tag !== undefined) {
      hasAnyValues = true;
      internalValueResult.tag = this._tag;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tag = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tag = value.tag;
      this._value = value.value;
    }
  }

  // tag - computed: false, optional: true, required: false
  private _tag?: string; 
  public get tag() {
    return this.getStringAttribute('tag');
  }
  public set tag(value: string) {
    this._tag = value;
  }
  public resetTag() {
    this._tag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagInput() {
    return this._tag;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stat_prefix DataK8SGatewaySoloIoGatewayV1Manifest#stat_prefix}
  */
  readonly statPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#target_uri DataK8SGatewaySoloIoGatewayV1Manifest#target_uri}
  */
  readonly targetUri?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    stat_prefix: cdktf.stringToTerraform(struct!.statPrefix),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    stat_prefix: {
      value: cdktf.stringToHclTerraform(struct!.statPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._statPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.statPrefix = this._statPrefix;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._statPrefix = undefined;
      this._targetUri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._statPrefix = value.statPrefix;
      this._targetUri = value.targetUri;
    }
  }

  // stat_prefix - computed: false, optional: true, required: false
  private _statPrefix?: string; 
  public get statPrefix() {
    return this.getStringAttribute('stat_prefix');
  }
  public set statPrefix(value: string) {
    this._statPrefix = value;
  }
  public resetStatPrefix() {
    this._statPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statPrefixInput() {
    return this._statPrefix;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#decision DataK8SGatewaySoloIoGatewayV1Manifest#decision}
  */
  readonly decision?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    decision: cdktf.stringToTerraform(struct!.decision),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    decision: {
      value: cdktf.stringToHclTerraform(struct!.decision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._decision !== undefined) {
      hasAnyValues = true;
      internalValueResult.decision = this._decision;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._decision = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._decision = value.decision;
    }
  }

  // decision - computed: false, optional: true, required: false
  private _decision?: string; 
  public get decision() {
    return this.getStringAttribute('decision');
  }
  public set decision(value: string) {
    this._decision = value;
  }
  public resetDecision() {
    this._decision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decisionInput() {
    return this._decision;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sampling_probability DataK8SGatewaySoloIoGatewayV1Manifest#sampling_probability}
  */
  readonly samplingProbability?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sampling_probability: cdktf.numberToTerraform(struct!.samplingProbability),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sampling_probability: {
      value: cdktf.numberToHclTerraform(struct!.samplingProbability),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._samplingProbability !== undefined) {
      hasAnyValues = true;
      internalValueResult.samplingProbability = this._samplingProbability;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._samplingProbability = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._samplingProbability = value.samplingProbability;
    }
  }

  // sampling_probability - computed: false, optional: true, required: false
  private _samplingProbability?: number; 
  public get samplingProbability() {
    return this.getNumberAttribute('sampling_probability');
  }
  public set samplingProbability(value: number) {
    this._samplingProbability = value;
  }
  public resetSamplingProbability() {
    this._samplingProbability = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get samplingProbabilityInput() {
    return this._samplingProbability;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#qps DataK8SGatewaySoloIoGatewayV1Manifest#qps}
  */
  readonly qps?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    qps: cdktf.numberToTerraform(struct!.qps),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    qps: {
      value: cdktf.numberToHclTerraform(struct!.qps),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._qps !== undefined) {
      hasAnyValues = true;
      internalValueResult.qps = this._qps;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._qps = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._qps = value.qps;
    }
  }

  // qps - computed: false, optional: true, required: false
  private _qps?: number; 
  public get qps() {
    return this.getNumberAttribute('qps');
  }
  public set qps(value: number) {
    this._qps = value;
  }
  public resetQps() {
    this._qps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qpsInput() {
    return this._qps;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#constant_sampler DataK8SGatewaySoloIoGatewayV1Manifest#constant_sampler}
  */
  readonly constantSampler?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_number_of_annotations DataK8SGatewaySoloIoGatewayV1Manifest#max_number_of_annotations}
  */
  readonly maxNumberOfAnnotations?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_number_of_attributes DataK8SGatewaySoloIoGatewayV1Manifest#max_number_of_attributes}
  */
  readonly maxNumberOfAttributes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_number_of_links DataK8SGatewaySoloIoGatewayV1Manifest#max_number_of_links}
  */
  readonly maxNumberOfLinks?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_number_of_message_events DataK8SGatewaySoloIoGatewayV1Manifest#max_number_of_message_events}
  */
  readonly maxNumberOfMessageEvents?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#probability_sampler DataK8SGatewaySoloIoGatewayV1Manifest#probability_sampler}
  */
  readonly probabilitySampler?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#rate_limiting_sampler DataK8SGatewaySoloIoGatewayV1Manifest#rate_limiting_sampler}
  */
  readonly rateLimitingSampler?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    constant_sampler: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToTerraform(struct!.constantSampler),
    max_number_of_annotations: cdktf.numberToTerraform(struct!.maxNumberOfAnnotations),
    max_number_of_attributes: cdktf.numberToTerraform(struct!.maxNumberOfAttributes),
    max_number_of_links: cdktf.numberToTerraform(struct!.maxNumberOfLinks),
    max_number_of_message_events: cdktf.numberToTerraform(struct!.maxNumberOfMessageEvents),
    probability_sampler: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToTerraform(struct!.probabilitySampler),
    rate_limiting_sampler: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToTerraform(struct!.rateLimitingSampler),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    constant_sampler: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerToHclTerraform(struct!.constantSampler),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler",
    },
    max_number_of_annotations: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_attributes: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfAttributes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_links: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfLinks),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_number_of_message_events: {
      value: cdktf.numberToHclTerraform(struct!.maxNumberOfMessageEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    probability_sampler: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerToHclTerraform(struct!.probabilitySampler),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler",
    },
    rate_limiting_sampler: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerToHclTerraform(struct!.rateLimitingSampler),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._constantSampler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.constantSampler = this._constantSampler?.internalValue;
    }
    if (this._maxNumberOfAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAnnotations = this._maxNumberOfAnnotations;
    }
    if (this._maxNumberOfAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfAttributes = this._maxNumberOfAttributes;
    }
    if (this._maxNumberOfLinks !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfLinks = this._maxNumberOfLinks;
    }
    if (this._maxNumberOfMessageEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxNumberOfMessageEvents = this._maxNumberOfMessageEvents;
    }
    if (this._probabilitySampler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.probabilitySampler = this._probabilitySampler?.internalValue;
    }
    if (this._rateLimitingSampler?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rateLimitingSampler = this._rateLimitingSampler?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._constantSampler.internalValue = undefined;
      this._maxNumberOfAnnotations = undefined;
      this._maxNumberOfAttributes = undefined;
      this._maxNumberOfLinks = undefined;
      this._maxNumberOfMessageEvents = undefined;
      this._probabilitySampler.internalValue = undefined;
      this._rateLimitingSampler.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._constantSampler.internalValue = value.constantSampler;
      this._maxNumberOfAnnotations = value.maxNumberOfAnnotations;
      this._maxNumberOfAttributes = value.maxNumberOfAttributes;
      this._maxNumberOfLinks = value.maxNumberOfLinks;
      this._maxNumberOfMessageEvents = value.maxNumberOfMessageEvents;
      this._probabilitySampler.internalValue = value.probabilitySampler;
      this._rateLimitingSampler.internalValue = value.rateLimitingSampler;
    }
  }

  // constant_sampler - computed: false, optional: true, required: false
  private _constantSampler = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSamplerOutputReference(this, "constant_sampler");
  public get constantSampler() {
    return this._constantSampler;
  }
  public putConstantSampler(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigConstantSampler) {
    this._constantSampler.internalValue = value;
  }
  public resetConstantSampler() {
    this._constantSampler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get constantSamplerInput() {
    return this._constantSampler.internalValue;
  }

  // max_number_of_annotations - computed: false, optional: true, required: false
  private _maxNumberOfAnnotations?: number; 
  public get maxNumberOfAnnotations() {
    return this.getNumberAttribute('max_number_of_annotations');
  }
  public set maxNumberOfAnnotations(value: number) {
    this._maxNumberOfAnnotations = value;
  }
  public resetMaxNumberOfAnnotations() {
    this._maxNumberOfAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAnnotationsInput() {
    return this._maxNumberOfAnnotations;
  }

  // max_number_of_attributes - computed: false, optional: true, required: false
  private _maxNumberOfAttributes?: number; 
  public get maxNumberOfAttributes() {
    return this.getNumberAttribute('max_number_of_attributes');
  }
  public set maxNumberOfAttributes(value: number) {
    this._maxNumberOfAttributes = value;
  }
  public resetMaxNumberOfAttributes() {
    this._maxNumberOfAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfAttributesInput() {
    return this._maxNumberOfAttributes;
  }

  // max_number_of_links - computed: false, optional: true, required: false
  private _maxNumberOfLinks?: number; 
  public get maxNumberOfLinks() {
    return this.getNumberAttribute('max_number_of_links');
  }
  public set maxNumberOfLinks(value: number) {
    this._maxNumberOfLinks = value;
  }
  public resetMaxNumberOfLinks() {
    this._maxNumberOfLinks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfLinksInput() {
    return this._maxNumberOfLinks;
  }

  // max_number_of_message_events - computed: false, optional: true, required: false
  private _maxNumberOfMessageEvents?: number; 
  public get maxNumberOfMessageEvents() {
    return this.getNumberAttribute('max_number_of_message_events');
  }
  public set maxNumberOfMessageEvents(value: number) {
    this._maxNumberOfMessageEvents = value;
  }
  public resetMaxNumberOfMessageEvents() {
    this._maxNumberOfMessageEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxNumberOfMessageEventsInput() {
    return this._maxNumberOfMessageEvents;
  }

  // probability_sampler - computed: false, optional: true, required: false
  private _probabilitySampler = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySamplerOutputReference(this, "probability_sampler");
  public get probabilitySampler() {
    return this._probabilitySampler;
  }
  public putProbabilitySampler(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigProbabilitySampler) {
    this._probabilitySampler.internalValue = value;
  }
  public resetProbabilitySampler() {
    this._probabilitySampler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get probabilitySamplerInput() {
    return this._probabilitySampler.internalValue;
  }

  // rate_limiting_sampler - computed: false, optional: true, required: false
  private _rateLimitingSampler = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSamplerOutputReference(this, "rate_limiting_sampler");
  public get rateLimitingSampler() {
    return this._rateLimitingSampler;
  }
  public putRateLimitingSampler(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigRateLimitingSampler) {
    this._rateLimitingSampler.internalValue = value;
  }
  public resetRateLimitingSampler() {
    this._rateLimitingSampler.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rateLimitingSamplerInput() {
    return this._rateLimitingSampler.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_address DataK8SGatewaySoloIoGatewayV1Manifest#grpc_address}
  */
  readonly grpcAddress?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http_address DataK8SGatewaySoloIoGatewayV1Manifest#http_address}
  */
  readonly httpAddress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#incoming_trace_context DataK8SGatewaySoloIoGatewayV1Manifest#incoming_trace_context}
  */
  readonly incomingTraceContext?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ocagent_exporter_enabled DataK8SGatewaySoloIoGatewayV1Manifest#ocagent_exporter_enabled}
  */
  readonly ocagentExporterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#outgoing_trace_context DataK8SGatewaySoloIoGatewayV1Manifest#outgoing_trace_context}
  */
  readonly outgoingTraceContext?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#trace_config DataK8SGatewaySoloIoGatewayV1Manifest#trace_config}
  */
  readonly traceConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_address: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToTerraform(struct!.grpcAddress),
    http_address: cdktf.stringToTerraform(struct!.httpAddress),
    incoming_trace_context: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.incomingTraceContext),
    ocagent_exporter_enabled: cdktf.booleanToTerraform(struct!.ocagentExporterEnabled),
    outgoing_trace_context: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.outgoingTraceContext),
    trace_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToTerraform(struct!.traceConfig),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_address: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressToHclTerraform(struct!.grpcAddress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress",
    },
    http_address: {
      value: cdktf.stringToHclTerraform(struct!.httpAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    incoming_trace_context: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.incomingTraceContext),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ocagent_exporter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.ocagentExporterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    outgoing_trace_context: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.outgoingTraceContext),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    trace_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigToHclTerraform(struct!.traceConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcAddress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcAddress = this._grpcAddress?.internalValue;
    }
    if (this._httpAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpAddress = this._httpAddress;
    }
    if (this._incomingTraceContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.incomingTraceContext = this._incomingTraceContext;
    }
    if (this._ocagentExporterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocagentExporterEnabled = this._ocagentExporterEnabled;
    }
    if (this._outgoingTraceContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.outgoingTraceContext = this._outgoingTraceContext;
    }
    if (this._traceConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceConfig = this._traceConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcAddress.internalValue = undefined;
      this._httpAddress = undefined;
      this._incomingTraceContext = undefined;
      this._ocagentExporterEnabled = undefined;
      this._outgoingTraceContext = undefined;
      this._traceConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcAddress.internalValue = value.grpcAddress;
      this._httpAddress = value.httpAddress;
      this._incomingTraceContext = value.incomingTraceContext;
      this._ocagentExporterEnabled = value.ocagentExporterEnabled;
      this._outgoingTraceContext = value.outgoingTraceContext;
      this._traceConfig.internalValue = value.traceConfig;
    }
  }

  // grpc_address - computed: false, optional: true, required: false
  private _grpcAddress = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddressOutputReference(this, "grpc_address");
  public get grpcAddress() {
    return this._grpcAddress;
  }
  public putGrpcAddress(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigGrpcAddress) {
    this._grpcAddress.internalValue = value;
  }
  public resetGrpcAddress() {
    this._grpcAddress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcAddressInput() {
    return this._grpcAddress.internalValue;
  }

  // http_address - computed: false, optional: true, required: false
  private _httpAddress?: string; 
  public get httpAddress() {
    return this.getStringAttribute('http_address');
  }
  public set httpAddress(value: string) {
    this._httpAddress = value;
  }
  public resetHttpAddress() {
    this._httpAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpAddressInput() {
    return this._httpAddress;
  }

  // incoming_trace_context - computed: false, optional: true, required: false
  private _incomingTraceContext?: string[]; 
  public get incomingTraceContext() {
    return this.getListAttribute('incoming_trace_context');
  }
  public set incomingTraceContext(value: string[]) {
    this._incomingTraceContext = value;
  }
  public resetIncomingTraceContext() {
    this._incomingTraceContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get incomingTraceContextInput() {
    return this._incomingTraceContext;
  }

  // ocagent_exporter_enabled - computed: false, optional: true, required: false
  private _ocagentExporterEnabled?: boolean | cdktf.IResolvable; 
  public get ocagentExporterEnabled() {
    return this.getBooleanAttribute('ocagent_exporter_enabled');
  }
  public set ocagentExporterEnabled(value: boolean | cdktf.IResolvable) {
    this._ocagentExporterEnabled = value;
  }
  public resetOcagentExporterEnabled() {
    this._ocagentExporterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocagentExporterEnabledInput() {
    return this._ocagentExporterEnabled;
  }

  // outgoing_trace_context - computed: false, optional: true, required: false
  private _outgoingTraceContext?: string[]; 
  public get outgoingTraceContext() {
    return this.getListAttribute('outgoing_trace_context');
  }
  public set outgoingTraceContext(value: string[]) {
    this._outgoingTraceContext = value;
  }
  public resetOutgoingTraceContext() {
    this._outgoingTraceContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outgoingTraceContextInput() {
    return this._outgoingTraceContext;
  }

  // trace_config - computed: false, optional: true, required: false
  private _traceConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfigOutputReference(this, "trace_config");
  public get traceConfig() {
    return this._traceConfig;
  }
  public putTraceConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigTraceConfig) {
    this._traceConfig.internalValue = value;
  }
  public resetTraceConfig() {
    this._traceConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceConfigInput() {
    return this._traceConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#collector_upstream_ref DataK8SGatewaySoloIoGatewayV1Manifest#collector_upstream_ref}
  */
  readonly collectorUpstreamRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    collector_upstream_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToTerraform(struct!.collectorUpstreamRef),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_upstream_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefToHclTerraform(struct!.collectorUpstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._collectorUpstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorUpstreamRef = this._collectorUpstreamRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterName = undefined;
      this._collectorUpstreamRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterName = value.clusterName;
      this._collectorUpstreamRef.internalValue = value.collectorUpstreamRef;
    }
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // collector_upstream_ref - computed: false, optional: true, required: false
  private _collectorUpstreamRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRefOutputReference(this, "collector_upstream_ref");
  public get collectorUpstreamRef() {
    return this._collectorUpstreamRef;
  }
  public putCollectorUpstreamRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigCollectorUpstreamRef) {
    this._collectorUpstreamRef.internalValue = value;
  }
  public resetCollectorUpstreamRef() {
    this._collectorUpstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorUpstreamRefInput() {
    return this._collectorUpstreamRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#client_sample_percentage DataK8SGatewaySoloIoGatewayV1Manifest#client_sample_percentage}
  */
  readonly clientSamplePercentage?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#overall_sample_percentage DataK8SGatewaySoloIoGatewayV1Manifest#overall_sample_percentage}
  */
  readonly overallSamplePercentage?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#random_sample_percentage DataK8SGatewaySoloIoGatewayV1Manifest#random_sample_percentage}
  */
  readonly randomSamplePercentage?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_sample_percentage: cdktf.numberToTerraform(struct!.clientSamplePercentage),
    overall_sample_percentage: cdktf.numberToTerraform(struct!.overallSamplePercentage),
    random_sample_percentage: cdktf.numberToTerraform(struct!.randomSamplePercentage),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_sample_percentage: {
      value: cdktf.numberToHclTerraform(struct!.clientSamplePercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    overall_sample_percentage: {
      value: cdktf.numberToHclTerraform(struct!.overallSamplePercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    random_sample_percentage: {
      value: cdktf.numberToHclTerraform(struct!.randomSamplePercentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientSamplePercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSamplePercentage = this._clientSamplePercentage;
    }
    if (this._overallSamplePercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.overallSamplePercentage = this._overallSamplePercentage;
    }
    if (this._randomSamplePercentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.randomSamplePercentage = this._randomSamplePercentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientSamplePercentage = undefined;
      this._overallSamplePercentage = undefined;
      this._randomSamplePercentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientSamplePercentage = value.clientSamplePercentage;
      this._overallSamplePercentage = value.overallSamplePercentage;
      this._randomSamplePercentage = value.randomSamplePercentage;
    }
  }

  // client_sample_percentage - computed: false, optional: true, required: false
  private _clientSamplePercentage?: number; 
  public get clientSamplePercentage() {
    return this.getNumberAttribute('client_sample_percentage');
  }
  public set clientSamplePercentage(value: number) {
    this._clientSamplePercentage = value;
  }
  public resetClientSamplePercentage() {
    this._clientSamplePercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSamplePercentageInput() {
    return this._clientSamplePercentage;
  }

  // overall_sample_percentage - computed: false, optional: true, required: false
  private _overallSamplePercentage?: number; 
  public get overallSamplePercentage() {
    return this.getNumberAttribute('overall_sample_percentage');
  }
  public set overallSamplePercentage(value: number) {
    this._overallSamplePercentage = value;
  }
  public resetOverallSamplePercentage() {
    this._overallSamplePercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overallSamplePercentageInput() {
    return this._overallSamplePercentage;
  }

  // random_sample_percentage - computed: false, optional: true, required: false
  private _randomSamplePercentage?: number; 
  public get randomSamplePercentage() {
    return this.getNumberAttribute('random_sample_percentage');
  }
  public set randomSamplePercentage(value: number) {
    this._randomSamplePercentage = value;
  }
  public resetRandomSamplePercentage() {
    this._randomSamplePercentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get randomSamplePercentageInput() {
    return this._randomSamplePercentage;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#collector_endpoint DataK8SGatewaySoloIoGatewayV1Manifest#collector_endpoint}
  */
  readonly collectorEndpoint?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#collector_endpoint_version DataK8SGatewaySoloIoGatewayV1Manifest#collector_endpoint_version}
  */
  readonly collectorEndpointVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#collector_upstream_ref DataK8SGatewaySoloIoGatewayV1Manifest#collector_upstream_ref}
  */
  readonly collectorUpstreamRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#shared_span_context DataK8SGatewaySoloIoGatewayV1Manifest#shared_span_context}
  */
  readonly sharedSpanContext?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#trace_id128bit DataK8SGatewaySoloIoGatewayV1Manifest#trace_id128bit}
  */
  readonly traceId128Bit?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    collector_endpoint: cdktf.stringToTerraform(struct!.collectorEndpoint),
    collector_endpoint_version: cdktf.stringToTerraform(struct!.collectorEndpointVersion),
    collector_upstream_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToTerraform(struct!.collectorUpstreamRef),
    shared_span_context: cdktf.booleanToTerraform(struct!.sharedSpanContext),
    trace_id128bit: cdktf.booleanToTerraform(struct!.traceId128Bit),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.collectorEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_endpoint_version: {
      value: cdktf.stringToHclTerraform(struct!.collectorEndpointVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_upstream_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefToHclTerraform(struct!.collectorUpstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef",
    },
    shared_span_context: {
      value: cdktf.booleanToHclTerraform(struct!.sharedSpanContext),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    trace_id128bit: {
      value: cdktf.booleanToHclTerraform(struct!.traceId128Bit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._collectorEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorEndpoint = this._collectorEndpoint;
    }
    if (this._collectorEndpointVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorEndpointVersion = this._collectorEndpointVersion;
    }
    if (this._collectorUpstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorUpstreamRef = this._collectorUpstreamRef?.internalValue;
    }
    if (this._sharedSpanContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedSpanContext = this._sharedSpanContext;
    }
    if (this._traceId128Bit !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceId128Bit = this._traceId128Bit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterName = undefined;
      this._collectorEndpoint = undefined;
      this._collectorEndpointVersion = undefined;
      this._collectorUpstreamRef.internalValue = undefined;
      this._sharedSpanContext = undefined;
      this._traceId128Bit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterName = value.clusterName;
      this._collectorEndpoint = value.collectorEndpoint;
      this._collectorEndpointVersion = value.collectorEndpointVersion;
      this._collectorUpstreamRef.internalValue = value.collectorUpstreamRef;
      this._sharedSpanContext = value.sharedSpanContext;
      this._traceId128Bit = value.traceId128Bit;
    }
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // collector_endpoint - computed: false, optional: true, required: false
  private _collectorEndpoint?: string; 
  public get collectorEndpoint() {
    return this.getStringAttribute('collector_endpoint');
  }
  public set collectorEndpoint(value: string) {
    this._collectorEndpoint = value;
  }
  public resetCollectorEndpoint() {
    this._collectorEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorEndpointInput() {
    return this._collectorEndpoint;
  }

  // collector_endpoint_version - computed: false, optional: true, required: false
  private _collectorEndpointVersion?: string; 
  public get collectorEndpointVersion() {
    return this.getStringAttribute('collector_endpoint_version');
  }
  public set collectorEndpointVersion(value: string) {
    this._collectorEndpointVersion = value;
  }
  public resetCollectorEndpointVersion() {
    this._collectorEndpointVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorEndpointVersionInput() {
    return this._collectorEndpointVersion;
  }

  // collector_upstream_ref - computed: false, optional: true, required: false
  private _collectorUpstreamRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRefOutputReference(this, "collector_upstream_ref");
  public get collectorUpstreamRef() {
    return this._collectorUpstreamRef;
  }
  public putCollectorUpstreamRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigCollectorUpstreamRef) {
    this._collectorUpstreamRef.internalValue = value;
  }
  public resetCollectorUpstreamRef() {
    this._collectorUpstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorUpstreamRefInput() {
    return this._collectorUpstreamRef.internalValue;
  }

  // shared_span_context - computed: false, optional: true, required: false
  private _sharedSpanContext?: boolean | cdktf.IResolvable; 
  public get sharedSpanContext() {
    return this.getBooleanAttribute('shared_span_context');
  }
  public set sharedSpanContext(value: boolean | cdktf.IResolvable) {
    this._sharedSpanContext = value;
  }
  public resetSharedSpanContext() {
    this._sharedSpanContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedSpanContextInput() {
    return this._sharedSpanContext;
  }

  // trace_id128bit - computed: false, optional: true, required: false
  private _traceId128Bit?: boolean | cdktf.IResolvable; 
  public get traceId128Bit() {
    return this.getBooleanAttribute('trace_id128bit');
  }
  public set traceId128Bit(value: boolean | cdktf.IResolvable) {
    this._traceId128Bit = value;
  }
  public resetTraceId128Bit() {
    this._traceId128Bit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceId128BitInput() {
    return this._traceId128Bit;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#datadog_config DataK8SGatewaySoloIoGatewayV1Manifest#datadog_config}
  */
  readonly datadogConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#environment_variables_for_tags DataK8SGatewaySoloIoGatewayV1Manifest#environment_variables_for_tags}
  */
  readonly environmentVariablesForTags?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#literals_for_tags DataK8SGatewaySoloIoGatewayV1Manifest#literals_for_tags}
  */
  readonly literalsForTags?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#open_census_config DataK8SGatewaySoloIoGatewayV1Manifest#open_census_config}
  */
  readonly openCensusConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#open_telemetry_config DataK8SGatewaySoloIoGatewayV1Manifest#open_telemetry_config}
  */
  readonly openTelemetryConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_headers_for_tags DataK8SGatewaySoloIoGatewayV1Manifest#request_headers_for_tags}
  */
  readonly requestHeadersForTags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#trace_percentages DataK8SGatewaySoloIoGatewayV1Manifest#trace_percentages}
  */
  readonly tracePercentages?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#verbose DataK8SGatewaySoloIoGatewayV1Manifest#verbose}
  */
  readonly verbose?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#zipkin_config DataK8SGatewaySoloIoGatewayV1Manifest#zipkin_config}
  */
  readonly zipkinConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datadog_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToTerraform(struct!.datadogConfig),
    environment_variables_for_tags: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToTerraform, false)(struct!.environmentVariablesForTags),
    literals_for_tags: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToTerraform, false)(struct!.literalsForTags),
    open_census_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToTerraform(struct!.openCensusConfig),
    open_telemetry_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToTerraform(struct!.openTelemetryConfig),
    request_headers_for_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestHeadersForTags),
    trace_percentages: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToTerraform(struct!.tracePercentages),
    verbose: cdktf.booleanToTerraform(struct!.verbose),
    zipkin_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToTerraform(struct!.zipkinConfig),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datadog_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigToHclTerraform(struct!.datadogConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig",
    },
    environment_variables_for_tags: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsToHclTerraform, false)(struct!.environmentVariablesForTags),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsList",
    },
    literals_for_tags: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsToHclTerraform, false)(struct!.literalsForTags),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsList",
    },
    open_census_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigToHclTerraform(struct!.openCensusConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig",
    },
    open_telemetry_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigToHclTerraform(struct!.openTelemetryConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig",
    },
    request_headers_for_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestHeadersForTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    trace_percentages: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesToHclTerraform(struct!.tracePercentages),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages",
    },
    verbose: {
      value: cdktf.booleanToHclTerraform(struct!.verbose),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    zipkin_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigToHclTerraform(struct!.zipkinConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datadogConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datadogConfig = this._datadogConfig?.internalValue;
    }
    if (this._environmentVariablesForTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentVariablesForTags = this._environmentVariablesForTags?.internalValue;
    }
    if (this._literalsForTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.literalsForTags = this._literalsForTags?.internalValue;
    }
    if (this._openCensusConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openCensusConfig = this._openCensusConfig?.internalValue;
    }
    if (this._openTelemetryConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openTelemetryConfig = this._openTelemetryConfig?.internalValue;
    }
    if (this._requestHeadersForTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersForTags = this._requestHeadersForTags;
    }
    if (this._tracePercentages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracePercentages = this._tracePercentages?.internalValue;
    }
    if (this._verbose !== undefined) {
      hasAnyValues = true;
      internalValueResult.verbose = this._verbose;
    }
    if (this._zipkinConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.zipkinConfig = this._zipkinConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datadogConfig.internalValue = undefined;
      this._environmentVariablesForTags.internalValue = undefined;
      this._literalsForTags.internalValue = undefined;
      this._openCensusConfig.internalValue = undefined;
      this._openTelemetryConfig.internalValue = undefined;
      this._requestHeadersForTags = undefined;
      this._tracePercentages.internalValue = undefined;
      this._verbose = undefined;
      this._zipkinConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datadogConfig.internalValue = value.datadogConfig;
      this._environmentVariablesForTags.internalValue = value.environmentVariablesForTags;
      this._literalsForTags.internalValue = value.literalsForTags;
      this._openCensusConfig.internalValue = value.openCensusConfig;
      this._openTelemetryConfig.internalValue = value.openTelemetryConfig;
      this._requestHeadersForTags = value.requestHeadersForTags;
      this._tracePercentages.internalValue = value.tracePercentages;
      this._verbose = value.verbose;
      this._zipkinConfig.internalValue = value.zipkinConfig;
    }
  }

  // datadog_config - computed: false, optional: true, required: false
  private _datadogConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfigOutputReference(this, "datadog_config");
  public get datadogConfig() {
    return this._datadogConfig;
  }
  public putDatadogConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingDatadogConfig) {
    this._datadogConfig.internalValue = value;
  }
  public resetDatadogConfig() {
    this._datadogConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datadogConfigInput() {
    return this._datadogConfig.internalValue;
  }

  // environment_variables_for_tags - computed: false, optional: true, required: false
  private _environmentVariablesForTags = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTagsList(this, "environment_variables_for_tags", false);
  public get environmentVariablesForTags() {
    return this._environmentVariablesForTags;
  }
  public putEnvironmentVariablesForTags(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingEnvironmentVariablesForTags[] | cdktf.IResolvable) {
    this._environmentVariablesForTags.internalValue = value;
  }
  public resetEnvironmentVariablesForTags() {
    this._environmentVariablesForTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentVariablesForTagsInput() {
    return this._environmentVariablesForTags.internalValue;
  }

  // literals_for_tags - computed: false, optional: true, required: false
  private _literalsForTags = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTagsList(this, "literals_for_tags", false);
  public get literalsForTags() {
    return this._literalsForTags;
  }
  public putLiteralsForTags(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingLiteralsForTags[] | cdktf.IResolvable) {
    this._literalsForTags.internalValue = value;
  }
  public resetLiteralsForTags() {
    this._literalsForTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get literalsForTagsInput() {
    return this._literalsForTags.internalValue;
  }

  // open_census_config - computed: false, optional: true, required: false
  private _openCensusConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfigOutputReference(this, "open_census_config");
  public get openCensusConfig() {
    return this._openCensusConfig;
  }
  public putOpenCensusConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenCensusConfig) {
    this._openCensusConfig.internalValue = value;
  }
  public resetOpenCensusConfig() {
    this._openCensusConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openCensusConfigInput() {
    return this._openCensusConfig.internalValue;
  }

  // open_telemetry_config - computed: false, optional: true, required: false
  private _openTelemetryConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfigOutputReference(this, "open_telemetry_config");
  public get openTelemetryConfig() {
    return this._openTelemetryConfig;
  }
  public putOpenTelemetryConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOpenTelemetryConfig) {
    this._openTelemetryConfig.internalValue = value;
  }
  public resetOpenTelemetryConfig() {
    this._openTelemetryConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openTelemetryConfigInput() {
    return this._openTelemetryConfig.internalValue;
  }

  // request_headers_for_tags - computed: false, optional: true, required: false
  private _requestHeadersForTags?: string[]; 
  public get requestHeadersForTags() {
    return this.getListAttribute('request_headers_for_tags');
  }
  public set requestHeadersForTags(value: string[]) {
    this._requestHeadersForTags = value;
  }
  public resetRequestHeadersForTags() {
    this._requestHeadersForTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersForTagsInput() {
    return this._requestHeadersForTags;
  }

  // trace_percentages - computed: false, optional: true, required: false
  private _tracePercentages = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentagesOutputReference(this, "trace_percentages");
  public get tracePercentages() {
    return this._tracePercentages;
  }
  public putTracePercentages(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingTracePercentages) {
    this._tracePercentages.internalValue = value;
  }
  public resetTracePercentages() {
    this._tracePercentages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracePercentagesInput() {
    return this._tracePercentages.internalValue;
  }

  // verbose - computed: false, optional: true, required: false
  private _verbose?: boolean | cdktf.IResolvable; 
  public get verbose() {
    return this.getBooleanAttribute('verbose');
  }
  public set verbose(value: boolean | cdktf.IResolvable) {
    this._verbose = value;
  }
  public resetVerbose() {
    this._verbose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verboseInput() {
    return this._verbose;
  }

  // zipkin_config - computed: false, optional: true, required: false
  private _zipkinConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfigOutputReference(this, "zipkin_config");
  public get zipkinConfig() {
    return this._zipkinConfig;
  }
  public putZipkinConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingZipkinConfig) {
    this._zipkinConfig.internalValue = value;
  }
  public resetZipkinConfig() {
    this._zipkinConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zipkinConfigInput() {
    return this._zipkinConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#enabled DataK8SGatewaySoloIoGatewayV1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#enabled DataK8SGatewaySoloIoGatewayV1Manifest#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connect DataK8SGatewaySoloIoGatewayV1Manifest#connect}
  */
  readonly connect?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#websocket DataK8SGatewaySoloIoGatewayV1Manifest#websocket}
  */
  readonly websocket?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToTerraform(struct!.connect),
    websocket: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToTerraform(struct!.websocket),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectToHclTerraform(struct!.connect),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect",
    },
    websocket: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketToHclTerraform(struct!.websocket),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connect = this._connect?.internalValue;
    }
    if (this._websocket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.websocket = this._websocket?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connect.internalValue = undefined;
      this._websocket.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connect.internalValue = value.connect;
      this._websocket.internalValue = value.websocket;
    }
  }

  // connect - computed: false, optional: true, required: false
  private _connect = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnectOutputReference(this, "connect");
  public get connect() {
    return this._connect;
  }
  public putConnect(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesConnect) {
    this._connect.internalValue = value;
  }
  public resetConnect() {
    this._connect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectInput() {
    return this._connect.internalValue;
  }

  // websocket - computed: false, optional: true, required: false
  private _websocket = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocketOutputReference(this, "websocket");
  public get websocket() {
    return this._websocket;
  }
  public putWebsocket(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesWebsocket) {
    this._websocket.internalValue = value;
  }
  public resetWebsocket() {
    this._websocket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get websocketInput() {
    return this._websocket.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#pack_trace_reason DataK8SGatewaySoloIoGatewayV1Manifest#pack_trace_reason}
  */
  readonly packTraceReason?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#use_request_id_for_trace_sampling DataK8SGatewaySoloIoGatewayV1Manifest#use_request_id_for_trace_sampling}
  */
  readonly useRequestIdForTraceSampling?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pack_trace_reason: cdktf.booleanToTerraform(struct!.packTraceReason),
    use_request_id_for_trace_sampling: cdktf.booleanToTerraform(struct!.useRequestIdForTraceSampling),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pack_trace_reason: {
      value: cdktf.booleanToHclTerraform(struct!.packTraceReason),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_request_id_for_trace_sampling: {
      value: cdktf.booleanToHclTerraform(struct!.useRequestIdForTraceSampling),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._packTraceReason !== undefined) {
      hasAnyValues = true;
      internalValueResult.packTraceReason = this._packTraceReason;
    }
    if (this._useRequestIdForTraceSampling !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRequestIdForTraceSampling = this._useRequestIdForTraceSampling;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._packTraceReason = undefined;
      this._useRequestIdForTraceSampling = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._packTraceReason = value.packTraceReason;
      this._useRequestIdForTraceSampling = value.useRequestIdForTraceSampling;
    }
  }

  // pack_trace_reason - computed: false, optional: true, required: false
  private _packTraceReason?: boolean | cdktf.IResolvable; 
  public get packTraceReason() {
    return this.getBooleanAttribute('pack_trace_reason');
  }
  public set packTraceReason(value: boolean | cdktf.IResolvable) {
    this._packTraceReason = value;
  }
  public resetPackTraceReason() {
    this._packTraceReason = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packTraceReasonInput() {
    return this._packTraceReason;
  }

  // use_request_id_for_trace_sampling - computed: false, optional: true, required: false
  private _useRequestIdForTraceSampling?: boolean | cdktf.IResolvable; 
  public get useRequestIdForTraceSampling() {
    return this.getBooleanAttribute('use_request_id_for_trace_sampling');
  }
  public set useRequestIdForTraceSampling(value: boolean | cdktf.IResolvable) {
    this._useRequestIdForTraceSampling = value;
  }
  public resetUseRequestIdForTraceSampling() {
    this._useRequestIdForTraceSampling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRequestIdForTraceSamplingInput() {
    return this._useRequestIdForTraceSampling;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#accept_http10 DataK8SGatewaySoloIoGatewayV1Manifest#accept_http10}
  */
  readonly acceptHttp10?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#allow_chunked_length DataK8SGatewaySoloIoGatewayV1Manifest#allow_chunked_length}
  */
  readonly allowChunkedLength?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#append_x_forwarded_port DataK8SGatewaySoloIoGatewayV1Manifest#append_x_forwarded_port}
  */
  readonly appendXForwardedPort?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#codec_type DataK8SGatewaySoloIoGatewayV1Manifest#codec_type}
  */
  readonly codecType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_host_for_http10 DataK8SGatewaySoloIoGatewayV1Manifest#default_host_for_http10}
  */
  readonly defaultHostForHttp10?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#delayed_close_timeout DataK8SGatewaySoloIoGatewayV1Manifest#delayed_close_timeout}
  */
  readonly delayedCloseTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#drain_timeout DataK8SGatewaySoloIoGatewayV1Manifest#drain_timeout}
  */
  readonly drainTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#enable_trailers DataK8SGatewaySoloIoGatewayV1Manifest#enable_trailers}
  */
  readonly enableTrailers?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#forward_client_cert_details DataK8SGatewaySoloIoGatewayV1Manifest#forward_client_cert_details}
  */
  readonly forwardClientCertDetails?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#generate_request_id DataK8SGatewaySoloIoGatewayV1Manifest#generate_request_id}
  */
  readonly generateRequestId?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_with_underscores_action DataK8SGatewaySoloIoGatewayV1Manifest#headers_with_underscores_action}
  */
  readonly headersWithUnderscoresAction?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http2_protocol_options DataK8SGatewaySoloIoGatewayV1Manifest#http2_protocol_options}
  */
  readonly http2ProtocolOptions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#idle_timeout DataK8SGatewaySoloIoGatewayV1Manifest#idle_timeout}
  */
  readonly idleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#internal_address_config DataK8SGatewaySoloIoGatewayV1Manifest#internal_address_config}
  */
  readonly internalAddressConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_connection_duration DataK8SGatewaySoloIoGatewayV1Manifest#max_connection_duration}
  */
  readonly maxConnectionDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_headers_count DataK8SGatewaySoloIoGatewayV1Manifest#max_headers_count}
  */
  readonly maxHeadersCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_request_headers_kb DataK8SGatewaySoloIoGatewayV1Manifest#max_request_headers_kb}
  */
  readonly maxRequestHeadersKb?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_requests_per_connection DataK8SGatewaySoloIoGatewayV1Manifest#max_requests_per_connection}
  */
  readonly maxRequestsPerConnection?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_stream_duration DataK8SGatewaySoloIoGatewayV1Manifest#max_stream_duration}
  */
  readonly maxStreamDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#merge_slashes DataK8SGatewaySoloIoGatewayV1Manifest#merge_slashes}
  */
  readonly mergeSlashes?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#normalize_path DataK8SGatewaySoloIoGatewayV1Manifest#normalize_path}
  */
  readonly normalizePath?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path_with_escaped_slashes_action DataK8SGatewaySoloIoGatewayV1Manifest#path_with_escaped_slashes_action}
  */
  readonly pathWithEscapedSlashesAction?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#preserve_case_header_key_format DataK8SGatewaySoloIoGatewayV1Manifest#preserve_case_header_key_format}
  */
  readonly preserveCaseHeaderKeyFormat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#preserve_external_request_id DataK8SGatewaySoloIoGatewayV1Manifest#preserve_external_request_id}
  */
  readonly preserveExternalRequestId?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#proper_case_header_key_format DataK8SGatewaySoloIoGatewayV1Manifest#proper_case_header_key_format}
  */
  readonly properCaseHeaderKeyFormat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#proxy100_continue DataK8SGatewaySoloIoGatewayV1Manifest#proxy100_continue}
  */
  readonly proxy100Continue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_headers_timeout DataK8SGatewaySoloIoGatewayV1Manifest#request_headers_timeout}
  */
  readonly requestHeadersTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_timeout DataK8SGatewaySoloIoGatewayV1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#server_header_transformation DataK8SGatewaySoloIoGatewayV1Manifest#server_header_transformation}
  */
  readonly serverHeaderTransformation?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#server_name DataK8SGatewaySoloIoGatewayV1Manifest#server_name}
  */
  readonly serverName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#set_current_client_cert_details DataK8SGatewaySoloIoGatewayV1Manifest#set_current_client_cert_details}
  */
  readonly setCurrentClientCertDetails?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#skip_xff_append DataK8SGatewaySoloIoGatewayV1Manifest#skip_xff_append}
  */
  readonly skipXffAppend?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stream_idle_timeout DataK8SGatewaySoloIoGatewayV1Manifest#stream_idle_timeout}
  */
  readonly streamIdleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#strip_any_host_port DataK8SGatewaySoloIoGatewayV1Manifest#strip_any_host_port}
  */
  readonly stripAnyHostPort?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tracing DataK8SGatewaySoloIoGatewayV1Manifest#tracing}
  */
  readonly tracing?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#upgrades DataK8SGatewaySoloIoGatewayV1Manifest#upgrades}
  */
  readonly upgrades?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#use_remote_address DataK8SGatewaySoloIoGatewayV1Manifest#use_remote_address}
  */
  readonly useRemoteAddress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#uuid_request_id_config DataK8SGatewaySoloIoGatewayV1Manifest#uuid_request_id_config}
  */
  readonly uuidRequestIdConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#via DataK8SGatewaySoloIoGatewayV1Manifest#via}
  */
  readonly via?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#xff_num_trusted_hops DataK8SGatewaySoloIoGatewayV1Manifest#xff_num_trusted_hops}
  */
  readonly xffNumTrustedHops?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    accept_http10: cdktf.booleanToTerraform(struct!.acceptHttp10),
    allow_chunked_length: cdktf.booleanToTerraform(struct!.allowChunkedLength),
    append_x_forwarded_port: cdktf.booleanToTerraform(struct!.appendXForwardedPort),
    codec_type: cdktf.stringToTerraform(struct!.codecType),
    default_host_for_http10: cdktf.stringToTerraform(struct!.defaultHostForHttp10),
    delayed_close_timeout: cdktf.stringToTerraform(struct!.delayedCloseTimeout),
    drain_timeout: cdktf.stringToTerraform(struct!.drainTimeout),
    enable_trailers: cdktf.booleanToTerraform(struct!.enableTrailers),
    forward_client_cert_details: cdktf.stringToTerraform(struct!.forwardClientCertDetails),
    generate_request_id: cdktf.booleanToTerraform(struct!.generateRequestId),
    headers_with_underscores_action: cdktf.stringToTerraform(struct!.headersWithUnderscoresAction),
    http2_protocol_options: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToTerraform(struct!.http2ProtocolOptions),
    idle_timeout: cdktf.stringToTerraform(struct!.idleTimeout),
    internal_address_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToTerraform(struct!.internalAddressConfig),
    max_connection_duration: cdktf.stringToTerraform(struct!.maxConnectionDuration),
    max_headers_count: cdktf.numberToTerraform(struct!.maxHeadersCount),
    max_request_headers_kb: cdktf.numberToTerraform(struct!.maxRequestHeadersKb),
    max_requests_per_connection: cdktf.numberToTerraform(struct!.maxRequestsPerConnection),
    max_stream_duration: cdktf.stringToTerraform(struct!.maxStreamDuration),
    merge_slashes: cdktf.booleanToTerraform(struct!.mergeSlashes),
    normalize_path: cdktf.booleanToTerraform(struct!.normalizePath),
    path_with_escaped_slashes_action: cdktf.stringToTerraform(struct!.pathWithEscapedSlashesAction),
    preserve_case_header_key_format: cdktf.booleanToTerraform(struct!.preserveCaseHeaderKeyFormat),
    preserve_external_request_id: cdktf.booleanToTerraform(struct!.preserveExternalRequestId),
    proper_case_header_key_format: cdktf.booleanToTerraform(struct!.properCaseHeaderKeyFormat),
    proxy100_continue: cdktf.booleanToTerraform(struct!.proxy100Continue),
    request_headers_timeout: cdktf.stringToTerraform(struct!.requestHeadersTimeout),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
    server_header_transformation: cdktf.stringToTerraform(struct!.serverHeaderTransformation),
    server_name: cdktf.stringToTerraform(struct!.serverName),
    set_current_client_cert_details: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToTerraform(struct!.setCurrentClientCertDetails),
    skip_xff_append: cdktf.booleanToTerraform(struct!.skipXffAppend),
    stream_idle_timeout: cdktf.stringToTerraform(struct!.streamIdleTimeout),
    strip_any_host_port: cdktf.booleanToTerraform(struct!.stripAnyHostPort),
    tracing: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingToTerraform(struct!.tracing),
    upgrades: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToTerraform, false)(struct!.upgrades),
    use_remote_address: cdktf.booleanToTerraform(struct!.useRemoteAddress),
    uuid_request_id_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToTerraform(struct!.uuidRequestIdConfig),
    via: cdktf.stringToTerraform(struct!.via),
    xff_num_trusted_hops: cdktf.numberToTerraform(struct!.xffNumTrustedHops),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    accept_http10: {
      value: cdktf.booleanToHclTerraform(struct!.acceptHttp10),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_chunked_length: {
      value: cdktf.booleanToHclTerraform(struct!.allowChunkedLength),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    append_x_forwarded_port: {
      value: cdktf.booleanToHclTerraform(struct!.appendXForwardedPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    codec_type: {
      value: cdktf.stringToHclTerraform(struct!.codecType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_host_for_http10: {
      value: cdktf.stringToHclTerraform(struct!.defaultHostForHttp10),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delayed_close_timeout: {
      value: cdktf.stringToHclTerraform(struct!.delayedCloseTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    drain_timeout: {
      value: cdktf.stringToHclTerraform(struct!.drainTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_trailers: {
      value: cdktf.booleanToHclTerraform(struct!.enableTrailers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    forward_client_cert_details: {
      value: cdktf.stringToHclTerraform(struct!.forwardClientCertDetails),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    generate_request_id: {
      value: cdktf.booleanToHclTerraform(struct!.generateRequestId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers_with_underscores_action: {
      value: cdktf.stringToHclTerraform(struct!.headersWithUnderscoresAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http2_protocol_options: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsToHclTerraform(struct!.http2ProtocolOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions",
    },
    idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.idleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    internal_address_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigToHclTerraform(struct!.internalAddressConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig",
    },
    max_connection_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxConnectionDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_headers_count: {
      value: cdktf.numberToHclTerraform(struct!.maxHeadersCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_request_headers_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestHeadersKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_connection: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_stream_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxStreamDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    merge_slashes: {
      value: cdktf.booleanToHclTerraform(struct!.mergeSlashes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    normalize_path: {
      value: cdktf.booleanToHclTerraform(struct!.normalizePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    path_with_escaped_slashes_action: {
      value: cdktf.stringToHclTerraform(struct!.pathWithEscapedSlashesAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preserve_case_header_key_format: {
      value: cdktf.booleanToHclTerraform(struct!.preserveCaseHeaderKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_external_request_id: {
      value: cdktf.booleanToHclTerraform(struct!.preserveExternalRequestId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proper_case_header_key_format: {
      value: cdktf.booleanToHclTerraform(struct!.properCaseHeaderKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proxy100_continue: {
      value: cdktf.booleanToHclTerraform(struct!.proxy100Continue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_headers_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestHeadersTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_header_transformation: {
      value: cdktf.stringToHclTerraform(struct!.serverHeaderTransformation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set_current_client_cert_details: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsToHclTerraform(struct!.setCurrentClientCertDetails),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails",
    },
    skip_xff_append: {
      value: cdktf.booleanToHclTerraform(struct!.skipXffAppend),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stream_idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.streamIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    strip_any_host_port: {
      value: cdktf.booleanToHclTerraform(struct!.stripAnyHostPort),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tracing: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingToHclTerraform(struct!.tracing),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing",
    },
    upgrades: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesToHclTerraform, false)(struct!.upgrades),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesList",
    },
    use_remote_address: {
      value: cdktf.booleanToHclTerraform(struct!.useRemoteAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    uuid_request_id_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigToHclTerraform(struct!.uuidRequestIdConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig",
    },
    via: {
      value: cdktf.stringToHclTerraform(struct!.via),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    xff_num_trusted_hops: {
      value: cdktf.numberToHclTerraform(struct!.xffNumTrustedHops),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._acceptHttp10 !== undefined) {
      hasAnyValues = true;
      internalValueResult.acceptHttp10 = this._acceptHttp10;
    }
    if (this._allowChunkedLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowChunkedLength = this._allowChunkedLength;
    }
    if (this._appendXForwardedPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.appendXForwardedPort = this._appendXForwardedPort;
    }
    if (this._codecType !== undefined) {
      hasAnyValues = true;
      internalValueResult.codecType = this._codecType;
    }
    if (this._defaultHostForHttp10 !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultHostForHttp10 = this._defaultHostForHttp10;
    }
    if (this._delayedCloseTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.delayedCloseTimeout = this._delayedCloseTimeout;
    }
    if (this._drainTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.drainTimeout = this._drainTimeout;
    }
    if (this._enableTrailers !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableTrailers = this._enableTrailers;
    }
    if (this._forwardClientCertDetails !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardClientCertDetails = this._forwardClientCertDetails;
    }
    if (this._generateRequestId !== undefined) {
      hasAnyValues = true;
      internalValueResult.generateRequestId = this._generateRequestId;
    }
    if (this._headersWithUnderscoresAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersWithUnderscoresAction = this._headersWithUnderscoresAction;
    }
    if (this._http2ProtocolOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http2ProtocolOptions = this._http2ProtocolOptions?.internalValue;
    }
    if (this._idleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleTimeout = this._idleTimeout;
    }
    if (this._internalAddressConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalAddressConfig = this._internalAddressConfig?.internalValue;
    }
    if (this._maxConnectionDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnectionDuration = this._maxConnectionDuration;
    }
    if (this._maxHeadersCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxHeadersCount = this._maxHeadersCount;
    }
    if (this._maxRequestHeadersKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestHeadersKb = this._maxRequestHeadersKb;
    }
    if (this._maxRequestsPerConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerConnection = this._maxRequestsPerConnection;
    }
    if (this._maxStreamDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxStreamDuration = this._maxStreamDuration;
    }
    if (this._mergeSlashes !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeSlashes = this._mergeSlashes;
    }
    if (this._normalizePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.normalizePath = this._normalizePath;
    }
    if (this._pathWithEscapedSlashesAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathWithEscapedSlashesAction = this._pathWithEscapedSlashesAction;
    }
    if (this._preserveCaseHeaderKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveCaseHeaderKeyFormat = this._preserveCaseHeaderKeyFormat;
    }
    if (this._preserveExternalRequestId !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveExternalRequestId = this._preserveExternalRequestId;
    }
    if (this._properCaseHeaderKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.properCaseHeaderKeyFormat = this._properCaseHeaderKeyFormat;
    }
    if (this._proxy100Continue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxy100Continue = this._proxy100Continue;
    }
    if (this._requestHeadersTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersTimeout = this._requestHeadersTimeout;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._serverHeaderTransformation !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverHeaderTransformation = this._serverHeaderTransformation;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    if (this._setCurrentClientCertDetails?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setCurrentClientCertDetails = this._setCurrentClientCertDetails?.internalValue;
    }
    if (this._skipXffAppend !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipXffAppend = this._skipXffAppend;
    }
    if (this._streamIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamIdleTimeout = this._streamIdleTimeout;
    }
    if (this._stripAnyHostPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.stripAnyHostPort = this._stripAnyHostPort;
    }
    if (this._tracing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tracing = this._tracing?.internalValue;
    }
    if (this._upgrades?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upgrades = this._upgrades?.internalValue;
    }
    if (this._useRemoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRemoteAddress = this._useRemoteAddress;
    }
    if (this._uuidRequestIdConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.uuidRequestIdConfig = this._uuidRequestIdConfig?.internalValue;
    }
    if (this._via !== undefined) {
      hasAnyValues = true;
      internalValueResult.via = this._via;
    }
    if (this._xffNumTrustedHops !== undefined) {
      hasAnyValues = true;
      internalValueResult.xffNumTrustedHops = this._xffNumTrustedHops;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._acceptHttp10 = undefined;
      this._allowChunkedLength = undefined;
      this._appendXForwardedPort = undefined;
      this._codecType = undefined;
      this._defaultHostForHttp10 = undefined;
      this._delayedCloseTimeout = undefined;
      this._drainTimeout = undefined;
      this._enableTrailers = undefined;
      this._forwardClientCertDetails = undefined;
      this._generateRequestId = undefined;
      this._headersWithUnderscoresAction = undefined;
      this._http2ProtocolOptions.internalValue = undefined;
      this._idleTimeout = undefined;
      this._internalAddressConfig.internalValue = undefined;
      this._maxConnectionDuration = undefined;
      this._maxHeadersCount = undefined;
      this._maxRequestHeadersKb = undefined;
      this._maxRequestsPerConnection = undefined;
      this._maxStreamDuration = undefined;
      this._mergeSlashes = undefined;
      this._normalizePath = undefined;
      this._pathWithEscapedSlashesAction = undefined;
      this._preserveCaseHeaderKeyFormat = undefined;
      this._preserveExternalRequestId = undefined;
      this._properCaseHeaderKeyFormat = undefined;
      this._proxy100Continue = undefined;
      this._requestHeadersTimeout = undefined;
      this._requestTimeout = undefined;
      this._serverHeaderTransformation = undefined;
      this._serverName = undefined;
      this._setCurrentClientCertDetails.internalValue = undefined;
      this._skipXffAppend = undefined;
      this._streamIdleTimeout = undefined;
      this._stripAnyHostPort = undefined;
      this._tracing.internalValue = undefined;
      this._upgrades.internalValue = undefined;
      this._useRemoteAddress = undefined;
      this._uuidRequestIdConfig.internalValue = undefined;
      this._via = undefined;
      this._xffNumTrustedHops = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._acceptHttp10 = value.acceptHttp10;
      this._allowChunkedLength = value.allowChunkedLength;
      this._appendXForwardedPort = value.appendXForwardedPort;
      this._codecType = value.codecType;
      this._defaultHostForHttp10 = value.defaultHostForHttp10;
      this._delayedCloseTimeout = value.delayedCloseTimeout;
      this._drainTimeout = value.drainTimeout;
      this._enableTrailers = value.enableTrailers;
      this._forwardClientCertDetails = value.forwardClientCertDetails;
      this._generateRequestId = value.generateRequestId;
      this._headersWithUnderscoresAction = value.headersWithUnderscoresAction;
      this._http2ProtocolOptions.internalValue = value.http2ProtocolOptions;
      this._idleTimeout = value.idleTimeout;
      this._internalAddressConfig.internalValue = value.internalAddressConfig;
      this._maxConnectionDuration = value.maxConnectionDuration;
      this._maxHeadersCount = value.maxHeadersCount;
      this._maxRequestHeadersKb = value.maxRequestHeadersKb;
      this._maxRequestsPerConnection = value.maxRequestsPerConnection;
      this._maxStreamDuration = value.maxStreamDuration;
      this._mergeSlashes = value.mergeSlashes;
      this._normalizePath = value.normalizePath;
      this._pathWithEscapedSlashesAction = value.pathWithEscapedSlashesAction;
      this._preserveCaseHeaderKeyFormat = value.preserveCaseHeaderKeyFormat;
      this._preserveExternalRequestId = value.preserveExternalRequestId;
      this._properCaseHeaderKeyFormat = value.properCaseHeaderKeyFormat;
      this._proxy100Continue = value.proxy100Continue;
      this._requestHeadersTimeout = value.requestHeadersTimeout;
      this._requestTimeout = value.requestTimeout;
      this._serverHeaderTransformation = value.serverHeaderTransformation;
      this._serverName = value.serverName;
      this._setCurrentClientCertDetails.internalValue = value.setCurrentClientCertDetails;
      this._skipXffAppend = value.skipXffAppend;
      this._streamIdleTimeout = value.streamIdleTimeout;
      this._stripAnyHostPort = value.stripAnyHostPort;
      this._tracing.internalValue = value.tracing;
      this._upgrades.internalValue = value.upgrades;
      this._useRemoteAddress = value.useRemoteAddress;
      this._uuidRequestIdConfig.internalValue = value.uuidRequestIdConfig;
      this._via = value.via;
      this._xffNumTrustedHops = value.xffNumTrustedHops;
    }
  }

  // accept_http10 - computed: false, optional: true, required: false
  private _acceptHttp10?: boolean | cdktf.IResolvable; 
  public get acceptHttp10() {
    return this.getBooleanAttribute('accept_http10');
  }
  public set acceptHttp10(value: boolean | cdktf.IResolvable) {
    this._acceptHttp10 = value;
  }
  public resetAcceptHttp10() {
    this._acceptHttp10 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get acceptHttp10Input() {
    return this._acceptHttp10;
  }

  // allow_chunked_length - computed: false, optional: true, required: false
  private _allowChunkedLength?: boolean | cdktf.IResolvable; 
  public get allowChunkedLength() {
    return this.getBooleanAttribute('allow_chunked_length');
  }
  public set allowChunkedLength(value: boolean | cdktf.IResolvable) {
    this._allowChunkedLength = value;
  }
  public resetAllowChunkedLength() {
    this._allowChunkedLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowChunkedLengthInput() {
    return this._allowChunkedLength;
  }

  // append_x_forwarded_port - computed: false, optional: true, required: false
  private _appendXForwardedPort?: boolean | cdktf.IResolvable; 
  public get appendXForwardedPort() {
    return this.getBooleanAttribute('append_x_forwarded_port');
  }
  public set appendXForwardedPort(value: boolean | cdktf.IResolvable) {
    this._appendXForwardedPort = value;
  }
  public resetAppendXForwardedPort() {
    this._appendXForwardedPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendXForwardedPortInput() {
    return this._appendXForwardedPort;
  }

  // codec_type - computed: false, optional: true, required: false
  private _codecType?: string; 
  public get codecType() {
    return this.getStringAttribute('codec_type');
  }
  public set codecType(value: string) {
    this._codecType = value;
  }
  public resetCodecType() {
    this._codecType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codecTypeInput() {
    return this._codecType;
  }

  // default_host_for_http10 - computed: false, optional: true, required: false
  private _defaultHostForHttp10?: string; 
  public get defaultHostForHttp10() {
    return this.getStringAttribute('default_host_for_http10');
  }
  public set defaultHostForHttp10(value: string) {
    this._defaultHostForHttp10 = value;
  }
  public resetDefaultHostForHttp10() {
    this._defaultHostForHttp10 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultHostForHttp10Input() {
    return this._defaultHostForHttp10;
  }

  // delayed_close_timeout - computed: false, optional: true, required: false
  private _delayedCloseTimeout?: string; 
  public get delayedCloseTimeout() {
    return this.getStringAttribute('delayed_close_timeout');
  }
  public set delayedCloseTimeout(value: string) {
    this._delayedCloseTimeout = value;
  }
  public resetDelayedCloseTimeout() {
    this._delayedCloseTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayedCloseTimeoutInput() {
    return this._delayedCloseTimeout;
  }

  // drain_timeout - computed: false, optional: true, required: false
  private _drainTimeout?: string; 
  public get drainTimeout() {
    return this.getStringAttribute('drain_timeout');
  }
  public set drainTimeout(value: string) {
    this._drainTimeout = value;
  }
  public resetDrainTimeout() {
    this._drainTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get drainTimeoutInput() {
    return this._drainTimeout;
  }

  // enable_trailers - computed: false, optional: true, required: false
  private _enableTrailers?: boolean | cdktf.IResolvable; 
  public get enableTrailers() {
    return this.getBooleanAttribute('enable_trailers');
  }
  public set enableTrailers(value: boolean | cdktf.IResolvable) {
    this._enableTrailers = value;
  }
  public resetEnableTrailers() {
    this._enableTrailers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableTrailersInput() {
    return this._enableTrailers;
  }

  // forward_client_cert_details - computed: false, optional: true, required: false
  private _forwardClientCertDetails?: string; 
  public get forwardClientCertDetails() {
    return this.getStringAttribute('forward_client_cert_details');
  }
  public set forwardClientCertDetails(value: string) {
    this._forwardClientCertDetails = value;
  }
  public resetForwardClientCertDetails() {
    this._forwardClientCertDetails = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardClientCertDetailsInput() {
    return this._forwardClientCertDetails;
  }

  // generate_request_id - computed: false, optional: true, required: false
  private _generateRequestId?: boolean | cdktf.IResolvable; 
  public get generateRequestId() {
    return this.getBooleanAttribute('generate_request_id');
  }
  public set generateRequestId(value: boolean | cdktf.IResolvable) {
    this._generateRequestId = value;
  }
  public resetGenerateRequestId() {
    this._generateRequestId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get generateRequestIdInput() {
    return this._generateRequestId;
  }

  // headers_with_underscores_action - computed: false, optional: true, required: false
  private _headersWithUnderscoresAction?: string; 
  public get headersWithUnderscoresAction() {
    return this.getStringAttribute('headers_with_underscores_action');
  }
  public set headersWithUnderscoresAction(value: string) {
    this._headersWithUnderscoresAction = value;
  }
  public resetHeadersWithUnderscoresAction() {
    this._headersWithUnderscoresAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersWithUnderscoresActionInput() {
    return this._headersWithUnderscoresAction;
  }

  // http2_protocol_options - computed: false, optional: true, required: false
  private _http2ProtocolOptions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptionsOutputReference(this, "http2_protocol_options");
  public get http2ProtocolOptions() {
    return this._http2ProtocolOptions;
  }
  public putHttp2ProtocolOptions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsHttp2ProtocolOptions) {
    this._http2ProtocolOptions.internalValue = value;
  }
  public resetHttp2ProtocolOptions() {
    this._http2ProtocolOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get http2ProtocolOptionsInput() {
    return this._http2ProtocolOptions.internalValue;
  }

  // idle_timeout - computed: false, optional: true, required: false
  private _idleTimeout?: string; 
  public get idleTimeout() {
    return this.getStringAttribute('idle_timeout');
  }
  public set idleTimeout(value: string) {
    this._idleTimeout = value;
  }
  public resetIdleTimeout() {
    this._idleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleTimeoutInput() {
    return this._idleTimeout;
  }

  // internal_address_config - computed: false, optional: true, required: false
  private _internalAddressConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfigOutputReference(this, "internal_address_config");
  public get internalAddressConfig() {
    return this._internalAddressConfig;
  }
  public putInternalAddressConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsInternalAddressConfig) {
    this._internalAddressConfig.internalValue = value;
  }
  public resetInternalAddressConfig() {
    this._internalAddressConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get internalAddressConfigInput() {
    return this._internalAddressConfig.internalValue;
  }

  // max_connection_duration - computed: false, optional: true, required: false
  private _maxConnectionDuration?: string; 
  public get maxConnectionDuration() {
    return this.getStringAttribute('max_connection_duration');
  }
  public set maxConnectionDuration(value: string) {
    this._maxConnectionDuration = value;
  }
  public resetMaxConnectionDuration() {
    this._maxConnectionDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnectionDurationInput() {
    return this._maxConnectionDuration;
  }

  // max_headers_count - computed: false, optional: true, required: false
  private _maxHeadersCount?: number; 
  public get maxHeadersCount() {
    return this.getNumberAttribute('max_headers_count');
  }
  public set maxHeadersCount(value: number) {
    this._maxHeadersCount = value;
  }
  public resetMaxHeadersCount() {
    this._maxHeadersCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxHeadersCountInput() {
    return this._maxHeadersCount;
  }

  // max_request_headers_kb - computed: false, optional: true, required: false
  private _maxRequestHeadersKb?: number; 
  public get maxRequestHeadersKb() {
    return this.getNumberAttribute('max_request_headers_kb');
  }
  public set maxRequestHeadersKb(value: number) {
    this._maxRequestHeadersKb = value;
  }
  public resetMaxRequestHeadersKb() {
    this._maxRequestHeadersKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestHeadersKbInput() {
    return this._maxRequestHeadersKb;
  }

  // max_requests_per_connection - computed: false, optional: true, required: false
  private _maxRequestsPerConnection?: number; 
  public get maxRequestsPerConnection() {
    return this.getNumberAttribute('max_requests_per_connection');
  }
  public set maxRequestsPerConnection(value: number) {
    this._maxRequestsPerConnection = value;
  }
  public resetMaxRequestsPerConnection() {
    this._maxRequestsPerConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerConnectionInput() {
    return this._maxRequestsPerConnection;
  }

  // max_stream_duration - computed: false, optional: true, required: false
  private _maxStreamDuration?: string; 
  public get maxStreamDuration() {
    return this.getStringAttribute('max_stream_duration');
  }
  public set maxStreamDuration(value: string) {
    this._maxStreamDuration = value;
  }
  public resetMaxStreamDuration() {
    this._maxStreamDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxStreamDurationInput() {
    return this._maxStreamDuration;
  }

  // merge_slashes - computed: false, optional: true, required: false
  private _mergeSlashes?: boolean | cdktf.IResolvable; 
  public get mergeSlashes() {
    return this.getBooleanAttribute('merge_slashes');
  }
  public set mergeSlashes(value: boolean | cdktf.IResolvable) {
    this._mergeSlashes = value;
  }
  public resetMergeSlashes() {
    this._mergeSlashes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeSlashesInput() {
    return this._mergeSlashes;
  }

  // normalize_path - computed: false, optional: true, required: false
  private _normalizePath?: boolean | cdktf.IResolvable; 
  public get normalizePath() {
    return this.getBooleanAttribute('normalize_path');
  }
  public set normalizePath(value: boolean | cdktf.IResolvable) {
    this._normalizePath = value;
  }
  public resetNormalizePath() {
    this._normalizePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get normalizePathInput() {
    return this._normalizePath;
  }

  // path_with_escaped_slashes_action - computed: false, optional: true, required: false
  private _pathWithEscapedSlashesAction?: string; 
  public get pathWithEscapedSlashesAction() {
    return this.getStringAttribute('path_with_escaped_slashes_action');
  }
  public set pathWithEscapedSlashesAction(value: string) {
    this._pathWithEscapedSlashesAction = value;
  }
  public resetPathWithEscapedSlashesAction() {
    this._pathWithEscapedSlashesAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathWithEscapedSlashesActionInput() {
    return this._pathWithEscapedSlashesAction;
  }

  // preserve_case_header_key_format - computed: false, optional: true, required: false
  private _preserveCaseHeaderKeyFormat?: boolean | cdktf.IResolvable; 
  public get preserveCaseHeaderKeyFormat() {
    return this.getBooleanAttribute('preserve_case_header_key_format');
  }
  public set preserveCaseHeaderKeyFormat(value: boolean | cdktf.IResolvable) {
    this._preserveCaseHeaderKeyFormat = value;
  }
  public resetPreserveCaseHeaderKeyFormat() {
    this._preserveCaseHeaderKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveCaseHeaderKeyFormatInput() {
    return this._preserveCaseHeaderKeyFormat;
  }

  // preserve_external_request_id - computed: false, optional: true, required: false
  private _preserveExternalRequestId?: boolean | cdktf.IResolvable; 
  public get preserveExternalRequestId() {
    return this.getBooleanAttribute('preserve_external_request_id');
  }
  public set preserveExternalRequestId(value: boolean | cdktf.IResolvable) {
    this._preserveExternalRequestId = value;
  }
  public resetPreserveExternalRequestId() {
    this._preserveExternalRequestId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveExternalRequestIdInput() {
    return this._preserveExternalRequestId;
  }

  // proper_case_header_key_format - computed: false, optional: true, required: false
  private _properCaseHeaderKeyFormat?: boolean | cdktf.IResolvable; 
  public get properCaseHeaderKeyFormat() {
    return this.getBooleanAttribute('proper_case_header_key_format');
  }
  public set properCaseHeaderKeyFormat(value: boolean | cdktf.IResolvable) {
    this._properCaseHeaderKeyFormat = value;
  }
  public resetProperCaseHeaderKeyFormat() {
    this._properCaseHeaderKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get properCaseHeaderKeyFormatInput() {
    return this._properCaseHeaderKeyFormat;
  }

  // proxy100_continue - computed: false, optional: true, required: false
  private _proxy100Continue?: boolean | cdktf.IResolvable; 
  public get proxy100Continue() {
    return this.getBooleanAttribute('proxy100_continue');
  }
  public set proxy100Continue(value: boolean | cdktf.IResolvable) {
    this._proxy100Continue = value;
  }
  public resetProxy100Continue() {
    this._proxy100Continue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxy100ContinueInput() {
    return this._proxy100Continue;
  }

  // request_headers_timeout - computed: false, optional: true, required: false
  private _requestHeadersTimeout?: string; 
  public get requestHeadersTimeout() {
    return this.getStringAttribute('request_headers_timeout');
  }
  public set requestHeadersTimeout(value: string) {
    this._requestHeadersTimeout = value;
  }
  public resetRequestHeadersTimeout() {
    this._requestHeadersTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersTimeoutInput() {
    return this._requestHeadersTimeout;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // server_header_transformation - computed: false, optional: true, required: false
  private _serverHeaderTransformation?: string; 
  public get serverHeaderTransformation() {
    return this.getStringAttribute('server_header_transformation');
  }
  public set serverHeaderTransformation(value: string) {
    this._serverHeaderTransformation = value;
  }
  public resetServerHeaderTransformation() {
    this._serverHeaderTransformation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverHeaderTransformationInput() {
    return this._serverHeaderTransformation;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }

  // set_current_client_cert_details - computed: false, optional: true, required: false
  private _setCurrentClientCertDetails = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetailsOutputReference(this, "set_current_client_cert_details");
  public get setCurrentClientCertDetails() {
    return this._setCurrentClientCertDetails;
  }
  public putSetCurrentClientCertDetails(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsSetCurrentClientCertDetails) {
    this._setCurrentClientCertDetails.internalValue = value;
  }
  public resetSetCurrentClientCertDetails() {
    this._setCurrentClientCertDetails.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setCurrentClientCertDetailsInput() {
    return this._setCurrentClientCertDetails.internalValue;
  }

  // skip_xff_append - computed: false, optional: true, required: false
  private _skipXffAppend?: boolean | cdktf.IResolvable; 
  public get skipXffAppend() {
    return this.getBooleanAttribute('skip_xff_append');
  }
  public set skipXffAppend(value: boolean | cdktf.IResolvable) {
    this._skipXffAppend = value;
  }
  public resetSkipXffAppend() {
    this._skipXffAppend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipXffAppendInput() {
    return this._skipXffAppend;
  }

  // stream_idle_timeout - computed: false, optional: true, required: false
  private _streamIdleTimeout?: string; 
  public get streamIdleTimeout() {
    return this.getStringAttribute('stream_idle_timeout');
  }
  public set streamIdleTimeout(value: string) {
    this._streamIdleTimeout = value;
  }
  public resetStreamIdleTimeout() {
    this._streamIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamIdleTimeoutInput() {
    return this._streamIdleTimeout;
  }

  // strip_any_host_port - computed: false, optional: true, required: false
  private _stripAnyHostPort?: boolean | cdktf.IResolvable; 
  public get stripAnyHostPort() {
    return this.getBooleanAttribute('strip_any_host_port');
  }
  public set stripAnyHostPort(value: boolean | cdktf.IResolvable) {
    this._stripAnyHostPort = value;
  }
  public resetStripAnyHostPort() {
    this._stripAnyHostPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stripAnyHostPortInput() {
    return this._stripAnyHostPort;
  }

  // tracing - computed: false, optional: true, required: false
  private _tracing = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracingOutputReference(this, "tracing");
  public get tracing() {
    return this._tracing;
  }
  public putTracing(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsTracing) {
    this._tracing.internalValue = value;
  }
  public resetTracing() {
    this._tracing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tracingInput() {
    return this._tracing.internalValue;
  }

  // upgrades - computed: false, optional: true, required: false
  private _upgrades = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgradesList(this, "upgrades", false);
  public get upgrades() {
    return this._upgrades;
  }
  public putUpgrades(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUpgrades[] | cdktf.IResolvable) {
    this._upgrades.internalValue = value;
  }
  public resetUpgrades() {
    this._upgrades.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upgradesInput() {
    return this._upgrades.internalValue;
  }

  // use_remote_address - computed: false, optional: true, required: false
  private _useRemoteAddress?: boolean | cdktf.IResolvable; 
  public get useRemoteAddress() {
    return this.getBooleanAttribute('use_remote_address');
  }
  public set useRemoteAddress(value: boolean | cdktf.IResolvable) {
    this._useRemoteAddress = value;
  }
  public resetUseRemoteAddress() {
    this._useRemoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRemoteAddressInput() {
    return this._useRemoteAddress;
  }

  // uuid_request_id_config - computed: false, optional: true, required: false
  private _uuidRequestIdConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfigOutputReference(this, "uuid_request_id_config");
  public get uuidRequestIdConfig() {
    return this._uuidRequestIdConfig;
  }
  public putUuidRequestIdConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsUuidRequestIdConfig) {
    this._uuidRequestIdConfig.internalValue = value;
  }
  public resetUuidRequestIdConfig() {
    this._uuidRequestIdConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uuidRequestIdConfigInput() {
    return this._uuidRequestIdConfig.internalValue;
  }

  // via - computed: false, optional: true, required: false
  private _via?: string; 
  public get via() {
    return this.getStringAttribute('via');
  }
  public set via(value: string) {
    this._via = value;
  }
  public resetVia() {
    this._via = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get viaInput() {
    return this._via;
  }

  // xff_num_trusted_hops - computed: false, optional: true, required: false
  private _xffNumTrustedHops?: number; 
  public get xffNumTrustedHops() {
    return this.getNumberAttribute('xff_num_trusted_hops');
  }
  public set xffNumTrustedHops(value: number) {
    this._xffNumTrustedHops = value;
  }
  public resetXffNumTrustedHops() {
    this._xffNumTrustedHops = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get xffNumTrustedHopsInput() {
    return this._xffNumTrustedHops;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#fill_interval DataK8SGatewaySoloIoGatewayV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_tokens DataK8SGatewaySoloIoGatewayV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoGatewayV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#default_limit DataK8SGatewaySoloIoGatewayV1Manifest#default_limit}
  */
  readonly defaultLimit?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#enable_x_ratelimit_headers DataK8SGatewaySoloIoGatewayV1Manifest#enable_x_ratelimit_headers}
  */
  readonly enableXRatelimitHeaders?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#local_rate_limit_per_downstream_connection DataK8SGatewaySoloIoGatewayV1Manifest#local_rate_limit_per_downstream_connection}
  */
  readonly localRateLimitPerDownstreamConnection?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_limit: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToTerraform(struct!.defaultLimit),
    enable_x_ratelimit_headers: cdktf.booleanToTerraform(struct!.enableXRatelimitHeaders),
    local_rate_limit_per_downstream_connection: cdktf.booleanToTerraform(struct!.localRateLimitPerDownstreamConnection),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_limit: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimitToHclTerraform(struct!.defaultLimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit",
    },
    enable_x_ratelimit_headers: {
      value: cdktf.booleanToHclTerraform(struct!.enableXRatelimitHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_rate_limit_per_downstream_connection: {
      value: cdktf.booleanToHclTerraform(struct!.localRateLimitPerDownstreamConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultLimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultLimit = this._defaultLimit?.internalValue;
    }
    if (this._enableXRatelimitHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableXRatelimitHeaders = this._enableXRatelimitHeaders;
    }
    if (this._localRateLimitPerDownstreamConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRateLimitPerDownstreamConnection = this._localRateLimitPerDownstreamConnection;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultLimit.internalValue = undefined;
      this._enableXRatelimitHeaders = undefined;
      this._localRateLimitPerDownstreamConnection = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultLimit.internalValue = value.defaultLimit;
      this._enableXRatelimitHeaders = value.enableXRatelimitHeaders;
      this._localRateLimitPerDownstreamConnection = value.localRateLimitPerDownstreamConnection;
    }
  }

  // default_limit - computed: false, optional: true, required: false
  private _defaultLimit = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimitOutputReference(this, "default_limit");
  public get defaultLimit() {
    return this._defaultLimit;
  }
  public putDefaultLimit(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitDefaultLimit) {
    this._defaultLimit.internalValue = value;
  }
  public resetDefaultLimit() {
    this._defaultLimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultLimitInput() {
    return this._defaultLimit.internalValue;
  }

  // enable_x_ratelimit_headers - computed: false, optional: true, required: false
  private _enableXRatelimitHeaders?: boolean | cdktf.IResolvable; 
  public get enableXRatelimitHeaders() {
    return this.getBooleanAttribute('enable_x_ratelimit_headers');
  }
  public set enableXRatelimitHeaders(value: boolean | cdktf.IResolvable) {
    this._enableXRatelimitHeaders = value;
  }
  public resetEnableXRatelimitHeaders() {
    this._enableXRatelimitHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableXRatelimitHeadersInput() {
    return this._enableXRatelimitHeaders;
  }

  // local_rate_limit_per_downstream_connection - computed: false, optional: true, required: false
  private _localRateLimitPerDownstreamConnection?: boolean | cdktf.IResolvable; 
  public get localRateLimitPerDownstreamConnection() {
    return this.getBooleanAttribute('local_rate_limit_per_downstream_connection');
  }
  public set localRateLimitPerDownstreamConnection(value: boolean | cdktf.IResolvable) {
    this._localRateLimitPerDownstreamConnection = value;
  }
  public resetLocalRateLimitPerDownstreamConnection() {
    this._localRateLimitPerDownstreamConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRateLimitPerDownstreamConnectionInput() {
    return this._localRateLimitPerDownstreamConnection;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#fill_interval DataK8SGatewaySoloIoGatewayV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_tokens DataK8SGatewaySoloIoGatewayV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoGatewayV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#charge_cluster_stat DataK8SGatewaySoloIoGatewayV1Manifest#charge_cluster_stat}
  */
  readonly chargeClusterStat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#charge_listener_stat DataK8SGatewaySoloIoGatewayV1Manifest#charge_listener_stat}
  */
  readonly chargeListenerStat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#emit_dynamic_metadata DataK8SGatewaySoloIoGatewayV1Manifest#emit_dynamic_metadata}
  */
  readonly emitDynamicMetadata?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#measure_request_internally DataK8SGatewaySoloIoGatewayV1Manifest#measure_request_internally}
  */
  readonly measureRequestInternally?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request DataK8SGatewaySoloIoGatewayV1Manifest#request}
  */
  readonly request?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response DataK8SGatewaySoloIoGatewayV1Manifest#response}
  */
  readonly response?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatencyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    charge_cluster_stat: cdktf.booleanToTerraform(struct!.chargeClusterStat),
    charge_listener_stat: cdktf.booleanToTerraform(struct!.chargeListenerStat),
    emit_dynamic_metadata: cdktf.booleanToTerraform(struct!.emitDynamicMetadata),
    measure_request_internally: cdktf.booleanToTerraform(struct!.measureRequestInternally),
    request: cdktf.stringToTerraform(struct!.request),
    response: cdktf.stringToTerraform(struct!.response),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatencyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    charge_cluster_stat: {
      value: cdktf.booleanToHclTerraform(struct!.chargeClusterStat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    charge_listener_stat: {
      value: cdktf.booleanToHclTerraform(struct!.chargeListenerStat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    emit_dynamic_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.emitDynamicMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    measure_request_internally: {
      value: cdktf.booleanToHclTerraform(struct!.measureRequestInternally),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request: {
      value: cdktf.stringToHclTerraform(struct!.request),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response: {
      value: cdktf.stringToHclTerraform(struct!.response),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chargeClusterStat !== undefined) {
      hasAnyValues = true;
      internalValueResult.chargeClusterStat = this._chargeClusterStat;
    }
    if (this._chargeListenerStat !== undefined) {
      hasAnyValues = true;
      internalValueResult.chargeListenerStat = this._chargeListenerStat;
    }
    if (this._emitDynamicMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.emitDynamicMetadata = this._emitDynamicMetadata;
    }
    if (this._measureRequestInternally !== undefined) {
      hasAnyValues = true;
      internalValueResult.measureRequestInternally = this._measureRequestInternally;
    }
    if (this._request !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request;
    }
    if (this._response !== undefined) {
      hasAnyValues = true;
      internalValueResult.response = this._response;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chargeClusterStat = undefined;
      this._chargeListenerStat = undefined;
      this._emitDynamicMetadata = undefined;
      this._measureRequestInternally = undefined;
      this._request = undefined;
      this._response = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chargeClusterStat = value.chargeClusterStat;
      this._chargeListenerStat = value.chargeListenerStat;
      this._emitDynamicMetadata = value.emitDynamicMetadata;
      this._measureRequestInternally = value.measureRequestInternally;
      this._request = value.request;
      this._response = value.response;
    }
  }

  // charge_cluster_stat - computed: false, optional: true, required: false
  private _chargeClusterStat?: boolean | cdktf.IResolvable; 
  public get chargeClusterStat() {
    return this.getBooleanAttribute('charge_cluster_stat');
  }
  public set chargeClusterStat(value: boolean | cdktf.IResolvable) {
    this._chargeClusterStat = value;
  }
  public resetChargeClusterStat() {
    this._chargeClusterStat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chargeClusterStatInput() {
    return this._chargeClusterStat;
  }

  // charge_listener_stat - computed: false, optional: true, required: false
  private _chargeListenerStat?: boolean | cdktf.IResolvable; 
  public get chargeListenerStat() {
    return this.getBooleanAttribute('charge_listener_stat');
  }
  public set chargeListenerStat(value: boolean | cdktf.IResolvable) {
    this._chargeListenerStat = value;
  }
  public resetChargeListenerStat() {
    this._chargeListenerStat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chargeListenerStatInput() {
    return this._chargeListenerStat;
  }

  // emit_dynamic_metadata - computed: false, optional: true, required: false
  private _emitDynamicMetadata?: boolean | cdktf.IResolvable; 
  public get emitDynamicMetadata() {
    return this.getBooleanAttribute('emit_dynamic_metadata');
  }
  public set emitDynamicMetadata(value: boolean | cdktf.IResolvable) {
    this._emitDynamicMetadata = value;
  }
  public resetEmitDynamicMetadata() {
    this._emitDynamicMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emitDynamicMetadataInput() {
    return this._emitDynamicMetadata;
  }

  // measure_request_internally - computed: false, optional: true, required: false
  private _measureRequestInternally?: boolean | cdktf.IResolvable; 
  public get measureRequestInternally() {
    return this.getBooleanAttribute('measure_request_internally');
  }
  public set measureRequestInternally(value: boolean | cdktf.IResolvable) {
    this._measureRequestInternally = value;
  }
  public resetMeasureRequestInternally() {
    this._measureRequestInternally = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get measureRequestInternallyInput() {
    return this._measureRequestInternally;
  }

  // request - computed: false, optional: true, required: false
  private _request?: string; 
  public get request() {
    return this.getStringAttribute('request');
  }
  public set request(value: string) {
    this._request = value;
  }
  public resetRequest() {
    this._request = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request;
  }

  // response - computed: false, optional: true, required: false
  private _response?: string; 
  public get response() {
    return this.getStringAttribute('response');
  }
  public set response(value: string) {
    this._response = value;
  }
  public resetResponse() {
    this._response = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseInput() {
    return this._response;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#authority DataK8SGatewaySoloIoGatewayV1Manifest#authority}
  */
  readonly authority?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#deny_on_fail DataK8SGatewaySoloIoGatewayV1Manifest#deny_on_fail}
  */
  readonly denyOnFail?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#enable_x_ratelimit_headers DataK8SGatewaySoloIoGatewayV1Manifest#enable_x_ratelimit_headers}
  */
  readonly enableXRatelimitHeaders?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#rate_limit_before_auth DataK8SGatewaySoloIoGatewayV1Manifest#rate_limit_before_auth}
  */
  readonly rateLimitBeforeAuth?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ratelimit_server_ref DataK8SGatewaySoloIoGatewayV1Manifest#ratelimit_server_ref}
  */
  readonly ratelimitServerRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_timeout DataK8SGatewaySoloIoGatewayV1Manifest#request_timeout}
  */
  readonly requestTimeout?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deny_on_fail: cdktf.booleanToTerraform(struct!.denyOnFail),
    enable_x_ratelimit_headers: cdktf.booleanToTerraform(struct!.enableXRatelimitHeaders),
    grpc_service: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcServiceToTerraform(struct!.grpcService),
    rate_limit_before_auth: cdktf.booleanToTerraform(struct!.rateLimitBeforeAuth),
    ratelimit_server_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRefToTerraform(struct!.ratelimitServerRef),
    request_timeout: cdktf.stringToTerraform(struct!.requestTimeout),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deny_on_fail: {
      value: cdktf.booleanToHclTerraform(struct!.denyOnFail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_x_ratelimit_headers: {
      value: cdktf.booleanToHclTerraform(struct!.enableXRatelimitHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService",
    },
    rate_limit_before_auth: {
      value: cdktf.booleanToHclTerraform(struct!.rateLimitBeforeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ratelimit_server_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRefToHclTerraform(struct!.ratelimitServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef",
    },
    request_timeout: {
      value: cdktf.stringToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denyOnFail !== undefined) {
      hasAnyValues = true;
      internalValueResult.denyOnFail = this._denyOnFail;
    }
    if (this._enableXRatelimitHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableXRatelimitHeaders = this._enableXRatelimitHeaders;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._rateLimitBeforeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.rateLimitBeforeAuth = this._rateLimitBeforeAuth;
    }
    if (this._ratelimitServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ratelimitServerRef = this._ratelimitServerRef?.internalValue;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denyOnFail = undefined;
      this._enableXRatelimitHeaders = undefined;
      this._grpcService.internalValue = undefined;
      this._rateLimitBeforeAuth = undefined;
      this._ratelimitServerRef.internalValue = undefined;
      this._requestTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denyOnFail = value.denyOnFail;
      this._enableXRatelimitHeaders = value.enableXRatelimitHeaders;
      this._grpcService.internalValue = value.grpcService;
      this._rateLimitBeforeAuth = value.rateLimitBeforeAuth;
      this._ratelimitServerRef.internalValue = value.ratelimitServerRef;
      this._requestTimeout = value.requestTimeout;
    }
  }

  // deny_on_fail - computed: false, optional: true, required: false
  private _denyOnFail?: boolean | cdktf.IResolvable; 
  public get denyOnFail() {
    return this.getBooleanAttribute('deny_on_fail');
  }
  public set denyOnFail(value: boolean | cdktf.IResolvable) {
    this._denyOnFail = value;
  }
  public resetDenyOnFail() {
    this._denyOnFail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyOnFailInput() {
    return this._denyOnFail;
  }

  // enable_x_ratelimit_headers - computed: false, optional: true, required: false
  private _enableXRatelimitHeaders?: boolean | cdktf.IResolvable; 
  public get enableXRatelimitHeaders() {
    return this.getBooleanAttribute('enable_x_ratelimit_headers');
  }
  public set enableXRatelimitHeaders(value: boolean | cdktf.IResolvable) {
    this._enableXRatelimitHeaders = value;
  }
  public resetEnableXRatelimitHeaders() {
    this._enableXRatelimitHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableXRatelimitHeadersInput() {
    return this._enableXRatelimitHeaders;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // rate_limit_before_auth - computed: false, optional: true, required: false
  private _rateLimitBeforeAuth?: boolean | cdktf.IResolvable; 
  public get rateLimitBeforeAuth() {
    return this.getBooleanAttribute('rate_limit_before_auth');
  }
  public set rateLimitBeforeAuth(value: boolean | cdktf.IResolvable) {
    this._rateLimitBeforeAuth = value;
  }
  public resetRateLimitBeforeAuth() {
    this._rateLimitBeforeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rateLimitBeforeAuthInput() {
    return this._rateLimitBeforeAuth;
  }

  // ratelimit_server_ref - computed: false, optional: true, required: false
  private _ratelimitServerRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRefOutputReference(this, "ratelimit_server_ref");
  public get ratelimitServerRef() {
    return this._ratelimitServerRef;
  }
  public putRatelimitServerRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerRatelimitServerRef) {
    this._ratelimitServerRef.internalValue = value;
  }
  public resetRatelimitServerRef() {
    this._ratelimitServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ratelimitServerRefInput() {
    return this._ratelimitServerRef.internalValue;
  }

  // request_timeout - computed: false, optional: true, required: false
  private _requestTimeout?: string; 
  public get requestTimeout() {
    return this.getStringAttribute('request_timeout');
  }
  public set requestTimeout(value: string) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_stats DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_stats}
  */
  readonly dynamicStats?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#suppress_envoy_headers DataK8SGatewaySoloIoGatewayV1Manifest#suppress_envoy_headers}
  */
  readonly suppressEnvoyHeaders?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouterToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic_stats: cdktf.booleanToTerraform(struct!.dynamicStats),
    suppress_envoy_headers: cdktf.booleanToTerraform(struct!.suppressEnvoyHeaders),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouterToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic_stats: {
      value: cdktf.booleanToHclTerraform(struct!.dynamicStats),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    suppress_envoy_headers: {
      value: cdktf.booleanToHclTerraform(struct!.suppressEnvoyHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamicStats !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicStats = this._dynamicStats;
    }
    if (this._suppressEnvoyHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.suppressEnvoyHeaders = this._suppressEnvoyHeaders;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamicStats = undefined;
      this._suppressEnvoyHeaders = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamicStats = value.dynamicStats;
      this._suppressEnvoyHeaders = value.suppressEnvoyHeaders;
    }
  }

  // dynamic_stats - computed: false, optional: true, required: false
  private _dynamicStats?: boolean | cdktf.IResolvable; 
  public get dynamicStats() {
    return this.getBooleanAttribute('dynamic_stats');
  }
  public set dynamicStats(value: boolean | cdktf.IResolvable) {
    this._dynamicStats = value;
  }
  public resetDynamicStats() {
    this._dynamicStats = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicStatsInput() {
    return this._dynamicStats;
  }

  // suppress_envoy_headers - computed: false, optional: true, required: false
  private _suppressEnvoyHeaders?: boolean | cdktf.IResolvable; 
  public get suppressEnvoyHeaders() {
    return this.getBooleanAttribute('suppress_envoy_headers');
  }
  public set suppressEnvoyHeaders(value: boolean | cdktf.IResolvable) {
    this._suppressEnvoyHeaders = value;
  }
  public resetSuppressEnvoyHeaders() {
    this._suppressEnvoyHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suppressEnvoyHeadersInput() {
    return this._suppressEnvoyHeaders;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path DataK8SGatewaySoloIoGatewayV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ttl DataK8SGatewaySoloIoGatewayV1Manifest#ttl}
  */
  readonly ttl?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookieToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    ttl: cdktf.stringToTerraform(struct!.ttl),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookieToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
      this._ttl = value.ttl;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cookie DataK8SGatewaySoloIoGatewayV1Manifest#cookie}
  */
  readonly cookie?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookie: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookieToTerraform(struct!.cookie),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookie: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookie.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookie.internalValue = value.cookie;
    }
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_name DataK8SGatewaySoloIoGatewayV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBasedToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBasedToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBasedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headerName = value.headerName;
    }
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cookie_based DataK8SGatewaySoloIoGatewayV1Manifest#cookie_based}
  */
  readonly cookieBased?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_based DataK8SGatewaySoloIoGatewayV1Manifest#header_based}
  */
  readonly headerBased?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#strict DataK8SGatewaySoloIoGatewayV1Manifest#strict}
  */
  readonly strict?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookie_based: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedToTerraform(struct!.cookieBased),
    header_based: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBasedToTerraform(struct!.headerBased),
    strict: cdktf.booleanToTerraform(struct!.strict),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookie_based: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedToHclTerraform(struct!.cookieBased),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased",
    },
    header_based: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBasedToHclTerraform(struct!.headerBased),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased",
    },
    strict: {
      value: cdktf.booleanToHclTerraform(struct!.strict),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookieBased?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookieBased = this._cookieBased?.internalValue;
    }
    if (this._headerBased?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerBased = this._headerBased?.internalValue;
    }
    if (this._strict !== undefined) {
      hasAnyValues = true;
      internalValueResult.strict = this._strict;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookieBased.internalValue = undefined;
      this._headerBased.internalValue = undefined;
      this._strict = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookieBased.internalValue = value.cookieBased;
      this._headerBased.internalValue = value.headerBased;
      this._strict = value.strict;
    }
  }

  // cookie_based - computed: false, optional: true, required: false
  private _cookieBased = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBasedOutputReference(this, "cookie_based");
  public get cookieBased() {
    return this._cookieBased;
  }
  public putCookieBased(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionCookieBased) {
    this._cookieBased.internalValue = value;
  }
  public resetCookieBased() {
    this._cookieBased.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieBasedInput() {
    return this._cookieBased.internalValue;
  }

  // header_based - computed: false, optional: true, required: false
  private _headerBased = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBasedOutputReference(this, "header_based");
  public get headerBased() {
    return this._headerBased;
  }
  public putHeaderBased(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionHeaderBased) {
    this._headerBased.internalValue = value;
  }
  public resetHeaderBased() {
    this._headerBased.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerBasedInput() {
    return this._headerBased.internalValue;
  }

  // strict - computed: false, optional: true, required: false
  private _strict?: boolean | cdktf.IResolvable; 
  public get strict() {
    return this.getBooleanAttribute('strict');
  }
  public set strict(value: boolean | cdktf.IResolvable) {
    this._strict = value;
  }
  public resetStrict() {
    this._strict = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictInput() {
    return this._strict;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tap_server DataK8SGatewaySoloIoGatewayV1Manifest#tap_server}
  */
  readonly tapServer?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tap_server: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServerToTerraform(struct!.tapServer),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tap_server: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServerToHclTerraform(struct!.tapServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tapServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tapServer = this._tapServer?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = value.tapServer;
    }
  }

  // tap_server - computed: false, optional: true, required: false
  private _tapServer = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServerOutputReference(this, "tap_server");
  public get tapServer() {
    return this._tapServer;
  }
  public putTapServer(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceTapServer) {
    this._tapServer.internalValue = value;
  }
  public resetTapServer() {
    this._tapServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapServerInput() {
    return this._tapServer.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServerToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServerToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tap_server DataK8SGatewaySoloIoGatewayV1Manifest#tap_server}
  */
  readonly tapServer?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#timeout DataK8SGatewaySoloIoGatewayV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    tap_server: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServerToTerraform(struct!.tapServer),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    tap_server: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServerToHclTerraform(struct!.tapServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._tapServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tapServer = this._tapServer?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._tapServer.internalValue = value.tapServer;
      this._timeout = value.timeout;
    }
  }

  // tap_server - computed: false, optional: true, required: false
  private _tapServer = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServerOutputReference(this, "tap_server");
  public get tapServer() {
    return this._tapServer;
  }
  public putTapServer(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceTapServer) {
    this._tapServer.internalValue = value;
  }
  public resetTapServer() {
    this._tapServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapServerInput() {
    return this._tapServer.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_service DataK8SGatewaySoloIoGatewayV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http_service DataK8SGatewaySoloIoGatewayV1Manifest#http_service}
  */
  readonly httpService?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_service: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceToTerraform(struct!.grpcService),
    http_service: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceToTerraform(struct!.httpService),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_service: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService",
    },
    http_service: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceToHclTerraform(struct!.httpService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._httpService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpService = this._httpService?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcService.internalValue = undefined;
      this._httpService.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcService.internalValue = value.grpcService;
      this._httpService.internalValue = value.httpService;
    }
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // http_service - computed: false, optional: true, required: false
  private _httpService = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpServiceOutputReference(this, "http_service");
  public get httpService() {
    return this._httpService;
  }
  public putHttpService(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksHttpService) {
    this._httpService.internalValue = value;
  }
  public resetHttpService() {
    this._httpService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpServiceInput() {
    return this._httpService.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_buffered_rx_bytes DataK8SGatewaySoloIoGatewayV1Manifest#max_buffered_rx_bytes}
  */
  readonly maxBufferedRxBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_buffered_tx_bytes DataK8SGatewaySoloIoGatewayV1Manifest#max_buffered_tx_bytes}
  */
  readonly maxBufferedTxBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#record_downstream_connection DataK8SGatewaySoloIoGatewayV1Manifest#record_downstream_connection}
  */
  readonly recordDownstreamConnection?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#record_headers_received_time DataK8SGatewaySoloIoGatewayV1Manifest#record_headers_received_time}
  */
  readonly recordHeadersReceivedTime?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sinks DataK8SGatewaySoloIoGatewayV1Manifest#sinks}
  */
  readonly sinks?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_buffered_rx_bytes: cdktf.numberToTerraform(struct!.maxBufferedRxBytes),
    max_buffered_tx_bytes: cdktf.numberToTerraform(struct!.maxBufferedTxBytes),
    record_downstream_connection: cdktf.booleanToTerraform(struct!.recordDownstreamConnection),
    record_headers_received_time: cdktf.booleanToTerraform(struct!.recordHeadersReceivedTime),
    sinks: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksToTerraform, false)(struct!.sinks),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_buffered_rx_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferedRxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_buffered_tx_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferedTxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    record_downstream_connection: {
      value: cdktf.booleanToHclTerraform(struct!.recordDownstreamConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    record_headers_received_time: {
      value: cdktf.booleanToHclTerraform(struct!.recordHeadersReceivedTime),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sinks: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksToHclTerraform, false)(struct!.sinks),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxBufferedRxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferedRxBytes = this._maxBufferedRxBytes;
    }
    if (this._maxBufferedTxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferedTxBytes = this._maxBufferedTxBytes;
    }
    if (this._recordDownstreamConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordDownstreamConnection = this._recordDownstreamConnection;
    }
    if (this._recordHeadersReceivedTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordHeadersReceivedTime = this._recordHeadersReceivedTime;
    }
    if (this._sinks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sinks = this._sinks?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxBufferedRxBytes = undefined;
      this._maxBufferedTxBytes = undefined;
      this._recordDownstreamConnection = undefined;
      this._recordHeadersReceivedTime = undefined;
      this._sinks.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxBufferedRxBytes = value.maxBufferedRxBytes;
      this._maxBufferedTxBytes = value.maxBufferedTxBytes;
      this._recordDownstreamConnection = value.recordDownstreamConnection;
      this._recordHeadersReceivedTime = value.recordHeadersReceivedTime;
      this._sinks.internalValue = value.sinks;
    }
  }

  // max_buffered_rx_bytes - computed: false, optional: true, required: false
  private _maxBufferedRxBytes?: number; 
  public get maxBufferedRxBytes() {
    return this.getNumberAttribute('max_buffered_rx_bytes');
  }
  public set maxBufferedRxBytes(value: number) {
    this._maxBufferedRxBytes = value;
  }
  public resetMaxBufferedRxBytes() {
    this._maxBufferedRxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferedRxBytesInput() {
    return this._maxBufferedRxBytes;
  }

  // max_buffered_tx_bytes - computed: false, optional: true, required: false
  private _maxBufferedTxBytes?: number; 
  public get maxBufferedTxBytes() {
    return this.getNumberAttribute('max_buffered_tx_bytes');
  }
  public set maxBufferedTxBytes(value: number) {
    this._maxBufferedTxBytes = value;
  }
  public resetMaxBufferedTxBytes() {
    this._maxBufferedTxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferedTxBytesInput() {
    return this._maxBufferedTxBytes;
  }

  // record_downstream_connection - computed: false, optional: true, required: false
  private _recordDownstreamConnection?: boolean | cdktf.IResolvable; 
  public get recordDownstreamConnection() {
    return this.getBooleanAttribute('record_downstream_connection');
  }
  public set recordDownstreamConnection(value: boolean | cdktf.IResolvable) {
    this._recordDownstreamConnection = value;
  }
  public resetRecordDownstreamConnection() {
    this._recordDownstreamConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordDownstreamConnectionInput() {
    return this._recordDownstreamConnection;
  }

  // record_headers_received_time - computed: false, optional: true, required: false
  private _recordHeadersReceivedTime?: boolean | cdktf.IResolvable; 
  public get recordHeadersReceivedTime() {
    return this.getBooleanAttribute('record_headers_received_time');
  }
  public set recordHeadersReceivedTime(value: boolean | cdktf.IResolvable) {
    this._recordHeadersReceivedTime = value;
  }
  public resetRecordHeadersReceivedTime() {
    this._recordHeadersReceivedTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordHeadersReceivedTimeInput() {
    return this._recordHeadersReceivedTime;
  }

  // sinks - computed: false, optional: true, required: false
  private _sinks = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinksList(this, "sinks", false);
  public get sinks() {
    return this._sinks;
  }
  public putSinks(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapSinks[] | cdktf.IResolvable) {
    this._sinks.internalValue = value;
  }
  public resetSinks() {
    this._sinks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sinksInput() {
    return this._sinks.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#action DataK8SGatewaySoloIoGatewayV1Manifest#action}
  */
  readonly action?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#location DataK8SGatewaySoloIoGatewayV1Manifest#location}
  */
  readonly location?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLoggingToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    location: cdktf.stringToTerraform(struct!.location),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLoggingToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLoggingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._location = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._location = value.location;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // location - computed: false, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#config_map_ref DataK8SGatewaySoloIoGatewayV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#data_map_keys DataK8SGatewaySoloIoGatewayV1Manifest#data_map_keys}
  */
  readonly dataMapKeys?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToTerraform(struct!.configMapRef),
    data_map_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dataMapKeys),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef",
    },
    data_map_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dataMapKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._dataMapKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataMapKeys = this._dataMapKeys;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._dataMapKeys = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._dataMapKeys = value.dataMapKeys;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // data_map_keys - computed: false, optional: true, required: false
  private _dataMapKeys?: string[]; 
  public get dataMapKeys() {
    return this.getListAttribute('data_map_keys');
  }
  public set dataMapKeys(value: string[]) {
    this._dataMapKeys = value;
  }
  public resetDataMapKeys() {
    this._dataMapKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataMapKeysInput() {
    return this._dataMapKeys;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#custom_settings_file DataK8SGatewaySoloIoGatewayV1Manifest#custom_settings_file}
  */
  readonly customSettingsFile?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#custom_settings_string DataK8SGatewaySoloIoGatewayV1Manifest#custom_settings_string}
  */
  readonly customSettingsString?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSetToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_settings_file: cdktf.stringToTerraform(struct!.customSettingsFile),
    custom_settings_string: cdktf.stringToTerraform(struct!.customSettingsString),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSetToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_settings_file: {
      value: cdktf.stringToHclTerraform(struct!.customSettingsFile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_settings_string: {
      value: cdktf.stringToHclTerraform(struct!.customSettingsString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customSettingsFile !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSettingsFile = this._customSettingsFile;
    }
    if (this._customSettingsString !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSettingsString = this._customSettingsString;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customSettingsFile = undefined;
      this._customSettingsString = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customSettingsFile = value.customSettingsFile;
      this._customSettingsString = value.customSettingsString;
    }
  }

  // custom_settings_file - computed: false, optional: true, required: false
  private _customSettingsFile?: string; 
  public get customSettingsFile() {
    return this.getStringAttribute('custom_settings_file');
  }
  public set customSettingsFile(value: string) {
    this._customSettingsFile = value;
  }
  public resetCustomSettingsFile() {
    this._customSettingsFile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSettingsFileInput() {
    return this._customSettingsFile;
  }

  // custom_settings_string - computed: false, optional: true, required: false
  private _customSettingsString?: string; 
  public get customSettingsString() {
    return this.getStringAttribute('custom_settings_string');
  }
  public set customSettingsString(value: string) {
    this._customSettingsString = value;
  }
  public resetCustomSettingsString() {
    this._customSettingsString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSettingsStringInput() {
    return this._customSettingsString;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#directory DataK8SGatewaySoloIoGatewayV1Manifest#directory}
  */
  readonly directory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#files DataK8SGatewaySoloIoGatewayV1Manifest#files}
  */
  readonly files?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#rule_str DataK8SGatewaySoloIoGatewayV1Manifest#rule_str}
  */
  readonly ruleStr?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    directory: cdktf.stringToTerraform(struct!.directory),
    files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.files),
    rule_str: cdktf.stringToTerraform(struct!.ruleStr),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    directory: {
      value: cdktf.stringToHclTerraform(struct!.directory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.files),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    rule_str: {
      value: cdktf.stringToHclTerraform(struct!.ruleStr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._directory !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory;
    }
    if (this._files !== undefined) {
      hasAnyValues = true;
      internalValueResult.files = this._files;
    }
    if (this._ruleStr !== undefined) {
      hasAnyValues = true;
      internalValueResult.ruleStr = this._ruleStr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._directory = undefined;
      this._files = undefined;
      this._ruleStr = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._directory = value.directory;
      this._files = value.files;
      this._ruleStr = value.ruleStr;
    }
  }

  // directory - computed: false, optional: true, required: false
  private _directory?: string; 
  public get directory() {
    return this.getStringAttribute('directory');
  }
  public set directory(value: string) {
    this._directory = value;
  }
  public resetDirectory() {
    this._directory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory;
  }

  // files - computed: false, optional: true, required: false
  private _files?: string[]; 
  public get files() {
    return this.getListAttribute('files');
  }
  public set files(value: string[]) {
    this._files = value;
  }
  public resetFiles() {
    this._files = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filesInput() {
    return this._files;
  }

  // rule_str - computed: false, optional: true, required: false
  private _ruleStr?: string; 
  public get ruleStr() {
    return this.getStringAttribute('rule_str');
  }
  public set ruleStr(value: string) {
    this._ruleStr = value;
  }
  public resetRuleStr() {
    this._ruleStr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleStrInput() {
    return this._ruleStr;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#audit_logging DataK8SGatewaySoloIoGatewayV1Manifest#audit_logging}
  */
  readonly auditLogging?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#config_map_rule_sets DataK8SGatewaySoloIoGatewayV1Manifest#config_map_rule_sets}
  */
  readonly configMapRuleSets?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#core_rule_set DataK8SGatewaySoloIoGatewayV1Manifest#core_rule_set}
  */
  readonly coreRuleSet?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#custom_intervention_message DataK8SGatewaySoloIoGatewayV1Manifest#custom_intervention_message}
  */
  readonly customInterventionMessage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disabled DataK8SGatewaySoloIoGatewayV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_headers_only DataK8SGatewaySoloIoGatewayV1Manifest#request_headers_only}
  */
  readonly requestHeadersOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_headers_only DataK8SGatewaySoloIoGatewayV1Manifest#response_headers_only}
  */
  readonly responseHeadersOnly?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#rule_sets DataK8SGatewaySoloIoGatewayV1Manifest#rule_sets}
  */
  readonly ruleSets?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audit_logging: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLoggingToTerraform(struct!.auditLogging),
    config_map_rule_sets: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsToTerraform, false)(struct!.configMapRuleSets),
    core_rule_set: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSetToTerraform(struct!.coreRuleSet),
    custom_intervention_message: cdktf.stringToTerraform(struct!.customInterventionMessage),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    request_headers_only: cdktf.booleanToTerraform(struct!.requestHeadersOnly),
    response_headers_only: cdktf.booleanToTerraform(struct!.responseHeadersOnly),
    rule_sets: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsToTerraform, false)(struct!.ruleSets),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audit_logging: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLoggingToHclTerraform(struct!.auditLogging),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging",
    },
    config_map_rule_sets: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsToHclTerraform, false)(struct!.configMapRuleSets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsList",
    },
    core_rule_set: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSetToHclTerraform(struct!.coreRuleSet),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet",
    },
    custom_intervention_message: {
      value: cdktf.stringToHclTerraform(struct!.customInterventionMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_headers_only: {
      value: cdktf.booleanToHclTerraform(struct!.requestHeadersOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_headers_only: {
      value: cdktf.booleanToHclTerraform(struct!.responseHeadersOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rule_sets: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsToHclTerraform, false)(struct!.ruleSets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auditLogging?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditLogging = this._auditLogging?.internalValue;
    }
    if (this._configMapRuleSets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRuleSets = this._configMapRuleSets?.internalValue;
    }
    if (this._coreRuleSet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.coreRuleSet = this._coreRuleSet?.internalValue;
    }
    if (this._customInterventionMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.customInterventionMessage = this._customInterventionMessage;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._requestHeadersOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersOnly = this._requestHeadersOnly;
    }
    if (this._responseHeadersOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersOnly = this._responseHeadersOnly;
    }
    if (this._ruleSets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ruleSets = this._ruleSets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auditLogging.internalValue = undefined;
      this._configMapRuleSets.internalValue = undefined;
      this._coreRuleSet.internalValue = undefined;
      this._customInterventionMessage = undefined;
      this._disabled = undefined;
      this._requestHeadersOnly = undefined;
      this._responseHeadersOnly = undefined;
      this._ruleSets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auditLogging.internalValue = value.auditLogging;
      this._configMapRuleSets.internalValue = value.configMapRuleSets;
      this._coreRuleSet.internalValue = value.coreRuleSet;
      this._customInterventionMessage = value.customInterventionMessage;
      this._disabled = value.disabled;
      this._requestHeadersOnly = value.requestHeadersOnly;
      this._responseHeadersOnly = value.responseHeadersOnly;
      this._ruleSets.internalValue = value.ruleSets;
    }
  }

  // audit_logging - computed: false, optional: true, required: false
  private _auditLogging = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLoggingOutputReference(this, "audit_logging");
  public get auditLogging() {
    return this._auditLogging;
  }
  public putAuditLogging(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafAuditLogging) {
    this._auditLogging.internalValue = value;
  }
  public resetAuditLogging() {
    this._auditLogging.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditLoggingInput() {
    return this._auditLogging.internalValue;
  }

  // config_map_rule_sets - computed: false, optional: true, required: false
  private _configMapRuleSets = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSetsList(this, "config_map_rule_sets", false);
  public get configMapRuleSets() {
    return this._configMapRuleSets;
  }
  public putConfigMapRuleSets(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafConfigMapRuleSets[] | cdktf.IResolvable) {
    this._configMapRuleSets.internalValue = value;
  }
  public resetConfigMapRuleSets() {
    this._configMapRuleSets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRuleSetsInput() {
    return this._configMapRuleSets.internalValue;
  }

  // core_rule_set - computed: false, optional: true, required: false
  private _coreRuleSet = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSetOutputReference(this, "core_rule_set");
  public get coreRuleSet() {
    return this._coreRuleSet;
  }
  public putCoreRuleSet(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafCoreRuleSet) {
    this._coreRuleSet.internalValue = value;
  }
  public resetCoreRuleSet() {
    this._coreRuleSet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get coreRuleSetInput() {
    return this._coreRuleSet.internalValue;
  }

  // custom_intervention_message - computed: false, optional: true, required: false
  private _customInterventionMessage?: string; 
  public get customInterventionMessage() {
    return this.getStringAttribute('custom_intervention_message');
  }
  public set customInterventionMessage(value: string) {
    this._customInterventionMessage = value;
  }
  public resetCustomInterventionMessage() {
    this._customInterventionMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInterventionMessageInput() {
    return this._customInterventionMessage;
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // request_headers_only - computed: false, optional: true, required: false
  private _requestHeadersOnly?: boolean | cdktf.IResolvable; 
  public get requestHeadersOnly() {
    return this.getBooleanAttribute('request_headers_only');
  }
  public set requestHeadersOnly(value: boolean | cdktf.IResolvable) {
    this._requestHeadersOnly = value;
  }
  public resetRequestHeadersOnly() {
    this._requestHeadersOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersOnlyInput() {
    return this._requestHeadersOnly;
  }

  // response_headers_only - computed: false, optional: true, required: false
  private _responseHeadersOnly?: boolean | cdktf.IResolvable; 
  public get responseHeadersOnly() {
    return this.getBooleanAttribute('response_headers_only');
  }
  public set responseHeadersOnly(value: boolean | cdktf.IResolvable) {
    this._responseHeadersOnly = value;
  }
  public resetResponseHeadersOnly() {
    this._responseHeadersOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersOnlyInput() {
    return this._responseHeadersOnly;
  }

  // rule_sets - computed: false, optional: true, required: false
  private _ruleSets = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSetsList(this, "rule_sets", false);
  public get ruleSets() {
    return this._ruleSets;
  }
  public putRuleSets(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafRuleSets[] | cdktf.IResolvable) {
    this._ruleSets.internalValue = value;
  }
  public resetRuleSets() {
    this._ruleSets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleSetsInput() {
    return this._ruleSets.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#predicate DataK8SGatewaySoloIoGatewayV1Manifest#predicate}
  */
  readonly predicate?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stage DataK8SGatewaySoloIoGatewayV1Manifest#stage}
  */
  readonly stage?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStageToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    predicate: cdktf.stringToTerraform(struct!.predicate),
    stage: cdktf.stringToTerraform(struct!.stage),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStageToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    predicate: {
      value: cdktf.stringToHclTerraform(struct!.predicate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage: {
      value: cdktf.stringToHclTerraform(struct!.stage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._predicate !== undefined) {
      hasAnyValues = true;
      internalValueResult.predicate = this._predicate;
    }
    if (this._stage !== undefined) {
      hasAnyValues = true;
      internalValueResult.stage = this._stage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._predicate = undefined;
      this._stage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._predicate = value.predicate;
      this._stage = value.stage;
    }
  }

  // predicate - computed: false, optional: true, required: false
  private _predicate?: string; 
  public get predicate() {
    return this.getStringAttribute('predicate');
  }
  public set predicate(value: string) {
    this._predicate = value;
  }
  public resetPredicate() {
    this._predicate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get predicateInput() {
    return this._predicate;
  }

  // stage - computed: false, optional: true, required: false
  private _stage?: string; 
  public get stage() {
    return this.getStringAttribute('stage');
  }
  public set stage(value: string) {
    this._stage = value;
  }
  public resetStage() {
    this._stage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stageInput() {
    return this._stage;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#config DataK8SGatewaySoloIoGatewayV1Manifest#config}
  */
  readonly config?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#fail_open DataK8SGatewaySoloIoGatewayV1Manifest#fail_open}
  */
  readonly failOpen?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#file_path DataK8SGatewaySoloIoGatewayV1Manifest#file_path}
  */
  readonly filePath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#filter_stage DataK8SGatewaySoloIoGatewayV1Manifest#filter_stage}
  */
  readonly filterStage?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#image DataK8SGatewaySoloIoGatewayV1Manifest#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#root_id DataK8SGatewaySoloIoGatewayV1Manifest#root_id}
  */
  readonly rootId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#vm_type DataK8SGatewaySoloIoGatewayV1Manifest#vm_type}
  */
  readonly vmType?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.config),
    fail_open: cdktf.booleanToTerraform(struct!.failOpen),
    file_path: cdktf.stringToTerraform(struct!.filePath),
    filter_stage: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStageToTerraform(struct!.filterStage),
    image: cdktf.stringToTerraform(struct!.image),
    name: cdktf.stringToTerraform(struct!.name),
    root_id: cdktf.stringToTerraform(struct!.rootId),
    vm_type: cdktf.stringToTerraform(struct!.vmType),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.config),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    fail_open: {
      value: cdktf.booleanToHclTerraform(struct!.failOpen),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    file_path: {
      value: cdktf.stringToHclTerraform(struct!.filePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter_stage: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStageToHclTerraform(struct!.filterStage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_id: {
      value: cdktf.stringToHclTerraform(struct!.rootId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vm_type: {
      value: cdktf.stringToHclTerraform(struct!.vmType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._failOpen !== undefined) {
      hasAnyValues = true;
      internalValueResult.failOpen = this._failOpen;
    }
    if (this._filePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.filePath = this._filePath;
    }
    if (this._filterStage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterStage = this._filterStage?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._rootId !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootId = this._rootId;
    }
    if (this._vmType !== undefined) {
      hasAnyValues = true;
      internalValueResult.vmType = this._vmType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._config = undefined;
      this._failOpen = undefined;
      this._filePath = undefined;
      this._filterStage.internalValue = undefined;
      this._image = undefined;
      this._name = undefined;
      this._rootId = undefined;
      this._vmType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._config = value.config;
      this._failOpen = value.failOpen;
      this._filePath = value.filePath;
      this._filterStage.internalValue = value.filterStage;
      this._image = value.image;
      this._name = value.name;
      this._rootId = value.rootId;
      this._vmType = value.vmType;
    }
  }

  // config - computed: false, optional: true, required: false
  private _config?: { [key: string]: string }; 
  public get config() {
    return this.getStringMapAttribute('config');
  }
  public set config(value: { [key: string]: string }) {
    this._config = value;
  }
  public resetConfig() {
    this._config = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // fail_open - computed: false, optional: true, required: false
  private _failOpen?: boolean | cdktf.IResolvable; 
  public get failOpen() {
    return this.getBooleanAttribute('fail_open');
  }
  public set failOpen(value: boolean | cdktf.IResolvable) {
    this._failOpen = value;
  }
  public resetFailOpen() {
    this._failOpen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failOpenInput() {
    return this._failOpen;
  }

  // file_path - computed: false, optional: true, required: false
  private _filePath?: string; 
  public get filePath() {
    return this.getStringAttribute('file_path');
  }
  public set filePath(value: string) {
    this._filePath = value;
  }
  public resetFilePath() {
    this._filePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filePathInput() {
    return this._filePath;
  }

  // filter_stage - computed: false, optional: true, required: false
  private _filterStage = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStageOutputReference(this, "filter_stage");
  public get filterStage() {
    return this._filterStage;
  }
  public putFilterStage(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersFilterStage) {
    this._filterStage.internalValue = value;
  }
  public resetFilterStage() {
    this._filterStage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterStageInput() {
    return this._filterStage.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // root_id - computed: false, optional: true, required: false
  private _rootId?: string; 
  public get rootId() {
    return this.getStringAttribute('root_id');
  }
  public set rootId(value: string) {
    this._rootId = value;
  }
  public resetRootId() {
    this._rootId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootIdInput() {
    return this._rootId;
  }

  // vm_type - computed: false, optional: true, required: false
  private _vmType?: string; 
  public get vmType() {
    return this.getStringAttribute('vm_type');
  }
  public set vmType(value: string) {
    this._vmType = value;
  }
  public resetVmType() {
    this._vmType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vmTypeInput() {
    return this._vmType;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#filters DataK8SGatewaySoloIoGatewayV1Manifest#filters}
  */
  readonly filters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersToTerraform, false)(struct!.filters),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#buffer DataK8SGatewaySoloIoGatewayV1Manifest#buffer}
  */
  readonly buffer?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#caching DataK8SGatewaySoloIoGatewayV1Manifest#caching}
  */
  readonly caching?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connection_limit DataK8SGatewaySoloIoGatewayV1Manifest#connection_limit}
  */
  readonly connectionLimit?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#csrf DataK8SGatewaySoloIoGatewayV1Manifest#csrf}
  */
  readonly csrf?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable_ext_proc DataK8SGatewaySoloIoGatewayV1Manifest#disable_ext_proc}
  */
  readonly disableExtProc?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dlp DataK8SGatewaySoloIoGatewayV1Manifest#dlp}
  */
  readonly dlp?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#dynamic_forward_proxy DataK8SGatewaySoloIoGatewayV1Manifest#dynamic_forward_proxy}
  */
  readonly dynamicForwardProxy?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ext_proc DataK8SGatewaySoloIoGatewayV1Manifest#ext_proc}
  */
  readonly extProc?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extauth DataK8SGatewaySoloIoGatewayV1Manifest#extauth}
  */
  readonly extauth?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#extensions DataK8SGatewaySoloIoGatewayV1Manifest#extensions}
  */
  readonly extensions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_json_transcoder DataK8SGatewaySoloIoGatewayV1Manifest#grpc_json_transcoder}
  */
  readonly grpcJsonTranscoder?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#grpc_web DataK8SGatewaySoloIoGatewayV1Manifest#grpc_web}
  */
  readonly grpcWeb?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#gzip DataK8SGatewaySoloIoGatewayV1Manifest#gzip}
  */
  readonly gzip?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header_validation_settings DataK8SGatewaySoloIoGatewayV1Manifest#header_validation_settings}
  */
  readonly headerValidationSettings?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#health_check DataK8SGatewaySoloIoGatewayV1Manifest#health_check}
  */
  readonly healthCheck?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http_connection_manager_settings DataK8SGatewaySoloIoGatewayV1Manifest#http_connection_manager_settings}
  */
  readonly httpConnectionManagerSettings?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#http_local_ratelimit DataK8SGatewaySoloIoGatewayV1Manifest#http_local_ratelimit}
  */
  readonly httpLocalRatelimit?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#leftmost_xff_address DataK8SGatewaySoloIoGatewayV1Manifest#leftmost_xff_address}
  */
  readonly leftmostXffAddress?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#network_local_ratelimit DataK8SGatewaySoloIoGatewayV1Manifest#network_local_ratelimit}
  */
  readonly networkLocalRatelimit?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#proxy_latency DataK8SGatewaySoloIoGatewayV1Manifest#proxy_latency}
  */
  readonly proxyLatency?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ratelimit_server DataK8SGatewaySoloIoGatewayV1Manifest#ratelimit_server}
  */
  readonly ratelimitServer?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#router DataK8SGatewaySoloIoGatewayV1Manifest#router}
  */
  readonly router?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sanitize_cluster_header DataK8SGatewaySoloIoGatewayV1Manifest#sanitize_cluster_header}
  */
  readonly sanitizeClusterHeader?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#stateful_session DataK8SGatewaySoloIoGatewayV1Manifest#stateful_session}
  */
  readonly statefulSession?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tap DataK8SGatewaySoloIoGatewayV1Manifest#tap}
  */
  readonly tap?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#waf DataK8SGatewaySoloIoGatewayV1Manifest#waf}
  */
  readonly waf?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#wasm DataK8SGatewaySoloIoGatewayV1Manifest#wasm}
  */
  readonly wasm?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBufferToTerraform(struct!.buffer),
    caching: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingToTerraform(struct!.caching),
    connection_limit: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimitToTerraform(struct!.connectionLimit),
    csrf: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfToTerraform(struct!.csrf),
    disable_ext_proc: cdktf.booleanToTerraform(struct!.disableExtProc),
    dlp: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpToTerraform(struct!.dlp),
    dynamic_forward_proxy: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyToTerraform(struct!.dynamicForwardProxy),
    ext_proc: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcToTerraform(struct!.extProc),
    extauth: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthToTerraform(struct!.extauth),
    extensions: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensionsToTerraform(struct!.extensions),
    grpc_json_transcoder: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderToTerraform(struct!.grpcJsonTranscoder),
    grpc_web: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWebToTerraform(struct!.grpcWeb),
    gzip: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzipToTerraform(struct!.gzip),
    header_validation_settings: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettingsToTerraform(struct!.headerValidationSettings),
    health_check: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheckToTerraform(struct!.healthCheck),
    http_connection_manager_settings: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsToTerraform(struct!.httpConnectionManagerSettings),
    http_local_ratelimit: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitToTerraform(struct!.httpLocalRatelimit),
    leftmost_xff_address: cdktf.booleanToTerraform(struct!.leftmostXffAddress),
    network_local_ratelimit: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimitToTerraform(struct!.networkLocalRatelimit),
    proxy_latency: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatencyToTerraform(struct!.proxyLatency),
    ratelimit_server: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerToTerraform(struct!.ratelimitServer),
    router: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouterToTerraform(struct!.router),
    sanitize_cluster_header: cdktf.booleanToTerraform(struct!.sanitizeClusterHeader),
    stateful_session: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionToTerraform(struct!.statefulSession),
    tap: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapToTerraform(struct!.tap),
    waf: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafToTerraform(struct!.waf),
    wasm: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmToTerraform(struct!.wasm),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBufferToHclTerraform(struct!.buffer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer",
    },
    caching: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingToHclTerraform(struct!.caching),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching",
    },
    connection_limit: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimitToHclTerraform(struct!.connectionLimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit",
    },
    csrf: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfToHclTerraform(struct!.csrf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf",
    },
    disable_ext_proc: {
      value: cdktf.booleanToHclTerraform(struct!.disableExtProc),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dlp: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpToHclTerraform(struct!.dlp),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp",
    },
    dynamic_forward_proxy: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyToHclTerraform(struct!.dynamicForwardProxy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy",
    },
    ext_proc: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcToHclTerraform(struct!.extProc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc",
    },
    extauth: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthToHclTerraform(struct!.extauth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth",
    },
    extensions: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensionsToHclTerraform(struct!.extensions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions",
    },
    grpc_json_transcoder: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderToHclTerraform(struct!.grpcJsonTranscoder),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder",
    },
    grpc_web: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWebToHclTerraform(struct!.grpcWeb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb",
    },
    gzip: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzipToHclTerraform(struct!.gzip),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip",
    },
    header_validation_settings: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettingsToHclTerraform(struct!.headerValidationSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings",
    },
    health_check: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheckToHclTerraform(struct!.healthCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck",
    },
    http_connection_manager_settings: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsToHclTerraform(struct!.httpConnectionManagerSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings",
    },
    http_local_ratelimit: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitToHclTerraform(struct!.httpLocalRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit",
    },
    leftmost_xff_address: {
      value: cdktf.booleanToHclTerraform(struct!.leftmostXffAddress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    network_local_ratelimit: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimitToHclTerraform(struct!.networkLocalRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit",
    },
    proxy_latency: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatencyToHclTerraform(struct!.proxyLatency),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency",
    },
    ratelimit_server: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerToHclTerraform(struct!.ratelimitServer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer",
    },
    router: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouterToHclTerraform(struct!.router),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter",
    },
    sanitize_cluster_header: {
      value: cdktf.booleanToHclTerraform(struct!.sanitizeClusterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stateful_session: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionToHclTerraform(struct!.statefulSession),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession",
    },
    tap: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapToHclTerraform(struct!.tap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap",
    },
    waf: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafToHclTerraform(struct!.waf),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf",
    },
    wasm: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmToHclTerraform(struct!.wasm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._buffer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.buffer = this._buffer?.internalValue;
    }
    if (this._caching?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caching = this._caching?.internalValue;
    }
    if (this._connectionLimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionLimit = this._connectionLimit?.internalValue;
    }
    if (this._csrf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.csrf = this._csrf?.internalValue;
    }
    if (this._disableExtProc !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableExtProc = this._disableExtProc;
    }
    if (this._dlp?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dlp = this._dlp?.internalValue;
    }
    if (this._dynamicForwardProxy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicForwardProxy = this._dynamicForwardProxy?.internalValue;
    }
    if (this._extProc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extProc = this._extProc?.internalValue;
    }
    if (this._extauth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extauth = this._extauth?.internalValue;
    }
    if (this._extensions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extensions = this._extensions?.internalValue;
    }
    if (this._grpcJsonTranscoder?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcJsonTranscoder = this._grpcJsonTranscoder?.internalValue;
    }
    if (this._grpcWeb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcWeb = this._grpcWeb?.internalValue;
    }
    if (this._gzip?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gzip = this._gzip?.internalValue;
    }
    if (this._headerValidationSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValidationSettings = this._headerValidationSettings?.internalValue;
    }
    if (this._healthCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheck = this._healthCheck?.internalValue;
    }
    if (this._httpConnectionManagerSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpConnectionManagerSettings = this._httpConnectionManagerSettings?.internalValue;
    }
    if (this._httpLocalRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLocalRatelimit = this._httpLocalRatelimit?.internalValue;
    }
    if (this._leftmostXffAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.leftmostXffAddress = this._leftmostXffAddress;
    }
    if (this._networkLocalRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkLocalRatelimit = this._networkLocalRatelimit?.internalValue;
    }
    if (this._proxyLatency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyLatency = this._proxyLatency?.internalValue;
    }
    if (this._ratelimitServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ratelimitServer = this._ratelimitServer?.internalValue;
    }
    if (this._router?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.router = this._router?.internalValue;
    }
    if (this._sanitizeClusterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.sanitizeClusterHeader = this._sanitizeClusterHeader;
    }
    if (this._statefulSession?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.statefulSession = this._statefulSession?.internalValue;
    }
    if (this._tap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tap = this._tap?.internalValue;
    }
    if (this._waf?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.waf = this._waf?.internalValue;
    }
    if (this._wasm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wasm = this._wasm?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._buffer.internalValue = undefined;
      this._caching.internalValue = undefined;
      this._connectionLimit.internalValue = undefined;
      this._csrf.internalValue = undefined;
      this._disableExtProc = undefined;
      this._dlp.internalValue = undefined;
      this._dynamicForwardProxy.internalValue = undefined;
      this._extProc.internalValue = undefined;
      this._extauth.internalValue = undefined;
      this._extensions.internalValue = undefined;
      this._grpcJsonTranscoder.internalValue = undefined;
      this._grpcWeb.internalValue = undefined;
      this._gzip.internalValue = undefined;
      this._headerValidationSettings.internalValue = undefined;
      this._healthCheck.internalValue = undefined;
      this._httpConnectionManagerSettings.internalValue = undefined;
      this._httpLocalRatelimit.internalValue = undefined;
      this._leftmostXffAddress = undefined;
      this._networkLocalRatelimit.internalValue = undefined;
      this._proxyLatency.internalValue = undefined;
      this._ratelimitServer.internalValue = undefined;
      this._router.internalValue = undefined;
      this._sanitizeClusterHeader = undefined;
      this._statefulSession.internalValue = undefined;
      this._tap.internalValue = undefined;
      this._waf.internalValue = undefined;
      this._wasm.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._buffer.internalValue = value.buffer;
      this._caching.internalValue = value.caching;
      this._connectionLimit.internalValue = value.connectionLimit;
      this._csrf.internalValue = value.csrf;
      this._disableExtProc = value.disableExtProc;
      this._dlp.internalValue = value.dlp;
      this._dynamicForwardProxy.internalValue = value.dynamicForwardProxy;
      this._extProc.internalValue = value.extProc;
      this._extauth.internalValue = value.extauth;
      this._extensions.internalValue = value.extensions;
      this._grpcJsonTranscoder.internalValue = value.grpcJsonTranscoder;
      this._grpcWeb.internalValue = value.grpcWeb;
      this._gzip.internalValue = value.gzip;
      this._headerValidationSettings.internalValue = value.headerValidationSettings;
      this._healthCheck.internalValue = value.healthCheck;
      this._httpConnectionManagerSettings.internalValue = value.httpConnectionManagerSettings;
      this._httpLocalRatelimit.internalValue = value.httpLocalRatelimit;
      this._leftmostXffAddress = value.leftmostXffAddress;
      this._networkLocalRatelimit.internalValue = value.networkLocalRatelimit;
      this._proxyLatency.internalValue = value.proxyLatency;
      this._ratelimitServer.internalValue = value.ratelimitServer;
      this._router.internalValue = value.router;
      this._sanitizeClusterHeader = value.sanitizeClusterHeader;
      this._statefulSession.internalValue = value.statefulSession;
      this._tap.internalValue = value.tap;
      this._waf.internalValue = value.waf;
      this._wasm.internalValue = value.wasm;
    }
  }

  // buffer - computed: false, optional: true, required: false
  private _buffer = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBufferOutputReference(this, "buffer");
  public get buffer() {
    return this._buffer;
  }
  public putBuffer(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsBuffer) {
    this._buffer.internalValue = value;
  }
  public resetBuffer() {
    this._buffer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferInput() {
    return this._buffer.internalValue;
  }

  // caching - computed: false, optional: true, required: false
  private _caching = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCachingOutputReference(this, "caching");
  public get caching() {
    return this._caching;
  }
  public putCaching(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCaching) {
    this._caching.internalValue = value;
  }
  public resetCaching() {
    this._caching.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingInput() {
    return this._caching.internalValue;
  }

  // connection_limit - computed: false, optional: true, required: false
  private _connectionLimit = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimitOutputReference(this, "connection_limit");
  public get connectionLimit() {
    return this._connectionLimit;
  }
  public putConnectionLimit(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsConnectionLimit) {
    this._connectionLimit.internalValue = value;
  }
  public resetConnectionLimit() {
    this._connectionLimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionLimitInput() {
    return this._connectionLimit.internalValue;
  }

  // csrf - computed: false, optional: true, required: false
  private _csrf = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrfOutputReference(this, "csrf");
  public get csrf() {
    return this._csrf;
  }
  public putCsrf(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsCsrf) {
    this._csrf.internalValue = value;
  }
  public resetCsrf() {
    this._csrf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csrfInput() {
    return this._csrf.internalValue;
  }

  // disable_ext_proc - computed: false, optional: true, required: false
  private _disableExtProc?: boolean | cdktf.IResolvable; 
  public get disableExtProc() {
    return this.getBooleanAttribute('disable_ext_proc');
  }
  public set disableExtProc(value: boolean | cdktf.IResolvable) {
    this._disableExtProc = value;
  }
  public resetDisableExtProc() {
    this._disableExtProc = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableExtProcInput() {
    return this._disableExtProc;
  }

  // dlp - computed: false, optional: true, required: false
  private _dlp = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlpOutputReference(this, "dlp");
  public get dlp() {
    return this._dlp;
  }
  public putDlp(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDlp) {
    this._dlp.internalValue = value;
  }
  public resetDlp() {
    this._dlp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dlpInput() {
    return this._dlp.internalValue;
  }

  // dynamic_forward_proxy - computed: false, optional: true, required: false
  private _dynamicForwardProxy = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxyOutputReference(this, "dynamic_forward_proxy");
  public get dynamicForwardProxy() {
    return this._dynamicForwardProxy;
  }
  public putDynamicForwardProxy(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsDynamicForwardProxy) {
    this._dynamicForwardProxy.internalValue = value;
  }
  public resetDynamicForwardProxy() {
    this._dynamicForwardProxy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicForwardProxyInput() {
    return this._dynamicForwardProxy.internalValue;
  }

  // ext_proc - computed: false, optional: true, required: false
  private _extProc = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProcOutputReference(this, "ext_proc");
  public get extProc() {
    return this._extProc;
  }
  public putExtProc(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtProc) {
    this._extProc.internalValue = value;
  }
  public resetExtProc() {
    this._extProc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extProcInput() {
    return this._extProc.internalValue;
  }

  // extauth - computed: false, optional: true, required: false
  private _extauth = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauthOutputReference(this, "extauth");
  public get extauth() {
    return this._extauth;
  }
  public putExtauth(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtauth) {
    this._extauth.internalValue = value;
  }
  public resetExtauth() {
    this._extauth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extauthInput() {
    return this._extauth.internalValue;
  }

  // extensions - computed: false, optional: true, required: false
  private _extensions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensionsOutputReference(this, "extensions");
  public get extensions() {
    return this._extensions;
  }
  public putExtensions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsExtensions) {
    this._extensions.internalValue = value;
  }
  public resetExtensions() {
    this._extensions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extensionsInput() {
    return this._extensions.internalValue;
  }

  // grpc_json_transcoder - computed: false, optional: true, required: false
  private _grpcJsonTranscoder = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoderOutputReference(this, "grpc_json_transcoder");
  public get grpcJsonTranscoder() {
    return this._grpcJsonTranscoder;
  }
  public putGrpcJsonTranscoder(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcJsonTranscoder) {
    this._grpcJsonTranscoder.internalValue = value;
  }
  public resetGrpcJsonTranscoder() {
    this._grpcJsonTranscoder.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcJsonTranscoderInput() {
    return this._grpcJsonTranscoder.internalValue;
  }

  // grpc_web - computed: false, optional: true, required: false
  private _grpcWeb = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWebOutputReference(this, "grpc_web");
  public get grpcWeb() {
    return this._grpcWeb;
  }
  public putGrpcWeb(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGrpcWeb) {
    this._grpcWeb.internalValue = value;
  }
  public resetGrpcWeb() {
    this._grpcWeb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcWebInput() {
    return this._grpcWeb.internalValue;
  }

  // gzip - computed: false, optional: true, required: false
  private _gzip = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzipOutputReference(this, "gzip");
  public get gzip() {
    return this._gzip;
  }
  public putGzip(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsGzip) {
    this._gzip.internalValue = value;
  }
  public resetGzip() {
    this._gzip.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gzipInput() {
    return this._gzip.internalValue;
  }

  // header_validation_settings - computed: false, optional: true, required: false
  private _headerValidationSettings = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettingsOutputReference(this, "header_validation_settings");
  public get headerValidationSettings() {
    return this._headerValidationSettings;
  }
  public putHeaderValidationSettings(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHeaderValidationSettings) {
    this._headerValidationSettings.internalValue = value;
  }
  public resetHeaderValidationSettings() {
    this._headerValidationSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValidationSettingsInput() {
    return this._headerValidationSettings.internalValue;
  }

  // health_check - computed: false, optional: true, required: false
  private _healthCheck = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheckOutputReference(this, "health_check");
  public get healthCheck() {
    return this._healthCheck;
  }
  public putHealthCheck(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHealthCheck) {
    this._healthCheck.internalValue = value;
  }
  public resetHealthCheck() {
    this._healthCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckInput() {
    return this._healthCheck.internalValue;
  }

  // http_connection_manager_settings - computed: false, optional: true, required: false
  private _httpConnectionManagerSettings = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettingsOutputReference(this, "http_connection_manager_settings");
  public get httpConnectionManagerSettings() {
    return this._httpConnectionManagerSettings;
  }
  public putHttpConnectionManagerSettings(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpConnectionManagerSettings) {
    this._httpConnectionManagerSettings.internalValue = value;
  }
  public resetHttpConnectionManagerSettings() {
    this._httpConnectionManagerSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpConnectionManagerSettingsInput() {
    return this._httpConnectionManagerSettings.internalValue;
  }

  // http_local_ratelimit - computed: false, optional: true, required: false
  private _httpLocalRatelimit = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimitOutputReference(this, "http_local_ratelimit");
  public get httpLocalRatelimit() {
    return this._httpLocalRatelimit;
  }
  public putHttpLocalRatelimit(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsHttpLocalRatelimit) {
    this._httpLocalRatelimit.internalValue = value;
  }
  public resetHttpLocalRatelimit() {
    this._httpLocalRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLocalRatelimitInput() {
    return this._httpLocalRatelimit.internalValue;
  }

  // leftmost_xff_address - computed: false, optional: true, required: false
  private _leftmostXffAddress?: boolean | cdktf.IResolvable; 
  public get leftmostXffAddress() {
    return this.getBooleanAttribute('leftmost_xff_address');
  }
  public set leftmostXffAddress(value: boolean | cdktf.IResolvable) {
    this._leftmostXffAddress = value;
  }
  public resetLeftmostXffAddress() {
    this._leftmostXffAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leftmostXffAddressInput() {
    return this._leftmostXffAddress;
  }

  // network_local_ratelimit - computed: false, optional: true, required: false
  private _networkLocalRatelimit = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimitOutputReference(this, "network_local_ratelimit");
  public get networkLocalRatelimit() {
    return this._networkLocalRatelimit;
  }
  public putNetworkLocalRatelimit(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsNetworkLocalRatelimit) {
    this._networkLocalRatelimit.internalValue = value;
  }
  public resetNetworkLocalRatelimit() {
    this._networkLocalRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkLocalRatelimitInput() {
    return this._networkLocalRatelimit.internalValue;
  }

  // proxy_latency - computed: false, optional: true, required: false
  private _proxyLatency = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatencyOutputReference(this, "proxy_latency");
  public get proxyLatency() {
    return this._proxyLatency;
  }
  public putProxyLatency(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsProxyLatency) {
    this._proxyLatency.internalValue = value;
  }
  public resetProxyLatency() {
    this._proxyLatency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyLatencyInput() {
    return this._proxyLatency.internalValue;
  }

  // ratelimit_server - computed: false, optional: true, required: false
  private _ratelimitServer = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServerOutputReference(this, "ratelimit_server");
  public get ratelimitServer() {
    return this._ratelimitServer;
  }
  public putRatelimitServer(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRatelimitServer) {
    this._ratelimitServer.internalValue = value;
  }
  public resetRatelimitServer() {
    this._ratelimitServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ratelimitServerInput() {
    return this._ratelimitServer.internalValue;
  }

  // router - computed: false, optional: true, required: false
  private _router = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouterOutputReference(this, "router");
  public get router() {
    return this._router;
  }
  public putRouter(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsRouter) {
    this._router.internalValue = value;
  }
  public resetRouter() {
    this._router.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routerInput() {
    return this._router.internalValue;
  }

  // sanitize_cluster_header - computed: false, optional: true, required: false
  private _sanitizeClusterHeader?: boolean | cdktf.IResolvable; 
  public get sanitizeClusterHeader() {
    return this.getBooleanAttribute('sanitize_cluster_header');
  }
  public set sanitizeClusterHeader(value: boolean | cdktf.IResolvable) {
    this._sanitizeClusterHeader = value;
  }
  public resetSanitizeClusterHeader() {
    this._sanitizeClusterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sanitizeClusterHeaderInput() {
    return this._sanitizeClusterHeader;
  }

  // stateful_session - computed: false, optional: true, required: false
  private _statefulSession = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSessionOutputReference(this, "stateful_session");
  public get statefulSession() {
    return this._statefulSession;
  }
  public putStatefulSession(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsStatefulSession) {
    this._statefulSession.internalValue = value;
  }
  public resetStatefulSession() {
    this._statefulSession.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statefulSessionInput() {
    return this._statefulSession.internalValue;
  }

  // tap - computed: false, optional: true, required: false
  private _tap = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTapOutputReference(this, "tap");
  public get tap() {
    return this._tap;
  }
  public putTap(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsTap) {
    this._tap.internalValue = value;
  }
  public resetTap() {
    this._tap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tapInput() {
    return this._tap.internalValue;
  }

  // waf - computed: false, optional: true, required: false
  private _waf = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWafOutputReference(this, "waf");
  public get waf() {
    return this._waf;
  }
  public putWaf(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWaf) {
    this._waf.internalValue = value;
  }
  public resetWaf() {
    this._waf.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wafInput() {
    return this._waf.internalValue;
  }

  // wasm - computed: false, optional: true, required: false
  private _wasm = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasmOutputReference(this, "wasm");
  public get wasm() {
    return this._wasm;
  }
  public putWasm(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsWasm) {
    this._wasm.internalValue = value;
  }
  public resetWasm() {
    this._wasm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wasmInput() {
    return this._wasm.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#operator DataK8SGatewaySoloIoGatewayV1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#values DataK8SGatewaySoloIoGatewayV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#expressions DataK8SGatewaySoloIoGatewayV1Manifest#expressions}
  */
  readonly expressions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expressions: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsToTerraform, false)(struct!.expressions),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expressions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsToHclTerraform, false)(struct!.expressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressions = this._expressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expressions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expressions.internalValue = value.expressions;
    }
  }

  // expressions - computed: false, optional: true, required: false
  private _expressions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressionsList(this, "expressions", false);
  public get expressions() {
    return this._expressions;
  }
  public putExpressions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsExpressions[] | cdktf.IResolvable) {
    this._expressions.internalValue = value;
  }
  public resetExpressions() {
    this._expressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionsInput() {
    return this._expressions.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGateway {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#options DataK8SGatewaySoloIoGatewayV1Manifest#options}
  */
  readonly options?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#virtual_service_expressions DataK8SGatewaySoloIoGatewayV1Manifest#virtual_service_expressions}
  */
  readonly virtualServiceExpressions?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#virtual_service_namespaces DataK8SGatewaySoloIoGatewayV1Manifest#virtual_service_namespaces}
  */
  readonly virtualServiceNamespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#virtual_service_selector DataK8SGatewaySoloIoGatewayV1Manifest#virtual_service_selector}
  */
  readonly virtualServiceSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#virtual_services DataK8SGatewaySoloIoGatewayV1Manifest#virtual_services}
  */
  readonly virtualServices?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGateway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    options: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsToTerraform(struct!.options),
    virtual_service_expressions: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsToTerraform(struct!.virtualServiceExpressions),
    virtual_service_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.virtualServiceNamespaces),
    virtual_service_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.virtualServiceSelector),
    virtual_services: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesToTerraform, false)(struct!.virtualServices),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGateway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    options: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsToHclTerraform(struct!.options),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions",
    },
    virtual_service_expressions: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsToHclTerraform(struct!.virtualServiceExpressions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions",
    },
    virtual_service_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.virtualServiceNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    virtual_service_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.virtualServiceSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    virtual_services: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesToHclTerraform, false)(struct!.virtualServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGateway | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._options?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.options = this._options?.internalValue;
    }
    if (this._virtualServiceExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceExpressions = this._virtualServiceExpressions?.internalValue;
    }
    if (this._virtualServiceNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceNamespaces = this._virtualServiceNamespaces;
    }
    if (this._virtualServiceSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceSelector = this._virtualServiceSelector;
    }
    if (this._virtualServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServices = this._virtualServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGateway | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._options.internalValue = undefined;
      this._virtualServiceExpressions.internalValue = undefined;
      this._virtualServiceNamespaces = undefined;
      this._virtualServiceSelector = undefined;
      this._virtualServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._options.internalValue = value.options;
      this._virtualServiceExpressions.internalValue = value.virtualServiceExpressions;
      this._virtualServiceNamespaces = value.virtualServiceNamespaces;
      this._virtualServiceSelector = value.virtualServiceSelector;
      this._virtualServices.internalValue = value.virtualServices;
    }
  }

  // options - computed: false, optional: true, required: false
  private _options = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptionsOutputReference(this, "options");
  public get options() {
    return this._options;
  }
  public putOptions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayOptions) {
    this._options.internalValue = value;
  }
  public resetOptions() {
    this._options.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionsInput() {
    return this._options.internalValue;
  }

  // virtual_service_expressions - computed: false, optional: true, required: false
  private _virtualServiceExpressions = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressionsOutputReference(this, "virtual_service_expressions");
  public get virtualServiceExpressions() {
    return this._virtualServiceExpressions;
  }
  public putVirtualServiceExpressions(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServiceExpressions) {
    this._virtualServiceExpressions.internalValue = value;
  }
  public resetVirtualServiceExpressions() {
    this._virtualServiceExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceExpressionsInput() {
    return this._virtualServiceExpressions.internalValue;
  }

  // virtual_service_namespaces - computed: false, optional: true, required: false
  private _virtualServiceNamespaces?: string[]; 
  public get virtualServiceNamespaces() {
    return this.getListAttribute('virtual_service_namespaces');
  }
  public set virtualServiceNamespaces(value: string[]) {
    this._virtualServiceNamespaces = value;
  }
  public resetVirtualServiceNamespaces() {
    this._virtualServiceNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceNamespacesInput() {
    return this._virtualServiceNamespaces;
  }

  // virtual_service_selector - computed: false, optional: true, required: false
  private _virtualServiceSelector?: { [key: string]: string }; 
  public get virtualServiceSelector() {
    return this.getStringMapAttribute('virtual_service_selector');
  }
  public set virtualServiceSelector(value: { [key: string]: string }) {
    this._virtualServiceSelector = value;
  }
  public resetVirtualServiceSelector() {
    this._virtualServiceSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceSelectorInput() {
    return this._virtualServiceSelector;
  }

  // virtual_services - computed: false, optional: true, required: false
  private _virtualServices = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServicesList(this, "virtual_services", false);
  public get virtualServices() {
    return this._virtualServices;
  }
  public putVirtualServices(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysHttpGatewayVirtualServices[] | cdktf.IResolvable) {
    this._virtualServices.internalValue = value;
  }
  public resetVirtualServices() {
    this._virtualServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServicesInput() {
    return this._virtualServices.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#address_prefix DataK8SGatewaySoloIoGatewayV1Manifest#address_prefix}
  */
  readonly addressPrefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#prefix_len DataK8SGatewaySoloIoGatewayV1Manifest#prefix_len}
  */
  readonly prefixLen?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address_prefix: cdktf.stringToTerraform(struct!.addressPrefix),
    prefix_len: cdktf.numberToTerraform(struct!.prefixLen),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address_prefix: {
      value: cdktf.stringToHclTerraform(struct!.addressPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_len: {
      value: cdktf.numberToHclTerraform(struct!.prefixLen),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addressPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.addressPrefix = this._addressPrefix;
    }
    if (this._prefixLen !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixLen = this._prefixLen;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addressPrefix = undefined;
      this._prefixLen = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addressPrefix = value.addressPrefix;
      this._prefixLen = value.prefixLen;
    }
  }

  // address_prefix - computed: false, optional: true, required: false
  private _addressPrefix?: string; 
  public get addressPrefix() {
    return this.getStringAttribute('address_prefix');
  }
  public set addressPrefix(value: string) {
    this._addressPrefix = value;
  }
  public resetAddressPrefix() {
    this._addressPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressPrefixInput() {
    return this._addressPrefix;
  }

  // prefix_len - computed: false, optional: true, required: false
  private _prefixLen?: number; 
  public get prefixLen() {
    return this.getNumberAttribute('prefix_len');
  }
  public set prefixLen(value: number) {
    this._prefixLen = value;
  }
  public resetPrefixLen() {
    this._prefixLen = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixLenInput() {
    return this._prefixLen;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cipher_suites DataK8SGatewaySoloIoGatewayV1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ecdh_curves DataK8SGatewaySoloIoGatewayV1Manifest#ecdh_curves}
  */
  readonly ecdhCurves?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#maximum_protocol_version DataK8SGatewaySoloIoGatewayV1Manifest#maximum_protocol_version}
  */
  readonly maximumProtocolVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#minimum_protocol_version DataK8SGatewaySoloIoGatewayV1Manifest#minimum_protocol_version}
  */
  readonly minimumProtocolVersion?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    ecdh_curves: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ecdhCurves),
    maximum_protocol_version: cdktf.stringToTerraform(struct!.maximumProtocolVersion),
    minimum_protocol_version: cdktf.stringToTerraform(struct!.minimumProtocolVersion),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ecdh_curves: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ecdhCurves),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    maximum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maximumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    minimum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minimumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._ecdhCurves !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecdhCurves = this._ecdhCurves;
    }
    if (this._maximumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumProtocolVersion = this._maximumProtocolVersion;
    }
    if (this._minimumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumProtocolVersion = this._minimumProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cipherSuites = undefined;
      this._ecdhCurves = undefined;
      this._maximumProtocolVersion = undefined;
      this._minimumProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cipherSuites = value.cipherSuites;
      this._ecdhCurves = value.ecdhCurves;
      this._maximumProtocolVersion = value.maximumProtocolVersion;
      this._minimumProtocolVersion = value.minimumProtocolVersion;
    }
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // ecdh_curves - computed: false, optional: true, required: false
  private _ecdhCurves?: string[]; 
  public get ecdhCurves() {
    return this.getListAttribute('ecdh_curves');
  }
  public set ecdhCurves(value: string[]) {
    this._ecdhCurves = value;
  }
  public resetEcdhCurves() {
    this._ecdhCurves = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecdhCurvesInput() {
    return this._ecdhCurves;
  }

  // maximum_protocol_version - computed: false, optional: true, required: false
  private _maximumProtocolVersion?: string; 
  public get maximumProtocolVersion() {
    return this.getStringAttribute('maximum_protocol_version');
  }
  public set maximumProtocolVersion(value: string) {
    this._maximumProtocolVersion = value;
  }
  public resetMaximumProtocolVersion() {
    this._maximumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumProtocolVersionInput() {
    return this._maximumProtocolVersion;
  }

  // minimum_protocol_version - computed: false, optional: true, required: false
  private _minimumProtocolVersion?: string; 
  public get minimumProtocolVersion() {
    return this.getStringAttribute('minimum_protocol_version');
  }
  public set minimumProtocolVersion(value: string) {
    this._minimumProtocolVersion = value;
  }
  public resetMinimumProtocolVersion() {
    this._minimumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumProtocolVersionInput() {
    return this._minimumProtocolVersion;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#token_file_name DataK8SGatewaySoloIoGatewayV1Manifest#token_file_name}
  */
  readonly tokenFileName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    token_file_name: cdktf.stringToTerraform(struct!.tokenFileName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_file_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._tokenFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenFileName = this._tokenFileName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._tokenFileName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._tokenFileName = value.tokenFileName;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // token_file_name - computed: false, optional: true, required: false
  private _tokenFileName?: string; 
  public get tokenFileName() {
    return this.getStringAttribute('token_file_name');
  }
  public set tokenFileName(value: string) {
    this._tokenFileName = value;
  }
  public resetTokenFileName() {
    this._tokenFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenFileNameInput() {
    return this._tokenFileName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#file_credential_source DataK8SGatewaySoloIoGatewayV1Manifest#file_credential_source}
  */
  readonly fileCredentialSource?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file_credential_source: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct!.fileCredentialSource),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file_credential_source: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct!.fileCredentialSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fileCredentialSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileCredentialSource = this._fileCredentialSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = value.fileCredentialSource;
    }
  }

  // file_credential_source - computed: false, optional: true, required: false
  private _fileCredentialSource = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSourceOutputReference(this, "file_credential_source");
  public get fileCredentialSource() {
    return this._fileCredentialSource;
  }
  public putFileCredentialSource(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsFileCredentialSource) {
    this._fileCredentialSource.internalValue = value;
  }
  public resetFileCredentialSource() {
    this._fileCredentialSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileCredentialSourceInput() {
    return this._fileCredentialSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#call_credentials DataK8SGatewaySoloIoGatewayV1Manifest#call_credentials}
  */
  readonly callCredentials?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#certificates_secret_name DataK8SGatewaySoloIoGatewayV1Manifest#certificates_secret_name}
  */
  readonly certificatesSecretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#cluster_name DataK8SGatewaySoloIoGatewayV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#target_uri DataK8SGatewaySoloIoGatewayV1Manifest#target_uri}
  */
  readonly targetUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#validation_context_name DataK8SGatewaySoloIoGatewayV1Manifest#validation_context_name}
  */
  readonly validationContextName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    call_credentials: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsToTerraform(struct!.callCredentials),
    certificates_secret_name: cdktf.stringToTerraform(struct!.certificatesSecretName),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
    validation_context_name: cdktf.stringToTerraform(struct!.validationContextName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    call_credentials: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsToHclTerraform(struct!.callCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials",
    },
    certificates_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.certificatesSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validation_context_name: {
      value: cdktf.stringToHclTerraform(struct!.validationContextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._callCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.callCredentials = this._callCredentials?.internalValue;
    }
    if (this._certificatesSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesSecretName = this._certificatesSecretName;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    if (this._validationContextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationContextName = this._validationContextName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = undefined;
      this._certificatesSecretName = undefined;
      this._clusterName = undefined;
      this._targetUri = undefined;
      this._validationContextName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = value.callCredentials;
      this._certificatesSecretName = value.certificatesSecretName;
      this._clusterName = value.clusterName;
      this._targetUri = value.targetUri;
      this._validationContextName = value.validationContextName;
    }
  }

  // call_credentials - computed: false, optional: true, required: false
  private _callCredentials = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentialsOutputReference(this, "call_credentials");
  public get callCredentials() {
    return this._callCredentials;
  }
  public putCallCredentials(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsCallCredentials) {
    this._callCredentials.internalValue = value;
  }
  public resetCallCredentials() {
    this._callCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callCredentialsInput() {
    return this._callCredentials.internalValue;
  }

  // certificates_secret_name - computed: false, optional: true, required: false
  private _certificatesSecretName?: string; 
  public get certificatesSecretName() {
    return this.getStringAttribute('certificates_secret_name');
  }
  public set certificatesSecretName(value: string) {
    this._certificatesSecretName = value;
  }
  public resetCertificatesSecretName() {
    this._certificatesSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesSecretNameInput() {
    return this._certificatesSecretName;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }

  // validation_context_name - computed: false, optional: true, required: false
  private _validationContextName?: string; 
  public get validationContextName() {
    return this.getStringAttribute('validation_context_name');
  }
  public set validationContextName(value: string) {
    this._validationContextName = value;
  }
  public resetValidationContextName() {
    this._validationContextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationContextNameInput() {
    return this._validationContextName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#name DataK8SGatewaySoloIoGatewayV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#namespace DataK8SGatewaySoloIoGatewayV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRefToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ocsp_staple DataK8SGatewaySoloIoGatewayV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#root_ca DataK8SGatewaySoloIoGatewayV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tls_cert DataK8SGatewaySoloIoGatewayV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tls_key DataK8SGatewaySoloIoGatewayV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFilesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFilesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#alpn_protocols DataK8SGatewaySoloIoGatewayV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#disable_tls_session_resumption DataK8SGatewaySoloIoGatewayV1Manifest#disable_tls_session_resumption}
  */
  readonly disableTlsSessionResumption?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ocsp_staple_policy DataK8SGatewaySoloIoGatewayV1Manifest#ocsp_staple_policy}
  */
  readonly ocspStaplePolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#one_way_tls DataK8SGatewaySoloIoGatewayV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parameters DataK8SGatewaySoloIoGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sds DataK8SGatewaySoloIoGatewayV1Manifest#sds}
  */
  readonly sds?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#secret_ref DataK8SGatewaySoloIoGatewayV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#sni_domains DataK8SGatewaySoloIoGatewayV1Manifest#sni_domains}
  */
  readonly sniDomains?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ssl_files DataK8SGatewaySoloIoGatewayV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#transport_socket_connect_timeout DataK8SGatewaySoloIoGatewayV1Manifest#transport_socket_connect_timeout}
  */
  readonly transportSocketConnectTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#verify_subject_alt_name DataK8SGatewaySoloIoGatewayV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    disable_tls_session_resumption: cdktf.booleanToTerraform(struct!.disableTlsSessionResumption),
    ocsp_staple_policy: cdktf.stringToTerraform(struct!.ocspStaplePolicy),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRefToTerraform(struct!.secretRef),
    sni_domains: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.sniDomains),
    ssl_files: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFilesToTerraform(struct!.sslFiles),
    transport_socket_connect_timeout: cdktf.stringToTerraform(struct!.transportSocketConnectTimeout),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_tls_session_resumption: {
      value: cdktf.booleanToHclTerraform(struct!.disableTlsSessionResumption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ocsp_staple_policy: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaplePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters",
    },
    sds: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef",
    },
    sni_domains: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.sniDomains),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ssl_files: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles",
    },
    transport_socket_connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.transportSocketConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._disableTlsSessionResumption !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTlsSessionResumption = this._disableTlsSessionResumption;
    }
    if (this._ocspStaplePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaplePolicy = this._ocspStaplePolicy;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sniDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.sniDomains = this._sniDomains;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._transportSocketConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.transportSocketConnectTimeout = this._transportSocketConnectTimeout;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alpnProtocols = undefined;
      this._disableTlsSessionResumption = undefined;
      this._ocspStaplePolicy = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sniDomains = undefined;
      this._sslFiles.internalValue = undefined;
      this._transportSocketConnectTimeout = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alpnProtocols = value.alpnProtocols;
      this._disableTlsSessionResumption = value.disableTlsSessionResumption;
      this._ocspStaplePolicy = value.ocspStaplePolicy;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sniDomains = value.sniDomains;
      this._sslFiles.internalValue = value.sslFiles;
      this._transportSocketConnectTimeout = value.transportSocketConnectTimeout;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // disable_tls_session_resumption - computed: false, optional: true, required: false
  private _disableTlsSessionResumption?: boolean | cdktf.IResolvable; 
  public get disableTlsSessionResumption() {
    return this.getBooleanAttribute('disable_tls_session_resumption');
  }
  public set disableTlsSessionResumption(value: boolean | cdktf.IResolvable) {
    this._disableTlsSessionResumption = value;
  }
  public resetDisableTlsSessionResumption() {
    this._disableTlsSessionResumption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTlsSessionResumptionInput() {
    return this._disableTlsSessionResumption;
  }

  // ocsp_staple_policy - computed: false, optional: true, required: false
  private _ocspStaplePolicy?: string; 
  public get ocspStaplePolicy() {
    return this.getStringAttribute('ocsp_staple_policy');
  }
  public set ocspStaplePolicy(value: string) {
    this._ocspStaplePolicy = value;
  }
  public resetOcspStaplePolicy() {
    this._ocspStaplePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStaplePolicyInput() {
    return this._ocspStaplePolicy;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni_domains - computed: false, optional: true, required: false
  private _sniDomains?: string[]; 
  public get sniDomains() {
    return this.getListAttribute('sni_domains');
  }
  public set sniDomains(value: string[]) {
    this._sniDomains = value;
  }
  public resetSniDomains() {
    this._sniDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniDomainsInput() {
    return this._sniDomains;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // transport_socket_connect_timeout - computed: false, optional: true, required: false
  private _transportSocketConnectTimeout?: string; 
  public get transportSocketConnectTimeout() {
    return this.getStringAttribute('transport_socket_connect_timeout');
  }
  public set transportSocketConnectTimeout(value: string) {
    this._transportSocketConnectTimeout = value;
  }
  public resetTransportSocketConnectTimeout() {
    this._transportSocketConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transportSocketConnectTimeoutInput() {
    return this._transportSocketConnectTimeout;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcher {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#passthrough_cipher_suites DataK8SGatewaySoloIoGatewayV1Manifest#passthrough_cipher_suites}
  */
  readonly passthroughCipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#source_prefix_ranges DataK8SGatewaySoloIoGatewayV1Manifest#source_prefix_ranges}
  */
  readonly sourcePrefixRanges?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#ssl_config DataK8SGatewaySoloIoGatewayV1Manifest#ssl_config}
  */
  readonly sslConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    passthrough_cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.passthroughCipherSuites),
    source_prefix_ranges: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesToTerraform, false)(struct!.sourcePrefixRanges),
    ssl_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigToTerraform(struct!.sslConfig),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcher | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    passthrough_cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.passthroughCipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    source_prefix_ranges: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesToHclTerraform, false)(struct!.sourcePrefixRanges),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesList",
    },
    ssl_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigToHclTerraform(struct!.sslConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcher | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._passthroughCipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthroughCipherSuites = this._passthroughCipherSuites;
    }
    if (this._sourcePrefixRanges?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourcePrefixRanges = this._sourcePrefixRanges?.internalValue;
    }
    if (this._sslConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslConfig = this._sslConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcher | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._passthroughCipherSuites = undefined;
      this._sourcePrefixRanges.internalValue = undefined;
      this._sslConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._passthroughCipherSuites = value.passthroughCipherSuites;
      this._sourcePrefixRanges.internalValue = value.sourcePrefixRanges;
      this._sslConfig.internalValue = value.sslConfig;
    }
  }

  // passthrough_cipher_suites - computed: false, optional: true, required: false
  private _passthroughCipherSuites?: string[]; 
  public get passthroughCipherSuites() {
    return this.getListAttribute('passthrough_cipher_suites');
  }
  public set passthroughCipherSuites(value: string[]) {
    this._passthroughCipherSuites = value;
  }
  public resetPassthroughCipherSuites() {
    this._passthroughCipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughCipherSuitesInput() {
    return this._passthroughCipherSuites;
  }

  // source_prefix_ranges - computed: false, optional: true, required: false
  private _sourcePrefixRanges = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRangesList(this, "source_prefix_ranges", false);
  public get sourcePrefixRanges() {
    return this._sourcePrefixRanges;
  }
  public putSourcePrefixRanges(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSourcePrefixRanges[] | cdktf.IResolvable) {
    this._sourcePrefixRanges.internalValue = value;
  }
  public resetSourcePrefixRanges() {
    this._sourcePrefixRanges.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcePrefixRangesInput() {
    return this._sourcePrefixRanges.internalValue;
  }

  // ssl_config - computed: false, optional: true, required: false
  private _sslConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfigOutputReference(this, "ssl_config");
  public get sslConfig() {
    return this._sslConfig;
  }
  public putSslConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysMatcherSslConfig) {
    this._sslConfig.internalValue = value;
  }
  public resetSslConfig() {
    this._sslConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslConfigInput() {
    return this._sslConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#delay_before_close DataK8SGatewaySoloIoGatewayV1Manifest#delay_before_close}
  */
  readonly delayBeforeClose?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_active_connections DataK8SGatewaySoloIoGatewayV1Manifest#max_active_connections}
  */
  readonly maxActiveConnections?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimitToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    delay_before_close: cdktf.stringToTerraform(struct!.delayBeforeClose),
    max_active_connections: cdktf.numberToTerraform(struct!.maxActiveConnections),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimitToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    delay_before_close: {
      value: cdktf.stringToHclTerraform(struct!.delayBeforeClose),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._delayBeforeClose !== undefined) {
      hasAnyValues = true;
      internalValueResult.delayBeforeClose = this._delayBeforeClose;
    }
    if (this._maxActiveConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveConnections = this._maxActiveConnections;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._delayBeforeClose = undefined;
      this._maxActiveConnections = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._delayBeforeClose = value.delayBeforeClose;
      this._maxActiveConnections = value.maxActiveConnections;
    }
  }

  // delay_before_close - computed: false, optional: true, required: false
  private _delayBeforeClose?: string; 
  public get delayBeforeClose() {
    return this.getStringAttribute('delay_before_close');
  }
  public set delayBeforeClose(value: string) {
    this._delayBeforeClose = value;
  }
  public resetDelayBeforeClose() {
    this._delayBeforeClose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayBeforeCloseInput() {
    return this._delayBeforeClose;
  }

  // max_active_connections - computed: false, optional: true, required: false
  private _maxActiveConnections?: number; 
  public get maxActiveConnections() {
    return this.getNumberAttribute('max_active_connections');
  }
  public set maxActiveConnections(value: number) {
    this._maxActiveConnections = value;
  }
  public resetMaxActiveConnections() {
    this._maxActiveConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveConnectionsInput() {
    return this._maxActiveConnections;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#fill_interval DataK8SGatewaySoloIoGatewayV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_tokens DataK8SGatewaySoloIoGatewayV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoGatewayV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#append DataK8SGatewaySoloIoGatewayV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeaderToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers_to_add DataK8SGatewaySoloIoGatewayV1Manifest#headers_to_add}
  */
  readonly headersToAdd?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#hostname DataK8SGatewaySoloIoGatewayV1Manifest#hostname}
  */
  readonly hostname?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddToTerraform, false)(struct!.headersToAdd),
    hostname: cdktf.stringToTerraform(struct!.hostname),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddToHclTerraform, false)(struct!.headersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddList",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAdd = this._headersToAdd?.internalValue;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headersToAdd.internalValue = undefined;
      this._hostname = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headersToAdd.internalValue = value.headersToAdd;
      this._hostname = value.hostname;
    }
  }

  // headers_to_add - computed: false, optional: true, required: false
  private _headersToAdd = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAddList(this, "headers_to_add", false);
  public get headersToAdd() {
    return this._headersToAdd;
  }
  public putHeadersToAdd(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigHeadersToAdd[] | cdktf.IResolvable) {
    this._headersToAdd.internalValue = value;
  }
  public resetHeadersToAdd() {
    this._headersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAddInput() {
    return this._headersToAdd.internalValue;
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#access_log_flush_interval DataK8SGatewaySoloIoGatewayV1Manifest#access_log_flush_interval}
  */
  readonly accessLogFlushInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#idle_timeout DataK8SGatewaySoloIoGatewayV1Manifest#idle_timeout}
  */
  readonly idleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#max_connect_attempts DataK8SGatewaySoloIoGatewayV1Manifest#max_connect_attempts}
  */
  readonly maxConnectAttempts?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tunneling_config DataK8SGatewaySoloIoGatewayV1Manifest#tunneling_config}
  */
  readonly tunnelingConfig?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_log_flush_interval: cdktf.stringToTerraform(struct!.accessLogFlushInterval),
    idle_timeout: cdktf.stringToTerraform(struct!.idleTimeout),
    max_connect_attempts: cdktf.numberToTerraform(struct!.maxConnectAttempts),
    tunneling_config: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigToTerraform(struct!.tunnelingConfig),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_log_flush_interval: {
      value: cdktf.stringToHclTerraform(struct!.accessLogFlushInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.idleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_connect_attempts: {
      value: cdktf.numberToHclTerraform(struct!.maxConnectAttempts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tunneling_config: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigToHclTerraform(struct!.tunnelingConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessLogFlushInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessLogFlushInterval = this._accessLogFlushInterval;
    }
    if (this._idleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleTimeout = this._idleTimeout;
    }
    if (this._maxConnectAttempts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnectAttempts = this._maxConnectAttempts;
    }
    if (this._tunnelingConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tunnelingConfig = this._tunnelingConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessLogFlushInterval = undefined;
      this._idleTimeout = undefined;
      this._maxConnectAttempts = undefined;
      this._tunnelingConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessLogFlushInterval = value.accessLogFlushInterval;
      this._idleTimeout = value.idleTimeout;
      this._maxConnectAttempts = value.maxConnectAttempts;
      this._tunnelingConfig.internalValue = value.tunnelingConfig;
    }
  }

  // access_log_flush_interval - computed: false, optional: true, required: false
  private _accessLogFlushInterval?: string; 
  public get accessLogFlushInterval() {
    return this.getStringAttribute('access_log_flush_interval');
  }
  public set accessLogFlushInterval(value: string) {
    this._accessLogFlushInterval = value;
  }
  public resetAccessLogFlushInterval() {
    this._accessLogFlushInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessLogFlushIntervalInput() {
    return this._accessLogFlushInterval;
  }

  // idle_timeout - computed: false, optional: true, required: false
  private _idleTimeout?: string; 
  public get idleTimeout() {
    return this.getStringAttribute('idle_timeout');
  }
  public set idleTimeout(value: string) {
    this._idleTimeout = value;
  }
  public resetIdleTimeout() {
    this._idleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleTimeoutInput() {
    return this._idleTimeout;
  }

  // max_connect_attempts - computed: false, optional: true, required: false
  private _maxConnectAttempts?: number; 
  public get maxConnectAttempts() {
    return this.getNumberAttribute('max_connect_attempts');
  }
  public set maxConnectAttempts(value: number) {
    this._maxConnectAttempts = value;
  }
  public resetMaxConnectAttempts() {
    this._maxConnectAttempts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnectAttemptsInput() {
    return this._maxConnectAttempts;
  }

  // tunneling_config - computed: false, optional: true, required: false
  private _tunnelingConfig = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfigOutputReference(this, "tunneling_config");
  public get tunnelingConfig() {
    return this._tunnelingConfig;
  }
  public putTunnelingConfig(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsTunnelingConfig) {
    this._tunnelingConfig.internalValue = value;
  }
  public resetTunnelingConfig() {
    this._tunnelingConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tunnelingConfigInput() {
    return this._tunnelingConfig.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#connection_limit DataK8SGatewaySoloIoGatewayV1Manifest#connection_limit}
  */
  readonly connectionLimit?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#local_ratelimit DataK8SGatewaySoloIoGatewayV1Manifest#local_ratelimit}
  */
  readonly localRatelimit?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tcp_proxy_settings DataK8SGatewaySoloIoGatewayV1Manifest#tcp_proxy_settings}
  */
  readonly tcpProxySettings?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_limit: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimitToTerraform(struct!.connectionLimit),
    local_ratelimit: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimitToTerraform(struct!.localRatelimit),
    tcp_proxy_settings: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsToTerraform(struct!.tcpProxySettings),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_limit: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimitToHclTerraform(struct!.connectionLimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit",
    },
    local_ratelimit: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimitToHclTerraform(struct!.localRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit",
    },
    tcp_proxy_settings: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsToHclTerraform(struct!.tcpProxySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionLimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionLimit = this._connectionLimit?.internalValue;
    }
    if (this._localRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRatelimit = this._localRatelimit?.internalValue;
    }
    if (this._tcpProxySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpProxySettings = this._tcpProxySettings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionLimit.internalValue = undefined;
      this._localRatelimit.internalValue = undefined;
      this._tcpProxySettings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionLimit.internalValue = value.connectionLimit;
      this._localRatelimit.internalValue = value.localRatelimit;
      this._tcpProxySettings.internalValue = value.tcpProxySettings;
    }
  }

  // connection_limit - computed: false, optional: true, required: false
  private _connectionLimit = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimitOutputReference(this, "connection_limit");
  public get connectionLimit() {
    return this._connectionLimit;
  }
  public putConnectionLimit(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsConnectionLimit) {
    this._connectionLimit.internalValue = value;
  }
  public resetConnectionLimit() {
    this._connectionLimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionLimitInput() {
    return this._connectionLimit.internalValue;
  }

  // local_ratelimit - computed: false, optional: true, required: false
  private _localRatelimit = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimitOutputReference(this, "local_ratelimit");
  public get localRatelimit() {
    return this._localRatelimit;
  }
  public putLocalRatelimit(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsLocalRatelimit) {
    this._localRatelimit.internalValue = value;
  }
  public resetLocalRatelimit() {
    this._localRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRatelimitInput() {
    return this._localRatelimit.internalValue;
  }

  // tcp_proxy_settings - computed: false, optional: true, required: false
  private _tcpProxySettings = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettingsOutputReference(this, "tcp_proxy_settings");
  public get tcpProxySettings() {
    return this._tcpProxySettings;
  }
  public putTcpProxySettings(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayOptionsTcpProxySettings) {
    this._tcpProxySettings.internalValue = value;
  }
  public resetTcpProxySettings() {
    this._tcpProxySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpProxySettingsInput() {
    return this._tcpProxySettings.internalValue;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#data_centers DataK8SGatewaySoloIoGatewayV1Manifest#data_centers}
  */
  readonly dataCenters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#service_name DataK8SGatewaySoloIoGatewayV1Manifest#service_name}
  */
  readonly serviceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#tags DataK8SGatewaySoloIoGatewayV1Manifest#tags}
  */
  readonly tags?: string[];
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_centers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dataCenters),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
    tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tags),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_centers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dataCenters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsulOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataCenters !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataCenters = this._dataCenters;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationConsul | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataCenters = undefined;
      this._serviceName = undefined;
      this._tags = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataCenters = value.dataCenters;
      this._serviceName = value.serviceName;
      this._tags = value.tags;
    }
  }

  // data_centers - computed: false, optional: true, required: false
  private _dataCenters?: string[]; 
  public get dataCenters() {
    return this.getListAttribute('data_centers');
  }
  public set dataCenters(value: string[]) {
    this._dataCenters = value;
  }
  public resetDataCenters() {
    this._dataCenters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataCentersInput() {
    return this._dataCenters;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: string[]; 
  public get tags() {
    return this.getListAttribute('tags');
  }
  public set tags(value: string[]) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#invocation_style DataK8SGatewaySoloIoGatewayV1Manifest#invocation_style}
  */
  readonly invocationStyle?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#logical_name DataK8SGatewaySoloIoGatewayV1Manifest#logical_name}
  */
  readonly logicalName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#request_transformation DataK8SGatewaySoloIoGatewayV1Manifest#request_transformation}
  */
  readonly requestTransformation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#response_transformation DataK8SGatewaySoloIoGatewayV1Manifest#response_transformation}
  */
  readonly responseTransformation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#unwrap_as_alb DataK8SGatewaySoloIoGatewayV1Manifest#unwrap_as_alb}
  */
  readonly unwrapAsAlb?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#unwrap_as_api_gateway DataK8SGatewaySoloIoGatewayV1Manifest#unwrap_as_api_gateway}
  */
  readonly unwrapAsApiGateway?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#wrap_as_api_gateway DataK8SGatewaySoloIoGatewayV1Manifest#wrap_as_api_gateway}
  */
  readonly wrapAsApiGateway?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invocation_style: cdktf.stringToTerraform(struct!.invocationStyle),
    logical_name: cdktf.stringToTerraform(struct!.logicalName),
    request_transformation: cdktf.booleanToTerraform(struct!.requestTransformation),
    response_transformation: cdktf.booleanToTerraform(struct!.responseTransformation),
    unwrap_as_alb: cdktf.booleanToTerraform(struct!.unwrapAsAlb),
    unwrap_as_api_gateway: cdktf.booleanToTerraform(struct!.unwrapAsApiGateway),
    wrap_as_api_gateway: cdktf.booleanToTerraform(struct!.wrapAsApiGateway),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invocation_style: {
      value: cdktf.stringToHclTerraform(struct!.invocationStyle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logical_name: {
      value: cdktf.stringToHclTerraform(struct!.logicalName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_transformation: {
      value: cdktf.booleanToHclTerraform(struct!.requestTransformation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_transformation: {
      value: cdktf.booleanToHclTerraform(struct!.responseTransformation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unwrap_as_alb: {
      value: cdktf.booleanToHclTerraform(struct!.unwrapAsAlb),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unwrap_as_api_gateway: {
      value: cdktf.booleanToHclTerraform(struct!.unwrapAsApiGateway),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    wrap_as_api_gateway: {
      value: cdktf.booleanToHclTerraform(struct!.wrapAsApiGateway),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invocationStyle !== undefined) {
      hasAnyValues = true;
      internalValueResult.invocationStyle = this._invocationStyle;
    }
    if (this._logicalName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logicalName = this._logicalName;
    }
    if (this._requestTransformation !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransformation = this._requestTransformation;
    }
    if (this._responseTransformation !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation;
    }
    if (this._unwrapAsAlb !== undefined) {
      hasAnyValues = true;
      internalValueResult.unwrapAsAlb = this._unwrapAsAlb;
    }
    if (this._unwrapAsApiGateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.unwrapAsApiGateway = this._unwrapAsApiGateway;
    }
    if (this._wrapAsApiGateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.wrapAsApiGateway = this._wrapAsApiGateway;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAws | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invocationStyle = undefined;
      this._logicalName = undefined;
      this._requestTransformation = undefined;
      this._responseTransformation = undefined;
      this._unwrapAsAlb = undefined;
      this._unwrapAsApiGateway = undefined;
      this._wrapAsApiGateway = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invocationStyle = value.invocationStyle;
      this._logicalName = value.logicalName;
      this._requestTransformation = value.requestTransformation;
      this._responseTransformation = value.responseTransformation;
      this._unwrapAsAlb = value.unwrapAsAlb;
      this._unwrapAsApiGateway = value.unwrapAsApiGateway;
      this._wrapAsApiGateway = value.wrapAsApiGateway;
    }
  }

  // invocation_style - computed: false, optional: true, required: false
  private _invocationStyle?: string; 
  public get invocationStyle() {
    return this.getStringAttribute('invocation_style');
  }
  public set invocationStyle(value: string) {
    this._invocationStyle = value;
  }
  public resetInvocationStyle() {
    this._invocationStyle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invocationStyleInput() {
    return this._invocationStyle;
  }

  // logical_name - computed: false, optional: true, required: false
  private _logicalName?: string; 
  public get logicalName() {
    return this.getStringAttribute('logical_name');
  }
  public set logicalName(value: string) {
    this._logicalName = value;
  }
  public resetLogicalName() {
    this._logicalName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logicalNameInput() {
    return this._logicalName;
  }

  // request_transformation - computed: false, optional: true, required: false
  private _requestTransformation?: boolean | cdktf.IResolvable; 
  public get requestTransformation() {
    return this.getBooleanAttribute('request_transformation');
  }
  public set requestTransformation(value: boolean | cdktf.IResolvable) {
    this._requestTransformation = value;
  }
  public resetRequestTransformation() {
    this._requestTransformation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformationInput() {
    return this._requestTransformation;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation?: boolean | cdktf.IResolvable; 
  public get responseTransformation() {
    return this.getBooleanAttribute('response_transformation');
  }
  public set responseTransformation(value: boolean | cdktf.IResolvable) {
    this._responseTransformation = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation;
  }

  // unwrap_as_alb - computed: false, optional: true, required: false
  private _unwrapAsAlb?: boolean | cdktf.IResolvable; 
  public get unwrapAsAlb() {
    return this.getBooleanAttribute('unwrap_as_alb');
  }
  public set unwrapAsAlb(value: boolean | cdktf.IResolvable) {
    this._unwrapAsAlb = value;
  }
  public resetUnwrapAsAlb() {
    this._unwrapAsAlb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unwrapAsAlbInput() {
    return this._unwrapAsAlb;
  }

  // unwrap_as_api_gateway - computed: false, optional: true, required: false
  private _unwrapAsApiGateway?: boolean | cdktf.IResolvable; 
  public get unwrapAsApiGateway() {
    return this.getBooleanAttribute('unwrap_as_api_gateway');
  }
  public set unwrapAsApiGateway(value: boolean | cdktf.IResolvable) {
    this._unwrapAsApiGateway = value;
  }
  public resetUnwrapAsApiGateway() {
    this._unwrapAsApiGateway = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unwrapAsApiGatewayInput() {
    return this._unwrapAsApiGateway;
  }

  // wrap_as_api_gateway - computed: false, optional: true, required: false
  private _wrapAsApiGateway?: boolean | cdktf.IResolvable; 
  public get wrapAsApiGateway() {
    return this.getBooleanAttribute('wrap_as_api_gateway');
  }
  public set wrapAsApiGateway(value: boolean | cdktf.IResolvable) {
    this._wrapAsApiGateway = value;
  }
  public resetWrapAsApiGateway() {
    this._wrapAsApiGateway = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wrapAsApiGatewayInput() {
    return this._wrapAsApiGateway;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#function_name DataK8SGatewaySoloIoGatewayV1Manifest#function_name}
  */
  readonly functionName?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function_name: cdktf.stringToTerraform(struct!.functionName),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function_name: {
      value: cdktf.stringToHclTerraform(struct!.functionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._functionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionName = this._functionName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecAzure | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._functionName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._functionName = value.functionName;
    }
  }

  // function_name - computed: false, optional: true, required: false
  private _functionName?: string; 
  public get functionName() {
    return this.getStringAttribute('function_name');
  }
  public set functionName(value: string) {
    this._functionName = value;
  }
  public resetFunctionName() {
    this._functionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionNameInput() {
    return this._functionName;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path DataK8SGatewaySoloIoGatewayV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers = value.headers;
      this._path = value.path;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#function DataK8SGatewaySoloIoGatewayV1Manifest#function}
  */
  readonly function?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#package DataK8SGatewaySoloIoGatewayV1Manifest#package}
  */
  readonly package?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#parameters DataK8SGatewaySoloIoGatewayV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#service DataK8SGatewaySoloIoGatewayV1Manifest#service}
  */
  readonly service?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function: cdktf.stringToTerraform(struct!.function),
    package: cdktf.stringToTerraform(struct!.package),
    parameters: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParametersToTerraform(struct!.parameters),
    service: cdktf.stringToTerraform(struct!.service),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function: {
      value: cdktf.stringToHclTerraform(struct!.function),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    package: {
      value: cdktf.stringToHclTerraform(struct!.package),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parameters: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._function !== undefined) {
      hasAnyValues = true;
      internalValueResult.function = this._function;
    }
    if (this._package !== undefined) {
      hasAnyValues = true;
      internalValueResult.package = this._package;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._function = undefined;
      this._package = undefined;
      this._parameters.internalValue = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._function = value.function;
      this._package = value.package;
      this._parameters.internalValue = value.parameters;
      this._service = value.service;
    }
  }

  // function - computed: false, optional: true, required: false
  private _function?: string; 
  public get function() {
    return this.getStringAttribute('function');
  }
  public set function(value: string) {
    this._function = value;
  }
  public resetFunction() {
    this._function = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionInput() {
    return this._function;
  }

  // package - computed: false, optional: true, required: false
  private _package?: string; 
  public get package() {
    return this.getStringAttribute('package');
  }
  public set package(value: string) {
    this._package = value;
  }
  public resetPackage() {
    this._package = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packageInput() {
    return this._package;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecGrpcParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#headers DataK8SGatewaySoloIoGatewayV1Manifest#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#path DataK8SGatewaySoloIoGatewayV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers = value.headers;
      this._path = value.path;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValueToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#json_to_proto DataK8SGatewaySoloIoGatewayV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#key DataK8SGatewaySoloIoGatewayV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#metadata_namespace DataK8SGatewaySoloIoGatewayV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#value DataK8SGatewaySoloIoGatewayV1Manifest#value}
  */
  readonly value?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesOutputReference {
    return new DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#body DataK8SGatewaySoloIoGatewayV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#header DataK8SGatewaySoloIoGatewayV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#mode DataK8SGatewaySoloIoGatewayV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#regex DataK8SGatewaySoloIoGatewayV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#replacement_text DataK8SGatewaySoloIoGatewayV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#subgroup DataK8SGatewaySoloIoGatewayV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gateway_solo_io_gateway_v1_manifest#text DataK8SGatewaySoloIoGatewayV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoGatewayV1ManifestSpecHybridGatewayMatchedGatewaysTcpGatewayTcpHostsDestinationMultiDestinationsDestinationDestinationSpecRestResponseTransformationHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
