import * as cdktf from 'cdktf';
export interface DataK8SGlooSoloIoUpstreamV1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#annotations DataK8SGlooSoloIoUpstreamV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#labels DataK8SGlooSoloIoUpstreamV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestMetadataToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestMetadataToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHostToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHostToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_host DataK8SGlooSoloIoUpstreamV1Manifest#custom_host}
  */
  readonly customHost?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#version DataK8SGlooSoloIoUpstreamV1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenToTerraform(struct!.authToken),
    custom_host: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHostToTerraform(struct!.customHost),
    model: cdktf.stringToTerraform(struct!.model),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken",
    },
    custom_host: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHostToHclTerraform(struct!.customHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._customHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHost = this._customHost?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
      this._customHost.internalValue = undefined;
      this._model = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
      this._customHost.internalValue = value.customHost;
      this._model = value.model;
      this._version = value.version;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // custom_host - computed: false, optional: true, required: false
  private _customHost = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHostOutputReference(this, "custom_host");
  public get customHost() {
    return this._customHost;
  }
  public putCustomHost(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicCustomHost) {
    this._customHost.internalValue = value;
  }
  public resetCustomHost() {
    this._customHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHostInput() {
    return this._customHost.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#api_version DataK8SGlooSoloIoUpstreamV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#deployment_name DataK8SGlooSoloIoUpstreamV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#endpoint DataK8SGlooSoloIoUpstreamV1Manifest#endpoint}
  */
  readonly endpoint?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenToTerraform(struct!.authToken),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._deploymentName = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._deploymentName = value.deploymentName;
      this._endpoint = value.endpoint;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#api_version DataK8SGlooSoloIoUpstreamV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenToTerraform(struct!.authToken),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._model = value.model;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHostToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHostToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_host DataK8SGlooSoloIoUpstreamV1Manifest#custom_host}
  */
  readonly customHost?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenToTerraform(struct!.authToken),
    custom_host: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHostToTerraform(struct!.customHost),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken",
    },
    custom_host: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHostToHclTerraform(struct!.customHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._customHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHost = this._customHost?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
      this._customHost.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
      this._customHost.internalValue = value.customHost;
      this._model = value.model;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // custom_host - computed: false, optional: true, required: false
  private _customHost = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHostOutputReference(this, "custom_host");
  public get customHost() {
    return this._customHost;
  }
  public putCustomHost(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralCustomHost) {
    this._customHost.internalValue = value;
  }
  public resetCustomHost() {
    this._customHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHostInput() {
    return this._customHost.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHostToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHostToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_host DataK8SGlooSoloIoUpstreamV1Manifest#custom_host}
  */
  readonly customHost?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#version DataK8SGlooSoloIoUpstreamV1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenToTerraform(struct!.authToken),
    custom_host: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHostToTerraform(struct!.customHost),
    model: cdktf.stringToTerraform(struct!.model),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken",
    },
    custom_host: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHostToHclTerraform(struct!.customHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._customHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHost = this._customHost?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
      this._customHost.internalValue = undefined;
      this._model = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
      this._customHost.internalValue = value.customHost;
      this._model = value.model;
      this._version = value.version;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // custom_host - computed: false, optional: true, required: false
  private _customHost = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHostOutputReference(this, "custom_host");
  public get customHost() {
    return this._customHost;
  }
  public putCustomHost(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicCustomHost) {
    this._customHost.internalValue = value;
  }
  public resetCustomHost() {
    this._customHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHostInput() {
    return this._customHost.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#api_version DataK8SGlooSoloIoUpstreamV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#deployment_name DataK8SGlooSoloIoUpstreamV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#endpoint DataK8SGlooSoloIoUpstreamV1Manifest#endpoint}
  */
  readonly endpoint?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenToTerraform(struct!.authToken),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._deploymentName = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._deploymentName = value.deploymentName;
      this._endpoint = value.endpoint;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#api_version DataK8SGlooSoloIoUpstreamV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenToTerraform(struct!.authToken),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._model = value.model;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHostToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHostToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_host DataK8SGlooSoloIoUpstreamV1Manifest#custom_host}
  */
  readonly customHost?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenToTerraform(struct!.authToken),
    custom_host: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHostToTerraform(struct!.customHost),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken",
    },
    custom_host: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHostToHclTerraform(struct!.customHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._customHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHost = this._customHost?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
      this._customHost.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
      this._customHost.internalValue = value.customHost;
      this._model = value.model;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // custom_host - computed: false, optional: true, required: false
  private _customHost = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHostOutputReference(this, "custom_host");
  public get customHost() {
    return this._customHost;
  }
  public putCustomHost(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralCustomHost) {
    this._customHost.internalValue = value;
  }
  public resetCustomHost() {
    this._customHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHostInput() {
    return this._customHost.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHostToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHostToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_host DataK8SGlooSoloIoUpstreamV1Manifest#custom_host}
  */
  readonly customHost?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenToTerraform(struct!.authToken),
    custom_host: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHostToTerraform(struct!.customHost),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken",
    },
    custom_host: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHostToHclTerraform(struct!.customHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._customHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHost = this._customHost?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
      this._customHost.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
      this._customHost.internalValue = value.customHost;
      this._model = value.model;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // custom_host - computed: false, optional: true, required: false
  private _customHost = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHostOutputReference(this, "custom_host");
  public get customHost() {
    return this._customHost;
  }
  public putCustomHost(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiCustomHost) {
    this._customHost.internalValue = value;
  }
  public resetCustomHost() {
    this._customHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHostInput() {
    return this._customHost.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#anthropic DataK8SGlooSoloIoUpstreamV1Manifest#anthropic}
  */
  readonly anthropic?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#azure_openai DataK8SGlooSoloIoUpstreamV1Manifest#azure_openai}
  */
  readonly azureOpenai?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#gemini DataK8SGlooSoloIoUpstreamV1Manifest#gemini}
  */
  readonly gemini?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#mistral DataK8SGlooSoloIoUpstreamV1Manifest#mistral}
  */
  readonly mistral?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#openai DataK8SGlooSoloIoUpstreamV1Manifest#openai}
  */
  readonly openai?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    anthropic: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicToTerraform(struct!.anthropic),
    azure_openai: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiToTerraform(struct!.azureOpenai),
    gemini: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiToTerraform(struct!.gemini),
    mistral: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralToTerraform(struct!.mistral),
    openai: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiToTerraform(struct!.openai),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    anthropic: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicToHclTerraform(struct!.anthropic),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic",
    },
    azure_openai: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiToHclTerraform(struct!.azureOpenai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai",
    },
    gemini: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiToHclTerraform(struct!.gemini),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini",
    },
    mistral: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralToHclTerraform(struct!.mistral),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral",
    },
    openai: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiToHclTerraform(struct!.openai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anthropic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anthropic = this._anthropic?.internalValue;
    }
    if (this._azureOpenai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureOpenai = this._azureOpenai?.internalValue;
    }
    if (this._gemini?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gemini = this._gemini?.internalValue;
    }
    if (this._mistral?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mistral = this._mistral?.internalValue;
    }
    if (this._openai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openai = this._openai?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anthropic.internalValue = undefined;
      this._azureOpenai.internalValue = undefined;
      this._gemini.internalValue = undefined;
      this._mistral.internalValue = undefined;
      this._openai.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anthropic.internalValue = value.anthropic;
      this._azureOpenai.internalValue = value.azureOpenai;
      this._gemini.internalValue = value.gemini;
      this._mistral.internalValue = value.mistral;
      this._openai.internalValue = value.openai;
    }
  }

  // anthropic - computed: false, optional: true, required: false
  private _anthropic = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropicOutputReference(this, "anthropic");
  public get anthropic() {
    return this._anthropic;
  }
  public putAnthropic(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAnthropic) {
    this._anthropic.internalValue = value;
  }
  public resetAnthropic() {
    this._anthropic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anthropicInput() {
    return this._anthropic.internalValue;
  }

  // azure_openai - computed: false, optional: true, required: false
  private _azureOpenai = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenaiOutputReference(this, "azure_openai");
  public get azureOpenai() {
    return this._azureOpenai;
  }
  public putAzureOpenai(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolAzureOpenai) {
    this._azureOpenai.internalValue = value;
  }
  public resetAzureOpenai() {
    this._azureOpenai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureOpenaiInput() {
    return this._azureOpenai.internalValue;
  }

  // gemini - computed: false, optional: true, required: false
  private _gemini = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGeminiOutputReference(this, "gemini");
  public get gemini() {
    return this._gemini;
  }
  public putGemini(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolGemini) {
    this._gemini.internalValue = value;
  }
  public resetGemini() {
    this._gemini.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get geminiInput() {
    return this._gemini.internalValue;
  }

  // mistral - computed: false, optional: true, required: false
  private _mistral = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistralOutputReference(this, "mistral");
  public get mistral() {
    return this._mistral;
  }
  public putMistral(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolMistral) {
    this._mistral.internalValue = value;
  }
  public resetMistral() {
    this._mistral.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mistralInput() {
    return this._mistral.internalValue;
  }

  // openai - computed: false, optional: true, required: false
  private _openai = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenaiOutputReference(this, "openai");
  public get openai() {
    return this._openai;
  }
  public putOpenai(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOpenai) {
    this._openai.internalValue = value;
  }
  public resetOpenai() {
    this._openai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openaiInput() {
    return this._openai.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#pool DataK8SGlooSoloIoUpstreamV1Manifest#pool}
  */
  readonly pool?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pool: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolToTerraform, false)(struct!.pool),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pool: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolToHclTerraform, false)(struct!.pool),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pool?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pool = this._pool?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pool.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pool.internalValue = value.pool;
    }
  }

  // pool - computed: false, optional: true, required: false
  private _pool = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPoolList(this, "pool", false);
  public get pool() {
    return this._pool;
  }
  public putPool(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesPool[] | cdktf.IResolvable) {
    this._pool.internalValue = value;
  }
  public resetPool() {
    this._pool.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get poolInput() {
    return this._pool.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#priorities DataK8SGlooSoloIoUpstreamV1Manifest#priorities}
  */
  readonly priorities?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    priorities: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesToTerraform, false)(struct!.priorities),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    priorities: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesToHclTerraform, false)(struct!.priorities),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._priorities?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.priorities = this._priorities?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._priorities.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._priorities.internalValue = value.priorities;
    }
  }

  // priorities - computed: false, optional: true, required: false
  private _priorities = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPrioritiesList(this, "priorities", false);
  public get priorities() {
    return this._priorities;
  }
  public putPriorities(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiPriorities[] | cdktf.IResolvable) {
    this._priorities.internalValue = value;
  }
  public resetPriorities() {
    this._priorities.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prioritiesInput() {
    return this._priorities.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHostToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHostToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_token DataK8SGlooSoloIoUpstreamV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_host DataK8SGlooSoloIoUpstreamV1Manifest#custom_host}
  */
  readonly customHost?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#model DataK8SGlooSoloIoUpstreamV1Manifest#model}
  */
  readonly model?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenToTerraform(struct!.authToken),
    custom_host: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHostToTerraform(struct!.customHost),
    model: cdktf.stringToTerraform(struct!.model),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken",
    },
    custom_host: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHostToHclTerraform(struct!.customHost),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost",
    },
    model: {
      value: cdktf.stringToHclTerraform(struct!.model),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._customHost?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHost = this._customHost?.internalValue;
    }
    if (this._model !== undefined) {
      hasAnyValues = true;
      internalValueResult.model = this._model;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
      this._customHost.internalValue = undefined;
      this._model = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
      this._customHost.internalValue = value.customHost;
      this._model = value.model;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // custom_host - computed: false, optional: true, required: false
  private _customHost = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHostOutputReference(this, "custom_host");
  public get customHost() {
    return this._customHost;
  }
  public putCustomHost(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiCustomHost) {
    this._customHost.internalValue = value;
  }
  public resetCustomHost() {
    this._customHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHostInput() {
    return this._customHost.internalValue;
  }

  // model - computed: false, optional: true, required: false
  private _model?: string; 
  public get model() {
    return this.getStringAttribute('model');
  }
  public set model(value: string) {
    this._model = value;
  }
  public resetModel() {
    this._model = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modelInput() {
    return this._model;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAi {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#anthropic DataK8SGlooSoloIoUpstreamV1Manifest#anthropic}
  */
  readonly anthropic?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#azure_openai DataK8SGlooSoloIoUpstreamV1Manifest#azure_openai}
  */
  readonly azureOpenai?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#gemini DataK8SGlooSoloIoUpstreamV1Manifest#gemini}
  */
  readonly gemini?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#mistral DataK8SGlooSoloIoUpstreamV1Manifest#mistral}
  */
  readonly mistral?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#multi DataK8SGlooSoloIoUpstreamV1Manifest#multi}
  */
  readonly multi?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#openai DataK8SGlooSoloIoUpstreamV1Manifest#openai}
  */
  readonly openai?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    anthropic: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicToTerraform(struct!.anthropic),
    azure_openai: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiToTerraform(struct!.azureOpenai),
    gemini: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiToTerraform(struct!.gemini),
    mistral: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralToTerraform(struct!.mistral),
    multi: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiToTerraform(struct!.multi),
    openai: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiToTerraform(struct!.openai),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAiToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    anthropic: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicToHclTerraform(struct!.anthropic),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic",
    },
    azure_openai: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiToHclTerraform(struct!.azureOpenai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai",
    },
    gemini: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiToHclTerraform(struct!.gemini),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini",
    },
    mistral: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralToHclTerraform(struct!.mistral),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral",
    },
    multi: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiToHclTerraform(struct!.multi),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti",
    },
    openai: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiToHclTerraform(struct!.openai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anthropic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anthropic = this._anthropic?.internalValue;
    }
    if (this._azureOpenai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureOpenai = this._azureOpenai?.internalValue;
    }
    if (this._gemini?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gemini = this._gemini?.internalValue;
    }
    if (this._mistral?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mistral = this._mistral?.internalValue;
    }
    if (this._multi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.multi = this._multi?.internalValue;
    }
    if (this._openai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openai = this._openai?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anthropic.internalValue = undefined;
      this._azureOpenai.internalValue = undefined;
      this._gemini.internalValue = undefined;
      this._mistral.internalValue = undefined;
      this._multi.internalValue = undefined;
      this._openai.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anthropic.internalValue = value.anthropic;
      this._azureOpenai.internalValue = value.azureOpenai;
      this._gemini.internalValue = value.gemini;
      this._mistral.internalValue = value.mistral;
      this._multi.internalValue = value.multi;
      this._openai.internalValue = value.openai;
    }
  }

  // anthropic - computed: false, optional: true, required: false
  private _anthropic = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropicOutputReference(this, "anthropic");
  public get anthropic() {
    return this._anthropic;
  }
  public putAnthropic(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAnthropic) {
    this._anthropic.internalValue = value;
  }
  public resetAnthropic() {
    this._anthropic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anthropicInput() {
    return this._anthropic.internalValue;
  }

  // azure_openai - computed: false, optional: true, required: false
  private _azureOpenai = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenaiOutputReference(this, "azure_openai");
  public get azureOpenai() {
    return this._azureOpenai;
  }
  public putAzureOpenai(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiAzureOpenai) {
    this._azureOpenai.internalValue = value;
  }
  public resetAzureOpenai() {
    this._azureOpenai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureOpenaiInput() {
    return this._azureOpenai.internalValue;
  }

  // gemini - computed: false, optional: true, required: false
  private _gemini = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGeminiOutputReference(this, "gemini");
  public get gemini() {
    return this._gemini;
  }
  public putGemini(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiGemini) {
    this._gemini.internalValue = value;
  }
  public resetGemini() {
    this._gemini.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get geminiInput() {
    return this._gemini.internalValue;
  }

  // mistral - computed: false, optional: true, required: false
  private _mistral = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistralOutputReference(this, "mistral");
  public get mistral() {
    return this._mistral;
  }
  public putMistral(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMistral) {
    this._mistral.internalValue = value;
  }
  public resetMistral() {
    this._mistral.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mistralInput() {
    return this._mistral.internalValue;
  }

  // multi - computed: false, optional: true, required: false
  private _multi = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMultiOutputReference(this, "multi");
  public get multi() {
    return this._multi;
  }
  public putMulti(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiMulti) {
    this._multi.internalValue = value;
  }
  public resetMulti() {
    this._multi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiInput() {
    return this._multi.internalValue;
  }

  // openai - computed: false, optional: true, required: false
  private _openai = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenaiOutputReference(this, "openai");
  public get openai() {
    return this._openai;
  }
  public putOpenai(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAiOpenai) {
    this._openai.internalValue = value;
  }
  public resetOpenai() {
    this._openai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openaiInput() {
    return this._openai.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#invocation_style DataK8SGlooSoloIoUpstreamV1Manifest#invocation_style}
  */
  readonly invocationStyle?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#logical_name DataK8SGlooSoloIoUpstreamV1Manifest#logical_name}
  */
  readonly logicalName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#request_transformation DataK8SGlooSoloIoUpstreamV1Manifest#request_transformation}
  */
  readonly requestTransformation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#response_transformation DataK8SGlooSoloIoUpstreamV1Manifest#response_transformation}
  */
  readonly responseTransformation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#unwrap_as_alb DataK8SGlooSoloIoUpstreamV1Manifest#unwrap_as_alb}
  */
  readonly unwrapAsAlb?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#unwrap_as_api_gateway DataK8SGlooSoloIoUpstreamV1Manifest#unwrap_as_api_gateway}
  */
  readonly unwrapAsApiGateway?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#wrap_as_api_gateway DataK8SGlooSoloIoUpstreamV1Manifest#wrap_as_api_gateway}
  */
  readonly wrapAsApiGateway?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverridesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invocation_style: cdktf.stringToTerraform(struct!.invocationStyle),
    logical_name: cdktf.stringToTerraform(struct!.logicalName),
    request_transformation: cdktf.booleanToTerraform(struct!.requestTransformation),
    response_transformation: cdktf.booleanToTerraform(struct!.responseTransformation),
    unwrap_as_alb: cdktf.booleanToTerraform(struct!.unwrapAsAlb),
    unwrap_as_api_gateway: cdktf.booleanToTerraform(struct!.unwrapAsApiGateway),
    wrap_as_api_gateway: cdktf.booleanToTerraform(struct!.wrapAsApiGateway),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverridesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invocation_style: {
      value: cdktf.stringToHclTerraform(struct!.invocationStyle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logical_name: {
      value: cdktf.stringToHclTerraform(struct!.logicalName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_transformation: {
      value: cdktf.booleanToHclTerraform(struct!.requestTransformation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_transformation: {
      value: cdktf.booleanToHclTerraform(struct!.responseTransformation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unwrap_as_alb: {
      value: cdktf.booleanToHclTerraform(struct!.unwrapAsAlb),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    unwrap_as_api_gateway: {
      value: cdktf.booleanToHclTerraform(struct!.unwrapAsApiGateway),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    wrap_as_api_gateway: {
      value: cdktf.booleanToHclTerraform(struct!.wrapAsApiGateway),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invocationStyle !== undefined) {
      hasAnyValues = true;
      internalValueResult.invocationStyle = this._invocationStyle;
    }
    if (this._logicalName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logicalName = this._logicalName;
    }
    if (this._requestTransformation !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTransformation = this._requestTransformation;
    }
    if (this._responseTransformation !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTransformation = this._responseTransformation;
    }
    if (this._unwrapAsAlb !== undefined) {
      hasAnyValues = true;
      internalValueResult.unwrapAsAlb = this._unwrapAsAlb;
    }
    if (this._unwrapAsApiGateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.unwrapAsApiGateway = this._unwrapAsApiGateway;
    }
    if (this._wrapAsApiGateway !== undefined) {
      hasAnyValues = true;
      internalValueResult.wrapAsApiGateway = this._wrapAsApiGateway;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invocationStyle = undefined;
      this._logicalName = undefined;
      this._requestTransformation = undefined;
      this._responseTransformation = undefined;
      this._unwrapAsAlb = undefined;
      this._unwrapAsApiGateway = undefined;
      this._wrapAsApiGateway = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invocationStyle = value.invocationStyle;
      this._logicalName = value.logicalName;
      this._requestTransformation = value.requestTransformation;
      this._responseTransformation = value.responseTransformation;
      this._unwrapAsAlb = value.unwrapAsAlb;
      this._unwrapAsApiGateway = value.unwrapAsApiGateway;
      this._wrapAsApiGateway = value.wrapAsApiGateway;
    }
  }

  // invocation_style - computed: false, optional: true, required: false
  private _invocationStyle?: string; 
  public get invocationStyle() {
    return this.getStringAttribute('invocation_style');
  }
  public set invocationStyle(value: string) {
    this._invocationStyle = value;
  }
  public resetInvocationStyle() {
    this._invocationStyle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invocationStyleInput() {
    return this._invocationStyle;
  }

  // logical_name - computed: false, optional: true, required: false
  private _logicalName?: string; 
  public get logicalName() {
    return this.getStringAttribute('logical_name');
  }
  public set logicalName(value: string) {
    this._logicalName = value;
  }
  public resetLogicalName() {
    this._logicalName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logicalNameInput() {
    return this._logicalName;
  }

  // request_transformation - computed: false, optional: true, required: false
  private _requestTransformation?: boolean | cdktf.IResolvable; 
  public get requestTransformation() {
    return this.getBooleanAttribute('request_transformation');
  }
  public set requestTransformation(value: boolean | cdktf.IResolvable) {
    this._requestTransformation = value;
  }
  public resetRequestTransformation() {
    this._requestTransformation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTransformationInput() {
    return this._requestTransformation;
  }

  // response_transformation - computed: false, optional: true, required: false
  private _responseTransformation?: boolean | cdktf.IResolvable; 
  public get responseTransformation() {
    return this.getBooleanAttribute('response_transformation');
  }
  public set responseTransformation(value: boolean | cdktf.IResolvable) {
    this._responseTransformation = value;
  }
  public resetResponseTransformation() {
    this._responseTransformation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTransformationInput() {
    return this._responseTransformation;
  }

  // unwrap_as_alb - computed: false, optional: true, required: false
  private _unwrapAsAlb?: boolean | cdktf.IResolvable; 
  public get unwrapAsAlb() {
    return this.getBooleanAttribute('unwrap_as_alb');
  }
  public set unwrapAsAlb(value: boolean | cdktf.IResolvable) {
    this._unwrapAsAlb = value;
  }
  public resetUnwrapAsAlb() {
    this._unwrapAsAlb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unwrapAsAlbInput() {
    return this._unwrapAsAlb;
  }

  // unwrap_as_api_gateway - computed: false, optional: true, required: false
  private _unwrapAsApiGateway?: boolean | cdktf.IResolvable; 
  public get unwrapAsApiGateway() {
    return this.getBooleanAttribute('unwrap_as_api_gateway');
  }
  public set unwrapAsApiGateway(value: boolean | cdktf.IResolvable) {
    this._unwrapAsApiGateway = value;
  }
  public resetUnwrapAsApiGateway() {
    this._unwrapAsApiGateway = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unwrapAsApiGatewayInput() {
    return this._unwrapAsApiGateway;
  }

  // wrap_as_api_gateway - computed: false, optional: true, required: false
  private _wrapAsApiGateway?: boolean | cdktf.IResolvable; 
  public get wrapAsApiGateway() {
    return this.getBooleanAttribute('wrap_as_api_gateway');
  }
  public set wrapAsApiGateway(value: boolean | cdktf.IResolvable) {
    this._wrapAsApiGateway = value;
  }
  public resetWrapAsApiGateway() {
    this._wrapAsApiGateway = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wrapAsApiGatewayInput() {
    return this._wrapAsApiGateway;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#lambda_function_name DataK8SGlooSoloIoUpstreamV1Manifest#lambda_function_name}
  */
  readonly lambdaFunctionName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#logical_name DataK8SGlooSoloIoUpstreamV1Manifest#logical_name}
  */
  readonly logicalName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#qualifier DataK8SGlooSoloIoUpstreamV1Manifest#qualifier}
  */
  readonly qualifier?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    lambda_function_name: cdktf.stringToTerraform(struct!.lambdaFunctionName),
    logical_name: cdktf.stringToTerraform(struct!.logicalName),
    qualifier: cdktf.stringToTerraform(struct!.qualifier),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    lambda_function_name: {
      value: cdktf.stringToHclTerraform(struct!.lambdaFunctionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logical_name: {
      value: cdktf.stringToHclTerraform(struct!.logicalName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    qualifier: {
      value: cdktf.stringToHclTerraform(struct!.qualifier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._lambdaFunctionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.lambdaFunctionName = this._lambdaFunctionName;
    }
    if (this._logicalName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logicalName = this._logicalName;
    }
    if (this._qualifier !== undefined) {
      hasAnyValues = true;
      internalValueResult.qualifier = this._qualifier;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._lambdaFunctionName = undefined;
      this._logicalName = undefined;
      this._qualifier = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._lambdaFunctionName = value.lambdaFunctionName;
      this._logicalName = value.logicalName;
      this._qualifier = value.qualifier;
    }
  }

  // lambda_function_name - computed: false, optional: true, required: false
  private _lambdaFunctionName?: string; 
  public get lambdaFunctionName() {
    return this.getStringAttribute('lambda_function_name');
  }
  public set lambdaFunctionName(value: string) {
    this._lambdaFunctionName = value;
  }
  public resetLambdaFunctionName() {
    this._lambdaFunctionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lambdaFunctionNameInput() {
    return this._lambdaFunctionName;
  }

  // logical_name - computed: false, optional: true, required: false
  private _logicalName?: string; 
  public get logicalName() {
    return this.getStringAttribute('logical_name');
  }
  public set logicalName(value: string) {
    this._logicalName = value;
  }
  public resetLogicalName() {
    this._logicalName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logicalNameInput() {
    return this._logicalName;
  }

  // qualifier - computed: false, optional: true, required: false
  private _qualifier?: string; 
  public get qualifier() {
    return this.getStringAttribute('qualifier');
  }
  public set qualifier(value: string) {
    this._qualifier = value;
  }
  public resetQualifier() {
    this._qualifier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get qualifierInput() {
    return this._qualifier;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAws {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#aws_account_id DataK8SGlooSoloIoUpstreamV1Manifest#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#destination_overrides DataK8SGlooSoloIoUpstreamV1Manifest#destination_overrides}
  */
  readonly destinationOverrides?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#disable_role_chaining DataK8SGlooSoloIoUpstreamV1Manifest#disable_role_chaining}
  */
  readonly disableRoleChaining?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#lambda_functions DataK8SGlooSoloIoUpstreamV1Manifest#lambda_functions}
  */
  readonly lambdaFunctions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#region DataK8SGlooSoloIoUpstreamV1Manifest#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#role_arn DataK8SGlooSoloIoUpstreamV1Manifest#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    destination_overrides: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverridesToTerraform(struct!.destinationOverrides),
    disable_role_chaining: cdktf.booleanToTerraform(struct!.disableRoleChaining),
    lambda_functions: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsToTerraform, false)(struct!.lambdaFunctions),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    destination_overrides: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverridesToHclTerraform(struct!.destinationOverrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides",
    },
    disable_role_chaining: {
      value: cdktf.booleanToHclTerraform(struct!.disableRoleChaining),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    lambda_functions: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsToHclTerraform, false)(struct!.lambdaFunctions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsList",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAws | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._destinationOverrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationOverrides = this._destinationOverrides?.internalValue;
    }
    if (this._disableRoleChaining !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableRoleChaining = this._disableRoleChaining;
    }
    if (this._lambdaFunctions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lambdaFunctions = this._lambdaFunctions?.internalValue;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAws | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._awsAccountId = undefined;
      this._destinationOverrides.internalValue = undefined;
      this._disableRoleChaining = undefined;
      this._lambdaFunctions.internalValue = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._awsAccountId = value.awsAccountId;
      this._destinationOverrides.internalValue = value.destinationOverrides;
      this._disableRoleChaining = value.disableRoleChaining;
      this._lambdaFunctions.internalValue = value.lambdaFunctions;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // destination_overrides - computed: false, optional: true, required: false
  private _destinationOverrides = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverridesOutputReference(this, "destination_overrides");
  public get destinationOverrides() {
    return this._destinationOverrides;
  }
  public putDestinationOverrides(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsDestinationOverrides) {
    this._destinationOverrides.internalValue = value;
  }
  public resetDestinationOverrides() {
    this._destinationOverrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationOverridesInput() {
    return this._destinationOverrides.internalValue;
  }

  // disable_role_chaining - computed: false, optional: true, required: false
  private _disableRoleChaining?: boolean | cdktf.IResolvable; 
  public get disableRoleChaining() {
    return this.getBooleanAttribute('disable_role_chaining');
  }
  public set disableRoleChaining(value: boolean | cdktf.IResolvable) {
    this._disableRoleChaining = value;
  }
  public resetDisableRoleChaining() {
    this._disableRoleChaining = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableRoleChainingInput() {
    return this._disableRoleChaining;
  }

  // lambda_functions - computed: false, optional: true, required: false
  private _lambdaFunctions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctionsList(this, "lambda_functions", false);
  public get lambdaFunctions() {
    return this._lambdaFunctions;
  }
  public putLambdaFunctions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsLambdaFunctions[] | cdktf.IResolvable) {
    this._lambdaFunctions.internalValue = value;
  }
  public resetLambdaFunctions() {
    this._lambdaFunctions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lambdaFunctionsInput() {
    return this._lambdaFunctions.internalValue;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPairToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPairToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPairOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#kv_pair DataK8SGlooSoloIoUpstreamV1Manifest#kv_pair}
  */
  readonly kvPair?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    kv_pair: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPairToTerraform(struct!.kvPair),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kv_pair: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPairToHclTerraform(struct!.kvPair),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._kvPair?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kvPair = this._kvPair?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._kvPair.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._kvPair.internalValue = value.kvPair;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // kv_pair - computed: false, optional: true, required: false
  private _kvPair = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPairOutputReference(this, "kv_pair");
  public get kvPair() {
    return this._kvPair;
  }
  public putKvPair(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersKvPair) {
    this._kvPair.internalValue = value;
  }
  public resetKvPair() {
    this._kvPair.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kvPairInput() {
    return this._kvPair.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#filters DataK8SGlooSoloIoUpstreamV1Manifest#filters}
  */
  readonly filters?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#public_ip DataK8SGlooSoloIoUpstreamV1Manifest#public_ip}
  */
  readonly publicIp?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#region DataK8SGlooSoloIoUpstreamV1Manifest#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#role_arn DataK8SGlooSoloIoUpstreamV1Manifest#role_arn}
  */
  readonly roleArn?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2ToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filters: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersToTerraform, false)(struct!.filters),
    port: cdktf.numberToTerraform(struct!.port),
    public_ip: cdktf.booleanToTerraform(struct!.publicIp),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2ToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filters: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersList",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.publicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._publicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicIp = this._publicIp;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filters.internalValue = undefined;
      this._port = undefined;
      this._publicIp = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filters.internalValue = value.filters;
      this._port = value.port;
      this._publicIp = value.publicIp;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2FiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2Filters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // public_ip - computed: false, optional: true, required: false
  private _publicIp?: boolean | cdktf.IResolvable; 
  public get publicIp() {
    return this.getBooleanAttribute('public_ip');
  }
  public set publicIp(value: boolean | cdktf.IResolvable) {
    this._publicIp = value;
  }
  public resetPublicIp() {
    this._publicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicIpInput() {
    return this._publicIp;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAwsEc2SecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auth_level DataK8SGlooSoloIoUpstreamV1Manifest#auth_level}
  */
  readonly authLevel?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#function_name DataK8SGlooSoloIoUpstreamV1Manifest#function_name}
  */
  readonly functionName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_level: cdktf.stringToTerraform(struct!.authLevel),
    function_name: cdktf.stringToTerraform(struct!.functionName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_level: {
      value: cdktf.stringToHclTerraform(struct!.authLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    function_name: {
      value: cdktf.stringToHclTerraform(struct!.functionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.authLevel = this._authLevel;
    }
    if (this._functionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionName = this._functionName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authLevel = undefined;
      this._functionName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authLevel = value.authLevel;
      this._functionName = value.functionName;
    }
  }

  // auth_level - computed: false, optional: true, required: false
  private _authLevel?: string; 
  public get authLevel() {
    return this.getStringAttribute('auth_level');
  }
  public set authLevel(value: string) {
    this._authLevel = value;
  }
  public resetAuthLevel() {
    this._authLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authLevelInput() {
    return this._authLevel;
  }

  // function_name - computed: false, optional: true, required: false
  private _functionName?: string; 
  public get functionName() {
    return this.getStringAttribute('function_name');
  }
  public set functionName(value: string) {
    this._functionName = value;
  }
  public resetFunctionName() {
    this._functionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionNameInput() {
    return this._functionName;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecAzure {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#function_app_name DataK8SGlooSoloIoUpstreamV1Manifest#function_app_name}
  */
  readonly functionAppName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#functions DataK8SGlooSoloIoUpstreamV1Manifest#functions}
  */
  readonly functions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function_app_name: cdktf.stringToTerraform(struct!.functionAppName),
    functions: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsToTerraform, false)(struct!.functions),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function_app_name: {
      value: cdktf.stringToHclTerraform(struct!.functionAppName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    functions: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsToHclTerraform, false)(struct!.functions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsList",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecAzure | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._functionAppName !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionAppName = this._functionAppName;
    }
    if (this._functions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.functions = this._functions?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzure | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._functionAppName = undefined;
      this._functions.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._functionAppName = value.functionAppName;
      this._functions.internalValue = value.functions;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // function_app_name - computed: false, optional: true, required: false
  private _functionAppName?: string; 
  public get functionAppName() {
    return this.getStringAttribute('function_app_name');
  }
  public set functionAppName(value: string) {
    this._functionAppName = value;
  }
  public resetFunctionAppName() {
    this._functionAppName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionAppNameInput() {
    return this._functionAppName;
  }

  // functions - computed: false, optional: true, required: false
  private _functions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctionsList(this, "functions", false);
  public get functions() {
    return this._functions;
  }
  public putFunctions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureFunctions[] | cdktf.IResolvable) {
    this._functions.internalValue = value;
  }
  public resetFunctions() {
    this._functions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionsInput() {
    return this._functions.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecAzureSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_connections DataK8SGlooSoloIoUpstreamV1Manifest#max_connections}
  */
  readonly maxConnections?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_pending_requests DataK8SGlooSoloIoUpstreamV1Manifest#max_pending_requests}
  */
  readonly maxPendingRequests?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_requests DataK8SGlooSoloIoUpstreamV1Manifest#max_requests}
  */
  readonly maxRequests?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_retries DataK8SGlooSoloIoUpstreamV1Manifest#max_retries}
  */
  readonly maxRetries?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_connections: cdktf.numberToTerraform(struct!.maxConnections),
    max_pending_requests: cdktf.numberToTerraform(struct!.maxPendingRequests),
    max_requests: cdktf.numberToTerraform(struct!.maxRequests),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_connections: {
      value: cdktf.numberToHclTerraform(struct!.maxConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_pending_requests: {
      value: cdktf.numberToHclTerraform(struct!.maxPendingRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests: {
      value: cdktf.numberToHclTerraform(struct!.maxRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConnections = this._maxConnections;
    }
    if (this._maxPendingRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPendingRequests = this._maxPendingRequests;
    }
    if (this._maxRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequests = this._maxRequests;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecCircuitBreakers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxConnections = undefined;
      this._maxPendingRequests = undefined;
      this._maxRequests = undefined;
      this._maxRetries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxConnections = value.maxConnections;
      this._maxPendingRequests = value.maxPendingRequests;
      this._maxRequests = value.maxRequests;
      this._maxRetries = value.maxRetries;
    }
  }

  // max_connections - computed: false, optional: true, required: false
  private _maxConnections?: number; 
  public get maxConnections() {
    return this.getNumberAttribute('max_connections');
  }
  public set maxConnections(value: number) {
    this._maxConnections = value;
  }
  public resetMaxConnections() {
    this._maxConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConnectionsInput() {
    return this._maxConnections;
  }

  // max_pending_requests - computed: false, optional: true, required: false
  private _maxPendingRequests?: number; 
  public get maxPendingRequests() {
    return this.getNumberAttribute('max_pending_requests');
  }
  public set maxPendingRequests(value: number) {
    this._maxPendingRequests = value;
  }
  public resetMaxPendingRequests() {
    this._maxPendingRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPendingRequestsInput() {
    return this._maxPendingRequests;
  }

  // max_requests - computed: false, optional: true, required: false
  private _maxRequests?: number; 
  public get maxRequests() {
    return this.getNumberAttribute('max_requests');
  }
  public set maxRequests(value: number) {
    this._maxRequests = value;
  }
  public resetMaxRequests() {
    this._maxRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsInput() {
    return this._maxRequests;
  }

  // max_retries - computed: false, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers_with_underscores_action DataK8SGlooSoloIoUpstreamV1Manifest#headers_with_underscores_action}
  */
  readonly headersWithUnderscoresAction?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#idle_timeout DataK8SGlooSoloIoUpstreamV1Manifest#idle_timeout}
  */
  readonly idleTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_headers_count DataK8SGlooSoloIoUpstreamV1Manifest#max_headers_count}
  */
  readonly maxHeadersCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_stream_duration DataK8SGlooSoloIoUpstreamV1Manifest#max_stream_duration}
  */
  readonly maxStreamDuration?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers_with_underscores_action: cdktf.stringToTerraform(struct!.headersWithUnderscoresAction),
    idle_timeout: cdktf.stringToTerraform(struct!.idleTimeout),
    max_headers_count: cdktf.numberToTerraform(struct!.maxHeadersCount),
    max_stream_duration: cdktf.stringToTerraform(struct!.maxStreamDuration),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers_with_underscores_action: {
      value: cdktf.stringToHclTerraform(struct!.headersWithUnderscoresAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    idle_timeout: {
      value: cdktf.stringToHclTerraform(struct!.idleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_headers_count: {
      value: cdktf.numberToHclTerraform(struct!.maxHeadersCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_stream_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxStreamDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headersWithUnderscoresAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersWithUnderscoresAction = this._headersWithUnderscoresAction;
    }
    if (this._idleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.idleTimeout = this._idleTimeout;
    }
    if (this._maxHeadersCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxHeadersCount = this._maxHeadersCount;
    }
    if (this._maxStreamDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxStreamDuration = this._maxStreamDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headersWithUnderscoresAction = undefined;
      this._idleTimeout = undefined;
      this._maxHeadersCount = undefined;
      this._maxStreamDuration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headersWithUnderscoresAction = value.headersWithUnderscoresAction;
      this._idleTimeout = value.idleTimeout;
      this._maxHeadersCount = value.maxHeadersCount;
      this._maxStreamDuration = value.maxStreamDuration;
    }
  }

  // headers_with_underscores_action - computed: false, optional: true, required: false
  private _headersWithUnderscoresAction?: string; 
  public get headersWithUnderscoresAction() {
    return this.getStringAttribute('headers_with_underscores_action');
  }
  public set headersWithUnderscoresAction(value: string) {
    this._headersWithUnderscoresAction = value;
  }
  public resetHeadersWithUnderscoresAction() {
    this._headersWithUnderscoresAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersWithUnderscoresActionInput() {
    return this._headersWithUnderscoresAction;
  }

  // idle_timeout - computed: false, optional: true, required: false
  private _idleTimeout?: string; 
  public get idleTimeout() {
    return this.getStringAttribute('idle_timeout');
  }
  public set idleTimeout(value: string) {
    this._idleTimeout = value;
  }
  public resetIdleTimeout() {
    this._idleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idleTimeoutInput() {
    return this._idleTimeout;
  }

  // max_headers_count - computed: false, optional: true, required: false
  private _maxHeadersCount?: number; 
  public get maxHeadersCount() {
    return this.getNumberAttribute('max_headers_count');
  }
  public set maxHeadersCount(value: number) {
    this._maxHeadersCount = value;
  }
  public resetMaxHeadersCount() {
    this._maxHeadersCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxHeadersCountInput() {
    return this._maxHeadersCount;
  }

  // max_stream_duration - computed: false, optional: true, required: false
  private _maxStreamDuration?: string; 
  public get maxStreamDuration() {
    return this.getStringAttribute('max_stream_duration');
  }
  public set maxStreamDuration(value: string) {
    this._maxStreamDuration = value;
  }
  public resetMaxStreamDuration() {
    this._maxStreamDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxStreamDurationInput() {
    return this._maxStreamDuration;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#enable_trailers DataK8SGlooSoloIoUpstreamV1Manifest#enable_trailers}
  */
  readonly enableTrailers?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#override_stream_error_on_invalid_http_message DataK8SGlooSoloIoUpstreamV1Manifest#override_stream_error_on_invalid_http_message}
  */
  readonly overrideStreamErrorOnInvalidHttpMessage?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#preserve_case_header_key_format DataK8SGlooSoloIoUpstreamV1Manifest#preserve_case_header_key_format}
  */
  readonly preserveCaseHeaderKeyFormat?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proper_case_header_key_format DataK8SGlooSoloIoUpstreamV1Manifest#proper_case_header_key_format}
  */
  readonly properCaseHeaderKeyFormat?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable_trailers: cdktf.booleanToTerraform(struct!.enableTrailers),
    override_stream_error_on_invalid_http_message: cdktf.booleanToTerraform(struct!.overrideStreamErrorOnInvalidHttpMessage),
    preserve_case_header_key_format: cdktf.booleanToTerraform(struct!.preserveCaseHeaderKeyFormat),
    proper_case_header_key_format: cdktf.booleanToTerraform(struct!.properCaseHeaderKeyFormat),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable_trailers: {
      value: cdktf.booleanToHclTerraform(struct!.enableTrailers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    override_stream_error_on_invalid_http_message: {
      value: cdktf.booleanToHclTerraform(struct!.overrideStreamErrorOnInvalidHttpMessage),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_case_header_key_format: {
      value: cdktf.booleanToHclTerraform(struct!.preserveCaseHeaderKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    proper_case_header_key_format: {
      value: cdktf.booleanToHclTerraform(struct!.properCaseHeaderKeyFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enableTrailers !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableTrailers = this._enableTrailers;
    }
    if (this._overrideStreamErrorOnInvalidHttpMessage !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideStreamErrorOnInvalidHttpMessage = this._overrideStreamErrorOnInvalidHttpMessage;
    }
    if (this._preserveCaseHeaderKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveCaseHeaderKeyFormat = this._preserveCaseHeaderKeyFormat;
    }
    if (this._properCaseHeaderKeyFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.properCaseHeaderKeyFormat = this._properCaseHeaderKeyFormat;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enableTrailers = undefined;
      this._overrideStreamErrorOnInvalidHttpMessage = undefined;
      this._preserveCaseHeaderKeyFormat = undefined;
      this._properCaseHeaderKeyFormat = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enableTrailers = value.enableTrailers;
      this._overrideStreamErrorOnInvalidHttpMessage = value.overrideStreamErrorOnInvalidHttpMessage;
      this._preserveCaseHeaderKeyFormat = value.preserveCaseHeaderKeyFormat;
      this._properCaseHeaderKeyFormat = value.properCaseHeaderKeyFormat;
    }
  }

  // enable_trailers - computed: false, optional: true, required: false
  private _enableTrailers?: boolean | cdktf.IResolvable; 
  public get enableTrailers() {
    return this.getBooleanAttribute('enable_trailers');
  }
  public set enableTrailers(value: boolean | cdktf.IResolvable) {
    this._enableTrailers = value;
  }
  public resetEnableTrailers() {
    this._enableTrailers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableTrailersInput() {
    return this._enableTrailers;
  }

  // override_stream_error_on_invalid_http_message - computed: false, optional: true, required: false
  private _overrideStreamErrorOnInvalidHttpMessage?: boolean | cdktf.IResolvable; 
  public get overrideStreamErrorOnInvalidHttpMessage() {
    return this.getBooleanAttribute('override_stream_error_on_invalid_http_message');
  }
  public set overrideStreamErrorOnInvalidHttpMessage(value: boolean | cdktf.IResolvable) {
    this._overrideStreamErrorOnInvalidHttpMessage = value;
  }
  public resetOverrideStreamErrorOnInvalidHttpMessage() {
    this._overrideStreamErrorOnInvalidHttpMessage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideStreamErrorOnInvalidHttpMessageInput() {
    return this._overrideStreamErrorOnInvalidHttpMessage;
  }

  // preserve_case_header_key_format - computed: false, optional: true, required: false
  private _preserveCaseHeaderKeyFormat?: boolean | cdktf.IResolvable; 
  public get preserveCaseHeaderKeyFormat() {
    return this.getBooleanAttribute('preserve_case_header_key_format');
  }
  public set preserveCaseHeaderKeyFormat(value: boolean | cdktf.IResolvable) {
    this._preserveCaseHeaderKeyFormat = value;
  }
  public resetPreserveCaseHeaderKeyFormat() {
    this._preserveCaseHeaderKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveCaseHeaderKeyFormatInput() {
    return this._preserveCaseHeaderKeyFormat;
  }

  // proper_case_header_key_format - computed: false, optional: true, required: false
  private _properCaseHeaderKeyFormat?: boolean | cdktf.IResolvable; 
  public get properCaseHeaderKeyFormat() {
    return this.getBooleanAttribute('proper_case_header_key_format');
  }
  public set properCaseHeaderKeyFormat(value: boolean | cdktf.IResolvable) {
    this._properCaseHeaderKeyFormat = value;
  }
  public resetProperCaseHeaderKeyFormat() {
    this._properCaseHeaderKeyFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get properCaseHeaderKeyFormatInput() {
    return this._properCaseHeaderKeyFormat;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#keepalive_interval DataK8SGlooSoloIoUpstreamV1Manifest#keepalive_interval}
  */
  readonly keepaliveInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#keepalive_probes DataK8SGlooSoloIoUpstreamV1Manifest#keepalive_probes}
  */
  readonly keepaliveProbes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#keepalive_time DataK8SGlooSoloIoUpstreamV1Manifest#keepalive_time}
  */
  readonly keepaliveTime?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepaliveToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keepalive_interval: cdktf.stringToTerraform(struct!.keepaliveInterval),
    keepalive_probes: cdktf.numberToTerraform(struct!.keepaliveProbes),
    keepalive_time: cdktf.stringToTerraform(struct!.keepaliveTime),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepaliveToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keepalive_interval: {
      value: cdktf.stringToHclTerraform(struct!.keepaliveInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keepalive_probes: {
      value: cdktf.numberToHclTerraform(struct!.keepaliveProbes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keepalive_time: {
      value: cdktf.stringToHclTerraform(struct!.keepaliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepaliveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keepaliveInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveInterval = this._keepaliveInterval;
    }
    if (this._keepaliveProbes !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveProbes = this._keepaliveProbes;
    }
    if (this._keepaliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepaliveTime = this._keepaliveTime;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keepaliveInterval = undefined;
      this._keepaliveProbes = undefined;
      this._keepaliveTime = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keepaliveInterval = value.keepaliveInterval;
      this._keepaliveProbes = value.keepaliveProbes;
      this._keepaliveTime = value.keepaliveTime;
    }
  }

  // keepalive_interval - computed: false, optional: true, required: false
  private _keepaliveInterval?: string; 
  public get keepaliveInterval() {
    return this.getStringAttribute('keepalive_interval');
  }
  public set keepaliveInterval(value: string) {
    this._keepaliveInterval = value;
  }
  public resetKeepaliveInterval() {
    this._keepaliveInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveIntervalInput() {
    return this._keepaliveInterval;
  }

  // keepalive_probes - computed: false, optional: true, required: false
  private _keepaliveProbes?: number; 
  public get keepaliveProbes() {
    return this.getNumberAttribute('keepalive_probes');
  }
  public set keepaliveProbes(value: number) {
    this._keepaliveProbes = value;
  }
  public resetKeepaliveProbes() {
    this._keepaliveProbes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveProbesInput() {
    return this._keepaliveProbes;
  }

  // keepalive_time - computed: false, optional: true, required: false
  private _keepaliveTime?: string; 
  public get keepaliveTime() {
    return this.getStringAttribute('keepalive_time');
  }
  public set keepaliveTime(value: string) {
    this._keepaliveTime = value;
  }
  public resetKeepaliveTime() {
    this._keepaliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepaliveTimeInput() {
    return this._keepaliveTime;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#common_http_protocol_options DataK8SGlooSoloIoUpstreamV1Manifest#common_http_protocol_options}
  */
  readonly commonHttpProtocolOptions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#connect_timeout DataK8SGlooSoloIoUpstreamV1Manifest#connect_timeout}
  */
  readonly connectTimeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#http1_protocol_options DataK8SGlooSoloIoUpstreamV1Manifest#http1_protocol_options}
  */
  readonly http1ProtocolOptions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_requests_per_connection DataK8SGlooSoloIoUpstreamV1Manifest#max_requests_per_connection}
  */
  readonly maxRequestsPerConnection?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#per_connection_buffer_limit_bytes DataK8SGlooSoloIoUpstreamV1Manifest#per_connection_buffer_limit_bytes}
  */
  readonly perConnectionBufferLimitBytes?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tcp_keepalive DataK8SGlooSoloIoUpstreamV1Manifest#tcp_keepalive}
  */
  readonly tcpKeepalive?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_http_protocol_options: dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptionsToTerraform(struct!.commonHttpProtocolOptions),
    connect_timeout: cdktf.stringToTerraform(struct!.connectTimeout),
    http1_protocol_options: dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptionsToTerraform(struct!.http1ProtocolOptions),
    max_requests_per_connection: cdktf.numberToTerraform(struct!.maxRequestsPerConnection),
    per_connection_buffer_limit_bytes: cdktf.numberToTerraform(struct!.perConnectionBufferLimitBytes),
    tcp_keepalive: dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepaliveToTerraform(struct!.tcpKeepalive),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_http_protocol_options: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptionsToHclTerraform(struct!.commonHttpProtocolOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions",
    },
    connect_timeout: {
      value: cdktf.stringToHclTerraform(struct!.connectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http1_protocol_options: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptionsToHclTerraform(struct!.http1ProtocolOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions",
    },
    max_requests_per_connection: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    per_connection_buffer_limit_bytes: {
      value: cdktf.numberToHclTerraform(struct!.perConnectionBufferLimitBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tcp_keepalive: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepaliveToHclTerraform(struct!.tcpKeepalive),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonHttpProtocolOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonHttpProtocolOptions = this._commonHttpProtocolOptions?.internalValue;
    }
    if (this._connectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTimeout = this._connectTimeout;
    }
    if (this._http1ProtocolOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http1ProtocolOptions = this._http1ProtocolOptions?.internalValue;
    }
    if (this._maxRequestsPerConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerConnection = this._maxRequestsPerConnection;
    }
    if (this._perConnectionBufferLimitBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.perConnectionBufferLimitBytes = this._perConnectionBufferLimitBytes;
    }
    if (this._tcpKeepalive?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpKeepalive = this._tcpKeepalive?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commonHttpProtocolOptions.internalValue = undefined;
      this._connectTimeout = undefined;
      this._http1ProtocolOptions.internalValue = undefined;
      this._maxRequestsPerConnection = undefined;
      this._perConnectionBufferLimitBytes = undefined;
      this._tcpKeepalive.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commonHttpProtocolOptions.internalValue = value.commonHttpProtocolOptions;
      this._connectTimeout = value.connectTimeout;
      this._http1ProtocolOptions.internalValue = value.http1ProtocolOptions;
      this._maxRequestsPerConnection = value.maxRequestsPerConnection;
      this._perConnectionBufferLimitBytes = value.perConnectionBufferLimitBytes;
      this._tcpKeepalive.internalValue = value.tcpKeepalive;
    }
  }

  // common_http_protocol_options - computed: false, optional: true, required: false
  private _commonHttpProtocolOptions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptionsOutputReference(this, "common_http_protocol_options");
  public get commonHttpProtocolOptions() {
    return this._commonHttpProtocolOptions;
  }
  public putCommonHttpProtocolOptions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigCommonHttpProtocolOptions) {
    this._commonHttpProtocolOptions.internalValue = value;
  }
  public resetCommonHttpProtocolOptions() {
    this._commonHttpProtocolOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonHttpProtocolOptionsInput() {
    return this._commonHttpProtocolOptions.internalValue;
  }

  // connect_timeout - computed: false, optional: true, required: false
  private _connectTimeout?: string; 
  public get connectTimeout() {
    return this.getStringAttribute('connect_timeout');
  }
  public set connectTimeout(value: string) {
    this._connectTimeout = value;
  }
  public resetConnectTimeout() {
    this._connectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTimeoutInput() {
    return this._connectTimeout;
  }

  // http1_protocol_options - computed: false, optional: true, required: false
  private _http1ProtocolOptions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptionsOutputReference(this, "http1_protocol_options");
  public get http1ProtocolOptions() {
    return this._http1ProtocolOptions;
  }
  public putHttp1ProtocolOptions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigHttp1ProtocolOptions) {
    this._http1ProtocolOptions.internalValue = value;
  }
  public resetHttp1ProtocolOptions() {
    this._http1ProtocolOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get http1ProtocolOptionsInput() {
    return this._http1ProtocolOptions.internalValue;
  }

  // max_requests_per_connection - computed: false, optional: true, required: false
  private _maxRequestsPerConnection?: number; 
  public get maxRequestsPerConnection() {
    return this.getNumberAttribute('max_requests_per_connection');
  }
  public set maxRequestsPerConnection(value: number) {
    this._maxRequestsPerConnection = value;
  }
  public resetMaxRequestsPerConnection() {
    this._maxRequestsPerConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerConnectionInput() {
    return this._maxRequestsPerConnection;
  }

  // per_connection_buffer_limit_bytes - computed: false, optional: true, required: false
  private _perConnectionBufferLimitBytes?: number; 
  public get perConnectionBufferLimitBytes() {
    return this.getNumberAttribute('per_connection_buffer_limit_bytes');
  }
  public set perConnectionBufferLimitBytes(value: number) {
    this._perConnectionBufferLimitBytes = value;
  }
  public resetPerConnectionBufferLimitBytes() {
    this._perConnectionBufferLimitBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perConnectionBufferLimitBytesInput() {
    return this._perConnectionBufferLimitBytes;
  }

  // tcp_keepalive - computed: false, optional: true, required: false
  private _tcpKeepalive = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepaliveOutputReference(this, "tcp_keepalive");
  public get tcpKeepalive() {
    return this._tcpKeepalive;
  }
  public putTcpKeepalive(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConnectionConfigTcpKeepalive) {
    this._tcpKeepalive.internalValue = value;
  }
  public resetTcpKeepalive() {
    this._tcpKeepalive.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpKeepaliveInput() {
    return this._tcpKeepalive.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#use_cache DataK8SGlooSoloIoUpstreamV1Manifest#use_cache}
  */
  readonly useCache?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    use_cache: cdktf.booleanToTerraform(struct!.useCache),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    use_cache: {
      value: cdktf.booleanToHclTerraform(struct!.useCache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._useCache !== undefined) {
      hasAnyValues = true;
      internalValueResult.useCache = this._useCache;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._useCache = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._useCache = value.useCache;
    }
  }

  // use_cache - computed: false, optional: true, required: false
  private _useCache?: boolean | cdktf.IResolvable; 
  public get useCache() {
    return this.getBooleanAttribute('use_cache');
  }
  public set useCache(value: boolean | cdktf.IResolvable) {
    this._useCache = value;
  }
  public resetUseCache() {
    this._useCache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useCacheInput() {
    return this._useCache;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#url DataK8SGlooSoloIoUpstreamV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpointToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpointToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpointOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#endpoint DataK8SGlooSoloIoUpstreamV1Manifest#endpoint}
  */
  readonly endpoint?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpointToTerraform(struct!.endpoint),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpointToHclTerraform(struct!.endpoint),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint.internalValue = value.endpoint;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpointOutputReference(this, "endpoint");
  public get endpoint() {
    return this._endpoint;
  }
  public putEndpoint(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlEndpoint) {
    this._endpoint.internalValue = value;
  }
  public resetEndpoint() {
    this._endpoint.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#function_names DataK8SGlooSoloIoUpstreamV1Manifest#function_names}
  */
  readonly functionNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#package_name DataK8SGlooSoloIoUpstreamV1Manifest#package_name}
  */
  readonly packageName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.functionNames),
    package_name: cdktf.stringToTerraform(struct!.packageName),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.functionNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    package_name: {
      value: cdktf.stringToHclTerraform(struct!.packageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._functionNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionNames = this._functionNames;
    }
    if (this._packageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.packageName = this._packageName;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._functionNames = undefined;
      this._packageName = undefined;
      this._serviceName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._functionNames = value.functionNames;
      this._packageName = value.packageName;
      this._serviceName = value.serviceName;
    }
  }

  // function_names - computed: false, optional: true, required: false
  private _functionNames?: string[]; 
  public get functionNames() {
    return this.getListAttribute('function_names');
  }
  public set functionNames(value: string[]) {
    this._functionNames = value;
  }
  public resetFunctionNames() {
    this._functionNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionNamesInput() {
    return this._functionNames;
  }

  // package_name - computed: false, optional: true, required: false
  private _packageName?: string; 
  public get packageName() {
    return this.getStringAttribute('package_name');
  }
  public set packageName(value: string) {
    this._packageName = value;
  }
  public resetPackageName() {
    this._packageName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packageNameInput() {
    return this._packageName;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#descriptors DataK8SGlooSoloIoUpstreamV1Manifest#descriptors}
  */
  readonly descriptors?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc_services DataK8SGlooSoloIoUpstreamV1Manifest#grpc_services}
  */
  readonly grpcServices?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptors: cdktf.stringToTerraform(struct!.descriptors),
    grpc_services: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesToTerraform, false)(struct!.grpcServices),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptors: {
      value: cdktf.stringToHclTerraform(struct!.descriptors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grpc_services: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesToHclTerraform, false)(struct!.grpcServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptors !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptors = this._descriptors;
    }
    if (this._grpcServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcServices = this._grpcServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptors = undefined;
      this._grpcServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptors = value.descriptors;
      this._grpcServices.internalValue = value.grpcServices;
    }
  }

  // descriptors - computed: false, optional: true, required: false
  private _descriptors?: string; 
  public get descriptors() {
    return this.getStringAttribute('descriptors');
  }
  public set descriptors(value: string) {
    this._descriptors = value;
  }
  public resetDescriptors() {
    this._descriptors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorsInput() {
    return this._descriptors;
  }

  // grpc_services - computed: false, optional: true, required: false
  private _grpcServices = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServicesList(this, "grpc_services", false);
  public get grpcServices() {
    return this._grpcServices;
  }
  public putGrpcServices(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcGrpcServices[] | cdktf.IResolvable) {
    this._grpcServices.internalValue = value;
  }
  public resetGrpcServices() {
    this._grpcServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServicesInput() {
    return this._grpcServices.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#add_whitespace DataK8SGlooSoloIoUpstreamV1Manifest#add_whitespace}
  */
  readonly addWhitespace?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_print_enums_as_ints DataK8SGlooSoloIoUpstreamV1Manifest#always_print_enums_as_ints}
  */
  readonly alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_print_primitive_fields DataK8SGlooSoloIoUpstreamV1Manifest#always_print_primitive_fields}
  */
  readonly alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#preserve_proto_field_names DataK8SGlooSoloIoUpstreamV1Manifest#preserve_proto_field_names}
  */
  readonly preserveProtoFieldNames?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_whitespace: cdktf.booleanToTerraform(struct!.addWhitespace),
    always_print_enums_as_ints: cdktf.booleanToTerraform(struct!.alwaysPrintEnumsAsInts),
    always_print_primitive_fields: cdktf.booleanToTerraform(struct!.alwaysPrintPrimitiveFields),
    preserve_proto_field_names: cdktf.booleanToTerraform(struct!.preserveProtoFieldNames),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_whitespace: {
      value: cdktf.booleanToHclTerraform(struct!.addWhitespace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_enums_as_ints: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintEnumsAsInts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_primitive_fields: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintPrimitiveFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_proto_field_names: {
      value: cdktf.booleanToHclTerraform(struct!.preserveProtoFieldNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addWhitespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.addWhitespace = this._addWhitespace;
    }
    if (this._alwaysPrintEnumsAsInts !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintEnumsAsInts = this._alwaysPrintEnumsAsInts;
    }
    if (this._alwaysPrintPrimitiveFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintPrimitiveFields = this._alwaysPrintPrimitiveFields;
    }
    if (this._preserveProtoFieldNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveProtoFieldNames = this._preserveProtoFieldNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addWhitespace = undefined;
      this._alwaysPrintEnumsAsInts = undefined;
      this._alwaysPrintPrimitiveFields = undefined;
      this._preserveProtoFieldNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addWhitespace = value.addWhitespace;
      this._alwaysPrintEnumsAsInts = value.alwaysPrintEnumsAsInts;
      this._alwaysPrintPrimitiveFields = value.alwaysPrintPrimitiveFields;
      this._preserveProtoFieldNames = value.preserveProtoFieldNames;
    }
  }

  // add_whitespace - computed: false, optional: true, required: false
  private _addWhitespace?: boolean | cdktf.IResolvable; 
  public get addWhitespace() {
    return this.getBooleanAttribute('add_whitespace');
  }
  public set addWhitespace(value: boolean | cdktf.IResolvable) {
    this._addWhitespace = value;
  }
  public resetAddWhitespace() {
    this._addWhitespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addWhitespaceInput() {
    return this._addWhitespace;
  }

  // always_print_enums_as_ints - computed: false, optional: true, required: false
  private _alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable; 
  public get alwaysPrintEnumsAsInts() {
    return this.getBooleanAttribute('always_print_enums_as_ints');
  }
  public set alwaysPrintEnumsAsInts(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintEnumsAsInts = value;
  }
  public resetAlwaysPrintEnumsAsInts() {
    this._alwaysPrintEnumsAsInts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintEnumsAsIntsInput() {
    return this._alwaysPrintEnumsAsInts;
  }

  // always_print_primitive_fields - computed: false, optional: true, required: false
  private _alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable; 
  public get alwaysPrintPrimitiveFields() {
    return this.getBooleanAttribute('always_print_primitive_fields');
  }
  public set alwaysPrintPrimitiveFields(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintPrimitiveFields = value;
  }
  public resetAlwaysPrintPrimitiveFields() {
    this._alwaysPrintPrimitiveFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintPrimitiveFieldsInput() {
    return this._alwaysPrintPrimitiveFields;
  }

  // preserve_proto_field_names - computed: false, optional: true, required: false
  private _preserveProtoFieldNames?: boolean | cdktf.IResolvable; 
  public get preserveProtoFieldNames() {
    return this.getBooleanAttribute('preserve_proto_field_names');
  }
  public set preserveProtoFieldNames(value: boolean | cdktf.IResolvable) {
    this._preserveProtoFieldNames = value;
  }
  public resetPreserveProtoFieldNames() {
    this._preserveProtoFieldNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveProtoFieldNamesInput() {
    return this._preserveProtoFieldNames;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#config_map_ref DataK8SGlooSoloIoUpstreamV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct!.configMapRef),
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._key = value.key;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auto_mapping DataK8SGlooSoloIoUpstreamV1Manifest#auto_mapping}
  */
  readonly autoMapping?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#convert_grpc_status DataK8SGlooSoloIoUpstreamV1Manifest#convert_grpc_status}
  */
  readonly convertGrpcStatus?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignore_unknown_query_parameters DataK8SGlooSoloIoUpstreamV1Manifest#ignore_unknown_query_parameters}
  */
  readonly ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignored_query_parameters DataK8SGlooSoloIoUpstreamV1Manifest#ignored_query_parameters}
  */
  readonly ignoredQueryParameters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#match_incoming_request_route DataK8SGlooSoloIoUpstreamV1Manifest#match_incoming_request_route}
  */
  readonly matchIncomingRequestRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#print_options DataK8SGlooSoloIoUpstreamV1Manifest#print_options}
  */
  readonly printOptions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor}
  */
  readonly protoDescriptor?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor_bin DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor_bin}
  */
  readonly protoDescriptorBin?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor_config_map DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor_config_map}
  */
  readonly protoDescriptorConfigMap?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#services DataK8SGlooSoloIoUpstreamV1Manifest#services}
  */
  readonly services?: string[];
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_mapping: cdktf.booleanToTerraform(struct!.autoMapping),
    convert_grpc_status: cdktf.booleanToTerraform(struct!.convertGrpcStatus),
    ignore_unknown_query_parameters: cdktf.booleanToTerraform(struct!.ignoreUnknownQueryParameters),
    ignored_query_parameters: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ignoredQueryParameters),
    match_incoming_request_route: cdktf.booleanToTerraform(struct!.matchIncomingRequestRoute),
    print_options: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptionsToTerraform(struct!.printOptions),
    proto_descriptor: cdktf.stringToTerraform(struct!.protoDescriptor),
    proto_descriptor_bin: cdktf.stringToTerraform(struct!.protoDescriptorBin),
    proto_descriptor_config_map: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct!.protoDescriptorConfigMap),
    services: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.services),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_mapping: {
      value: cdktf.booleanToHclTerraform(struct!.autoMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    convert_grpc_status: {
      value: cdktf.booleanToHclTerraform(struct!.convertGrpcStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_unknown_query_parameters: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreUnknownQueryParameters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignored_query_parameters: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ignoredQueryParameters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    match_incoming_request_route: {
      value: cdktf.booleanToHclTerraform(struct!.matchIncomingRequestRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    print_options: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptionsToHclTerraform(struct!.printOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions",
    },
    proto_descriptor: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_bin: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptorBin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_config_map: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct!.protoDescriptorConfigMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap",
    },
    services: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.services),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoMapping = this._autoMapping;
    }
    if (this._convertGrpcStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.convertGrpcStatus = this._convertGrpcStatus;
    }
    if (this._ignoreUnknownQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreUnknownQueryParameters = this._ignoreUnknownQueryParameters;
    }
    if (this._ignoredQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoredQueryParameters = this._ignoredQueryParameters;
    }
    if (this._matchIncomingRequestRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchIncomingRequestRoute = this._matchIncomingRequestRoute;
    }
    if (this._printOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.printOptions = this._printOptions?.internalValue;
    }
    if (this._protoDescriptor !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptor = this._protoDescriptor;
    }
    if (this._protoDescriptorBin !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorBin = this._protoDescriptorBin;
    }
    if (this._protoDescriptorConfigMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorConfigMap = this._protoDescriptorConfigMap?.internalValue;
    }
    if (this._services !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoMapping = undefined;
      this._convertGrpcStatus = undefined;
      this._ignoreUnknownQueryParameters = undefined;
      this._ignoredQueryParameters = undefined;
      this._matchIncomingRequestRoute = undefined;
      this._printOptions.internalValue = undefined;
      this._protoDescriptor = undefined;
      this._protoDescriptorBin = undefined;
      this._protoDescriptorConfigMap.internalValue = undefined;
      this._services = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoMapping = value.autoMapping;
      this._convertGrpcStatus = value.convertGrpcStatus;
      this._ignoreUnknownQueryParameters = value.ignoreUnknownQueryParameters;
      this._ignoredQueryParameters = value.ignoredQueryParameters;
      this._matchIncomingRequestRoute = value.matchIncomingRequestRoute;
      this._printOptions.internalValue = value.printOptions;
      this._protoDescriptor = value.protoDescriptor;
      this._protoDescriptorBin = value.protoDescriptorBin;
      this._protoDescriptorConfigMap.internalValue = value.protoDescriptorConfigMap;
      this._services = value.services;
    }
  }

  // auto_mapping - computed: false, optional: true, required: false
  private _autoMapping?: boolean | cdktf.IResolvable; 
  public get autoMapping() {
    return this.getBooleanAttribute('auto_mapping');
  }
  public set autoMapping(value: boolean | cdktf.IResolvable) {
    this._autoMapping = value;
  }
  public resetAutoMapping() {
    this._autoMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoMappingInput() {
    return this._autoMapping;
  }

  // convert_grpc_status - computed: false, optional: true, required: false
  private _convertGrpcStatus?: boolean | cdktf.IResolvable; 
  public get convertGrpcStatus() {
    return this.getBooleanAttribute('convert_grpc_status');
  }
  public set convertGrpcStatus(value: boolean | cdktf.IResolvable) {
    this._convertGrpcStatus = value;
  }
  public resetConvertGrpcStatus() {
    this._convertGrpcStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get convertGrpcStatusInput() {
    return this._convertGrpcStatus;
  }

  // ignore_unknown_query_parameters - computed: false, optional: true, required: false
  private _ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable; 
  public get ignoreUnknownQueryParameters() {
    return this.getBooleanAttribute('ignore_unknown_query_parameters');
  }
  public set ignoreUnknownQueryParameters(value: boolean | cdktf.IResolvable) {
    this._ignoreUnknownQueryParameters = value;
  }
  public resetIgnoreUnknownQueryParameters() {
    this._ignoreUnknownQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreUnknownQueryParametersInput() {
    return this._ignoreUnknownQueryParameters;
  }

  // ignored_query_parameters - computed: false, optional: true, required: false
  private _ignoredQueryParameters?: string[]; 
  public get ignoredQueryParameters() {
    return this.getListAttribute('ignored_query_parameters');
  }
  public set ignoredQueryParameters(value: string[]) {
    this._ignoredQueryParameters = value;
  }
  public resetIgnoredQueryParameters() {
    this._ignoredQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoredQueryParametersInput() {
    return this._ignoredQueryParameters;
  }

  // match_incoming_request_route - computed: false, optional: true, required: false
  private _matchIncomingRequestRoute?: boolean | cdktf.IResolvable; 
  public get matchIncomingRequestRoute() {
    return this.getBooleanAttribute('match_incoming_request_route');
  }
  public set matchIncomingRequestRoute(value: boolean | cdktf.IResolvable) {
    this._matchIncomingRequestRoute = value;
  }
  public resetMatchIncomingRequestRoute() {
    this._matchIncomingRequestRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchIncomingRequestRouteInput() {
    return this._matchIncomingRequestRoute;
  }

  // print_options - computed: false, optional: true, required: false
  private _printOptions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptionsOutputReference(this, "print_options");
  public get printOptions() {
    return this._printOptions;
  }
  public putPrintOptions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderPrintOptions) {
    this._printOptions.internalValue = value;
  }
  public resetPrintOptions() {
    this._printOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get printOptionsInput() {
    return this._printOptions.internalValue;
  }

  // proto_descriptor - computed: false, optional: true, required: false
  private _protoDescriptor?: string; 
  public get protoDescriptor() {
    return this.getStringAttribute('proto_descriptor');
  }
  public set protoDescriptor(value: string) {
    this._protoDescriptor = value;
  }
  public resetProtoDescriptor() {
    this._protoDescriptor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorInput() {
    return this._protoDescriptor;
  }

  // proto_descriptor_bin - computed: false, optional: true, required: false
  private _protoDescriptorBin?: string; 
  public get protoDescriptorBin() {
    return this.getStringAttribute('proto_descriptor_bin');
  }
  public set protoDescriptorBin(value: string) {
    this._protoDescriptorBin = value;
  }
  public resetProtoDescriptorBin() {
    this._protoDescriptorBin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorBinInput() {
    return this._protoDescriptorBin;
  }

  // proto_descriptor_config_map - computed: false, optional: true, required: false
  private _protoDescriptorConfigMap = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference(this, "proto_descriptor_config_map");
  public get protoDescriptorConfigMap() {
    return this._protoDescriptorConfigMap;
  }
  public putProtoDescriptorConfigMap(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap) {
    this._protoDescriptorConfigMap.internalValue = value;
  }
  public resetProtoDescriptorConfigMap() {
    this._protoDescriptorConfigMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorConfigMapInput() {
    return this._protoDescriptorConfigMap.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services?: string[]; 
  public get services() {
    return this.getListAttribute('services');
  }
  public set services(value: string[]) {
    this._services = value;
  }
  public resetServices() {
    this._services = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#url DataK8SGlooSoloIoUpstreamV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfoToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfoToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._url = value.url;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBodyToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBodyToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValueToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#json_to_proto DataK8SGlooSoloIoUpstreamV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#metadata_namespace DataK8SGlooSoloIoUpstreamV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#body DataK8SGlooSoloIoUpstreamV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#mode DataK8SGlooSoloIoUpstreamV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#regex DataK8SGlooSoloIoUpstreamV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#replacement_text DataK8SGlooSoloIoUpstreamV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#subgroup DataK8SGlooSoloIoUpstreamV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractorsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractorsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValueToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValueToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#override_empty DataK8SGlooSoloIoUpstreamV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tmpl DataK8SGlooSoloIoUpstreamV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#json_keys DataK8SGlooSoloIoUpstreamV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#advanced_templates DataK8SGlooSoloIoUpstreamV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#body DataK8SGlooSoloIoUpstreamV1Manifest#body}
  */
  readonly body?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#dynamic_metadata_values DataK8SGlooSoloIoUpstreamV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#escape_characters DataK8SGlooSoloIoUpstreamV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#extractors DataK8SGlooSoloIoUpstreamV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers DataK8SGlooSoloIoUpstreamV1Manifest#headers}
  */
  readonly headers?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers_to_append DataK8SGlooSoloIoUpstreamV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers_to_remove DataK8SGlooSoloIoUpstreamV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignore_error_on_parse DataK8SGlooSoloIoUpstreamV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#merge_extractors_to_body DataK8SGlooSoloIoUpstreamV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#merge_json_keys DataK8SGlooSoloIoUpstreamV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#parse_body_behavior DataK8SGlooSoloIoUpstreamV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#passthrough DataK8SGlooSoloIoUpstreamV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors",
    },
    headers: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#swagger_info DataK8SGlooSoloIoUpstreamV1Manifest#swagger_info}
  */
  readonly swaggerInfo?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#transformations DataK8SGlooSoloIoUpstreamV1Manifest#transformations}
  */
  readonly transformations?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    swagger_info: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfoToTerraform(struct!.swaggerInfo),
    transformations: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsToTerraform(struct!.transformations),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    swagger_info: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfoToHclTerraform(struct!.swaggerInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo",
    },
    transformations: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsToHclTerraform(struct!.transformations),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._swaggerInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.swaggerInfo = this._swaggerInfo?.internalValue;
    }
    if (this._transformations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformations = this._transformations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._swaggerInfo.internalValue = undefined;
      this._transformations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._swaggerInfo.internalValue = value.swaggerInfo;
      this._transformations.internalValue = value.transformations;
    }
  }

  // swagger_info - computed: false, optional: true, required: false
  private _swaggerInfo = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfoOutputReference(this, "swagger_info");
  public get swaggerInfo() {
    return this._swaggerInfo;
  }
  public putSwaggerInfo(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestSwaggerInfo) {
    this._swaggerInfo.internalValue = value;
  }
  public resetSwaggerInfo() {
    this._swaggerInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get swaggerInfoInput() {
    return this._swaggerInfo.internalValue;
  }

  // transformations - computed: false, optional: true, required: false
  private _transformations = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformationsOutputReference(this, "transformations");
  public get transformations() {
    return this._transformations;
  }
  public putTransformations(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestTransformations) {
    this._transformations.internalValue = value;
  }
  public resetTransformations() {
    this._transformations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationsInput() {
    return this._transformations.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#graphql DataK8SGlooSoloIoUpstreamV1Manifest#graphql}
  */
  readonly graphql?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc DataK8SGlooSoloIoUpstreamV1Manifest#grpc}
  */
  readonly grpc?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc_json_transcoder DataK8SGlooSoloIoUpstreamV1Manifest#grpc_json_transcoder}
  */
  readonly grpcJsonTranscoder?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#rest DataK8SGlooSoloIoUpstreamV1Manifest#rest}
  */
  readonly rest?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    graphql: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlToTerraform(struct!.graphql),
    grpc: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcToTerraform(struct!.grpc),
    grpc_json_transcoder: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderToTerraform(struct!.grpcJsonTranscoder),
    rest: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestToTerraform(struct!.rest),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    graphql: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlToHclTerraform(struct!.graphql),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql",
    },
    grpc: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcToHclTerraform(struct!.grpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc",
    },
    grpc_json_transcoder: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderToHclTerraform(struct!.grpcJsonTranscoder),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder",
    },
    rest: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestToHclTerraform(struct!.rest),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._graphql?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.graphql = this._graphql?.internalValue;
    }
    if (this._grpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpc = this._grpc?.internalValue;
    }
    if (this._grpcJsonTranscoder?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcJsonTranscoder = this._grpcJsonTranscoder?.internalValue;
    }
    if (this._rest?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rest = this._rest?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._graphql.internalValue = undefined;
      this._grpc.internalValue = undefined;
      this._grpcJsonTranscoder.internalValue = undefined;
      this._rest.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._graphql.internalValue = value.graphql;
      this._grpc.internalValue = value.grpc;
      this._grpcJsonTranscoder.internalValue = value.grpcJsonTranscoder;
      this._rest.internalValue = value.rest;
    }
  }

  // graphql - computed: false, optional: true, required: false
  private _graphql = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphqlOutputReference(this, "graphql");
  public get graphql() {
    return this._graphql;
  }
  public putGraphql(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGraphql) {
    this._graphql.internalValue = value;
  }
  public resetGraphql() {
    this._graphql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get graphqlInput() {
    return this._graphql.internalValue;
  }

  // grpc - computed: false, optional: true, required: false
  private _grpc = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcOutputReference(this, "grpc");
  public get grpc() {
    return this._grpc;
  }
  public putGrpc(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpc) {
    this._grpc.internalValue = value;
  }
  public resetGrpc() {
    this._grpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcInput() {
    return this._grpc.internalValue;
  }

  // grpc_json_transcoder - computed: false, optional: true, required: false
  private _grpcJsonTranscoder = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoderOutputReference(this, "grpc_json_transcoder");
  public get grpcJsonTranscoder() {
    return this._grpcJsonTranscoder;
  }
  public putGrpcJsonTranscoder(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecGrpcJsonTranscoder) {
    this._grpcJsonTranscoder.internalValue = value;
  }
  public resetGrpcJsonTranscoder() {
    this._grpcJsonTranscoder.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcJsonTranscoderInput() {
    return this._grpcJsonTranscoder.internalValue;
  }

  // rest - computed: false, optional: true, required: false
  private _rest = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRestOutputReference(this, "rest");
  public get rest() {
    return this._rest;
  }
  public putRest(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecRest) {
    this._rest.internalValue = value;
  }
  public resetRest() {
    this._rest.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restInput() {
    return this._rest.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecConsul {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#connect_enabled DataK8SGlooSoloIoUpstreamV1Manifest#connect_enabled}
  */
  readonly connectEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#consistency_mode DataK8SGlooSoloIoUpstreamV1Manifest#consistency_mode}
  */
  readonly consistencyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#data_centers DataK8SGlooSoloIoUpstreamV1Manifest#data_centers}
  */
  readonly dataCenters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#instance_blacklist_tags DataK8SGlooSoloIoUpstreamV1Manifest#instance_blacklist_tags}
  */
  readonly instanceBlacklistTags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#instance_tags DataK8SGlooSoloIoUpstreamV1Manifest#instance_tags}
  */
  readonly instanceTags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#query_options DataK8SGlooSoloIoUpstreamV1Manifest#query_options}
  */
  readonly queryOptions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_spec DataK8SGlooSoloIoUpstreamV1Manifest#service_spec}
  */
  readonly serviceSpec?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_tags DataK8SGlooSoloIoUpstreamV1Manifest#service_tags}
  */
  readonly serviceTags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#subset_tags DataK8SGlooSoloIoUpstreamV1Manifest#subset_tags}
  */
  readonly subsetTags?: string[];
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsul | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_enabled: cdktf.booleanToTerraform(struct!.connectEnabled),
    consistency_mode: cdktf.stringToTerraform(struct!.consistencyMode),
    data_centers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dataCenters),
    instance_blacklist_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.instanceBlacklistTags),
    instance_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.instanceTags),
    query_options: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptionsToTerraform(struct!.queryOptions),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
    service_spec: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecToTerraform(struct!.serviceSpec),
    service_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.serviceTags),
    subset_tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subsetTags),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsul | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.connectEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    consistency_mode: {
      value: cdktf.stringToHclTerraform(struct!.consistencyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    data_centers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dataCenters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    instance_blacklist_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.instanceBlacklistTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    instance_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.instanceTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    query_options: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptionsToHclTerraform(struct!.queryOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_spec: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecToHclTerraform(struct!.serviceSpec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec",
    },
    service_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.serviceTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subset_tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subsetTags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecConsul | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectEnabled = this._connectEnabled;
    }
    if (this._consistencyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.consistencyMode = this._consistencyMode;
    }
    if (this._dataCenters !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataCenters = this._dataCenters;
    }
    if (this._instanceBlacklistTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.instanceBlacklistTags = this._instanceBlacklistTags;
    }
    if (this._instanceTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.instanceTags = this._instanceTags;
    }
    if (this._queryOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryOptions = this._queryOptions?.internalValue;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    if (this._serviceSpec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceSpec = this._serviceSpec?.internalValue;
    }
    if (this._serviceTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceTags = this._serviceTags;
    }
    if (this._subsetTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsetTags = this._subsetTags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsul | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectEnabled = undefined;
      this._consistencyMode = undefined;
      this._dataCenters = undefined;
      this._instanceBlacklistTags = undefined;
      this._instanceTags = undefined;
      this._queryOptions.internalValue = undefined;
      this._serviceName = undefined;
      this._serviceSpec.internalValue = undefined;
      this._serviceTags = undefined;
      this._subsetTags = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectEnabled = value.connectEnabled;
      this._consistencyMode = value.consistencyMode;
      this._dataCenters = value.dataCenters;
      this._instanceBlacklistTags = value.instanceBlacklistTags;
      this._instanceTags = value.instanceTags;
      this._queryOptions.internalValue = value.queryOptions;
      this._serviceName = value.serviceName;
      this._serviceSpec.internalValue = value.serviceSpec;
      this._serviceTags = value.serviceTags;
      this._subsetTags = value.subsetTags;
    }
  }

  // connect_enabled - computed: false, optional: true, required: false
  private _connectEnabled?: boolean | cdktf.IResolvable; 
  public get connectEnabled() {
    return this.getBooleanAttribute('connect_enabled');
  }
  public set connectEnabled(value: boolean | cdktf.IResolvable) {
    this._connectEnabled = value;
  }
  public resetConnectEnabled() {
    this._connectEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectEnabledInput() {
    return this._connectEnabled;
  }

  // consistency_mode - computed: false, optional: true, required: false
  private _consistencyMode?: string; 
  public get consistencyMode() {
    return this.getStringAttribute('consistency_mode');
  }
  public set consistencyMode(value: string) {
    this._consistencyMode = value;
  }
  public resetConsistencyMode() {
    this._consistencyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consistencyModeInput() {
    return this._consistencyMode;
  }

  // data_centers - computed: false, optional: true, required: false
  private _dataCenters?: string[]; 
  public get dataCenters() {
    return this.getListAttribute('data_centers');
  }
  public set dataCenters(value: string[]) {
    this._dataCenters = value;
  }
  public resetDataCenters() {
    this._dataCenters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataCentersInput() {
    return this._dataCenters;
  }

  // instance_blacklist_tags - computed: false, optional: true, required: false
  private _instanceBlacklistTags?: string[]; 
  public get instanceBlacklistTags() {
    return this.getListAttribute('instance_blacklist_tags');
  }
  public set instanceBlacklistTags(value: string[]) {
    this._instanceBlacklistTags = value;
  }
  public resetInstanceBlacklistTags() {
    this._instanceBlacklistTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instanceBlacklistTagsInput() {
    return this._instanceBlacklistTags;
  }

  // instance_tags - computed: false, optional: true, required: false
  private _instanceTags?: string[]; 
  public get instanceTags() {
    return this.getListAttribute('instance_tags');
  }
  public set instanceTags(value: string[]) {
    this._instanceTags = value;
  }
  public resetInstanceTags() {
    this._instanceTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instanceTagsInput() {
    return this._instanceTags;
  }

  // query_options - computed: false, optional: true, required: false
  private _queryOptions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptionsOutputReference(this, "query_options");
  public get queryOptions() {
    return this._queryOptions;
  }
  public putQueryOptions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulQueryOptions) {
    this._queryOptions.internalValue = value;
  }
  public resetQueryOptions() {
    this._queryOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryOptionsInput() {
    return this._queryOptions.internalValue;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }

  // service_spec - computed: false, optional: true, required: false
  private _serviceSpec = new DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpecOutputReference(this, "service_spec");
  public get serviceSpec() {
    return this._serviceSpec;
  }
  public putServiceSpec(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecConsulServiceSpec) {
    this._serviceSpec.internalValue = value;
  }
  public resetServiceSpec() {
    this._serviceSpec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceSpecInput() {
    return this._serviceSpec.internalValue;
  }

  // service_tags - computed: false, optional: true, required: false
  private _serviceTags?: string[]; 
  public get serviceTags() {
    return this.getListAttribute('service_tags');
  }
  public set serviceTags(value: string[]) {
    this._serviceTags = value;
  }
  public resetServiceTags() {
    this._serviceTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceTagsInput() {
    return this._serviceTags;
  }

  // subset_tags - computed: false, optional: true, required: false
  private _subsetTags?: string[]; 
  public get subsetTags() {
    return this.getListAttribute('subset_tags');
  }
  public set subsetTags(value: string[]) {
    this._subsetTags = value;
  }
  public resetSubsetTags() {
    this._subsetTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsetTagsInput() {
    return this._subsetTags;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#labels DataK8SGlooSoloIoUpstreamV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadataToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadataToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecDiscoveryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labels = value.labels;
    }
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#overprovisioning_factor DataK8SGlooSoloIoUpstreamV1Manifest#overprovisioning_factor}
  */
  readonly overprovisioningFactor?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicyToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    overprovisioning_factor: cdktf.numberToTerraform(struct!.overprovisioningFactor),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicyToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    overprovisioning_factor: {
      value: cdktf.numberToHclTerraform(struct!.overprovisioningFactor),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overprovisioningFactor !== undefined) {
      hasAnyValues = true;
      internalValueResult.overprovisioningFactor = this._overprovisioningFactor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overprovisioningFactor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overprovisioningFactor = value.overprovisioningFactor;
    }
  }

  // overprovisioning_factor - computed: false, optional: true, required: false
  private _overprovisioningFactor?: number; 
  public get overprovisioningFactor() {
    return this.getNumberAttribute('overprovisioning_factor');
  }
  public set overprovisioningFactor(value: number) {
    this._overprovisioningFactor = value;
  }
  public resetOverprovisioningFactor() {
    this._overprovisioningFactor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overprovisioningFactorInput() {
    return this._overprovisioningFactor;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#hostname DataK8SGlooSoloIoUpstreamV1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#method DataK8SGlooSoloIoUpstreamV1Manifest#method}
  */
  readonly method?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#path DataK8SGlooSoloIoUpstreamV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port_value DataK8SGlooSoloIoUpstreamV1Manifest#port_value}
  */
  readonly portValue?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    method: cdktf.stringToTerraform(struct!.method),
    path: cdktf.stringToTerraform(struct!.path),
    port_value: cdktf.numberToTerraform(struct!.portValue),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_value: {
      value: cdktf.numberToHclTerraform(struct!.portValue),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._portValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.portValue = this._portValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._method = undefined;
      this._path = undefined;
      this._portValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._method = value.method;
      this._path = value.path;
      this._portValue = value.portValue;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // port_value - computed: false, optional: true, required: false
  private _portValue?: number; 
  public get portValue() {
    return this.getNumberAttribute('port_value');
  }
  public set portValue(value: number) {
    this._portValue = value;
  }
  public resetPortValue() {
    this._portValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portValueInput() {
    return this._portValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#cipher_suites DataK8SGlooSoloIoUpstreamV1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ecdh_curves DataK8SGlooSoloIoUpstreamV1Manifest#ecdh_curves}
  */
  readonly ecdhCurves?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#maximum_protocol_version DataK8SGlooSoloIoUpstreamV1Manifest#maximum_protocol_version}
  */
  readonly maximumProtocolVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#minimum_protocol_version DataK8SGlooSoloIoUpstreamV1Manifest#minimum_protocol_version}
  */
  readonly minimumProtocolVersion?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParametersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    ecdh_curves: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ecdhCurves),
    maximum_protocol_version: cdktf.stringToTerraform(struct!.maximumProtocolVersion),
    minimum_protocol_version: cdktf.stringToTerraform(struct!.minimumProtocolVersion),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParametersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ecdh_curves: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ecdhCurves),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    maximum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maximumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    minimum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minimumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._ecdhCurves !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecdhCurves = this._ecdhCurves;
    }
    if (this._maximumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumProtocolVersion = this._maximumProtocolVersion;
    }
    if (this._minimumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumProtocolVersion = this._minimumProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cipherSuites = undefined;
      this._ecdhCurves = undefined;
      this._maximumProtocolVersion = undefined;
      this._minimumProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cipherSuites = value.cipherSuites;
      this._ecdhCurves = value.ecdhCurves;
      this._maximumProtocolVersion = value.maximumProtocolVersion;
      this._minimumProtocolVersion = value.minimumProtocolVersion;
    }
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // ecdh_curves - computed: false, optional: true, required: false
  private _ecdhCurves?: string[]; 
  public get ecdhCurves() {
    return this.getListAttribute('ecdh_curves');
  }
  public set ecdhCurves(value: string[]) {
    this._ecdhCurves = value;
  }
  public resetEcdhCurves() {
    this._ecdhCurves = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecdhCurvesInput() {
    return this._ecdhCurves;
  }

  // maximum_protocol_version - computed: false, optional: true, required: false
  private _maximumProtocolVersion?: string; 
  public get maximumProtocolVersion() {
    return this.getStringAttribute('maximum_protocol_version');
  }
  public set maximumProtocolVersion(value: string) {
    this._maximumProtocolVersion = value;
  }
  public resetMaximumProtocolVersion() {
    this._maximumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumProtocolVersionInput() {
    return this._maximumProtocolVersion;
  }

  // minimum_protocol_version - computed: false, optional: true, required: false
  private _minimumProtocolVersion?: string; 
  public get minimumProtocolVersion() {
    return this.getStringAttribute('minimum_protocol_version');
  }
  public set minimumProtocolVersion(value: string) {
    this._minimumProtocolVersion = value;
  }
  public resetMinimumProtocolVersion() {
    this._minimumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumProtocolVersionInput() {
    return this._minimumProtocolVersion;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#token_file_name DataK8SGlooSoloIoUpstreamV1Manifest#token_file_name}
  */
  readonly tokenFileName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    token_file_name: cdktf.stringToTerraform(struct!.tokenFileName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_file_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._tokenFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenFileName = this._tokenFileName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._tokenFileName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._tokenFileName = value.tokenFileName;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // token_file_name - computed: false, optional: true, required: false
  private _tokenFileName?: string; 
  public get tokenFileName() {
    return this.getStringAttribute('token_file_name');
  }
  public set tokenFileName(value: string) {
    this._tokenFileName = value;
  }
  public resetTokenFileName() {
    this._tokenFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenFileNameInput() {
    return this._tokenFileName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#file_credential_source DataK8SGlooSoloIoUpstreamV1Manifest#file_credential_source}
  */
  readonly fileCredentialSource?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file_credential_source: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct!.fileCredentialSource),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file_credential_source: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct!.fileCredentialSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fileCredentialSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileCredentialSource = this._fileCredentialSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = value.fileCredentialSource;
    }
  }

  // file_credential_source - computed: false, optional: true, required: false
  private _fileCredentialSource = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSourceOutputReference(this, "file_credential_source");
  public get fileCredentialSource() {
    return this._fileCredentialSource;
  }
  public putFileCredentialSource(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsFileCredentialSource) {
    this._fileCredentialSource.internalValue = value;
  }
  public resetFileCredentialSource() {
    this._fileCredentialSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileCredentialSourceInput() {
    return this._fileCredentialSource.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#call_credentials DataK8SGlooSoloIoUpstreamV1Manifest#call_credentials}
  */
  readonly callCredentials?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#certificates_secret_name DataK8SGlooSoloIoUpstreamV1Manifest#certificates_secret_name}
  */
  readonly certificatesSecretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#cluster_name DataK8SGlooSoloIoUpstreamV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#target_uri DataK8SGlooSoloIoUpstreamV1Manifest#target_uri}
  */
  readonly targetUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#validation_context_name DataK8SGlooSoloIoUpstreamV1Manifest#validation_context_name}
  */
  readonly validationContextName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    call_credentials: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsToTerraform(struct!.callCredentials),
    certificates_secret_name: cdktf.stringToTerraform(struct!.certificatesSecretName),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
    validation_context_name: cdktf.stringToTerraform(struct!.validationContextName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    call_credentials: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsToHclTerraform(struct!.callCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials",
    },
    certificates_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.certificatesSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validation_context_name: {
      value: cdktf.stringToHclTerraform(struct!.validationContextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._callCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.callCredentials = this._callCredentials?.internalValue;
    }
    if (this._certificatesSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesSecretName = this._certificatesSecretName;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    if (this._validationContextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationContextName = this._validationContextName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = undefined;
      this._certificatesSecretName = undefined;
      this._clusterName = undefined;
      this._targetUri = undefined;
      this._validationContextName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = value.callCredentials;
      this._certificatesSecretName = value.certificatesSecretName;
      this._clusterName = value.clusterName;
      this._targetUri = value.targetUri;
      this._validationContextName = value.validationContextName;
    }
  }

  // call_credentials - computed: false, optional: true, required: false
  private _callCredentials = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentialsOutputReference(this, "call_credentials");
  public get callCredentials() {
    return this._callCredentials;
  }
  public putCallCredentials(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsCallCredentials) {
    this._callCredentials.internalValue = value;
  }
  public resetCallCredentials() {
    this._callCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callCredentialsInput() {
    return this._callCredentials.internalValue;
  }

  // certificates_secret_name - computed: false, optional: true, required: false
  private _certificatesSecretName?: string; 
  public get certificatesSecretName() {
    return this.getStringAttribute('certificates_secret_name');
  }
  public set certificatesSecretName(value: string) {
    this._certificatesSecretName = value;
  }
  public resetCertificatesSecretName() {
    this._certificatesSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesSecretNameInput() {
    return this._certificatesSecretName;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }

  // validation_context_name - computed: false, optional: true, required: false
  private _validationContextName?: string; 
  public get validationContextName() {
    return this.getStringAttribute('validation_context_name');
  }
  public set validationContextName(value: string) {
    this._validationContextName = value;
  }
  public resetValidationContextName() {
    this._validationContextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationContextNameInput() {
    return this._validationContextName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ocsp_staple DataK8SGlooSoloIoUpstreamV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#root_ca DataK8SGlooSoloIoUpstreamV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tls_cert DataK8SGlooSoloIoUpstreamV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tls_key DataK8SGlooSoloIoUpstreamV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFilesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFilesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#allow_renegotiation DataK8SGlooSoloIoUpstreamV1Manifest#allow_renegotiation}
  */
  readonly allowRenegotiation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#alpn_protocols DataK8SGlooSoloIoUpstreamV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#one_way_tls DataK8SGlooSoloIoUpstreamV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#parameters DataK8SGlooSoloIoUpstreamV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#sds DataK8SGlooSoloIoUpstreamV1Manifest#sds}
  */
  readonly sds?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#sni DataK8SGlooSoloIoUpstreamV1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ssl_files DataK8SGlooSoloIoUpstreamV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#verify_subject_alt_name DataK8SGlooSoloIoUpstreamV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_renegotiation: cdktf.booleanToTerraform(struct!.allowRenegotiation),
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRefToTerraform(struct!.secretRef),
    sni: cdktf.stringToTerraform(struct!.sni),
    ssl_files: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFilesToTerraform(struct!.sslFiles),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_renegotiation: {
      value: cdktf.booleanToHclTerraform(struct!.allowRenegotiation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters",
    },
    sds: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_files: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowRenegotiation !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRenegotiation = this._allowRenegotiation;
    }
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowRenegotiation = undefined;
      this._alpnProtocols = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sni = undefined;
      this._sslFiles.internalValue = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowRenegotiation = value.allowRenegotiation;
      this._alpnProtocols = value.alpnProtocols;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sni = value.sni;
      this._sslFiles.internalValue = value.sslFiles;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // allow_renegotiation - computed: false, optional: true, required: false
  private _allowRenegotiation?: boolean | cdktf.IResolvable; 
  public get allowRenegotiation() {
    return this.getBooleanAttribute('allow_renegotiation');
  }
  public set allowRenegotiation(value: boolean | cdktf.IResolvable) {
    this._allowRenegotiation = value;
  }
  public resetAllowRenegotiation() {
    this._allowRenegotiation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRenegotiationInput() {
    return this._allowRenegotiation;
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#address DataK8SGlooSoloIoUpstreamV1Manifest#address}
  */
  readonly address?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#health_check_config DataK8SGlooSoloIoUpstreamV1Manifest#health_check_config}
  */
  readonly healthCheckConfig?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#load_balancing_weight DataK8SGlooSoloIoUpstreamV1Manifest#load_balancing_weight}
  */
  readonly loadBalancingWeight?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#metadata DataK8SGlooSoloIoUpstreamV1Manifest#metadata}
  */
  readonly metadata?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#port DataK8SGlooSoloIoUpstreamV1Manifest#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#upstream_ssl_config DataK8SGlooSoloIoUpstreamV1Manifest#upstream_ssl_config}
  */
  readonly upstreamSslConfig?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    address: cdktf.stringToTerraform(struct!.address),
    health_check_config: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfigToTerraform(struct!.healthCheckConfig),
    load_balancing_weight: cdktf.numberToTerraform(struct!.loadBalancingWeight),
    metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.metadata),
    port: cdktf.numberToTerraform(struct!.port),
    upstream_ssl_config: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigToTerraform(struct!.upstreamSslConfig),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    address: {
      value: cdktf.stringToHclTerraform(struct!.address),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    health_check_config: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfigToHclTerraform(struct!.healthCheckConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig",
    },
    load_balancing_weight: {
      value: cdktf.numberToHclTerraform(struct!.loadBalancingWeight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.metadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    upstream_ssl_config: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigToHclTerraform(struct!.upstreamSslConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._address !== undefined) {
      hasAnyValues = true;
      internalValueResult.address = this._address;
    }
    if (this._healthCheckConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheckConfig = this._healthCheckConfig?.internalValue;
    }
    if (this._loadBalancingWeight !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancingWeight = this._loadBalancingWeight;
    }
    if (this._metadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._upstreamSslConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamSslConfig = this._upstreamSslConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._address = undefined;
      this._healthCheckConfig.internalValue = undefined;
      this._loadBalancingWeight = undefined;
      this._metadata = undefined;
      this._port = undefined;
      this._upstreamSslConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._address = value.address;
      this._healthCheckConfig.internalValue = value.healthCheckConfig;
      this._loadBalancingWeight = value.loadBalancingWeight;
      this._metadata = value.metadata;
      this._port = value.port;
      this._upstreamSslConfig.internalValue = value.upstreamSslConfig;
    }
  }

  // address - computed: false, optional: true, required: false
  private _address?: string; 
  public get address() {
    return this.getStringAttribute('address');
  }
  public set address(value: string) {
    this._address = value;
  }
  public resetAddress() {
    this._address = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addressInput() {
    return this._address;
  }

  // health_check_config - computed: false, optional: true, required: false
  private _healthCheckConfig = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfigOutputReference(this, "health_check_config");
  public get healthCheckConfig() {
    return this._healthCheckConfig;
  }
  public putHealthCheckConfig(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsHealthCheckConfig) {
    this._healthCheckConfig.internalValue = value;
  }
  public resetHealthCheckConfig() {
    this._healthCheckConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckConfigInput() {
    return this._healthCheckConfig.internalValue;
  }

  // load_balancing_weight - computed: false, optional: true, required: false
  private _loadBalancingWeight?: number; 
  public get loadBalancingWeight() {
    return this.getNumberAttribute('load_balancing_weight');
  }
  public set loadBalancingWeight(value: number) {
    this._loadBalancingWeight = value;
  }
  public resetLoadBalancingWeight() {
    this._loadBalancingWeight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancingWeightInput() {
    return this._loadBalancingWeight;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata?: { [key: string]: string }; 
  public get metadata() {
    return this.getStringMapAttribute('metadata');
  }
  public set metadata(value: { [key: string]: string }) {
    this._metadata = value;
  }
  public resetMetadata() {
    this._metadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // upstream_ssl_config - computed: false, optional: true, required: false
  private _upstreamSslConfig = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfigOutputReference(this, "upstream_ssl_config");
  public get upstreamSslConfig() {
    return this._upstreamSslConfig;
  }
  public putUpstreamSslConfig(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsUpstreamSslConfig) {
    this._upstreamSslConfig.internalValue = value;
  }
  public resetUpstreamSslConfig() {
    this._upstreamSslConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamSslConfigInput() {
    return this._upstreamSslConfig.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#region DataK8SGlooSoloIoUpstreamV1Manifest#region}
  */
  readonly region?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#sub_zone DataK8SGlooSoloIoUpstreamV1Manifest#sub_zone}
  */
  readonly subZone?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#zone DataK8SGlooSoloIoUpstreamV1Manifest#zone}
  */
  readonly zone?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocalityToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    region: cdktf.stringToTerraform(struct!.region),
    sub_zone: cdktf.stringToTerraform(struct!.subZone),
    zone: cdktf.stringToTerraform(struct!.zone),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocalityToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sub_zone: {
      value: cdktf.stringToHclTerraform(struct!.subZone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    zone: {
      value: cdktf.stringToHclTerraform(struct!.zone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocalityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._subZone !== undefined) {
      hasAnyValues = true;
      internalValueResult.subZone = this._subZone;
    }
    if (this._zone !== undefined) {
      hasAnyValues = true;
      internalValueResult.zone = this._zone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._region = undefined;
      this._subZone = undefined;
      this._zone = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._region = value.region;
      this._subZone = value.subZone;
      this._zone = value.zone;
    }
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // sub_zone - computed: false, optional: true, required: false
  private _subZone?: string; 
  public get subZone() {
    return this.getStringAttribute('sub_zone');
  }
  public set subZone(value: string) {
    this._subZone = value;
  }
  public resetSubZone() {
    this._subZone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subZoneInput() {
    return this._subZone;
  }

  // zone - computed: false, optional: true, required: false
  private _zone?: string; 
  public get zone() {
    return this.getStringAttribute('zone');
  }
  public set zone(value: string) {
    this._zone = value;
  }
  public resetZone() {
    this._zone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zoneInput() {
    return this._zone;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#lb_endpoints DataK8SGlooSoloIoUpstreamV1Manifest#lb_endpoints}
  */
  readonly lbEndpoints?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#load_balancing_weight DataK8SGlooSoloIoUpstreamV1Manifest#load_balancing_weight}
  */
  readonly loadBalancingWeight?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#locality DataK8SGlooSoloIoUpstreamV1Manifest#locality}
  */
  readonly locality?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    lb_endpoints: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsToTerraform, false)(struct!.lbEndpoints),
    load_balancing_weight: cdktf.numberToTerraform(struct!.loadBalancingWeight),
    locality: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocalityToTerraform(struct!.locality),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    lb_endpoints: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsToHclTerraform, false)(struct!.lbEndpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsList",
    },
    load_balancing_weight: {
      value: cdktf.numberToHclTerraform(struct!.loadBalancingWeight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    locality: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocalityToHclTerraform(struct!.locality),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._lbEndpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lbEndpoints = this._lbEndpoints?.internalValue;
    }
    if (this._loadBalancingWeight !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancingWeight = this._loadBalancingWeight;
    }
    if (this._locality?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.locality = this._locality?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._lbEndpoints.internalValue = undefined;
      this._loadBalancingWeight = undefined;
      this._locality.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._lbEndpoints.internalValue = value.lbEndpoints;
      this._loadBalancingWeight = value.loadBalancingWeight;
      this._locality.internalValue = value.locality;
    }
  }

  // lb_endpoints - computed: false, optional: true, required: false
  private _lbEndpoints = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpointsList(this, "lb_endpoints", false);
  public get lbEndpoints() {
    return this._lbEndpoints;
  }
  public putLbEndpoints(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLbEndpoints[] | cdktf.IResolvable) {
    this._lbEndpoints.internalValue = value;
  }
  public resetLbEndpoints() {
    this._lbEndpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lbEndpointsInput() {
    return this._lbEndpoints.internalValue;
  }

  // load_balancing_weight - computed: false, optional: true, required: false
  private _loadBalancingWeight?: number; 
  public get loadBalancingWeight() {
    return this.getNumberAttribute('load_balancing_weight');
  }
  public set loadBalancingWeight(value: number) {
    this._loadBalancingWeight = value;
  }
  public resetLoadBalancingWeight() {
    this._loadBalancingWeight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancingWeightInput() {
    return this._loadBalancingWeight;
  }

  // locality - computed: false, optional: true, required: false
  private _locality = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocalityOutputReference(this, "locality");
  public get locality() {
    return this._locality;
  }
  public putLocality(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsLocality) {
    this._locality.internalValue = value;
  }
  public resetLocality() {
    this._locality.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localityInput() {
    return this._locality.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#locality_endpoints DataK8SGlooSoloIoUpstreamV1Manifest#locality_endpoints}
  */
  readonly localityEndpoints?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    locality_endpoints: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsToTerraform, false)(struct!.localityEndpoints),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    locality_endpoints: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsToHclTerraform, false)(struct!.localityEndpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localityEndpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localityEndpoints = this._localityEndpoints?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localityEndpoints.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localityEndpoints.internalValue = value.localityEndpoints;
    }
  }

  // locality_endpoints - computed: false, optional: true, required: false
  private _localityEndpoints = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpointsList(this, "locality_endpoints", false);
  public get localityEndpoints() {
    return this._localityEndpoints;
  }
  public putLocalityEndpoints(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesLocalityEndpoints[] | cdktf.IResolvable) {
    this._localityEndpoints.internalValue = value;
  }
  public resetLocalityEndpoints() {
    this._localityEndpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localityEndpointsInput() {
    return this._localityEndpoints.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecFailover {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#policy DataK8SGlooSoloIoUpstreamV1Manifest#policy}
  */
  readonly policy?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#prioritized_localities DataK8SGlooSoloIoUpstreamV1Manifest#prioritized_localities}
  */
  readonly prioritizedLocalities?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailover | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    policy: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicyToTerraform(struct!.policy),
    prioritized_localities: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesToTerraform, false)(struct!.prioritizedLocalities),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailover | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    policy: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicyToHclTerraform(struct!.policy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy",
    },
    prioritized_localities: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesToHclTerraform, false)(struct!.prioritizedLocalities),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecFailover | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._policy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy?.internalValue;
    }
    if (this._prioritizedLocalities?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prioritizedLocalities = this._prioritizedLocalities?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailover | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._policy.internalValue = undefined;
      this._prioritizedLocalities.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._policy.internalValue = value.policy;
      this._prioritizedLocalities.internalValue = value.prioritizedLocalities;
    }
  }

  // policy - computed: false, optional: true, required: false
  private _policy = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicyOutputReference(this, "policy");
  public get policy() {
    return this._policy;
  }
  public putPolicy(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPolicy) {
    this._policy.internalValue = value;
  }
  public resetPolicy() {
    this._policy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy.internalValue;
  }

  // prioritized_localities - computed: false, optional: true, required: false
  private _prioritizedLocalities = new DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalitiesList(this, "prioritized_localities", false);
  public get prioritizedLocalities() {
    return this._prioritizedLocalities;
  }
  public putPrioritizedLocalities(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecFailoverPrioritizedLocalities[] | cdktf.IResolvable) {
    this._prioritizedLocalities.internalValue = value;
  }
  public resetPrioritizedLocalities() {
    this._prioritizedLocalities.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prioritizedLocalitiesInput() {
    return this._prioritizedLocalities.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecGcp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#audience DataK8SGlooSoloIoUpstreamV1Manifest#audience}
  */
  readonly audience?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecGcpToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecGcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audience: cdktf.stringToTerraform(struct!.audience),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecGcpToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecGcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audience: {
      value: cdktf.stringToHclTerraform(struct!.audience),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecGcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecGcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audience !== undefined) {
      hasAnyValues = true;
      internalValueResult.audience = this._audience;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecGcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audience = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audience = value.audience;
      this._host = value.host;
    }
  }

  // audience - computed: false, optional: true, required: false
  private _audience?: string; 
  public get audience() {
    return this.getStringAttribute('audience');
  }
  public set audience(value: string) {
    this._audience = value;
  }
  public resetAudience() {
    this._audience = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audienceInput() {
    return this._audience;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#config DataK8SGlooSoloIoUpstreamV1Manifest#config}
  */
  readonly config?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#typed_config DataK8SGlooSoloIoUpstreamV1Manifest#typed_config}
  */
  readonly typedConfig?: { [key: string]: string };
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheckToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.config),
    name: cdktf.stringToTerraform(struct!.name),
    typed_config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.typedConfig),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheckToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.config),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    typed_config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.typedConfig),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._typedConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.typedConfig = this._typedConfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._config = undefined;
      this._name = undefined;
      this._typedConfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._config = value.config;
      this._name = value.name;
      this._typedConfig = value.typedConfig;
    }
  }

  // config - computed: false, optional: true, required: false
  private _config?: { [key: string]: string }; 
  public get config() {
    return this.getStringMapAttribute('config');
  }
  public set config(value: { [key: string]: string }) {
    this._config = value;
  }
  public resetConfig() {
    this._config = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // typed_config - computed: false, optional: true, required: false
  private _typedConfig?: { [key: string]: string }; 
  public get typedConfig() {
    return this.getStringMapAttribute('typed_config');
  }
  public set typedConfig(value: { [key: string]: string }) {
    this._typedConfig = value;
  }
  public resetTypedConfig() {
    this._typedConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typedConfigInput() {
    return this._typedConfig;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#append DataK8SGlooSoloIoUpstreamV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header_secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#header_secret_ref}
  */
  readonly headerSecretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderToTerraform(struct!.header),
    header_secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRefToTerraform(struct!.headerSecretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader",
    },
    header_secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRefToHclTerraform(struct!.headerSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    if (this._headerSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerSecretRef = this._headerSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
      this._headerSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
      this._headerSecretRef.internalValue = value.headerSecretRef;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }

  // header_secret_ref - computed: false, optional: true, required: false
  private _headerSecretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRefOutputReference(this, "header_secret_ref");
  public get headerSecretRef() {
    return this._headerSecretRef;
  }
  public putHeaderSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataHeaderSecretRef) {
    this._headerSecretRef.internalValue = value;
  }
  public resetHeaderSecretRef() {
    this._headerSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerSecretRefInput() {
    return this._headerSecretRef.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#authority DataK8SGlooSoloIoUpstreamV1Manifest#authority}
  */
  readonly authority?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#initial_metadata DataK8SGlooSoloIoUpstreamV1Manifest#initial_metadata}
  */
  readonly initialMetadata?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
    initial_metadata: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataToTerraform, false)(struct!.initialMetadata),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_metadata: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataToHclTerraform, false)(struct!.initialMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataList",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    if (this._initialMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialMetadata = this._initialMetadata?.internalValue;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
      this._initialMetadata.internalValue = undefined;
      this._serviceName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
      this._initialMetadata.internalValue = value.initialMetadata;
      this._serviceName = value.serviceName;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }

  // initial_metadata - computed: false, optional: true, required: false
  private _initialMetadata = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadataList(this, "initial_metadata", false);
  public get initialMetadata() {
    return this._initialMetadata;
  }
  public putInitialMetadata(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckInitialMetadata[] | cdktf.IResolvable) {
    this._initialMetadata.internalValue = value;
  }
  public resetInitialMetadata() {
    this._initialMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialMetadataInput() {
    return this._initialMetadata.internalValue;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#end DataK8SGlooSoloIoUpstreamV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#start DataK8SGlooSoloIoUpstreamV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#append DataK8SGlooSoloIoUpstreamV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header_secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#header_secret_ref}
  */
  readonly headerSecretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderToTerraform(struct!.header),
    header_secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRefToTerraform(struct!.headerSecretRef),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader",
    },
    header_secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRefToHclTerraform(struct!.headerSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    if (this._headerSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerSecretRef = this._headerSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
      this._headerSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
      this._headerSecretRef.internalValue = value.headerSecretRef;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }

  // header_secret_ref - computed: false, optional: true, required: false
  private _headerSecretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRefOutputReference(this, "header_secret_ref");
  public get headerSecretRef() {
    return this._headerSecretRef;
  }
  public putHeaderSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddHeaderSecretRef) {
    this._headerSecretRef.internalValue = value;
  }
  public resetHeaderSecretRef() {
    this._headerSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerSecretRefInput() {
    return this._headerSecretRef.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#path DataK8SGlooSoloIoUpstreamV1Manifest#path}
  */
  readonly path?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path.internalValue = value.path;
    }
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#body DataK8SGlooSoloIoUpstreamV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignore_error_on_parse DataK8SGlooSoloIoUpstreamV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#json_key DataK8SGlooSoloIoUpstreamV1Manifest#json_key}
  */
  readonly jsonKey?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#regex DataK8SGlooSoloIoUpstreamV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    json_key: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyToTerraform(struct!.jsonKey),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    json_key: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyToHclTerraform(struct!.jsonKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._jsonKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKey = this._jsonKey?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._ignoreErrorOnParse = undefined;
      this._jsonKey.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._jsonKey.internalValue = value.jsonKey;
      this._regex = value.regex;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // json_key - computed: false, optional: true, required: false
  private _jsonKey = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKeyOutputReference(this, "json_key");
  public get jsonKey() {
    return this._jsonKey;
  }
  public putJsonKey(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchJsonKey) {
    this._jsonKey.internalValue = value;
  }
  public resetJsonKey() {
    this._jsonKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeyInput() {
    return this._jsonKey.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#match_health DataK8SGlooSoloIoUpstreamV1Manifest#match_health}
  */
  readonly matchHealth?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#response_match DataK8SGlooSoloIoUpstreamV1Manifest#response_match}
  */
  readonly responseMatch?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_health: cdktf.stringToTerraform(struct!.matchHealth),
    response_match: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchToTerraform(struct!.responseMatch),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_health: {
      value: cdktf.stringToHclTerraform(struct!.matchHealth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_match: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchToHclTerraform(struct!.responseMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchHealth !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchHealth = this._matchHealth;
    }
    if (this._responseMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseMatch = this._responseMatch?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchHealth = undefined;
      this._responseMatch.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchHealth = value.matchHealth;
      this._responseMatch.internalValue = value.responseMatch;
    }
  }

  // match_health - computed: false, optional: true, required: false
  private _matchHealth?: string; 
  public get matchHealth() {
    return this.getStringAttribute('match_health');
  }
  public set matchHealth(value: string) {
    this._matchHealth = value;
  }
  public resetMatchHealth() {
    this._matchHealth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchHealthInput() {
    return this._matchHealth;
  }

  // response_match - computed: false, optional: true, required: false
  private _responseMatch = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatchOutputReference(this, "response_match");
  public get responseMatch() {
    return this._responseMatch;
  }
  public putResponseMatch(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersResponseMatch) {
    this._responseMatch.internalValue = value;
  }
  public resetResponseMatch() {
    this._responseMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseMatchInput() {
    return this._responseMatch.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#no_match_health DataK8SGlooSoloIoUpstreamV1Manifest#no_match_health}
  */
  readonly noMatchHealth?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#response_matchers DataK8SGlooSoloIoUpstreamV1Manifest#response_matchers}
  */
  readonly responseMatchers?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    no_match_health: cdktf.stringToTerraform(struct!.noMatchHealth),
    response_matchers: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersToTerraform, false)(struct!.responseMatchers),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    no_match_health: {
      value: cdktf.stringToHclTerraform(struct!.noMatchHealth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_matchers: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersToHclTerraform, false)(struct!.responseMatchers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._noMatchHealth !== undefined) {
      hasAnyValues = true;
      internalValueResult.noMatchHealth = this._noMatchHealth;
    }
    if (this._responseMatchers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseMatchers = this._responseMatchers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._noMatchHealth = undefined;
      this._responseMatchers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._noMatchHealth = value.noMatchHealth;
      this._responseMatchers.internalValue = value.responseMatchers;
    }
  }

  // no_match_health - computed: false, optional: true, required: false
  private _noMatchHealth?: string; 
  public get noMatchHealth() {
    return this.getStringAttribute('no_match_health');
  }
  public set noMatchHealth(value: string) {
    this._noMatchHealth = value;
  }
  public resetNoMatchHealth() {
    this._noMatchHealth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noMatchHealthInput() {
    return this._noMatchHealth;
  }

  // response_matchers - computed: false, optional: true, required: false
  private _responseMatchers = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchersList(this, "response_matchers", false);
  public get responseMatchers() {
    return this._responseMatchers;
  }
  public putResponseMatchers(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsResponseMatchers[] | cdktf.IResolvable) {
    this._responseMatchers.internalValue = value;
  }
  public resetResponseMatchers() {
    this._responseMatchers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseMatchersInput() {
    return this._responseMatchers.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#expected_statuses DataK8SGlooSoloIoUpstreamV1Manifest#expected_statuses}
  */
  readonly expectedStatuses?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#host DataK8SGlooSoloIoUpstreamV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#method DataK8SGlooSoloIoUpstreamV1Manifest#method}
  */
  readonly method?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#path DataK8SGlooSoloIoUpstreamV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#request_headers_to_add DataK8SGlooSoloIoUpstreamV1Manifest#request_headers_to_add}
  */
  readonly requestHeadersToAdd?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#request_headers_to_remove DataK8SGlooSoloIoUpstreamV1Manifest#request_headers_to_remove}
  */
  readonly requestHeadersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#response_assertions DataK8SGlooSoloIoUpstreamV1Manifest#response_assertions}
  */
  readonly responseAssertions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#use_http2 DataK8SGlooSoloIoUpstreamV1Manifest#use_http2}
  */
  readonly useHttp2?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expected_statuses: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesToTerraform, false)(struct!.expectedStatuses),
    host: cdktf.stringToTerraform(struct!.host),
    method: cdktf.stringToTerraform(struct!.method),
    path: cdktf.stringToTerraform(struct!.path),
    request_headers_to_add: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddToTerraform, false)(struct!.requestHeadersToAdd),
    request_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestHeadersToRemove),
    response_assertions: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsToTerraform(struct!.responseAssertions),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
    use_http2: cdktf.booleanToTerraform(struct!.useHttp2),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expected_statuses: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesToHclTerraform, false)(struct!.expectedStatuses),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesList",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddToHclTerraform, false)(struct!.requestHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddList",
    },
    request_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_assertions: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsToHclTerraform(struct!.responseAssertions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_http2: {
      value: cdktf.booleanToHclTerraform(struct!.useHttp2),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expectedStatuses?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectedStatuses = this._expectedStatuses?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._requestHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToAdd = this._requestHeadersToAdd?.internalValue;
    }
    if (this._requestHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToRemove = this._requestHeadersToRemove;
    }
    if (this._responseAssertions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseAssertions = this._responseAssertions?.internalValue;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    if (this._useHttp2 !== undefined) {
      hasAnyValues = true;
      internalValueResult.useHttp2 = this._useHttp2;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expectedStatuses.internalValue = undefined;
      this._host = undefined;
      this._method = undefined;
      this._path = undefined;
      this._requestHeadersToAdd.internalValue = undefined;
      this._requestHeadersToRemove = undefined;
      this._responseAssertions.internalValue = undefined;
      this._serviceName = undefined;
      this._useHttp2 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expectedStatuses.internalValue = value.expectedStatuses;
      this._host = value.host;
      this._method = value.method;
      this._path = value.path;
      this._requestHeadersToAdd.internalValue = value.requestHeadersToAdd;
      this._requestHeadersToRemove = value.requestHeadersToRemove;
      this._responseAssertions.internalValue = value.responseAssertions;
      this._serviceName = value.serviceName;
      this._useHttp2 = value.useHttp2;
    }
  }

  // expected_statuses - computed: false, optional: true, required: false
  private _expectedStatuses = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatusesList(this, "expected_statuses", false);
  public get expectedStatuses() {
    return this._expectedStatuses;
  }
  public putExpectedStatuses(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckExpectedStatuses[] | cdktf.IResolvable) {
    this._expectedStatuses.internalValue = value;
  }
  public resetExpectedStatuses() {
    this._expectedStatuses.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectedStatusesInput() {
    return this._expectedStatuses.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // request_headers_to_add - computed: false, optional: true, required: false
  private _requestHeadersToAdd = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAddList(this, "request_headers_to_add", false);
  public get requestHeadersToAdd() {
    return this._requestHeadersToAdd;
  }
  public putRequestHeadersToAdd(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckRequestHeadersToAdd[] | cdktf.IResolvable) {
    this._requestHeadersToAdd.internalValue = value;
  }
  public resetRequestHeadersToAdd() {
    this._requestHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToAddInput() {
    return this._requestHeadersToAdd.internalValue;
  }

  // request_headers_to_remove - computed: false, optional: true, required: false
  private _requestHeadersToRemove?: string[]; 
  public get requestHeadersToRemove() {
    return this.getListAttribute('request_headers_to_remove');
  }
  public set requestHeadersToRemove(value: string[]) {
    this._requestHeadersToRemove = value;
  }
  public resetRequestHeadersToRemove() {
    this._requestHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToRemoveInput() {
    return this._requestHeadersToRemove;
  }

  // response_assertions - computed: false, optional: true, required: false
  private _responseAssertions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertionsOutputReference(this, "response_assertions");
  public get responseAssertions() {
    return this._responseAssertions;
  }
  public putResponseAssertions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckResponseAssertions) {
    this._responseAssertions.internalValue = value;
  }
  public resetResponseAssertions() {
    this._responseAssertions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseAssertionsInput() {
    return this._responseAssertions.internalValue;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }

  // use_http2 - computed: false, optional: true, required: false
  private _useHttp2?: boolean | cdktf.IResolvable; 
  public get useHttp2() {
    return this.getBooleanAttribute('use_http2');
  }
  public set useHttp2(value: boolean | cdktf.IResolvable) {
    this._useHttp2 = value;
  }
  public resetUseHttp2() {
    this._useHttp2 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useHttp2Input() {
    return this._useHttp2;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSendToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSendToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#receive DataK8SGlooSoloIoUpstreamV1Manifest#receive}
  */
  readonly receive?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#send DataK8SGlooSoloIoUpstreamV1Manifest#send}
  */
  readonly send?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    receive: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveToTerraform, false)(struct!.receive),
    send: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSendToTerraform(struct!.send),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    receive: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveToHclTerraform, false)(struct!.receive),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveList",
    },
    send: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSendToHclTerraform(struct!.send),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._receive?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.receive = this._receive?.internalValue;
    }
    if (this._send?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.send = this._send?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._receive.internalValue = undefined;
      this._send.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._receive.internalValue = value.receive;
      this._send.internalValue = value.send;
    }
  }

  // receive - computed: false, optional: true, required: false
  private _receive = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceiveList(this, "receive", false);
  public get receive() {
    return this._receive;
  }
  public putReceive(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckReceive[] | cdktf.IResolvable) {
    this._receive.internalValue = value;
  }
  public resetReceive() {
    this._receive.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get receiveInput() {
    return this._receive.internalValue;
  }

  // send - computed: false, optional: true, required: false
  private _send = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSendOutputReference(this, "send");
  public get send() {
    return this._send;
  }
  public putSend(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckSend) {
    this._send.internalValue = value;
  }
  public resetSend() {
    this._send.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendInput() {
    return this._send.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_log_health_check_failures DataK8SGlooSoloIoUpstreamV1Manifest#always_log_health_check_failures}
  */
  readonly alwaysLogHealthCheckFailures?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#custom_health_check DataK8SGlooSoloIoUpstreamV1Manifest#custom_health_check}
  */
  readonly customHealthCheck?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#event_log_path DataK8SGlooSoloIoUpstreamV1Manifest#event_log_path}
  */
  readonly eventLogPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc_health_check DataK8SGlooSoloIoUpstreamV1Manifest#grpc_health_check}
  */
  readonly grpcHealthCheck?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#healthy_edge_interval DataK8SGlooSoloIoUpstreamV1Manifest#healthy_edge_interval}
  */
  readonly healthyEdgeInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#healthy_threshold DataK8SGlooSoloIoUpstreamV1Manifest#healthy_threshold}
  */
  readonly healthyThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#http_health_check DataK8SGlooSoloIoUpstreamV1Manifest#http_health_check}
  */
  readonly httpHealthCheck?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#initial_jitter DataK8SGlooSoloIoUpstreamV1Manifest#initial_jitter}
  */
  readonly initialJitter?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#interval DataK8SGlooSoloIoUpstreamV1Manifest#interval}
  */
  readonly interval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#interval_jitter DataK8SGlooSoloIoUpstreamV1Manifest#interval_jitter}
  */
  readonly intervalJitter?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#interval_jitter_percent DataK8SGlooSoloIoUpstreamV1Manifest#interval_jitter_percent}
  */
  readonly intervalJitterPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#no_traffic_interval DataK8SGlooSoloIoUpstreamV1Manifest#no_traffic_interval}
  */
  readonly noTrafficInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#reuse_connection DataK8SGlooSoloIoUpstreamV1Manifest#reuse_connection}
  */
  readonly reuseConnection?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tcp_health_check DataK8SGlooSoloIoUpstreamV1Manifest#tcp_health_check}
  */
  readonly tcpHealthCheck?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#timeout DataK8SGlooSoloIoUpstreamV1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#unhealthy_edge_interval DataK8SGlooSoloIoUpstreamV1Manifest#unhealthy_edge_interval}
  */
  readonly unhealthyEdgeInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#unhealthy_interval DataK8SGlooSoloIoUpstreamV1Manifest#unhealthy_interval}
  */
  readonly unhealthyInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#unhealthy_threshold DataK8SGlooSoloIoUpstreamV1Manifest#unhealthy_threshold}
  */
  readonly unhealthyThreshold?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    always_log_health_check_failures: cdktf.booleanToTerraform(struct!.alwaysLogHealthCheckFailures),
    custom_health_check: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheckToTerraform(struct!.customHealthCheck),
    event_log_path: cdktf.stringToTerraform(struct!.eventLogPath),
    grpc_health_check: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckToTerraform(struct!.grpcHealthCheck),
    healthy_edge_interval: cdktf.stringToTerraform(struct!.healthyEdgeInterval),
    healthy_threshold: cdktf.numberToTerraform(struct!.healthyThreshold),
    http_health_check: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckToTerraform(struct!.httpHealthCheck),
    initial_jitter: cdktf.stringToTerraform(struct!.initialJitter),
    interval: cdktf.stringToTerraform(struct!.interval),
    interval_jitter: cdktf.stringToTerraform(struct!.intervalJitter),
    interval_jitter_percent: cdktf.numberToTerraform(struct!.intervalJitterPercent),
    no_traffic_interval: cdktf.stringToTerraform(struct!.noTrafficInterval),
    reuse_connection: cdktf.booleanToTerraform(struct!.reuseConnection),
    tcp_health_check: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckToTerraform(struct!.tcpHealthCheck),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    unhealthy_edge_interval: cdktf.stringToTerraform(struct!.unhealthyEdgeInterval),
    unhealthy_interval: cdktf.stringToTerraform(struct!.unhealthyInterval),
    unhealthy_threshold: cdktf.numberToTerraform(struct!.unhealthyThreshold),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    always_log_health_check_failures: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysLogHealthCheckFailures),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    custom_health_check: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheckToHclTerraform(struct!.customHealthCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck",
    },
    event_log_path: {
      value: cdktf.stringToHclTerraform(struct!.eventLogPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grpc_health_check: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckToHclTerraform(struct!.grpcHealthCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck",
    },
    healthy_edge_interval: {
      value: cdktf.stringToHclTerraform(struct!.healthyEdgeInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthy_threshold: {
      value: cdktf.numberToHclTerraform(struct!.healthyThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_health_check: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckToHclTerraform(struct!.httpHealthCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck",
    },
    initial_jitter: {
      value: cdktf.stringToHclTerraform(struct!.initialJitter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval_jitter: {
      value: cdktf.stringToHclTerraform(struct!.intervalJitter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval_jitter_percent: {
      value: cdktf.numberToHclTerraform(struct!.intervalJitterPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    no_traffic_interval: {
      value: cdktf.stringToHclTerraform(struct!.noTrafficInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reuse_connection: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp_health_check: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckToHclTerraform(struct!.tcpHealthCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unhealthy_edge_interval: {
      value: cdktf.stringToHclTerraform(struct!.unhealthyEdgeInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unhealthy_interval: {
      value: cdktf.stringToHclTerraform(struct!.unhealthyInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unhealthy_threshold: {
      value: cdktf.numberToHclTerraform(struct!.unhealthyThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._alwaysLogHealthCheckFailures !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysLogHealthCheckFailures = this._alwaysLogHealthCheckFailures;
    }
    if (this._customHealthCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHealthCheck = this._customHealthCheck?.internalValue;
    }
    if (this._eventLogPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventLogPath = this._eventLogPath;
    }
    if (this._grpcHealthCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcHealthCheck = this._grpcHealthCheck?.internalValue;
    }
    if (this._healthyEdgeInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthyEdgeInterval = this._healthyEdgeInterval;
    }
    if (this._healthyThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthyThreshold = this._healthyThreshold;
    }
    if (this._httpHealthCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpHealthCheck = this._httpHealthCheck?.internalValue;
    }
    if (this._initialJitter !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialJitter = this._initialJitter;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._intervalJitter !== undefined) {
      hasAnyValues = true;
      internalValueResult.intervalJitter = this._intervalJitter;
    }
    if (this._intervalJitterPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.intervalJitterPercent = this._intervalJitterPercent;
    }
    if (this._noTrafficInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.noTrafficInterval = this._noTrafficInterval;
    }
    if (this._reuseConnection !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnection = this._reuseConnection;
    }
    if (this._tcpHealthCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpHealthCheck = this._tcpHealthCheck?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._unhealthyEdgeInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.unhealthyEdgeInterval = this._unhealthyEdgeInterval;
    }
    if (this._unhealthyInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.unhealthyInterval = this._unhealthyInterval;
    }
    if (this._unhealthyThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.unhealthyThreshold = this._unhealthyThreshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._alwaysLogHealthCheckFailures = undefined;
      this._customHealthCheck.internalValue = undefined;
      this._eventLogPath = undefined;
      this._grpcHealthCheck.internalValue = undefined;
      this._healthyEdgeInterval = undefined;
      this._healthyThreshold = undefined;
      this._httpHealthCheck.internalValue = undefined;
      this._initialJitter = undefined;
      this._interval = undefined;
      this._intervalJitter = undefined;
      this._intervalJitterPercent = undefined;
      this._noTrafficInterval = undefined;
      this._reuseConnection = undefined;
      this._tcpHealthCheck.internalValue = undefined;
      this._timeout = undefined;
      this._unhealthyEdgeInterval = undefined;
      this._unhealthyInterval = undefined;
      this._unhealthyThreshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._alwaysLogHealthCheckFailures = value.alwaysLogHealthCheckFailures;
      this._customHealthCheck.internalValue = value.customHealthCheck;
      this._eventLogPath = value.eventLogPath;
      this._grpcHealthCheck.internalValue = value.grpcHealthCheck;
      this._healthyEdgeInterval = value.healthyEdgeInterval;
      this._healthyThreshold = value.healthyThreshold;
      this._httpHealthCheck.internalValue = value.httpHealthCheck;
      this._initialJitter = value.initialJitter;
      this._interval = value.interval;
      this._intervalJitter = value.intervalJitter;
      this._intervalJitterPercent = value.intervalJitterPercent;
      this._noTrafficInterval = value.noTrafficInterval;
      this._reuseConnection = value.reuseConnection;
      this._tcpHealthCheck.internalValue = value.tcpHealthCheck;
      this._timeout = value.timeout;
      this._unhealthyEdgeInterval = value.unhealthyEdgeInterval;
      this._unhealthyInterval = value.unhealthyInterval;
      this._unhealthyThreshold = value.unhealthyThreshold;
    }
  }

  // always_log_health_check_failures - computed: false, optional: true, required: false
  private _alwaysLogHealthCheckFailures?: boolean | cdktf.IResolvable; 
  public get alwaysLogHealthCheckFailures() {
    return this.getBooleanAttribute('always_log_health_check_failures');
  }
  public set alwaysLogHealthCheckFailures(value: boolean | cdktf.IResolvable) {
    this._alwaysLogHealthCheckFailures = value;
  }
  public resetAlwaysLogHealthCheckFailures() {
    this._alwaysLogHealthCheckFailures = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysLogHealthCheckFailuresInput() {
    return this._alwaysLogHealthCheckFailures;
  }

  // custom_health_check - computed: false, optional: true, required: false
  private _customHealthCheck = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheckOutputReference(this, "custom_health_check");
  public get customHealthCheck() {
    return this._customHealthCheck;
  }
  public putCustomHealthCheck(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksCustomHealthCheck) {
    this._customHealthCheck.internalValue = value;
  }
  public resetCustomHealthCheck() {
    this._customHealthCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHealthCheckInput() {
    return this._customHealthCheck.internalValue;
  }

  // event_log_path - computed: false, optional: true, required: false
  private _eventLogPath?: string; 
  public get eventLogPath() {
    return this.getStringAttribute('event_log_path');
  }
  public set eventLogPath(value: string) {
    this._eventLogPath = value;
  }
  public resetEventLogPath() {
    this._eventLogPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventLogPathInput() {
    return this._eventLogPath;
  }

  // grpc_health_check - computed: false, optional: true, required: false
  private _grpcHealthCheck = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheckOutputReference(this, "grpc_health_check");
  public get grpcHealthCheck() {
    return this._grpcHealthCheck;
  }
  public putGrpcHealthCheck(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksGrpcHealthCheck) {
    this._grpcHealthCheck.internalValue = value;
  }
  public resetGrpcHealthCheck() {
    this._grpcHealthCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcHealthCheckInput() {
    return this._grpcHealthCheck.internalValue;
  }

  // healthy_edge_interval - computed: false, optional: true, required: false
  private _healthyEdgeInterval?: string; 
  public get healthyEdgeInterval() {
    return this.getStringAttribute('healthy_edge_interval');
  }
  public set healthyEdgeInterval(value: string) {
    this._healthyEdgeInterval = value;
  }
  public resetHealthyEdgeInterval() {
    this._healthyEdgeInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthyEdgeIntervalInput() {
    return this._healthyEdgeInterval;
  }

  // healthy_threshold - computed: false, optional: true, required: false
  private _healthyThreshold?: number; 
  public get healthyThreshold() {
    return this.getNumberAttribute('healthy_threshold');
  }
  public set healthyThreshold(value: number) {
    this._healthyThreshold = value;
  }
  public resetHealthyThreshold() {
    this._healthyThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthyThresholdInput() {
    return this._healthyThreshold;
  }

  // http_health_check - computed: false, optional: true, required: false
  private _httpHealthCheck = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheckOutputReference(this, "http_health_check");
  public get httpHealthCheck() {
    return this._httpHealthCheck;
  }
  public putHttpHealthCheck(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksHttpHealthCheck) {
    this._httpHealthCheck.internalValue = value;
  }
  public resetHttpHealthCheck() {
    this._httpHealthCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpHealthCheckInput() {
    return this._httpHealthCheck.internalValue;
  }

  // initial_jitter - computed: false, optional: true, required: false
  private _initialJitter?: string; 
  public get initialJitter() {
    return this.getStringAttribute('initial_jitter');
  }
  public set initialJitter(value: string) {
    this._initialJitter = value;
  }
  public resetInitialJitter() {
    this._initialJitter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialJitterInput() {
    return this._initialJitter;
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // interval_jitter - computed: false, optional: true, required: false
  private _intervalJitter?: string; 
  public get intervalJitter() {
    return this.getStringAttribute('interval_jitter');
  }
  public set intervalJitter(value: string) {
    this._intervalJitter = value;
  }
  public resetIntervalJitter() {
    this._intervalJitter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalJitterInput() {
    return this._intervalJitter;
  }

  // interval_jitter_percent - computed: false, optional: true, required: false
  private _intervalJitterPercent?: number; 
  public get intervalJitterPercent() {
    return this.getNumberAttribute('interval_jitter_percent');
  }
  public set intervalJitterPercent(value: number) {
    this._intervalJitterPercent = value;
  }
  public resetIntervalJitterPercent() {
    this._intervalJitterPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalJitterPercentInput() {
    return this._intervalJitterPercent;
  }

  // no_traffic_interval - computed: false, optional: true, required: false
  private _noTrafficInterval?: string; 
  public get noTrafficInterval() {
    return this.getStringAttribute('no_traffic_interval');
  }
  public set noTrafficInterval(value: string) {
    this._noTrafficInterval = value;
  }
  public resetNoTrafficInterval() {
    this._noTrafficInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noTrafficIntervalInput() {
    return this._noTrafficInterval;
  }

  // reuse_connection - computed: false, optional: true, required: false
  private _reuseConnection?: boolean | cdktf.IResolvable; 
  public get reuseConnection() {
    return this.getBooleanAttribute('reuse_connection');
  }
  public set reuseConnection(value: boolean | cdktf.IResolvable) {
    this._reuseConnection = value;
  }
  public resetReuseConnection() {
    this._reuseConnection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionInput() {
    return this._reuseConnection;
  }

  // tcp_health_check - computed: false, optional: true, required: false
  private _tcpHealthCheck = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheckOutputReference(this, "tcp_health_check");
  public get tcpHealthCheck() {
    return this._tcpHealthCheck;
  }
  public putTcpHealthCheck(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksTcpHealthCheck) {
    this._tcpHealthCheck.internalValue = value;
  }
  public resetTcpHealthCheck() {
    this._tcpHealthCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpHealthCheckInput() {
    return this._tcpHealthCheck.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // unhealthy_edge_interval - computed: false, optional: true, required: false
  private _unhealthyEdgeInterval?: string; 
  public get unhealthyEdgeInterval() {
    return this.getStringAttribute('unhealthy_edge_interval');
  }
  public set unhealthyEdgeInterval(value: string) {
    this._unhealthyEdgeInterval = value;
  }
  public resetUnhealthyEdgeInterval() {
    this._unhealthyEdgeInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unhealthyEdgeIntervalInput() {
    return this._unhealthyEdgeInterval;
  }

  // unhealthy_interval - computed: false, optional: true, required: false
  private _unhealthyInterval?: string; 
  public get unhealthyInterval() {
    return this.getStringAttribute('unhealthy_interval');
  }
  public set unhealthyInterval(value: string) {
    this._unhealthyInterval = value;
  }
  public resetUnhealthyInterval() {
    this._unhealthyInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unhealthyIntervalInput() {
    return this._unhealthyInterval;
  }

  // unhealthy_threshold - computed: false, optional: true, required: false
  private _unhealthyThreshold?: number; 
  public get unhealthyThreshold() {
    return this.getNumberAttribute('unhealthy_threshold');
  }
  public set unhealthyThreshold(value: number) {
    this._unhealthyThreshold = value;
  }
  public resetUnhealthyThreshold() {
    this._unhealthyThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unhealthyThresholdInput() {
    return this._unhealthyThreshold;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecks[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHealthChecksOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeadersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeadersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeadersOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#cipher_suites DataK8SGlooSoloIoUpstreamV1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ecdh_curves DataK8SGlooSoloIoUpstreamV1Manifest#ecdh_curves}
  */
  readonly ecdhCurves?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#maximum_protocol_version DataK8SGlooSoloIoUpstreamV1Manifest#maximum_protocol_version}
  */
  readonly maximumProtocolVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#minimum_protocol_version DataK8SGlooSoloIoUpstreamV1Manifest#minimum_protocol_version}
  */
  readonly minimumProtocolVersion?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParametersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    ecdh_curves: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ecdhCurves),
    maximum_protocol_version: cdktf.stringToTerraform(struct!.maximumProtocolVersion),
    minimum_protocol_version: cdktf.stringToTerraform(struct!.minimumProtocolVersion),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParametersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ecdh_curves: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ecdhCurves),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    maximum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maximumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    minimum_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minimumProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._ecdhCurves !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecdhCurves = this._ecdhCurves;
    }
    if (this._maximumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumProtocolVersion = this._maximumProtocolVersion;
    }
    if (this._minimumProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumProtocolVersion = this._minimumProtocolVersion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cipherSuites = undefined;
      this._ecdhCurves = undefined;
      this._maximumProtocolVersion = undefined;
      this._minimumProtocolVersion = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cipherSuites = value.cipherSuites;
      this._ecdhCurves = value.ecdhCurves;
      this._maximumProtocolVersion = value.maximumProtocolVersion;
      this._minimumProtocolVersion = value.minimumProtocolVersion;
    }
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // ecdh_curves - computed: false, optional: true, required: false
  private _ecdhCurves?: string[]; 
  public get ecdhCurves() {
    return this.getListAttribute('ecdh_curves');
  }
  public set ecdhCurves(value: string[]) {
    this._ecdhCurves = value;
  }
  public resetEcdhCurves() {
    this._ecdhCurves = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecdhCurvesInput() {
    return this._ecdhCurves;
  }

  // maximum_protocol_version - computed: false, optional: true, required: false
  private _maximumProtocolVersion?: string; 
  public get maximumProtocolVersion() {
    return this.getStringAttribute('maximum_protocol_version');
  }
  public set maximumProtocolVersion(value: string) {
    this._maximumProtocolVersion = value;
  }
  public resetMaximumProtocolVersion() {
    this._maximumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumProtocolVersionInput() {
    return this._maximumProtocolVersion;
  }

  // minimum_protocol_version - computed: false, optional: true, required: false
  private _minimumProtocolVersion?: string; 
  public get minimumProtocolVersion() {
    return this.getStringAttribute('minimum_protocol_version');
  }
  public set minimumProtocolVersion(value: string) {
    this._minimumProtocolVersion = value;
  }
  public resetMinimumProtocolVersion() {
    this._minimumProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumProtocolVersionInput() {
    return this._minimumProtocolVersion;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#token_file_name DataK8SGlooSoloIoUpstreamV1Manifest#token_file_name}
  */
  readonly tokenFileName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    token_file_name: cdktf.stringToTerraform(struct!.tokenFileName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_file_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._tokenFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenFileName = this._tokenFileName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._tokenFileName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._tokenFileName = value.tokenFileName;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // token_file_name - computed: false, optional: true, required: false
  private _tokenFileName?: string; 
  public get tokenFileName() {
    return this.getStringAttribute('token_file_name');
  }
  public set tokenFileName(value: string) {
    this._tokenFileName = value;
  }
  public resetTokenFileName() {
    this._tokenFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenFileNameInput() {
    return this._tokenFileName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#file_credential_source DataK8SGlooSoloIoUpstreamV1Manifest#file_credential_source}
  */
  readonly fileCredentialSource?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    file_credential_source: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSourceToTerraform(struct!.fileCredentialSource),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    file_credential_source: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSourceToHclTerraform(struct!.fileCredentialSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fileCredentialSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileCredentialSource = this._fileCredentialSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fileCredentialSource.internalValue = value.fileCredentialSource;
    }
  }

  // file_credential_source - computed: false, optional: true, required: false
  private _fileCredentialSource = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSourceOutputReference(this, "file_credential_source");
  public get fileCredentialSource() {
    return this._fileCredentialSource;
  }
  public putFileCredentialSource(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsFileCredentialSource) {
    this._fileCredentialSource.internalValue = value;
  }
  public resetFileCredentialSource() {
    this._fileCredentialSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileCredentialSourceInput() {
    return this._fileCredentialSource.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#call_credentials DataK8SGlooSoloIoUpstreamV1Manifest#call_credentials}
  */
  readonly callCredentials?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#certificates_secret_name DataK8SGlooSoloIoUpstreamV1Manifest#certificates_secret_name}
  */
  readonly certificatesSecretName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#cluster_name DataK8SGlooSoloIoUpstreamV1Manifest#cluster_name}
  */
  readonly clusterName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#target_uri DataK8SGlooSoloIoUpstreamV1Manifest#target_uri}
  */
  readonly targetUri?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#validation_context_name DataK8SGlooSoloIoUpstreamV1Manifest#validation_context_name}
  */
  readonly validationContextName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    call_credentials: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsToTerraform(struct!.callCredentials),
    certificates_secret_name: cdktf.stringToTerraform(struct!.certificatesSecretName),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    target_uri: cdktf.stringToTerraform(struct!.targetUri),
    validation_context_name: cdktf.stringToTerraform(struct!.validationContextName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    call_credentials: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsToHclTerraform(struct!.callCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials",
    },
    certificates_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.certificatesSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_uri: {
      value: cdktf.stringToHclTerraform(struct!.targetUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validation_context_name: {
      value: cdktf.stringToHclTerraform(struct!.validationContextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._callCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.callCredentials = this._callCredentials?.internalValue;
    }
    if (this._certificatesSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificatesSecretName = this._certificatesSecretName;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._targetUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetUri = this._targetUri;
    }
    if (this._validationContextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationContextName = this._validationContextName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = undefined;
      this._certificatesSecretName = undefined;
      this._clusterName = undefined;
      this._targetUri = undefined;
      this._validationContextName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._callCredentials.internalValue = value.callCredentials;
      this._certificatesSecretName = value.certificatesSecretName;
      this._clusterName = value.clusterName;
      this._targetUri = value.targetUri;
      this._validationContextName = value.validationContextName;
    }
  }

  // call_credentials - computed: false, optional: true, required: false
  private _callCredentials = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentialsOutputReference(this, "call_credentials");
  public get callCredentials() {
    return this._callCredentials;
  }
  public putCallCredentials(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsCallCredentials) {
    this._callCredentials.internalValue = value;
  }
  public resetCallCredentials() {
    this._callCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get callCredentialsInput() {
    return this._callCredentials.internalValue;
  }

  // certificates_secret_name - computed: false, optional: true, required: false
  private _certificatesSecretName?: string; 
  public get certificatesSecretName() {
    return this.getStringAttribute('certificates_secret_name');
  }
  public set certificatesSecretName(value: string) {
    this._certificatesSecretName = value;
  }
  public resetCertificatesSecretName() {
    this._certificatesSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesSecretNameInput() {
    return this._certificatesSecretName;
  }

  // cluster_name - computed: false, optional: true, required: false
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  public resetClusterName() {
    this._clusterName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // target_uri - computed: false, optional: true, required: false
  private _targetUri?: string; 
  public get targetUri() {
    return this.getStringAttribute('target_uri');
  }
  public set targetUri(value: string) {
    this._targetUri = value;
  }
  public resetTargetUri() {
    this._targetUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetUriInput() {
    return this._targetUri;
  }

  // validation_context_name - computed: false, optional: true, required: false
  private _validationContextName?: string; 
  public get validationContextName() {
    return this.getStringAttribute('validation_context_name');
  }
  public set validationContextName(value: string) {
    this._validationContextName = value;
  }
  public resetValidationContextName() {
    this._validationContextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationContextNameInput() {
    return this._validationContextName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ocsp_staple DataK8SGlooSoloIoUpstreamV1Manifest#ocsp_staple}
  */
  readonly ocspStaple?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#root_ca DataK8SGlooSoloIoUpstreamV1Manifest#root_ca}
  */
  readonly rootCa?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tls_cert DataK8SGlooSoloIoUpstreamV1Manifest#tls_cert}
  */
  readonly tlsCert?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tls_key DataK8SGlooSoloIoUpstreamV1Manifest#tls_key}
  */
  readonly tlsKey?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFilesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ocsp_staple: cdktf.stringToTerraform(struct!.ocspStaple),
    root_ca: cdktf.stringToTerraform(struct!.rootCa),
    tls_cert: cdktf.stringToTerraform(struct!.tlsCert),
    tls_key: cdktf.stringToTerraform(struct!.tlsKey),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFilesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ocsp_staple: {
      value: cdktf.stringToHclTerraform(struct!.ocspStaple),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    root_ca: {
      value: cdktf.stringToHclTerraform(struct!.rootCa),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_cert: {
      value: cdktf.stringToHclTerraform(struct!.tlsCert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_key: {
      value: cdktf.stringToHclTerraform(struct!.tlsKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ocspStaple !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspStaple = this._ocspStaple;
    }
    if (this._rootCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootCa = this._rootCa;
    }
    if (this._tlsCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsCert = this._tlsCert;
    }
    if (this._tlsKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsKey = this._tlsKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ocspStaple = undefined;
      this._rootCa = undefined;
      this._tlsCert = undefined;
      this._tlsKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ocspStaple = value.ocspStaple;
      this._rootCa = value.rootCa;
      this._tlsCert = value.tlsCert;
      this._tlsKey = value.tlsKey;
    }
  }

  // ocsp_staple - computed: false, optional: true, required: false
  private _ocspStaple?: string; 
  public get ocspStaple() {
    return this.getStringAttribute('ocsp_staple');
  }
  public set ocspStaple(value: string) {
    this._ocspStaple = value;
  }
  public resetOcspStaple() {
    this._ocspStaple = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspStapleInput() {
    return this._ocspStaple;
  }

  // root_ca - computed: false, optional: true, required: false
  private _rootCa?: string; 
  public get rootCa() {
    return this.getStringAttribute('root_ca');
  }
  public set rootCa(value: string) {
    this._rootCa = value;
  }
  public resetRootCa() {
    this._rootCa = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootCaInput() {
    return this._rootCa;
  }

  // tls_cert - computed: false, optional: true, required: false
  private _tlsCert?: string; 
  public get tlsCert() {
    return this.getStringAttribute('tls_cert');
  }
  public set tlsCert(value: string) {
    this._tlsCert = value;
  }
  public resetTlsCert() {
    this._tlsCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsCertInput() {
    return this._tlsCert;
  }

  // tls_key - computed: false, optional: true, required: false
  private _tlsKey?: string; 
  public get tlsKey() {
    return this.getStringAttribute('tls_key');
  }
  public set tlsKey(value: string) {
    this._tlsKey = value;
  }
  public resetTlsKey() {
    this._tlsKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsKeyInput() {
    return this._tlsKey;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#allow_renegotiation DataK8SGlooSoloIoUpstreamV1Manifest#allow_renegotiation}
  */
  readonly allowRenegotiation?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#alpn_protocols DataK8SGlooSoloIoUpstreamV1Manifest#alpn_protocols}
  */
  readonly alpnProtocols?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#one_way_tls DataK8SGlooSoloIoUpstreamV1Manifest#one_way_tls}
  */
  readonly oneWayTls?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#parameters DataK8SGlooSoloIoUpstreamV1Manifest#parameters}
  */
  readonly parameters?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#sds DataK8SGlooSoloIoUpstreamV1Manifest#sds}
  */
  readonly sds?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#secret_ref DataK8SGlooSoloIoUpstreamV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#sni DataK8SGlooSoloIoUpstreamV1Manifest#sni}
  */
  readonly sni?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ssl_files DataK8SGlooSoloIoUpstreamV1Manifest#ssl_files}
  */
  readonly sslFiles?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#verify_subject_alt_name DataK8SGlooSoloIoUpstreamV1Manifest#verify_subject_alt_name}
  */
  readonly verifySubjectAltName?: string[];
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_renegotiation: cdktf.booleanToTerraform(struct!.allowRenegotiation),
    alpn_protocols: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.alpnProtocols),
    one_way_tls: cdktf.booleanToTerraform(struct!.oneWayTls),
    parameters: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParametersToTerraform(struct!.parameters),
    sds: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsToTerraform(struct!.sds),
    secret_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRefToTerraform(struct!.secretRef),
    sni: cdktf.stringToTerraform(struct!.sni),
    ssl_files: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFilesToTerraform(struct!.sslFiles),
    verify_subject_alt_name: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifySubjectAltName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_renegotiation: {
      value: cdktf.booleanToHclTerraform(struct!.allowRenegotiation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    alpn_protocols: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.alpnProtocols),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    one_way_tls: {
      value: cdktf.booleanToHclTerraform(struct!.oneWayTls),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    parameters: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParametersToHclTerraform(struct!.parameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters",
    },
    sds: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsToHclTerraform(struct!.sds),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds",
    },
    secret_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef",
    },
    sni: {
      value: cdktf.stringToHclTerraform(struct!.sni),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_files: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFilesToHclTerraform(struct!.sslFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles",
    },
    verify_subject_alt_name: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifySubjectAltName),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowRenegotiation !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRenegotiation = this._allowRenegotiation;
    }
    if (this._alpnProtocols !== undefined) {
      hasAnyValues = true;
      internalValueResult.alpnProtocols = this._alpnProtocols;
    }
    if (this._oneWayTls !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneWayTls = this._oneWayTls;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    if (this._sds?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sds = this._sds?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._sni !== undefined) {
      hasAnyValues = true;
      internalValueResult.sni = this._sni;
    }
    if (this._sslFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslFiles = this._sslFiles?.internalValue;
    }
    if (this._verifySubjectAltName !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifySubjectAltName = this._verifySubjectAltName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowRenegotiation = undefined;
      this._alpnProtocols = undefined;
      this._oneWayTls = undefined;
      this._parameters.internalValue = undefined;
      this._sds.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._sni = undefined;
      this._sslFiles.internalValue = undefined;
      this._verifySubjectAltName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowRenegotiation = value.allowRenegotiation;
      this._alpnProtocols = value.alpnProtocols;
      this._oneWayTls = value.oneWayTls;
      this._parameters.internalValue = value.parameters;
      this._sds.internalValue = value.sds;
      this._secretRef.internalValue = value.secretRef;
      this._sni = value.sni;
      this._sslFiles.internalValue = value.sslFiles;
      this._verifySubjectAltName = value.verifySubjectAltName;
    }
  }

  // allow_renegotiation - computed: false, optional: true, required: false
  private _allowRenegotiation?: boolean | cdktf.IResolvable; 
  public get allowRenegotiation() {
    return this.getBooleanAttribute('allow_renegotiation');
  }
  public set allowRenegotiation(value: boolean | cdktf.IResolvable) {
    this._allowRenegotiation = value;
  }
  public resetAllowRenegotiation() {
    this._allowRenegotiation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRenegotiationInput() {
    return this._allowRenegotiation;
  }

  // alpn_protocols - computed: false, optional: true, required: false
  private _alpnProtocols?: string[]; 
  public get alpnProtocols() {
    return this.getListAttribute('alpn_protocols');
  }
  public set alpnProtocols(value: string[]) {
    this._alpnProtocols = value;
  }
  public resetAlpnProtocols() {
    this._alpnProtocols = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alpnProtocolsInput() {
    return this._alpnProtocols;
  }

  // one_way_tls - computed: false, optional: true, required: false
  private _oneWayTls?: boolean | cdktf.IResolvable; 
  public get oneWayTls() {
    return this.getBooleanAttribute('one_way_tls');
  }
  public set oneWayTls(value: boolean | cdktf.IResolvable) {
    this._oneWayTls = value;
  }
  public resetOneWayTls() {
    this._oneWayTls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oneWayTlsInput() {
    return this._oneWayTls;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParametersOutputReference(this, "parameters");
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigParameters) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }

  // sds - computed: false, optional: true, required: false
  private _sds = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSdsOutputReference(this, "sds");
  public get sds() {
    return this._sds;
  }
  public putSds(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSds) {
    this._sds.internalValue = value;
  }
  public resetSds() {
    this._sds.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sdsInput() {
    return this._sds.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // sni - computed: false, optional: true, required: false
  private _sni?: string; 
  public get sni() {
    return this.getStringAttribute('sni');
  }
  public set sni(value: string) {
    this._sni = value;
  }
  public resetSni() {
    this._sni = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sniInput() {
    return this._sni;
  }

  // ssl_files - computed: false, optional: true, required: false
  private _sslFiles = new DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFilesOutputReference(this, "ssl_files");
  public get sslFiles() {
    return this._sslFiles;
  }
  public putSslFiles(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecHttpConnectSslConfigSslFiles) {
    this._sslFiles.internalValue = value;
  }
  public resetSslFiles() {
    this._sslFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslFilesInput() {
    return this._sslFiles.internalValue;
  }

  // verify_subject_alt_name - computed: false, optional: true, required: false
  private _verifySubjectAltName?: string[]; 
  public get verifySubjectAltName() {
    return this.getListAttribute('verify_subject_alt_name');
  }
  public set verifySubjectAltName(value: string[]) {
    this._verifySubjectAltName = value;
  }
  public resetVerifySubjectAltName() {
    this._verifySubjectAltName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifySubjectAltNameInput() {
    return this._verifySubjectAltName;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#url DataK8SGlooSoloIoUpstreamV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpointToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpointToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpointOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#endpoint DataK8SGlooSoloIoUpstreamV1Manifest#endpoint}
  */
  readonly endpoint?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpointToTerraform(struct!.endpoint),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpointToHclTerraform(struct!.endpoint),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint.internalValue = value.endpoint;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpointOutputReference(this, "endpoint");
  public get endpoint() {
    return this._endpoint;
  }
  public putEndpoint(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlEndpoint) {
    this._endpoint.internalValue = value;
  }
  public resetEndpoint() {
    this._endpoint.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#function_names DataK8SGlooSoloIoUpstreamV1Manifest#function_names}
  */
  readonly functionNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#package_name DataK8SGlooSoloIoUpstreamV1Manifest#package_name}
  */
  readonly packageName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.functionNames),
    package_name: cdktf.stringToTerraform(struct!.packageName),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.functionNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    package_name: {
      value: cdktf.stringToHclTerraform(struct!.packageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._functionNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionNames = this._functionNames;
    }
    if (this._packageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.packageName = this._packageName;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._functionNames = undefined;
      this._packageName = undefined;
      this._serviceName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._functionNames = value.functionNames;
      this._packageName = value.packageName;
      this._serviceName = value.serviceName;
    }
  }

  // function_names - computed: false, optional: true, required: false
  private _functionNames?: string[]; 
  public get functionNames() {
    return this.getListAttribute('function_names');
  }
  public set functionNames(value: string[]) {
    this._functionNames = value;
  }
  public resetFunctionNames() {
    this._functionNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionNamesInput() {
    return this._functionNames;
  }

  // package_name - computed: false, optional: true, required: false
  private _packageName?: string; 
  public get packageName() {
    return this.getStringAttribute('package_name');
  }
  public set packageName(value: string) {
    this._packageName = value;
  }
  public resetPackageName() {
    this._packageName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packageNameInput() {
    return this._packageName;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#descriptors DataK8SGlooSoloIoUpstreamV1Manifest#descriptors}
  */
  readonly descriptors?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc_services DataK8SGlooSoloIoUpstreamV1Manifest#grpc_services}
  */
  readonly grpcServices?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptors: cdktf.stringToTerraform(struct!.descriptors),
    grpc_services: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesToTerraform, false)(struct!.grpcServices),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptors: {
      value: cdktf.stringToHclTerraform(struct!.descriptors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grpc_services: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesToHclTerraform, false)(struct!.grpcServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptors !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptors = this._descriptors;
    }
    if (this._grpcServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcServices = this._grpcServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptors = undefined;
      this._grpcServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptors = value.descriptors;
      this._grpcServices.internalValue = value.grpcServices;
    }
  }

  // descriptors - computed: false, optional: true, required: false
  private _descriptors?: string; 
  public get descriptors() {
    return this.getStringAttribute('descriptors');
  }
  public set descriptors(value: string) {
    this._descriptors = value;
  }
  public resetDescriptors() {
    this._descriptors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorsInput() {
    return this._descriptors;
  }

  // grpc_services - computed: false, optional: true, required: false
  private _grpcServices = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServicesList(this, "grpc_services", false);
  public get grpcServices() {
    return this._grpcServices;
  }
  public putGrpcServices(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcGrpcServices[] | cdktf.IResolvable) {
    this._grpcServices.internalValue = value;
  }
  public resetGrpcServices() {
    this._grpcServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServicesInput() {
    return this._grpcServices.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#add_whitespace DataK8SGlooSoloIoUpstreamV1Manifest#add_whitespace}
  */
  readonly addWhitespace?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_print_enums_as_ints DataK8SGlooSoloIoUpstreamV1Manifest#always_print_enums_as_ints}
  */
  readonly alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_print_primitive_fields DataK8SGlooSoloIoUpstreamV1Manifest#always_print_primitive_fields}
  */
  readonly alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#preserve_proto_field_names DataK8SGlooSoloIoUpstreamV1Manifest#preserve_proto_field_names}
  */
  readonly preserveProtoFieldNames?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_whitespace: cdktf.booleanToTerraform(struct!.addWhitespace),
    always_print_enums_as_ints: cdktf.booleanToTerraform(struct!.alwaysPrintEnumsAsInts),
    always_print_primitive_fields: cdktf.booleanToTerraform(struct!.alwaysPrintPrimitiveFields),
    preserve_proto_field_names: cdktf.booleanToTerraform(struct!.preserveProtoFieldNames),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_whitespace: {
      value: cdktf.booleanToHclTerraform(struct!.addWhitespace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_enums_as_ints: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintEnumsAsInts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_primitive_fields: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintPrimitiveFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_proto_field_names: {
      value: cdktf.booleanToHclTerraform(struct!.preserveProtoFieldNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addWhitespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.addWhitespace = this._addWhitespace;
    }
    if (this._alwaysPrintEnumsAsInts !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintEnumsAsInts = this._alwaysPrintEnumsAsInts;
    }
    if (this._alwaysPrintPrimitiveFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintPrimitiveFields = this._alwaysPrintPrimitiveFields;
    }
    if (this._preserveProtoFieldNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveProtoFieldNames = this._preserveProtoFieldNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addWhitespace = undefined;
      this._alwaysPrintEnumsAsInts = undefined;
      this._alwaysPrintPrimitiveFields = undefined;
      this._preserveProtoFieldNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addWhitespace = value.addWhitespace;
      this._alwaysPrintEnumsAsInts = value.alwaysPrintEnumsAsInts;
      this._alwaysPrintPrimitiveFields = value.alwaysPrintPrimitiveFields;
      this._preserveProtoFieldNames = value.preserveProtoFieldNames;
    }
  }

  // add_whitespace - computed: false, optional: true, required: false
  private _addWhitespace?: boolean | cdktf.IResolvable; 
  public get addWhitespace() {
    return this.getBooleanAttribute('add_whitespace');
  }
  public set addWhitespace(value: boolean | cdktf.IResolvable) {
    this._addWhitespace = value;
  }
  public resetAddWhitespace() {
    this._addWhitespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addWhitespaceInput() {
    return this._addWhitespace;
  }

  // always_print_enums_as_ints - computed: false, optional: true, required: false
  private _alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable; 
  public get alwaysPrintEnumsAsInts() {
    return this.getBooleanAttribute('always_print_enums_as_ints');
  }
  public set alwaysPrintEnumsAsInts(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintEnumsAsInts = value;
  }
  public resetAlwaysPrintEnumsAsInts() {
    this._alwaysPrintEnumsAsInts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintEnumsAsIntsInput() {
    return this._alwaysPrintEnumsAsInts;
  }

  // always_print_primitive_fields - computed: false, optional: true, required: false
  private _alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable; 
  public get alwaysPrintPrimitiveFields() {
    return this.getBooleanAttribute('always_print_primitive_fields');
  }
  public set alwaysPrintPrimitiveFields(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintPrimitiveFields = value;
  }
  public resetAlwaysPrintPrimitiveFields() {
    this._alwaysPrintPrimitiveFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintPrimitiveFieldsInput() {
    return this._alwaysPrintPrimitiveFields;
  }

  // preserve_proto_field_names - computed: false, optional: true, required: false
  private _preserveProtoFieldNames?: boolean | cdktf.IResolvable; 
  public get preserveProtoFieldNames() {
    return this.getBooleanAttribute('preserve_proto_field_names');
  }
  public set preserveProtoFieldNames(value: boolean | cdktf.IResolvable) {
    this._preserveProtoFieldNames = value;
  }
  public resetPreserveProtoFieldNames() {
    this._preserveProtoFieldNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveProtoFieldNamesInput() {
    return this._preserveProtoFieldNames;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#config_map_ref DataK8SGlooSoloIoUpstreamV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct!.configMapRef),
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._key = value.key;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auto_mapping DataK8SGlooSoloIoUpstreamV1Manifest#auto_mapping}
  */
  readonly autoMapping?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#convert_grpc_status DataK8SGlooSoloIoUpstreamV1Manifest#convert_grpc_status}
  */
  readonly convertGrpcStatus?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignore_unknown_query_parameters DataK8SGlooSoloIoUpstreamV1Manifest#ignore_unknown_query_parameters}
  */
  readonly ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignored_query_parameters DataK8SGlooSoloIoUpstreamV1Manifest#ignored_query_parameters}
  */
  readonly ignoredQueryParameters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#match_incoming_request_route DataK8SGlooSoloIoUpstreamV1Manifest#match_incoming_request_route}
  */
  readonly matchIncomingRequestRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#print_options DataK8SGlooSoloIoUpstreamV1Manifest#print_options}
  */
  readonly printOptions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor}
  */
  readonly protoDescriptor?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor_bin DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor_bin}
  */
  readonly protoDescriptorBin?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor_config_map DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor_config_map}
  */
  readonly protoDescriptorConfigMap?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#services DataK8SGlooSoloIoUpstreamV1Manifest#services}
  */
  readonly services?: string[];
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_mapping: cdktf.booleanToTerraform(struct!.autoMapping),
    convert_grpc_status: cdktf.booleanToTerraform(struct!.convertGrpcStatus),
    ignore_unknown_query_parameters: cdktf.booleanToTerraform(struct!.ignoreUnknownQueryParameters),
    ignored_query_parameters: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ignoredQueryParameters),
    match_incoming_request_route: cdktf.booleanToTerraform(struct!.matchIncomingRequestRoute),
    print_options: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptionsToTerraform(struct!.printOptions),
    proto_descriptor: cdktf.stringToTerraform(struct!.protoDescriptor),
    proto_descriptor_bin: cdktf.stringToTerraform(struct!.protoDescriptorBin),
    proto_descriptor_config_map: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct!.protoDescriptorConfigMap),
    services: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.services),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_mapping: {
      value: cdktf.booleanToHclTerraform(struct!.autoMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    convert_grpc_status: {
      value: cdktf.booleanToHclTerraform(struct!.convertGrpcStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_unknown_query_parameters: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreUnknownQueryParameters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignored_query_parameters: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ignoredQueryParameters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    match_incoming_request_route: {
      value: cdktf.booleanToHclTerraform(struct!.matchIncomingRequestRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    print_options: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptionsToHclTerraform(struct!.printOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions",
    },
    proto_descriptor: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_bin: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptorBin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_config_map: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct!.protoDescriptorConfigMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap",
    },
    services: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.services),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoMapping = this._autoMapping;
    }
    if (this._convertGrpcStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.convertGrpcStatus = this._convertGrpcStatus;
    }
    if (this._ignoreUnknownQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreUnknownQueryParameters = this._ignoreUnknownQueryParameters;
    }
    if (this._ignoredQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoredQueryParameters = this._ignoredQueryParameters;
    }
    if (this._matchIncomingRequestRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchIncomingRequestRoute = this._matchIncomingRequestRoute;
    }
    if (this._printOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.printOptions = this._printOptions?.internalValue;
    }
    if (this._protoDescriptor !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptor = this._protoDescriptor;
    }
    if (this._protoDescriptorBin !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorBin = this._protoDescriptorBin;
    }
    if (this._protoDescriptorConfigMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorConfigMap = this._protoDescriptorConfigMap?.internalValue;
    }
    if (this._services !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoMapping = undefined;
      this._convertGrpcStatus = undefined;
      this._ignoreUnknownQueryParameters = undefined;
      this._ignoredQueryParameters = undefined;
      this._matchIncomingRequestRoute = undefined;
      this._printOptions.internalValue = undefined;
      this._protoDescriptor = undefined;
      this._protoDescriptorBin = undefined;
      this._protoDescriptorConfigMap.internalValue = undefined;
      this._services = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoMapping = value.autoMapping;
      this._convertGrpcStatus = value.convertGrpcStatus;
      this._ignoreUnknownQueryParameters = value.ignoreUnknownQueryParameters;
      this._ignoredQueryParameters = value.ignoredQueryParameters;
      this._matchIncomingRequestRoute = value.matchIncomingRequestRoute;
      this._printOptions.internalValue = value.printOptions;
      this._protoDescriptor = value.protoDescriptor;
      this._protoDescriptorBin = value.protoDescriptorBin;
      this._protoDescriptorConfigMap.internalValue = value.protoDescriptorConfigMap;
      this._services = value.services;
    }
  }

  // auto_mapping - computed: false, optional: true, required: false
  private _autoMapping?: boolean | cdktf.IResolvable; 
  public get autoMapping() {
    return this.getBooleanAttribute('auto_mapping');
  }
  public set autoMapping(value: boolean | cdktf.IResolvable) {
    this._autoMapping = value;
  }
  public resetAutoMapping() {
    this._autoMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoMappingInput() {
    return this._autoMapping;
  }

  // convert_grpc_status - computed: false, optional: true, required: false
  private _convertGrpcStatus?: boolean | cdktf.IResolvable; 
  public get convertGrpcStatus() {
    return this.getBooleanAttribute('convert_grpc_status');
  }
  public set convertGrpcStatus(value: boolean | cdktf.IResolvable) {
    this._convertGrpcStatus = value;
  }
  public resetConvertGrpcStatus() {
    this._convertGrpcStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get convertGrpcStatusInput() {
    return this._convertGrpcStatus;
  }

  // ignore_unknown_query_parameters - computed: false, optional: true, required: false
  private _ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable; 
  public get ignoreUnknownQueryParameters() {
    return this.getBooleanAttribute('ignore_unknown_query_parameters');
  }
  public set ignoreUnknownQueryParameters(value: boolean | cdktf.IResolvable) {
    this._ignoreUnknownQueryParameters = value;
  }
  public resetIgnoreUnknownQueryParameters() {
    this._ignoreUnknownQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreUnknownQueryParametersInput() {
    return this._ignoreUnknownQueryParameters;
  }

  // ignored_query_parameters - computed: false, optional: true, required: false
  private _ignoredQueryParameters?: string[]; 
  public get ignoredQueryParameters() {
    return this.getListAttribute('ignored_query_parameters');
  }
  public set ignoredQueryParameters(value: string[]) {
    this._ignoredQueryParameters = value;
  }
  public resetIgnoredQueryParameters() {
    this._ignoredQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoredQueryParametersInput() {
    return this._ignoredQueryParameters;
  }

  // match_incoming_request_route - computed: false, optional: true, required: false
  private _matchIncomingRequestRoute?: boolean | cdktf.IResolvable; 
  public get matchIncomingRequestRoute() {
    return this.getBooleanAttribute('match_incoming_request_route');
  }
  public set matchIncomingRequestRoute(value: boolean | cdktf.IResolvable) {
    this._matchIncomingRequestRoute = value;
  }
  public resetMatchIncomingRequestRoute() {
    this._matchIncomingRequestRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchIncomingRequestRouteInput() {
    return this._matchIncomingRequestRoute;
  }

  // print_options - computed: false, optional: true, required: false
  private _printOptions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptionsOutputReference(this, "print_options");
  public get printOptions() {
    return this._printOptions;
  }
  public putPrintOptions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderPrintOptions) {
    this._printOptions.internalValue = value;
  }
  public resetPrintOptions() {
    this._printOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get printOptionsInput() {
    return this._printOptions.internalValue;
  }

  // proto_descriptor - computed: false, optional: true, required: false
  private _protoDescriptor?: string; 
  public get protoDescriptor() {
    return this.getStringAttribute('proto_descriptor');
  }
  public set protoDescriptor(value: string) {
    this._protoDescriptor = value;
  }
  public resetProtoDescriptor() {
    this._protoDescriptor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorInput() {
    return this._protoDescriptor;
  }

  // proto_descriptor_bin - computed: false, optional: true, required: false
  private _protoDescriptorBin?: string; 
  public get protoDescriptorBin() {
    return this.getStringAttribute('proto_descriptor_bin');
  }
  public set protoDescriptorBin(value: string) {
    this._protoDescriptorBin = value;
  }
  public resetProtoDescriptorBin() {
    this._protoDescriptorBin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorBinInput() {
    return this._protoDescriptorBin;
  }

  // proto_descriptor_config_map - computed: false, optional: true, required: false
  private _protoDescriptorConfigMap = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference(this, "proto_descriptor_config_map");
  public get protoDescriptorConfigMap() {
    return this._protoDescriptorConfigMap;
  }
  public putProtoDescriptorConfigMap(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap) {
    this._protoDescriptorConfigMap.internalValue = value;
  }
  public resetProtoDescriptorConfigMap() {
    this._protoDescriptorConfigMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorConfigMapInput() {
    return this._protoDescriptorConfigMap.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services?: string[]; 
  public get services() {
    return this.getListAttribute('services');
  }
  public set services(value: string[]) {
    this._services = value;
  }
  public resetServices() {
    this._services = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#url DataK8SGlooSoloIoUpstreamV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfoToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfoToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._url = value.url;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBodyToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBodyToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValueToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#json_to_proto DataK8SGlooSoloIoUpstreamV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#metadata_namespace DataK8SGlooSoloIoUpstreamV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#body DataK8SGlooSoloIoUpstreamV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#mode DataK8SGlooSoloIoUpstreamV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#regex DataK8SGlooSoloIoUpstreamV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#replacement_text DataK8SGlooSoloIoUpstreamV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#subgroup DataK8SGlooSoloIoUpstreamV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractorsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractorsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValueToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValueToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValueToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value.internalValue = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#override_empty DataK8SGlooSoloIoUpstreamV1Manifest#override_empty}
  */
  readonly overrideEmpty?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#tmpl DataK8SGlooSoloIoUpstreamV1Manifest#tmpl}
  */
  readonly tmpl?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    override_empty: cdktf.booleanToTerraform(struct!.overrideEmpty),
    tmpl: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToTerraform(struct!.tmpl),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    override_empty: {
      value: cdktf.booleanToHclTerraform(struct!.overrideEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tmpl: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplToHclTerraform(struct!.tmpl),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._overrideEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideEmpty = this._overrideEmpty;
    }
    if (this._tmpl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tmpl = this._tmpl?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._overrideEmpty = undefined;
      this._tmpl.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._overrideEmpty = value.overrideEmpty;
      this._tmpl.internalValue = value.tmpl;
    }
  }

  // override_empty - computed: false, optional: true, required: false
  private _overrideEmpty?: boolean | cdktf.IResolvable; 
  public get overrideEmpty() {
    return this.getBooleanAttribute('override_empty');
  }
  public set overrideEmpty(value: boolean | cdktf.IResolvable) {
    this._overrideEmpty = value;
  }
  public resetOverrideEmpty() {
    this._overrideEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideEmptyInput() {
    return this._overrideEmpty;
  }

  // tmpl - computed: false, optional: true, required: false
  private _tmpl = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmplOutputReference(this, "tmpl");
  public get tmpl() {
    return this._tmpl;
  }
  public putTmpl(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysTmpl) {
    this._tmpl.internalValue = value;
  }
  public resetTmpl() {
    this._tmpl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tmplInput() {
    return this._tmpl.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#json_keys DataK8SGlooSoloIoUpstreamV1Manifest#json_keys}
  */
  readonly jsonKeys?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_keys: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysToTerraform(struct!.jsonKeys),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_keys: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysToHclTerraform(struct!.jsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonKeys = this._jsonKeys?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonKeys.internalValue = value.jsonKeys;
    }
  }

  // json_keys - computed: false, optional: true, required: false
  private _jsonKeys = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeysOutputReference(this, "json_keys");
  public get jsonKeys() {
    return this._jsonKeys;
  }
  public putJsonKeys(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysJsonKeys) {
    this._jsonKeys.internalValue = value;
  }
  public resetJsonKeys() {
    this._jsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonKeysInput() {
    return this._jsonKeys.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#advanced_templates DataK8SGlooSoloIoUpstreamV1Manifest#advanced_templates}
  */
  readonly advancedTemplates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#body DataK8SGlooSoloIoUpstreamV1Manifest#body}
  */
  readonly body?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#dynamic_metadata_values DataK8SGlooSoloIoUpstreamV1Manifest#dynamic_metadata_values}
  */
  readonly dynamicMetadataValues?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#escape_characters DataK8SGlooSoloIoUpstreamV1Manifest#escape_characters}
  */
  readonly escapeCharacters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#extractors DataK8SGlooSoloIoUpstreamV1Manifest#extractors}
  */
  readonly extractors?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers DataK8SGlooSoloIoUpstreamV1Manifest#headers}
  */
  readonly headers?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers_to_append DataK8SGlooSoloIoUpstreamV1Manifest#headers_to_append}
  */
  readonly headersToAppend?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#headers_to_remove DataK8SGlooSoloIoUpstreamV1Manifest#headers_to_remove}
  */
  readonly headersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignore_error_on_parse DataK8SGlooSoloIoUpstreamV1Manifest#ignore_error_on_parse}
  */
  readonly ignoreErrorOnParse?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#merge_extractors_to_body DataK8SGlooSoloIoUpstreamV1Manifest#merge_extractors_to_body}
  */
  readonly mergeExtractorsToBody?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#merge_json_keys DataK8SGlooSoloIoUpstreamV1Manifest#merge_json_keys}
  */
  readonly mergeJsonKeys?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#parse_body_behavior DataK8SGlooSoloIoUpstreamV1Manifest#parse_body_behavior}
  */
  readonly parseBodyBehavior?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#passthrough DataK8SGlooSoloIoUpstreamV1Manifest#passthrough}
  */
  readonly passthrough?: { [key: string]: string };
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_templates: cdktf.booleanToTerraform(struct!.advancedTemplates),
    body: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBodyToTerraform(struct!.body),
    dynamic_metadata_values: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesToTerraform, false)(struct!.dynamicMetadataValues),
    escape_characters: cdktf.booleanToTerraform(struct!.escapeCharacters),
    extractors: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractorsToTerraform(struct!.extractors),
    headers: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToTerraform(struct!.headers),
    headers_to_append: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendToTerraform, false)(struct!.headersToAppend),
    headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.headersToRemove),
    ignore_error_on_parse: cdktf.booleanToTerraform(struct!.ignoreErrorOnParse),
    merge_extractors_to_body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.mergeExtractorsToBody),
    merge_json_keys: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysToTerraform(struct!.mergeJsonKeys),
    parse_body_behavior: cdktf.stringToTerraform(struct!.parseBodyBehavior),
    passthrough: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.passthrough),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_templates: {
      value: cdktf.booleanToHclTerraform(struct!.advancedTemplates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    body: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody",
    },
    dynamic_metadata_values: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesToHclTerraform, false)(struct!.dynamicMetadataValues),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesList",
    },
    escape_characters: {
      value: cdktf.booleanToHclTerraform(struct!.escapeCharacters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extractors: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractorsToHclTerraform(struct!.extractors),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors",
    },
    headers: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders",
    },
    headers_to_append: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendToHclTerraform, false)(struct!.headersToAppend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendList",
    },
    headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.headersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ignore_error_on_parse: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreErrorOnParse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    merge_extractors_to_body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.mergeExtractorsToBody),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    merge_json_keys: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysToHclTerraform(struct!.mergeJsonKeys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys",
    },
    parse_body_behavior: {
      value: cdktf.stringToHclTerraform(struct!.parseBodyBehavior),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passthrough: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.passthrough),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedTemplates !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedTemplates = this._advancedTemplates;
    }
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._dynamicMetadataValues?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadataValues = this._dynamicMetadataValues?.internalValue;
    }
    if (this._escapeCharacters !== undefined) {
      hasAnyValues = true;
      internalValueResult.escapeCharacters = this._escapeCharacters;
    }
    if (this._extractors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractors = this._extractors?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._headersToAppend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToAppend = this._headersToAppend?.internalValue;
    }
    if (this._headersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersToRemove = this._headersToRemove;
    }
    if (this._ignoreErrorOnParse !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreErrorOnParse = this._ignoreErrorOnParse;
    }
    if (this._mergeExtractorsToBody !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeExtractorsToBody = this._mergeExtractorsToBody;
    }
    if (this._mergeJsonKeys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.mergeJsonKeys = this._mergeJsonKeys?.internalValue;
    }
    if (this._parseBodyBehavior !== undefined) {
      hasAnyValues = true;
      internalValueResult.parseBodyBehavior = this._parseBodyBehavior;
    }
    if (this._passthrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.passthrough = this._passthrough;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedTemplates = undefined;
      this._body.internalValue = undefined;
      this._dynamicMetadataValues.internalValue = undefined;
      this._escapeCharacters = undefined;
      this._extractors.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._headersToAppend.internalValue = undefined;
      this._headersToRemove = undefined;
      this._ignoreErrorOnParse = undefined;
      this._mergeExtractorsToBody = undefined;
      this._mergeJsonKeys.internalValue = undefined;
      this._parseBodyBehavior = undefined;
      this._passthrough = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedTemplates = value.advancedTemplates;
      this._body.internalValue = value.body;
      this._dynamicMetadataValues.internalValue = value.dynamicMetadataValues;
      this._escapeCharacters = value.escapeCharacters;
      this._extractors.internalValue = value.extractors;
      this._headers.internalValue = value.headers;
      this._headersToAppend.internalValue = value.headersToAppend;
      this._headersToRemove = value.headersToRemove;
      this._ignoreErrorOnParse = value.ignoreErrorOnParse;
      this._mergeExtractorsToBody = value.mergeExtractorsToBody;
      this._mergeJsonKeys.internalValue = value.mergeJsonKeys;
      this._parseBodyBehavior = value.parseBodyBehavior;
      this._passthrough = value.passthrough;
    }
  }

  // advanced_templates - computed: false, optional: true, required: false
  private _advancedTemplates?: boolean | cdktf.IResolvable; 
  public get advancedTemplates() {
    return this.getBooleanAttribute('advanced_templates');
  }
  public set advancedTemplates(value: boolean | cdktf.IResolvable) {
    this._advancedTemplates = value;
  }
  public resetAdvancedTemplates() {
    this._advancedTemplates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedTemplatesInput() {
    return this._advancedTemplates;
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // dynamic_metadata_values - computed: false, optional: true, required: false
  private _dynamicMetadataValues = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValuesList(this, "dynamic_metadata_values", false);
  public get dynamicMetadataValues() {
    return this._dynamicMetadataValues;
  }
  public putDynamicMetadataValues(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable) {
    this._dynamicMetadataValues.internalValue = value;
  }
  public resetDynamicMetadataValues() {
    this._dynamicMetadataValues.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataValuesInput() {
    return this._dynamicMetadataValues.internalValue;
  }

  // escape_characters - computed: false, optional: true, required: false
  private _escapeCharacters?: boolean | cdktf.IResolvable; 
  public get escapeCharacters() {
    return this.getBooleanAttribute('escape_characters');
  }
  public set escapeCharacters(value: boolean | cdktf.IResolvable) {
    this._escapeCharacters = value;
  }
  public resetEscapeCharacters() {
    this._escapeCharacters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get escapeCharactersInput() {
    return this._escapeCharacters;
  }

  // extractors - computed: false, optional: true, required: false
  private _extractors = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractorsOutputReference(this, "extractors");
  public get extractors() {
    return this._extractors;
  }
  public putExtractors(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsExtractors) {
    this._extractors.internalValue = value;
  }
  public resetExtractors() {
    this._extractors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractorsInput() {
    return this._extractors.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // headers_to_append - computed: false, optional: true, required: false
  private _headersToAppend = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppendList(this, "headers_to_append", false);
  public get headersToAppend() {
    return this._headersToAppend;
  }
  public putHeadersToAppend(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsHeadersToAppend[] | cdktf.IResolvable) {
    this._headersToAppend.internalValue = value;
  }
  public resetHeadersToAppend() {
    this._headersToAppend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToAppendInput() {
    return this._headersToAppend.internalValue;
  }

  // headers_to_remove - computed: false, optional: true, required: false
  private _headersToRemove?: string[]; 
  public get headersToRemove() {
    return this.getListAttribute('headers_to_remove');
  }
  public set headersToRemove(value: string[]) {
    this._headersToRemove = value;
  }
  public resetHeadersToRemove() {
    this._headersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersToRemoveInput() {
    return this._headersToRemove;
  }

  // ignore_error_on_parse - computed: false, optional: true, required: false
  private _ignoreErrorOnParse?: boolean | cdktf.IResolvable; 
  public get ignoreErrorOnParse() {
    return this.getBooleanAttribute('ignore_error_on_parse');
  }
  public set ignoreErrorOnParse(value: boolean | cdktf.IResolvable) {
    this._ignoreErrorOnParse = value;
  }
  public resetIgnoreErrorOnParse() {
    this._ignoreErrorOnParse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreErrorOnParseInput() {
    return this._ignoreErrorOnParse;
  }

  // merge_extractors_to_body - computed: false, optional: true, required: false
  private _mergeExtractorsToBody?: { [key: string]: string }; 
  public get mergeExtractorsToBody() {
    return this.getStringMapAttribute('merge_extractors_to_body');
  }
  public set mergeExtractorsToBody(value: { [key: string]: string }) {
    this._mergeExtractorsToBody = value;
  }
  public resetMergeExtractorsToBody() {
    this._mergeExtractorsToBody = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeExtractorsToBodyInput() {
    return this._mergeExtractorsToBody;
  }

  // merge_json_keys - computed: false, optional: true, required: false
  private _mergeJsonKeys = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeysOutputReference(this, "merge_json_keys");
  public get mergeJsonKeys() {
    return this._mergeJsonKeys;
  }
  public putMergeJsonKeys(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsMergeJsonKeys) {
    this._mergeJsonKeys.internalValue = value;
  }
  public resetMergeJsonKeys() {
    this._mergeJsonKeys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeJsonKeysInput() {
    return this._mergeJsonKeys.internalValue;
  }

  // parse_body_behavior - computed: false, optional: true, required: false
  private _parseBodyBehavior?: string; 
  public get parseBodyBehavior() {
    return this.getStringAttribute('parse_body_behavior');
  }
  public set parseBodyBehavior(value: string) {
    this._parseBodyBehavior = value;
  }
  public resetParseBodyBehavior() {
    this._parseBodyBehavior = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parseBodyBehaviorInput() {
    return this._parseBodyBehavior;
  }

  // passthrough - computed: false, optional: true, required: false
  private _passthrough?: { [key: string]: string }; 
  public get passthrough() {
    return this.getStringMapAttribute('passthrough');
  }
  public set passthrough(value: { [key: string]: string }) {
    this._passthrough = value;
  }
  public resetPassthrough() {
    this._passthrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passthroughInput() {
    return this._passthrough;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#swagger_info DataK8SGlooSoloIoUpstreamV1Manifest#swagger_info}
  */
  readonly swaggerInfo?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#transformations DataK8SGlooSoloIoUpstreamV1Manifest#transformations}
  */
  readonly transformations?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    swagger_info: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfoToTerraform(struct!.swaggerInfo),
    transformations: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsToTerraform(struct!.transformations),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    swagger_info: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfoToHclTerraform(struct!.swaggerInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo",
    },
    transformations: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsToHclTerraform(struct!.transformations),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._swaggerInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.swaggerInfo = this._swaggerInfo?.internalValue;
    }
    if (this._transformations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.transformations = this._transformations?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._swaggerInfo.internalValue = undefined;
      this._transformations.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._swaggerInfo.internalValue = value.swaggerInfo;
      this._transformations.internalValue = value.transformations;
    }
  }

  // swagger_info - computed: false, optional: true, required: false
  private _swaggerInfo = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfoOutputReference(this, "swagger_info");
  public get swaggerInfo() {
    return this._swaggerInfo;
  }
  public putSwaggerInfo(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestSwaggerInfo) {
    this._swaggerInfo.internalValue = value;
  }
  public resetSwaggerInfo() {
    this._swaggerInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get swaggerInfoInput() {
    return this._swaggerInfo.internalValue;
  }

  // transformations - computed: false, optional: true, required: false
  private _transformations = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformationsOutputReference(this, "transformations");
  public get transformations() {
    return this._transformations;
  }
  public putTransformations(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestTransformations) {
    this._transformations.internalValue = value;
  }
  public resetTransformations() {
    this._transformations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transformationsInput() {
    return this._transformations.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#graphql DataK8SGlooSoloIoUpstreamV1Manifest#graphql}
  */
  readonly graphql?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc DataK8SGlooSoloIoUpstreamV1Manifest#grpc}
  */
  readonly grpc?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc_json_transcoder DataK8SGlooSoloIoUpstreamV1Manifest#grpc_json_transcoder}
  */
  readonly grpcJsonTranscoder?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#rest DataK8SGlooSoloIoUpstreamV1Manifest#rest}
  */
  readonly rest?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    graphql: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlToTerraform(struct!.graphql),
    grpc: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcToTerraform(struct!.grpc),
    grpc_json_transcoder: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderToTerraform(struct!.grpcJsonTranscoder),
    rest: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestToTerraform(struct!.rest),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    graphql: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlToHclTerraform(struct!.graphql),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql",
    },
    grpc: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcToHclTerraform(struct!.grpc),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc",
    },
    grpc_json_transcoder: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderToHclTerraform(struct!.grpcJsonTranscoder),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder",
    },
    rest: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestToHclTerraform(struct!.rest),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._graphql?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.graphql = this._graphql?.internalValue;
    }
    if (this._grpc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpc = this._grpc?.internalValue;
    }
    if (this._grpcJsonTranscoder?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcJsonTranscoder = this._grpcJsonTranscoder?.internalValue;
    }
    if (this._rest?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rest = this._rest?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._graphql.internalValue = undefined;
      this._grpc.internalValue = undefined;
      this._grpcJsonTranscoder.internalValue = undefined;
      this._rest.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._graphql.internalValue = value.graphql;
      this._grpc.internalValue = value.grpc;
      this._grpcJsonTranscoder.internalValue = value.grpcJsonTranscoder;
      this._rest.internalValue = value.rest;
    }
  }

  // graphql - computed: false, optional: true, required: false
  private _graphql = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphqlOutputReference(this, "graphql");
  public get graphql() {
    return this._graphql;
  }
  public putGraphql(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGraphql) {
    this._graphql.internalValue = value;
  }
  public resetGraphql() {
    this._graphql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get graphqlInput() {
    return this._graphql.internalValue;
  }

  // grpc - computed: false, optional: true, required: false
  private _grpc = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcOutputReference(this, "grpc");
  public get grpc() {
    return this._grpc;
  }
  public putGrpc(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpc) {
    this._grpc.internalValue = value;
  }
  public resetGrpc() {
    this._grpc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcInput() {
    return this._grpc.internalValue;
  }

  // grpc_json_transcoder - computed: false, optional: true, required: false
  private _grpcJsonTranscoder = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoderOutputReference(this, "grpc_json_transcoder");
  public get grpcJsonTranscoder() {
    return this._grpcJsonTranscoder;
  }
  public putGrpcJsonTranscoder(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecGrpcJsonTranscoder) {
    this._grpcJsonTranscoder.internalValue = value;
  }
  public resetGrpcJsonTranscoder() {
    this._grpcJsonTranscoder.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcJsonTranscoderInput() {
    return this._grpcJsonTranscoder.internalValue;
  }

  // rest - computed: false, optional: true, required: false
  private _rest = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRestOutputReference(this, "rest");
  public get rest() {
    return this._rest;
  }
  public putRest(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecRest) {
    this._rest.internalValue = value;
  }
  public resetRest() {
    this._rest.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restInput() {
    return this._rest.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#values DataK8SGlooSoloIoUpstreamV1Manifest#values}
  */
  readonly values?: { [key: string]: string };
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubsetToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    values: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.values),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubsetToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    values: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.values),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubsetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._values = value.values;
    }
  }

  // values - computed: false, optional: true, required: false
  private _values?: { [key: string]: string }; 
  public get values() {
    return this.getStringMapAttribute('values');
  }
  public set values(value: { [key: string]: string }) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#keys DataK8SGlooSoloIoUpstreamV1Manifest#keys}
  */
  readonly keys?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#single_host_per_subset DataK8SGlooSoloIoUpstreamV1Manifest#single_host_per_subset}
  */
  readonly singleHostPerSubset?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keys),
    single_host_per_subset: cdktf.booleanToTerraform(struct!.singleHostPerSubset),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    single_host_per_subset: {
      value: cdktf.booleanToHclTerraform(struct!.singleHostPerSubset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keys !== undefined) {
      hasAnyValues = true;
      internalValueResult.keys = this._keys;
    }
    if (this._singleHostPerSubset !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleHostPerSubset = this._singleHostPerSubset;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keys = undefined;
      this._singleHostPerSubset = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keys = value.keys;
      this._singleHostPerSubset = value.singleHostPerSubset;
    }
  }

  // keys - computed: false, optional: true, required: false
  private _keys?: string[]; 
  public get keys() {
    return this.getListAttribute('keys');
  }
  public set keys(value: string[]) {
    this._keys = value;
  }
  public resetKeys() {
    this._keys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keysInput() {
    return this._keys;
  }

  // single_host_per_subset - computed: false, optional: true, required: false
  private _singleHostPerSubset?: boolean | cdktf.IResolvable; 
  public get singleHostPerSubset() {
    return this.getBooleanAttribute('single_host_per_subset');
  }
  public set singleHostPerSubset(value: boolean | cdktf.IResolvable) {
    this._singleHostPerSubset = value;
  }
  public resetSingleHostPerSubset() {
    this._singleHostPerSubset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleHostPerSubsetInput() {
    return this._singleHostPerSubset;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#default_subset DataK8SGlooSoloIoUpstreamV1Manifest#default_subset}
  */
  readonly defaultSubset?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#fallback_policy DataK8SGlooSoloIoUpstreamV1Manifest#fallback_policy}
  */
  readonly fallbackPolicy?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#selectors DataK8SGlooSoloIoUpstreamV1Manifest#selectors}
  */
  readonly selectors?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_subset: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubsetToTerraform(struct!.defaultSubset),
    fallback_policy: cdktf.stringToTerraform(struct!.fallbackPolicy),
    selectors: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsToTerraform, false)(struct!.selectors),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_subset: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubsetToHclTerraform(struct!.defaultSubset),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset",
    },
    fallback_policy: {
      value: cdktf.stringToHclTerraform(struct!.fallbackPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selectors: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsToHclTerraform, false)(struct!.selectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultSubset?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultSubset = this._defaultSubset?.internalValue;
    }
    if (this._fallbackPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.fallbackPolicy = this._fallbackPolicy;
    }
    if (this._selectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selectors = this._selectors?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultSubset.internalValue = undefined;
      this._fallbackPolicy = undefined;
      this._selectors.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultSubset.internalValue = value.defaultSubset;
      this._fallbackPolicy = value.fallbackPolicy;
      this._selectors.internalValue = value.selectors;
    }
  }

  // default_subset - computed: false, optional: true, required: false
  private _defaultSubset = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubsetOutputReference(this, "default_subset");
  public get defaultSubset() {
    return this._defaultSubset;
  }
  public putDefaultSubset(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecDefaultSubset) {
    this._defaultSubset.internalValue = value;
  }
  public resetDefaultSubset() {
    this._defaultSubset.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultSubsetInput() {
    return this._defaultSubset.internalValue;
  }

  // fallback_policy - computed: false, optional: true, required: false
  private _fallbackPolicy?: string; 
  public get fallbackPolicy() {
    return this.getStringAttribute('fallback_policy');
  }
  public set fallbackPolicy(value: string) {
    this._fallbackPolicy = value;
  }
  public resetFallbackPolicy() {
    this._fallbackPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fallbackPolicyInput() {
    return this._fallbackPolicy;
  }

  // selectors - computed: false, optional: true, required: false
  private _selectors = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectorsList(this, "selectors", false);
  public get selectors() {
    return this._selectors;
  }
  public putSelectors(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecSelectors[] | cdktf.IResolvable) {
    this._selectors.internalValue = value;
  }
  public resetSelectors() {
    this._selectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorsInput() {
    return this._selectors.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecKube {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#selector DataK8SGlooSoloIoUpstreamV1Manifest#selector}
  */
  readonly selector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_namespace DataK8SGlooSoloIoUpstreamV1Manifest#service_namespace}
  */
  readonly serviceNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_port DataK8SGlooSoloIoUpstreamV1Manifest#service_port}
  */
  readonly servicePort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_spec DataK8SGlooSoloIoUpstreamV1Manifest#service_spec}
  */
  readonly serviceSpec?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#subset_spec DataK8SGlooSoloIoUpstreamV1Manifest#subset_spec}
  */
  readonly subsetSpec?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKube | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.selector),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
    service_namespace: cdktf.stringToTerraform(struct!.serviceNamespace),
    service_port: cdktf.numberToTerraform(struct!.servicePort),
    service_spec: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecToTerraform(struct!.serviceSpec),
    subset_spec: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecToTerraform(struct!.subsetSpec),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecKube | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.selector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_namespace: {
      value: cdktf.stringToHclTerraform(struct!.serviceNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_port: {
      value: cdktf.numberToHclTerraform(struct!.servicePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service_spec: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecToHclTerraform(struct!.serviceSpec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec",
    },
    subset_spec: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecToHclTerraform(struct!.subsetSpec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecKube | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    if (this._serviceNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceNamespace = this._serviceNamespace;
    }
    if (this._servicePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.servicePort = this._servicePort;
    }
    if (this._serviceSpec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceSpec = this._serviceSpec?.internalValue;
    }
    if (this._subsetSpec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subsetSpec = this._subsetSpec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKube | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._serviceName = undefined;
      this._serviceNamespace = undefined;
      this._servicePort = undefined;
      this._serviceSpec.internalValue = undefined;
      this._subsetSpec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._serviceName = value.serviceName;
      this._serviceNamespace = value.serviceNamespace;
      this._servicePort = value.servicePort;
      this._serviceSpec.internalValue = value.serviceSpec;
      this._subsetSpec.internalValue = value.subsetSpec;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: { [key: string]: string }; 
  public get selector() {
    return this.getStringMapAttribute('selector');
  }
  public set selector(value: { [key: string]: string }) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }

  // service_namespace - computed: false, optional: true, required: false
  private _serviceNamespace?: string; 
  public get serviceNamespace() {
    return this.getStringAttribute('service_namespace');
  }
  public set serviceNamespace(value: string) {
    this._serviceNamespace = value;
  }
  public resetServiceNamespace() {
    this._serviceNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNamespaceInput() {
    return this._serviceNamespace;
  }

  // service_port - computed: false, optional: true, required: false
  private _servicePort?: number; 
  public get servicePort() {
    return this.getNumberAttribute('service_port');
  }
  public set servicePort(value: number) {
    this._servicePort = value;
  }
  public resetServicePort() {
    this._servicePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicePortInput() {
    return this._servicePort;
  }

  // service_spec - computed: false, optional: true, required: false
  private _serviceSpec = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpecOutputReference(this, "service_spec");
  public get serviceSpec() {
    return this._serviceSpec;
  }
  public putServiceSpec(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeServiceSpec) {
    this._serviceSpec.internalValue = value;
  }
  public resetServiceSpec() {
    this._serviceSpec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceSpecInput() {
    return this._serviceSpec.internalValue;
  }

  // subset_spec - computed: false, optional: true, required: false
  private _subsetSpec = new DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpecOutputReference(this, "subset_spec");
  public get subsetSpec() {
    return this._subsetSpec;
  }
  public putSubsetSpec(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecKubeSubsetSpec) {
    this._subsetSpec.internalValue = value;
  }
  public resetSubsetSpec() {
    this._subsetSpec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subsetSpecInput() {
    return this._subsetSpec.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#aggression DataK8SGlooSoloIoUpstreamV1Manifest#aggression}
  */
  readonly aggression?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#min_weight_percent DataK8SGlooSoloIoUpstreamV1Manifest#min_weight_percent}
  */
  readonly minWeightPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#slow_start_window DataK8SGlooSoloIoUpstreamV1Manifest#slow_start_window}
  */
  readonly slowStartWindow?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggression: cdktf.numberToTerraform(struct!.aggression),
    min_weight_percent: cdktf.numberToTerraform(struct!.minWeightPercent),
    slow_start_window: cdktf.stringToTerraform(struct!.slowStartWindow),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggression: {
      value: cdktf.numberToHclTerraform(struct!.aggression),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_weight_percent: {
      value: cdktf.numberToHclTerraform(struct!.minWeightPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    slow_start_window: {
      value: cdktf.stringToHclTerraform(struct!.slowStartWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggression !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggression = this._aggression;
    }
    if (this._minWeightPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.minWeightPercent = this._minWeightPercent;
    }
    if (this._slowStartWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.slowStartWindow = this._slowStartWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggression = undefined;
      this._minWeightPercent = undefined;
      this._slowStartWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggression = value.aggression;
      this._minWeightPercent = value.minWeightPercent;
      this._slowStartWindow = value.slowStartWindow;
    }
  }

  // aggression - computed: false, optional: true, required: false
  private _aggression?: number; 
  public get aggression() {
    return this.getNumberAttribute('aggression');
  }
  public set aggression(value: number) {
    this._aggression = value;
  }
  public resetAggression() {
    this._aggression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggressionInput() {
    return this._aggression;
  }

  // min_weight_percent - computed: false, optional: true, required: false
  private _minWeightPercent?: number; 
  public get minWeightPercent() {
    return this.getNumberAttribute('min_weight_percent');
  }
  public set minWeightPercent(value: number) {
    this._minWeightPercent = value;
  }
  public resetMinWeightPercent() {
    this._minWeightPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minWeightPercentInput() {
    return this._minWeightPercent;
  }

  // slow_start_window - computed: false, optional: true, required: false
  private _slowStartWindow?: string; 
  public get slowStartWindow() {
    return this.getStringAttribute('slow_start_window');
  }
  public set slowStartWindow(value: string) {
    this._slowStartWindow = value;
  }
  public resetSlowStartWindow() {
    this._slowStartWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slowStartWindowInput() {
    return this._slowStartWindow;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#choice_count DataK8SGlooSoloIoUpstreamV1Manifest#choice_count}
  */
  readonly choiceCount?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#slow_start_config DataK8SGlooSoloIoUpstreamV1Manifest#slow_start_config}
  */
  readonly slowStartConfig?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    choice_count: cdktf.numberToTerraform(struct!.choiceCount),
    slow_start_config: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfigToTerraform(struct!.slowStartConfig),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    choice_count: {
      value: cdktf.numberToHclTerraform(struct!.choiceCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    slow_start_config: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfigToHclTerraform(struct!.slowStartConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._choiceCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.choiceCount = this._choiceCount;
    }
    if (this._slowStartConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slowStartConfig = this._slowStartConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._choiceCount = undefined;
      this._slowStartConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._choiceCount = value.choiceCount;
      this._slowStartConfig.internalValue = value.slowStartConfig;
    }
  }

  // choice_count - computed: false, optional: true, required: false
  private _choiceCount?: number; 
  public get choiceCount() {
    return this.getNumberAttribute('choice_count');
  }
  public set choiceCount(value: number) {
    this._choiceCount = value;
  }
  public resetChoiceCount() {
    this._choiceCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get choiceCountInput() {
    return this._choiceCount;
  }

  // slow_start_config - computed: false, optional: true, required: false
  private _slowStartConfig = new DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfigOutputReference(this, "slow_start_config");
  public get slowStartConfig() {
    return this._slowStartConfig;
  }
  public putSlowStartConfig(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestSlowStartConfig) {
    this._slowStartConfig.internalValue = value;
  }
  public resetSlowStartConfig() {
    this._slowStartConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slowStartConfigInput() {
    return this._slowStartConfig.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#maximum_ring_size DataK8SGlooSoloIoUpstreamV1Manifest#maximum_ring_size}
  */
  readonly maximumRingSize?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#minimum_ring_size DataK8SGlooSoloIoUpstreamV1Manifest#minimum_ring_size}
  */
  readonly minimumRingSize?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    maximum_ring_size: cdktf.numberToTerraform(struct!.maximumRingSize),
    minimum_ring_size: cdktf.numberToTerraform(struct!.minimumRingSize),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    maximum_ring_size: {
      value: cdktf.numberToHclTerraform(struct!.maximumRingSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    minimum_ring_size: {
      value: cdktf.numberToHclTerraform(struct!.minimumRingSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maximumRingSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maximumRingSize = this._maximumRingSize;
    }
    if (this._minimumRingSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.minimumRingSize = this._minimumRingSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maximumRingSize = undefined;
      this._minimumRingSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maximumRingSize = value.maximumRingSize;
      this._minimumRingSize = value.minimumRingSize;
    }
  }

  // maximum_ring_size - computed: false, optional: true, required: false
  private _maximumRingSize?: number; 
  public get maximumRingSize() {
    return this.getNumberAttribute('maximum_ring_size');
  }
  public set maximumRingSize(value: number) {
    this._maximumRingSize = value;
  }
  public resetMaximumRingSize() {
    this._maximumRingSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maximumRingSizeInput() {
    return this._maximumRingSize;
  }

  // minimum_ring_size - computed: false, optional: true, required: false
  private _minimumRingSize?: number; 
  public get minimumRingSize() {
    return this.getNumberAttribute('minimum_ring_size');
  }
  public set minimumRingSize(value: number) {
    this._minimumRingSize = value;
  }
  public resetMinimumRingSize() {
    this._minimumRingSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minimumRingSizeInput() {
    return this._minimumRingSize;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ring_hash_config DataK8SGlooSoloIoUpstreamV1Manifest#ring_hash_config}
  */
  readonly ringHashConfig?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ring_hash_config: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfigToTerraform(struct!.ringHashConfig),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ring_hash_config: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfigToHclTerraform(struct!.ringHashConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ringHashConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ringHashConfig = this._ringHashConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ringHashConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ringHashConfig.internalValue = value.ringHashConfig;
    }
  }

  // ring_hash_config - computed: false, optional: true, required: false
  private _ringHashConfig = new DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfigOutputReference(this, "ring_hash_config");
  public get ringHashConfig() {
    return this._ringHashConfig;
  }
  public putRingHashConfig(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashRingHashConfig) {
    this._ringHashConfig.internalValue = value;
  }
  public resetRingHashConfig() {
    this._ringHashConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ringHashConfigInput() {
    return this._ringHashConfig.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#aggression DataK8SGlooSoloIoUpstreamV1Manifest#aggression}
  */
  readonly aggression?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#min_weight_percent DataK8SGlooSoloIoUpstreamV1Manifest#min_weight_percent}
  */
  readonly minWeightPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#slow_start_window DataK8SGlooSoloIoUpstreamV1Manifest#slow_start_window}
  */
  readonly slowStartWindow?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    aggression: cdktf.numberToTerraform(struct!.aggression),
    min_weight_percent: cdktf.numberToTerraform(struct!.minWeightPercent),
    slow_start_window: cdktf.stringToTerraform(struct!.slowStartWindow),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    aggression: {
      value: cdktf.numberToHclTerraform(struct!.aggression),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_weight_percent: {
      value: cdktf.numberToHclTerraform(struct!.minWeightPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    slow_start_window: {
      value: cdktf.stringToHclTerraform(struct!.slowStartWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._aggression !== undefined) {
      hasAnyValues = true;
      internalValueResult.aggression = this._aggression;
    }
    if (this._minWeightPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.minWeightPercent = this._minWeightPercent;
    }
    if (this._slowStartWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.slowStartWindow = this._slowStartWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._aggression = undefined;
      this._minWeightPercent = undefined;
      this._slowStartWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._aggression = value.aggression;
      this._minWeightPercent = value.minWeightPercent;
      this._slowStartWindow = value.slowStartWindow;
    }
  }

  // aggression - computed: false, optional: true, required: false
  private _aggression?: number; 
  public get aggression() {
    return this.getNumberAttribute('aggression');
  }
  public set aggression(value: number) {
    this._aggression = value;
  }
  public resetAggression() {
    this._aggression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aggressionInput() {
    return this._aggression;
  }

  // min_weight_percent - computed: false, optional: true, required: false
  private _minWeightPercent?: number; 
  public get minWeightPercent() {
    return this.getNumberAttribute('min_weight_percent');
  }
  public set minWeightPercent(value: number) {
    this._minWeightPercent = value;
  }
  public resetMinWeightPercent() {
    this._minWeightPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minWeightPercentInput() {
    return this._minWeightPercent;
  }

  // slow_start_window - computed: false, optional: true, required: false
  private _slowStartWindow?: string; 
  public get slowStartWindow() {
    return this.getStringAttribute('slow_start_window');
  }
  public set slowStartWindow(value: string) {
    this._slowStartWindow = value;
  }
  public resetSlowStartWindow() {
    this._slowStartWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slowStartWindowInput() {
    return this._slowStartWindow;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#slow_start_config DataK8SGlooSoloIoUpstreamV1Manifest#slow_start_config}
  */
  readonly slowStartConfig?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    slow_start_config: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfigToTerraform(struct!.slowStartConfig),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    slow_start_config: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfigToHclTerraform(struct!.slowStartConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._slowStartConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.slowStartConfig = this._slowStartConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._slowStartConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._slowStartConfig.internalValue = value.slowStartConfig;
    }
  }

  // slow_start_config - computed: false, optional: true, required: false
  private _slowStartConfig = new DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfigOutputReference(this, "slow_start_config");
  public get slowStartConfig() {
    return this._slowStartConfig;
  }
  public putSlowStartConfig(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinSlowStartConfig) {
    this._slowStartConfig.internalValue = value;
  }
  public resetSlowStartConfig() {
    this._slowStartConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get slowStartConfigInput() {
    return this._slowStartConfig.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#healthy_panic_threshold DataK8SGlooSoloIoUpstreamV1Manifest#healthy_panic_threshold}
  */
  readonly healthyPanicThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#least_request DataK8SGlooSoloIoUpstreamV1Manifest#least_request}
  */
  readonly leastRequest?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#locality_weighted_lb_config DataK8SGlooSoloIoUpstreamV1Manifest#locality_weighted_lb_config}
  */
  readonly localityWeightedLbConfig?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#maglev DataK8SGlooSoloIoUpstreamV1Manifest#maglev}
  */
  readonly maglev?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#random DataK8SGlooSoloIoUpstreamV1Manifest#random}
  */
  readonly random?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ring_hash DataK8SGlooSoloIoUpstreamV1Manifest#ring_hash}
  */
  readonly ringHash?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#round_robin DataK8SGlooSoloIoUpstreamV1Manifest#round_robin}
  */
  readonly roundRobin?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#update_merge_window DataK8SGlooSoloIoUpstreamV1Manifest#update_merge_window}
  */
  readonly updateMergeWindow?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#use_hostname_for_hashing DataK8SGlooSoloIoUpstreamV1Manifest#use_hostname_for_hashing}
  */
  readonly useHostnameForHashing?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    healthy_panic_threshold: cdktf.numberToTerraform(struct!.healthyPanicThreshold),
    least_request: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestToTerraform(struct!.leastRequest),
    locality_weighted_lb_config: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.localityWeightedLbConfig),
    maglev: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.maglev),
    random: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.random),
    ring_hash: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashToTerraform(struct!.ringHash),
    round_robin: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinToTerraform(struct!.roundRobin),
    update_merge_window: cdktf.stringToTerraform(struct!.updateMergeWindow),
    use_hostname_for_hashing: cdktf.booleanToTerraform(struct!.useHostnameForHashing),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    healthy_panic_threshold: {
      value: cdktf.numberToHclTerraform(struct!.healthyPanicThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    least_request: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestToHclTerraform(struct!.leastRequest),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest",
    },
    locality_weighted_lb_config: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.localityWeightedLbConfig),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    maglev: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.maglev),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    random: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.random),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    ring_hash: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashToHclTerraform(struct!.ringHash),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash",
    },
    round_robin: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinToHclTerraform(struct!.roundRobin),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin",
    },
    update_merge_window: {
      value: cdktf.stringToHclTerraform(struct!.updateMergeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_hostname_for_hashing: {
      value: cdktf.booleanToHclTerraform(struct!.useHostnameForHashing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._healthyPanicThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthyPanicThreshold = this._healthyPanicThreshold;
    }
    if (this._leastRequest?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.leastRequest = this._leastRequest?.internalValue;
    }
    if (this._localityWeightedLbConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.localityWeightedLbConfig = this._localityWeightedLbConfig;
    }
    if (this._maglev !== undefined) {
      hasAnyValues = true;
      internalValueResult.maglev = this._maglev;
    }
    if (this._random !== undefined) {
      hasAnyValues = true;
      internalValueResult.random = this._random;
    }
    if (this._ringHash?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ringHash = this._ringHash?.internalValue;
    }
    if (this._roundRobin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.roundRobin = this._roundRobin?.internalValue;
    }
    if (this._updateMergeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateMergeWindow = this._updateMergeWindow;
    }
    if (this._useHostnameForHashing !== undefined) {
      hasAnyValues = true;
      internalValueResult.useHostnameForHashing = this._useHostnameForHashing;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._healthyPanicThreshold = undefined;
      this._leastRequest.internalValue = undefined;
      this._localityWeightedLbConfig = undefined;
      this._maglev = undefined;
      this._random = undefined;
      this._ringHash.internalValue = undefined;
      this._roundRobin.internalValue = undefined;
      this._updateMergeWindow = undefined;
      this._useHostnameForHashing = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._healthyPanicThreshold = value.healthyPanicThreshold;
      this._leastRequest.internalValue = value.leastRequest;
      this._localityWeightedLbConfig = value.localityWeightedLbConfig;
      this._maglev = value.maglev;
      this._random = value.random;
      this._ringHash.internalValue = value.ringHash;
      this._roundRobin.internalValue = value.roundRobin;
      this._updateMergeWindow = value.updateMergeWindow;
      this._useHostnameForHashing = value.useHostnameForHashing;
    }
  }

  // healthy_panic_threshold - computed: false, optional: true, required: false
  private _healthyPanicThreshold?: number; 
  public get healthyPanicThreshold() {
    return this.getNumberAttribute('healthy_panic_threshold');
  }
  public set healthyPanicThreshold(value: number) {
    this._healthyPanicThreshold = value;
  }
  public resetHealthyPanicThreshold() {
    this._healthyPanicThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthyPanicThresholdInput() {
    return this._healthyPanicThreshold;
  }

  // least_request - computed: false, optional: true, required: false
  private _leastRequest = new DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequestOutputReference(this, "least_request");
  public get leastRequest() {
    return this._leastRequest;
  }
  public putLeastRequest(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigLeastRequest) {
    this._leastRequest.internalValue = value;
  }
  public resetLeastRequest() {
    this._leastRequest.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get leastRequestInput() {
    return this._leastRequest.internalValue;
  }

  // locality_weighted_lb_config - computed: false, optional: true, required: false
  private _localityWeightedLbConfig?: { [key: string]: string }; 
  public get localityWeightedLbConfig() {
    return this.getStringMapAttribute('locality_weighted_lb_config');
  }
  public set localityWeightedLbConfig(value: { [key: string]: string }) {
    this._localityWeightedLbConfig = value;
  }
  public resetLocalityWeightedLbConfig() {
    this._localityWeightedLbConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localityWeightedLbConfigInput() {
    return this._localityWeightedLbConfig;
  }

  // maglev - computed: false, optional: true, required: false
  private _maglev?: { [key: string]: string }; 
  public get maglev() {
    return this.getStringMapAttribute('maglev');
  }
  public set maglev(value: { [key: string]: string }) {
    this._maglev = value;
  }
  public resetMaglev() {
    this._maglev = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maglevInput() {
    return this._maglev;
  }

  // random - computed: false, optional: true, required: false
  private _random?: { [key: string]: string }; 
  public get random() {
    return this.getStringMapAttribute('random');
  }
  public set random(value: { [key: string]: string }) {
    this._random = value;
  }
  public resetRandom() {
    this._random = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get randomInput() {
    return this._random;
  }

  // ring_hash - computed: false, optional: true, required: false
  private _ringHash = new DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHashOutputReference(this, "ring_hash");
  public get ringHash() {
    return this._ringHash;
  }
  public putRingHash(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRingHash) {
    this._ringHash.internalValue = value;
  }
  public resetRingHash() {
    this._ringHash.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ringHashInput() {
    return this._ringHash.internalValue;
  }

  // round_robin - computed: false, optional: true, required: false
  private _roundRobin = new DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobinOutputReference(this, "round_robin");
  public get roundRobin() {
    return this._roundRobin;
  }
  public putRoundRobin(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecLoadBalancerConfigRoundRobin) {
    this._roundRobin.internalValue = value;
  }
  public resetRoundRobin() {
    this._roundRobin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roundRobinInput() {
    return this._roundRobin.internalValue;
  }

  // update_merge_window - computed: false, optional: true, required: false
  private _updateMergeWindow?: string; 
  public get updateMergeWindow() {
    return this.getStringAttribute('update_merge_window');
  }
  public set updateMergeWindow(value: string) {
    this._updateMergeWindow = value;
  }
  public resetUpdateMergeWindow() {
    this._updateMergeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateMergeWindowInput() {
    return this._updateMergeWindow;
  }

  // use_hostname_for_hashing - computed: false, optional: true, required: false
  private _useHostnameForHashing?: boolean | cdktf.IResolvable; 
  public get useHostnameForHashing() {
    return this.getBooleanAttribute('use_hostname_for_hashing');
  }
  public set useHostnameForHashing(value: boolean | cdktf.IResolvable) {
    this._useHostnameForHashing = value;
  }
  public resetUseHostnameForHashing() {
    this._useHostnameForHashing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useHostnameForHashingInput() {
    return this._useHostnameForHashing;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatuses {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#statuses DataK8SGlooSoloIoUpstreamV1Manifest#statuses}
  */
  readonly statuses?: { [key: string]: string };
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatusesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    statuses: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.statuses),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatusesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    statuses: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.statuses),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatusesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._statuses !== undefined) {
      hasAnyValues = true;
      internalValueResult.statuses = this._statuses;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._statuses = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._statuses = value.statuses;
    }
  }

  // statuses - computed: false, optional: true, required: false
  private _statuses?: { [key: string]: string }; 
  public get statuses() {
    return this.getStringMapAttribute('statuses');
  }
  public set statuses(value: { [key: string]: string }) {
    this._statuses = value;
  }
  public resetStatuses() {
    this._statuses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusesInput() {
    return this._statuses;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetection {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#base_ejection_time DataK8SGlooSoloIoUpstreamV1Manifest#base_ejection_time}
  */
  readonly baseEjectionTime?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#consecutive5xx DataK8SGlooSoloIoUpstreamV1Manifest#consecutive5xx}
  */
  readonly consecutive5Xx?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#consecutive_gateway_failure DataK8SGlooSoloIoUpstreamV1Manifest#consecutive_gateway_failure}
  */
  readonly consecutiveGatewayFailure?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#consecutive_local_origin_failure DataK8SGlooSoloIoUpstreamV1Manifest#consecutive_local_origin_failure}
  */
  readonly consecutiveLocalOriginFailure?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#enforcing_consecutive5xx DataK8SGlooSoloIoUpstreamV1Manifest#enforcing_consecutive5xx}
  */
  readonly enforcingConsecutive5Xx?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#enforcing_consecutive_gateway_failure DataK8SGlooSoloIoUpstreamV1Manifest#enforcing_consecutive_gateway_failure}
  */
  readonly enforcingConsecutiveGatewayFailure?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#enforcing_consecutive_local_origin_failure DataK8SGlooSoloIoUpstreamV1Manifest#enforcing_consecutive_local_origin_failure}
  */
  readonly enforcingConsecutiveLocalOriginFailure?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#enforcing_local_origin_success_rate DataK8SGlooSoloIoUpstreamV1Manifest#enforcing_local_origin_success_rate}
  */
  readonly enforcingLocalOriginSuccessRate?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#enforcing_success_rate DataK8SGlooSoloIoUpstreamV1Manifest#enforcing_success_rate}
  */
  readonly enforcingSuccessRate?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#interval DataK8SGlooSoloIoUpstreamV1Manifest#interval}
  */
  readonly interval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#max_ejection_percent DataK8SGlooSoloIoUpstreamV1Manifest#max_ejection_percent}
  */
  readonly maxEjectionPercent?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#split_external_local_origin_errors DataK8SGlooSoloIoUpstreamV1Manifest#split_external_local_origin_errors}
  */
  readonly splitExternalLocalOriginErrors?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#success_rate_minimum_hosts DataK8SGlooSoloIoUpstreamV1Manifest#success_rate_minimum_hosts}
  */
  readonly successRateMinimumHosts?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#success_rate_request_volume DataK8SGlooSoloIoUpstreamV1Manifest#success_rate_request_volume}
  */
  readonly successRateRequestVolume?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#success_rate_stdev_factor DataK8SGlooSoloIoUpstreamV1Manifest#success_rate_stdev_factor}
  */
  readonly successRateStdevFactor?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetectionToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_ejection_time: cdktf.stringToTerraform(struct!.baseEjectionTime),
    consecutive5xx: cdktf.numberToTerraform(struct!.consecutive5Xx),
    consecutive_gateway_failure: cdktf.numberToTerraform(struct!.consecutiveGatewayFailure),
    consecutive_local_origin_failure: cdktf.numberToTerraform(struct!.consecutiveLocalOriginFailure),
    enforcing_consecutive5xx: cdktf.numberToTerraform(struct!.enforcingConsecutive5Xx),
    enforcing_consecutive_gateway_failure: cdktf.numberToTerraform(struct!.enforcingConsecutiveGatewayFailure),
    enforcing_consecutive_local_origin_failure: cdktf.numberToTerraform(struct!.enforcingConsecutiveLocalOriginFailure),
    enforcing_local_origin_success_rate: cdktf.numberToTerraform(struct!.enforcingLocalOriginSuccessRate),
    enforcing_success_rate: cdktf.numberToTerraform(struct!.enforcingSuccessRate),
    interval: cdktf.stringToTerraform(struct!.interval),
    max_ejection_percent: cdktf.numberToTerraform(struct!.maxEjectionPercent),
    split_external_local_origin_errors: cdktf.booleanToTerraform(struct!.splitExternalLocalOriginErrors),
    success_rate_minimum_hosts: cdktf.numberToTerraform(struct!.successRateMinimumHosts),
    success_rate_request_volume: cdktf.numberToTerraform(struct!.successRateRequestVolume),
    success_rate_stdev_factor: cdktf.numberToTerraform(struct!.successRateStdevFactor),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetectionToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_ejection_time: {
      value: cdktf.stringToHclTerraform(struct!.baseEjectionTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    consecutive5xx: {
      value: cdktf.numberToHclTerraform(struct!.consecutive5Xx),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    consecutive_gateway_failure: {
      value: cdktf.numberToHclTerraform(struct!.consecutiveGatewayFailure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    consecutive_local_origin_failure: {
      value: cdktf.numberToHclTerraform(struct!.consecutiveLocalOriginFailure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enforcing_consecutive5xx: {
      value: cdktf.numberToHclTerraform(struct!.enforcingConsecutive5Xx),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enforcing_consecutive_gateway_failure: {
      value: cdktf.numberToHclTerraform(struct!.enforcingConsecutiveGatewayFailure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enforcing_consecutive_local_origin_failure: {
      value: cdktf.numberToHclTerraform(struct!.enforcingConsecutiveLocalOriginFailure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enforcing_local_origin_success_rate: {
      value: cdktf.numberToHclTerraform(struct!.enforcingLocalOriginSuccessRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enforcing_success_rate: {
      value: cdktf.numberToHclTerraform(struct!.enforcingSuccessRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    interval: {
      value: cdktf.stringToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_ejection_percent: {
      value: cdktf.numberToHclTerraform(struct!.maxEjectionPercent),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    split_external_local_origin_errors: {
      value: cdktf.booleanToHclTerraform(struct!.splitExternalLocalOriginErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    success_rate_minimum_hosts: {
      value: cdktf.numberToHclTerraform(struct!.successRateMinimumHosts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    success_rate_request_volume: {
      value: cdktf.numberToHclTerraform(struct!.successRateRequestVolume),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    success_rate_stdev_factor: {
      value: cdktf.numberToHclTerraform(struct!.successRateStdevFactor),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseEjectionTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseEjectionTime = this._baseEjectionTime;
    }
    if (this._consecutive5Xx !== undefined) {
      hasAnyValues = true;
      internalValueResult.consecutive5Xx = this._consecutive5Xx;
    }
    if (this._consecutiveGatewayFailure !== undefined) {
      hasAnyValues = true;
      internalValueResult.consecutiveGatewayFailure = this._consecutiveGatewayFailure;
    }
    if (this._consecutiveLocalOriginFailure !== undefined) {
      hasAnyValues = true;
      internalValueResult.consecutiveLocalOriginFailure = this._consecutiveLocalOriginFailure;
    }
    if (this._enforcingConsecutive5Xx !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforcingConsecutive5Xx = this._enforcingConsecutive5Xx;
    }
    if (this._enforcingConsecutiveGatewayFailure !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforcingConsecutiveGatewayFailure = this._enforcingConsecutiveGatewayFailure;
    }
    if (this._enforcingConsecutiveLocalOriginFailure !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforcingConsecutiveLocalOriginFailure = this._enforcingConsecutiveLocalOriginFailure;
    }
    if (this._enforcingLocalOriginSuccessRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforcingLocalOriginSuccessRate = this._enforcingLocalOriginSuccessRate;
    }
    if (this._enforcingSuccessRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.enforcingSuccessRate = this._enforcingSuccessRate;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._maxEjectionPercent !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxEjectionPercent = this._maxEjectionPercent;
    }
    if (this._splitExternalLocalOriginErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.splitExternalLocalOriginErrors = this._splitExternalLocalOriginErrors;
    }
    if (this._successRateMinimumHosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.successRateMinimumHosts = this._successRateMinimumHosts;
    }
    if (this._successRateRequestVolume !== undefined) {
      hasAnyValues = true;
      internalValueResult.successRateRequestVolume = this._successRateRequestVolume;
    }
    if (this._successRateStdevFactor !== undefined) {
      hasAnyValues = true;
      internalValueResult.successRateStdevFactor = this._successRateStdevFactor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecOutlierDetection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseEjectionTime = undefined;
      this._consecutive5Xx = undefined;
      this._consecutiveGatewayFailure = undefined;
      this._consecutiveLocalOriginFailure = undefined;
      this._enforcingConsecutive5Xx = undefined;
      this._enforcingConsecutiveGatewayFailure = undefined;
      this._enforcingConsecutiveLocalOriginFailure = undefined;
      this._enforcingLocalOriginSuccessRate = undefined;
      this._enforcingSuccessRate = undefined;
      this._interval = undefined;
      this._maxEjectionPercent = undefined;
      this._splitExternalLocalOriginErrors = undefined;
      this._successRateMinimumHosts = undefined;
      this._successRateRequestVolume = undefined;
      this._successRateStdevFactor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseEjectionTime = value.baseEjectionTime;
      this._consecutive5Xx = value.consecutive5Xx;
      this._consecutiveGatewayFailure = value.consecutiveGatewayFailure;
      this._consecutiveLocalOriginFailure = value.consecutiveLocalOriginFailure;
      this._enforcingConsecutive5Xx = value.enforcingConsecutive5Xx;
      this._enforcingConsecutiveGatewayFailure = value.enforcingConsecutiveGatewayFailure;
      this._enforcingConsecutiveLocalOriginFailure = value.enforcingConsecutiveLocalOriginFailure;
      this._enforcingLocalOriginSuccessRate = value.enforcingLocalOriginSuccessRate;
      this._enforcingSuccessRate = value.enforcingSuccessRate;
      this._interval = value.interval;
      this._maxEjectionPercent = value.maxEjectionPercent;
      this._splitExternalLocalOriginErrors = value.splitExternalLocalOriginErrors;
      this._successRateMinimumHosts = value.successRateMinimumHosts;
      this._successRateRequestVolume = value.successRateRequestVolume;
      this._successRateStdevFactor = value.successRateStdevFactor;
    }
  }

  // base_ejection_time - computed: false, optional: true, required: false
  private _baseEjectionTime?: string; 
  public get baseEjectionTime() {
    return this.getStringAttribute('base_ejection_time');
  }
  public set baseEjectionTime(value: string) {
    this._baseEjectionTime = value;
  }
  public resetBaseEjectionTime() {
    this._baseEjectionTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseEjectionTimeInput() {
    return this._baseEjectionTime;
  }

  // consecutive5xx - computed: false, optional: true, required: false
  private _consecutive5Xx?: number; 
  public get consecutive5Xx() {
    return this.getNumberAttribute('consecutive5xx');
  }
  public set consecutive5Xx(value: number) {
    this._consecutive5Xx = value;
  }
  public resetConsecutive5Xx() {
    this._consecutive5Xx = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consecutive5XxInput() {
    return this._consecutive5Xx;
  }

  // consecutive_gateway_failure - computed: false, optional: true, required: false
  private _consecutiveGatewayFailure?: number; 
  public get consecutiveGatewayFailure() {
    return this.getNumberAttribute('consecutive_gateway_failure');
  }
  public set consecutiveGatewayFailure(value: number) {
    this._consecutiveGatewayFailure = value;
  }
  public resetConsecutiveGatewayFailure() {
    this._consecutiveGatewayFailure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consecutiveGatewayFailureInput() {
    return this._consecutiveGatewayFailure;
  }

  // consecutive_local_origin_failure - computed: false, optional: true, required: false
  private _consecutiveLocalOriginFailure?: number; 
  public get consecutiveLocalOriginFailure() {
    return this.getNumberAttribute('consecutive_local_origin_failure');
  }
  public set consecutiveLocalOriginFailure(value: number) {
    this._consecutiveLocalOriginFailure = value;
  }
  public resetConsecutiveLocalOriginFailure() {
    this._consecutiveLocalOriginFailure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get consecutiveLocalOriginFailureInput() {
    return this._consecutiveLocalOriginFailure;
  }

  // enforcing_consecutive5xx - computed: false, optional: true, required: false
  private _enforcingConsecutive5Xx?: number; 
  public get enforcingConsecutive5Xx() {
    return this.getNumberAttribute('enforcing_consecutive5xx');
  }
  public set enforcingConsecutive5Xx(value: number) {
    this._enforcingConsecutive5Xx = value;
  }
  public resetEnforcingConsecutive5Xx() {
    this._enforcingConsecutive5Xx = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforcingConsecutive5XxInput() {
    return this._enforcingConsecutive5Xx;
  }

  // enforcing_consecutive_gateway_failure - computed: false, optional: true, required: false
  private _enforcingConsecutiveGatewayFailure?: number; 
  public get enforcingConsecutiveGatewayFailure() {
    return this.getNumberAttribute('enforcing_consecutive_gateway_failure');
  }
  public set enforcingConsecutiveGatewayFailure(value: number) {
    this._enforcingConsecutiveGatewayFailure = value;
  }
  public resetEnforcingConsecutiveGatewayFailure() {
    this._enforcingConsecutiveGatewayFailure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforcingConsecutiveGatewayFailureInput() {
    return this._enforcingConsecutiveGatewayFailure;
  }

  // enforcing_consecutive_local_origin_failure - computed: false, optional: true, required: false
  private _enforcingConsecutiveLocalOriginFailure?: number; 
  public get enforcingConsecutiveLocalOriginFailure() {
    return this.getNumberAttribute('enforcing_consecutive_local_origin_failure');
  }
  public set enforcingConsecutiveLocalOriginFailure(value: number) {
    this._enforcingConsecutiveLocalOriginFailure = value;
  }
  public resetEnforcingConsecutiveLocalOriginFailure() {
    this._enforcingConsecutiveLocalOriginFailure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforcingConsecutiveLocalOriginFailureInput() {
    return this._enforcingConsecutiveLocalOriginFailure;
  }

  // enforcing_local_origin_success_rate - computed: false, optional: true, required: false
  private _enforcingLocalOriginSuccessRate?: number; 
  public get enforcingLocalOriginSuccessRate() {
    return this.getNumberAttribute('enforcing_local_origin_success_rate');
  }
  public set enforcingLocalOriginSuccessRate(value: number) {
    this._enforcingLocalOriginSuccessRate = value;
  }
  public resetEnforcingLocalOriginSuccessRate() {
    this._enforcingLocalOriginSuccessRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforcingLocalOriginSuccessRateInput() {
    return this._enforcingLocalOriginSuccessRate;
  }

  // enforcing_success_rate - computed: false, optional: true, required: false
  private _enforcingSuccessRate?: number; 
  public get enforcingSuccessRate() {
    return this.getNumberAttribute('enforcing_success_rate');
  }
  public set enforcingSuccessRate(value: number) {
    this._enforcingSuccessRate = value;
  }
  public resetEnforcingSuccessRate() {
    this._enforcingSuccessRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforcingSuccessRateInput() {
    return this._enforcingSuccessRate;
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // max_ejection_percent - computed: false, optional: true, required: false
  private _maxEjectionPercent?: number; 
  public get maxEjectionPercent() {
    return this.getNumberAttribute('max_ejection_percent');
  }
  public set maxEjectionPercent(value: number) {
    this._maxEjectionPercent = value;
  }
  public resetMaxEjectionPercent() {
    this._maxEjectionPercent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxEjectionPercentInput() {
    return this._maxEjectionPercent;
  }

  // split_external_local_origin_errors - computed: false, optional: true, required: false
  private _splitExternalLocalOriginErrors?: boolean | cdktf.IResolvable; 
  public get splitExternalLocalOriginErrors() {
    return this.getBooleanAttribute('split_external_local_origin_errors');
  }
  public set splitExternalLocalOriginErrors(value: boolean | cdktf.IResolvable) {
    this._splitExternalLocalOriginErrors = value;
  }
  public resetSplitExternalLocalOriginErrors() {
    this._splitExternalLocalOriginErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splitExternalLocalOriginErrorsInput() {
    return this._splitExternalLocalOriginErrors;
  }

  // success_rate_minimum_hosts - computed: false, optional: true, required: false
  private _successRateMinimumHosts?: number; 
  public get successRateMinimumHosts() {
    return this.getNumberAttribute('success_rate_minimum_hosts');
  }
  public set successRateMinimumHosts(value: number) {
    this._successRateMinimumHosts = value;
  }
  public resetSuccessRateMinimumHosts() {
    this._successRateMinimumHosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successRateMinimumHostsInput() {
    return this._successRateMinimumHosts;
  }

  // success_rate_request_volume - computed: false, optional: true, required: false
  private _successRateRequestVolume?: number; 
  public get successRateRequestVolume() {
    return this.getNumberAttribute('success_rate_request_volume');
  }
  public set successRateRequestVolume(value: number) {
    this._successRateRequestVolume = value;
  }
  public resetSuccessRateRequestVolume() {
    this._successRateRequestVolume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successRateRequestVolumeInput() {
    return this._successRateRequestVolume;
  }

  // success_rate_stdev_factor - computed: false, optional: true, required: false
  private _successRateStdevFactor?: number; 
  public get successRateStdevFactor() {
    return this.getNumberAttribute('success_rate_stdev_factor');
  }
  public set successRateStdevFactor(value: number) {
    this._successRateStdevFactor = value;
  }
  public resetSuccessRateStdevFactor() {
    this._successRateStdevFactor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successRateStdevFactorInput() {
    return this._successRateStdevFactor;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#url DataK8SGlooSoloIoUpstreamV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpointToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpointToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpointOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphql {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#endpoint DataK8SGlooSoloIoUpstreamV1Manifest#endpoint}
  */
  readonly endpoint?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpointToTerraform(struct!.endpoint),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphql | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpointToHclTerraform(struct!.endpoint),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphql | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphql | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint.internalValue = value.endpoint;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint = new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpointOutputReference(this, "endpoint");
  public get endpoint() {
    return this._endpoint;
  }
  public putEndpoint(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGraphqlEndpoint) {
    this._endpoint.internalValue = value;
  }
  public resetEndpoint() {
    this._endpoint.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#function_names DataK8SGlooSoloIoUpstreamV1Manifest#function_names}
  */
  readonly functionNames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#package_name DataK8SGlooSoloIoUpstreamV1Manifest#package_name}
  */
  readonly packageName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#service_name DataK8SGlooSoloIoUpstreamV1Manifest#service_name}
  */
  readonly serviceName?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    function_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.functionNames),
    package_name: cdktf.stringToTerraform(struct!.packageName),
    service_name: cdktf.stringToTerraform(struct!.serviceName),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    function_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.functionNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    package_name: {
      value: cdktf.stringToHclTerraform(struct!.packageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._functionNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionNames = this._functionNames;
    }
    if (this._packageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.packageName = this._packageName;
    }
    if (this._serviceName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceName = this._serviceName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._functionNames = undefined;
      this._packageName = undefined;
      this._serviceName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._functionNames = value.functionNames;
      this._packageName = value.packageName;
      this._serviceName = value.serviceName;
    }
  }

  // function_names - computed: false, optional: true, required: false
  private _functionNames?: string[]; 
  public get functionNames() {
    return this.getListAttribute('function_names');
  }
  public set functionNames(value: string[]) {
    this._functionNames = value;
  }
  public resetFunctionNames() {
    this._functionNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionNamesInput() {
    return this._functionNames;
  }

  // package_name - computed: false, optional: true, required: false
  private _packageName?: string; 
  public get packageName() {
    return this.getStringAttribute('package_name');
  }
  public set packageName(value: string) {
    this._packageName = value;
  }
  public resetPackageName() {
    this._packageName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packageNameInput() {
    return this._packageName;
  }

  // service_name - computed: false, optional: true, required: false
  private _serviceName?: string; 
  public get serviceName() {
    return this.getStringAttribute('service_name');
  }
  public set serviceName(value: string) {
    this._serviceName = value;
  }
  public resetServiceName() {
    this._serviceName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceNameInput() {
    return this._serviceName;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#descriptors DataK8SGlooSoloIoUpstreamV1Manifest#descriptors}
  */
  readonly descriptors?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#grpc_services DataK8SGlooSoloIoUpstreamV1Manifest#grpc_services}
  */
  readonly grpcServices?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices[] | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptors: cdktf.stringToTerraform(struct!.descriptors),
    grpc_services: cdktf.listMapper(dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesToTerraform, false)(struct!.grpcServices),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptors: {
      value: cdktf.stringToHclTerraform(struct!.descriptors),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grpc_services: {
      value: cdktf.listMapperHcl(dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesToHclTerraform, false)(struct!.grpcServices),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptors !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptors = this._descriptors;
    }
    if (this._grpcServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcServices = this._grpcServices?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptors = undefined;
      this._grpcServices.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptors = value.descriptors;
      this._grpcServices.internalValue = value.grpcServices;
    }
  }

  // descriptors - computed: false, optional: true, required: false
  private _descriptors?: string; 
  public get descriptors() {
    return this.getStringAttribute('descriptors');
  }
  public set descriptors(value: string) {
    this._descriptors = value;
  }
  public resetDescriptors() {
    this._descriptors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorsInput() {
    return this._descriptors;
  }

  // grpc_services - computed: false, optional: true, required: false
  private _grpcServices = new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServicesList(this, "grpc_services", false);
  public get grpcServices() {
    return this._grpcServices;
  }
  public putGrpcServices(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcGrpcServices[] | cdktf.IResolvable) {
    this._grpcServices.internalValue = value;
  }
  public resetGrpcServices() {
    this._grpcServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServicesInput() {
    return this._grpcServices.internalValue;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#add_whitespace DataK8SGlooSoloIoUpstreamV1Manifest#add_whitespace}
  */
  readonly addWhitespace?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_print_enums_as_ints DataK8SGlooSoloIoUpstreamV1Manifest#always_print_enums_as_ints}
  */
  readonly alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#always_print_primitive_fields DataK8SGlooSoloIoUpstreamV1Manifest#always_print_primitive_fields}
  */
  readonly alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#preserve_proto_field_names DataK8SGlooSoloIoUpstreamV1Manifest#preserve_proto_field_names}
  */
  readonly preserveProtoFieldNames?: boolean | cdktf.IResolvable;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptionsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_whitespace: cdktf.booleanToTerraform(struct!.addWhitespace),
    always_print_enums_as_ints: cdktf.booleanToTerraform(struct!.alwaysPrintEnumsAsInts),
    always_print_primitive_fields: cdktf.booleanToTerraform(struct!.alwaysPrintPrimitiveFields),
    preserve_proto_field_names: cdktf.booleanToTerraform(struct!.preserveProtoFieldNames),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptionsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_whitespace: {
      value: cdktf.booleanToHclTerraform(struct!.addWhitespace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_enums_as_ints: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintEnumsAsInts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    always_print_primitive_fields: {
      value: cdktf.booleanToHclTerraform(struct!.alwaysPrintPrimitiveFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preserve_proto_field_names: {
      value: cdktf.booleanToHclTerraform(struct!.preserveProtoFieldNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addWhitespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.addWhitespace = this._addWhitespace;
    }
    if (this._alwaysPrintEnumsAsInts !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintEnumsAsInts = this._alwaysPrintEnumsAsInts;
    }
    if (this._alwaysPrintPrimitiveFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.alwaysPrintPrimitiveFields = this._alwaysPrintPrimitiveFields;
    }
    if (this._preserveProtoFieldNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveProtoFieldNames = this._preserveProtoFieldNames;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addWhitespace = undefined;
      this._alwaysPrintEnumsAsInts = undefined;
      this._alwaysPrintPrimitiveFields = undefined;
      this._preserveProtoFieldNames = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addWhitespace = value.addWhitespace;
      this._alwaysPrintEnumsAsInts = value.alwaysPrintEnumsAsInts;
      this._alwaysPrintPrimitiveFields = value.alwaysPrintPrimitiveFields;
      this._preserveProtoFieldNames = value.preserveProtoFieldNames;
    }
  }

  // add_whitespace - computed: false, optional: true, required: false
  private _addWhitespace?: boolean | cdktf.IResolvable; 
  public get addWhitespace() {
    return this.getBooleanAttribute('add_whitespace');
  }
  public set addWhitespace(value: boolean | cdktf.IResolvable) {
    this._addWhitespace = value;
  }
  public resetAddWhitespace() {
    this._addWhitespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addWhitespaceInput() {
    return this._addWhitespace;
  }

  // always_print_enums_as_ints - computed: false, optional: true, required: false
  private _alwaysPrintEnumsAsInts?: boolean | cdktf.IResolvable; 
  public get alwaysPrintEnumsAsInts() {
    return this.getBooleanAttribute('always_print_enums_as_ints');
  }
  public set alwaysPrintEnumsAsInts(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintEnumsAsInts = value;
  }
  public resetAlwaysPrintEnumsAsInts() {
    this._alwaysPrintEnumsAsInts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintEnumsAsIntsInput() {
    return this._alwaysPrintEnumsAsInts;
  }

  // always_print_primitive_fields - computed: false, optional: true, required: false
  private _alwaysPrintPrimitiveFields?: boolean | cdktf.IResolvable; 
  public get alwaysPrintPrimitiveFields() {
    return this.getBooleanAttribute('always_print_primitive_fields');
  }
  public set alwaysPrintPrimitiveFields(value: boolean | cdktf.IResolvable) {
    this._alwaysPrintPrimitiveFields = value;
  }
  public resetAlwaysPrintPrimitiveFields() {
    this._alwaysPrintPrimitiveFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alwaysPrintPrimitiveFieldsInput() {
    return this._alwaysPrintPrimitiveFields;
  }

  // preserve_proto_field_names - computed: false, optional: true, required: false
  private _preserveProtoFieldNames?: boolean | cdktf.IResolvable; 
  public get preserveProtoFieldNames() {
    return this.getBooleanAttribute('preserve_proto_field_names');
  }
  public set preserveProtoFieldNames(value: boolean | cdktf.IResolvable) {
    this._preserveProtoFieldNames = value;
  }
  public resetPreserveProtoFieldNames() {
    this._preserveProtoFieldNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveProtoFieldNamesInput() {
    return this._preserveProtoFieldNames;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#name DataK8SGlooSoloIoUpstreamV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#namespace DataK8SGlooSoloIoUpstreamV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#config_map_ref DataK8SGlooSoloIoUpstreamV1Manifest#config_map_ref}
  */
  readonly configMapRef?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_ref: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToTerraform(struct!.configMapRef),
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_ref: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefToHclTerraform(struct!.configMapRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapRef = this._configMapRef?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapRef.internalValue = value.configMapRef;
      this._key = value.key;
    }
  }

  // config_map_ref - computed: false, optional: true, required: false
  private _configMapRef = new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRefOutputReference(this, "config_map_ref");
  public get configMapRef() {
    return this._configMapRef;
  }
  public putConfigMapRef(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapConfigMapRef) {
    this._configMapRef.internalValue = value;
  }
  public resetConfigMapRef() {
    this._configMapRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapRefInput() {
    return this._configMapRef.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoder {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#auto_mapping DataK8SGlooSoloIoUpstreamV1Manifest#auto_mapping}
  */
  readonly autoMapping?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#convert_grpc_status DataK8SGlooSoloIoUpstreamV1Manifest#convert_grpc_status}
  */
  readonly convertGrpcStatus?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignore_unknown_query_parameters DataK8SGlooSoloIoUpstreamV1Manifest#ignore_unknown_query_parameters}
  */
  readonly ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#ignored_query_parameters DataK8SGlooSoloIoUpstreamV1Manifest#ignored_query_parameters}
  */
  readonly ignoredQueryParameters?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#match_incoming_request_route DataK8SGlooSoloIoUpstreamV1Manifest#match_incoming_request_route}
  */
  readonly matchIncomingRequestRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#print_options DataK8SGlooSoloIoUpstreamV1Manifest#print_options}
  */
  readonly printOptions?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor}
  */
  readonly protoDescriptor?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor_bin DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor_bin}
  */
  readonly protoDescriptorBin?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#proto_descriptor_config_map DataK8SGlooSoloIoUpstreamV1Manifest#proto_descriptor_config_map}
  */
  readonly protoDescriptorConfigMap?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#services DataK8SGlooSoloIoUpstreamV1Manifest#services}
  */
  readonly services?: string[];
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_mapping: cdktf.booleanToTerraform(struct!.autoMapping),
    convert_grpc_status: cdktf.booleanToTerraform(struct!.convertGrpcStatus),
    ignore_unknown_query_parameters: cdktf.booleanToTerraform(struct!.ignoreUnknownQueryParameters),
    ignored_query_parameters: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.ignoredQueryParameters),
    match_incoming_request_route: cdktf.booleanToTerraform(struct!.matchIncomingRequestRoute),
    print_options: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptionsToTerraform(struct!.printOptions),
    proto_descriptor: cdktf.stringToTerraform(struct!.protoDescriptor),
    proto_descriptor_bin: cdktf.stringToTerraform(struct!.protoDescriptorBin),
    proto_descriptor_config_map: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToTerraform(struct!.protoDescriptorConfigMap),
    services: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.services),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_mapping: {
      value: cdktf.booleanToHclTerraform(struct!.autoMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    convert_grpc_status: {
      value: cdktf.booleanToHclTerraform(struct!.convertGrpcStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignore_unknown_query_parameters: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreUnknownQueryParameters),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ignored_query_parameters: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.ignoredQueryParameters),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    match_incoming_request_route: {
      value: cdktf.booleanToHclTerraform(struct!.matchIncomingRequestRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    print_options: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptionsToHclTerraform(struct!.printOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions",
    },
    proto_descriptor: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_bin: {
      value: cdktf.stringToHclTerraform(struct!.protoDescriptorBin),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proto_descriptor_config_map: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapToHclTerraform(struct!.protoDescriptorConfigMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap",
    },
    services: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.services),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoMapping = this._autoMapping;
    }
    if (this._convertGrpcStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.convertGrpcStatus = this._convertGrpcStatus;
    }
    if (this._ignoreUnknownQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreUnknownQueryParameters = this._ignoreUnknownQueryParameters;
    }
    if (this._ignoredQueryParameters !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoredQueryParameters = this._ignoredQueryParameters;
    }
    if (this._matchIncomingRequestRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchIncomingRequestRoute = this._matchIncomingRequestRoute;
    }
    if (this._printOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.printOptions = this._printOptions?.internalValue;
    }
    if (this._protoDescriptor !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptor = this._protoDescriptor;
    }
    if (this._protoDescriptorBin !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorBin = this._protoDescriptorBin;
    }
    if (this._protoDescriptorConfigMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.protoDescriptorConfigMap = this._protoDescriptorConfigMap?.internalValue;
    }
    if (this._services !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoder | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoMapping = undefined;
      this._convertGrpcStatus = undefined;
      this._ignoreUnknownQueryParameters = undefined;
      this._ignoredQueryParameters = undefined;
      this._matchIncomingRequestRoute = undefined;
      this._printOptions.internalValue = undefined;
      this._protoDescriptor = undefined;
      this._protoDescriptorBin = undefined;
      this._protoDescriptorConfigMap.internalValue = undefined;
      this._services = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoMapping = value.autoMapping;
      this._convertGrpcStatus = value.convertGrpcStatus;
      this._ignoreUnknownQueryParameters = value.ignoreUnknownQueryParameters;
      this._ignoredQueryParameters = value.ignoredQueryParameters;
      this._matchIncomingRequestRoute = value.matchIncomingRequestRoute;
      this._printOptions.internalValue = value.printOptions;
      this._protoDescriptor = value.protoDescriptor;
      this._protoDescriptorBin = value.protoDescriptorBin;
      this._protoDescriptorConfigMap.internalValue = value.protoDescriptorConfigMap;
      this._services = value.services;
    }
  }

  // auto_mapping - computed: false, optional: true, required: false
  private _autoMapping?: boolean | cdktf.IResolvable; 
  public get autoMapping() {
    return this.getBooleanAttribute('auto_mapping');
  }
  public set autoMapping(value: boolean | cdktf.IResolvable) {
    this._autoMapping = value;
  }
  public resetAutoMapping() {
    this._autoMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoMappingInput() {
    return this._autoMapping;
  }

  // convert_grpc_status - computed: false, optional: true, required: false
  private _convertGrpcStatus?: boolean | cdktf.IResolvable; 
  public get convertGrpcStatus() {
    return this.getBooleanAttribute('convert_grpc_status');
  }
  public set convertGrpcStatus(value: boolean | cdktf.IResolvable) {
    this._convertGrpcStatus = value;
  }
  public resetConvertGrpcStatus() {
    this._convertGrpcStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get convertGrpcStatusInput() {
    return this._convertGrpcStatus;
  }

  // ignore_unknown_query_parameters - computed: false, optional: true, required: false
  private _ignoreUnknownQueryParameters?: boolean | cdktf.IResolvable; 
  public get ignoreUnknownQueryParameters() {
    return this.getBooleanAttribute('ignore_unknown_query_parameters');
  }
  public set ignoreUnknownQueryParameters(value: boolean | cdktf.IResolvable) {
    this._ignoreUnknownQueryParameters = value;
  }
  public resetIgnoreUnknownQueryParameters() {
    this._ignoreUnknownQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreUnknownQueryParametersInput() {
    return this._ignoreUnknownQueryParameters;
  }

  // ignored_query_parameters - computed: false, optional: true, required: false
  private _ignoredQueryParameters?: string[]; 
  public get ignoredQueryParameters() {
    return this.getListAttribute('ignored_query_parameters');
  }
  public set ignoredQueryParameters(value: string[]) {
    this._ignoredQueryParameters = value;
  }
  public resetIgnoredQueryParameters() {
    this._ignoredQueryParameters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoredQueryParametersInput() {
    return this._ignoredQueryParameters;
  }

  // match_incoming_request_route - computed: false, optional: true, required: false
  private _matchIncomingRequestRoute?: boolean | cdktf.IResolvable; 
  public get matchIncomingRequestRoute() {
    return this.getBooleanAttribute('match_incoming_request_route');
  }
  public set matchIncomingRequestRoute(value: boolean | cdktf.IResolvable) {
    this._matchIncomingRequestRoute = value;
  }
  public resetMatchIncomingRequestRoute() {
    this._matchIncomingRequestRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchIncomingRequestRouteInput() {
    return this._matchIncomingRequestRoute;
  }

  // print_options - computed: false, optional: true, required: false
  private _printOptions = new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptionsOutputReference(this, "print_options");
  public get printOptions() {
    return this._printOptions;
  }
  public putPrintOptions(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderPrintOptions) {
    this._printOptions.internalValue = value;
  }
  public resetPrintOptions() {
    this._printOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get printOptionsInput() {
    return this._printOptions.internalValue;
  }

  // proto_descriptor - computed: false, optional: true, required: false
  private _protoDescriptor?: string; 
  public get protoDescriptor() {
    return this.getStringAttribute('proto_descriptor');
  }
  public set protoDescriptor(value: string) {
    this._protoDescriptor = value;
  }
  public resetProtoDescriptor() {
    this._protoDescriptor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorInput() {
    return this._protoDescriptor;
  }

  // proto_descriptor_bin - computed: false, optional: true, required: false
  private _protoDescriptorBin?: string; 
  public get protoDescriptorBin() {
    return this.getStringAttribute('proto_descriptor_bin');
  }
  public set protoDescriptorBin(value: string) {
    this._protoDescriptorBin = value;
  }
  public resetProtoDescriptorBin() {
    this._protoDescriptorBin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorBinInput() {
    return this._protoDescriptorBin;
  }

  // proto_descriptor_config_map - computed: false, optional: true, required: false
  private _protoDescriptorConfigMap = new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMapOutputReference(this, "proto_descriptor_config_map");
  public get protoDescriptorConfigMap() {
    return this._protoDescriptorConfigMap;
  }
  public putProtoDescriptorConfigMap(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecGrpcJsonTranscoderProtoDescriptorConfigMap) {
    this._protoDescriptorConfigMap.internalValue = value;
  }
  public resetProtoDescriptorConfigMap() {
    this._protoDescriptorConfigMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protoDescriptorConfigMapInput() {
    return this._protoDescriptorConfigMap.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services?: string[]; 
  public get services() {
    return this.getListAttribute('services');
  }
  public set services(value: string[]) {
    this._services = value;
  }
  public resetServices() {
    this._services = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfo {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#inline DataK8SGlooSoloIoUpstreamV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#url DataK8SGlooSoloIoUpstreamV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfoToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfoToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestSwaggerInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._url = value.url;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBody {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBodyToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBodyToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValueToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValueToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValues {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#json_to_proto DataK8SGlooSoloIoUpstreamV1Manifest#json_to_proto}
  */
  readonly jsonToProto?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#key DataK8SGlooSoloIoUpstreamV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#metadata_namespace DataK8SGlooSoloIoUpstreamV1Manifest#metadata_namespace}
  */
  readonly metadataNamespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#value DataK8SGlooSoloIoUpstreamV1Manifest#value}
  */
  readonly value?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_to_proto: cdktf.booleanToTerraform(struct!.jsonToProto),
    key: cdktf.stringToTerraform(struct!.key),
    metadata_namespace: cdktf.stringToTerraform(struct!.metadataNamespace),
    value: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValueToTerraform(struct!.value),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_to_proto: {
      value: cdktf.booleanToHclTerraform(struct!.jsonToProto),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_namespace: {
      value: cdktf.stringToHclTerraform(struct!.metadataNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValueToHclTerraform(struct!.value),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonToProto !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonToProto = this._jsonToProto;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metadataNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataNamespace = this._metadataNamespace;
    }
    if (this._value?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValues | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonToProto = undefined;
      this._key = undefined;
      this._metadataNamespace = undefined;
      this._value.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonToProto = value.jsonToProto;
      this._key = value.key;
      this._metadataNamespace = value.metadataNamespace;
      this._value.internalValue = value.value;
    }
  }

  // json_to_proto - computed: false, optional: true, required: false
  private _jsonToProto?: boolean | cdktf.IResolvable; 
  public get jsonToProto() {
    return this.getBooleanAttribute('json_to_proto');
  }
  public set jsonToProto(value: boolean | cdktf.IResolvable) {
    this._jsonToProto = value;
  }
  public resetJsonToProto() {
    this._jsonToProto = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonToProtoInput() {
    return this._jsonToProto;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metadata_namespace - computed: false, optional: true, required: false
  private _metadataNamespace?: string; 
  public get metadataNamespace() {
    return this.getStringAttribute('metadata_namespace');
  }
  public set metadataNamespace(value: string) {
    this._metadataNamespace = value;
  }
  public resetMetadataNamespace() {
    this._metadataNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataNamespaceInput() {
    return this._metadataNamespace;
  }

  // value - computed: false, optional: true, required: false
  private _value = new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValueOutputReference(this, "value");
  public get value() {
    return this._value;
  }
  public putValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesValue) {
    this._value.internalValue = value;
  }
  public resetValue() {
    this._value.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value.internalValue;
  }
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValues[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesOutputReference {
    return new DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsDynamicMetadataValuesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#body DataK8SGlooSoloIoUpstreamV1Manifest#body}
  */
  readonly body?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#header DataK8SGlooSoloIoUpstreamV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#mode DataK8SGlooSoloIoUpstreamV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#regex DataK8SGlooSoloIoUpstreamV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#replacement_text DataK8SGlooSoloIoUpstreamV1Manifest#replacement_text}
  */
  readonly replacementText?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#subgroup DataK8SGlooSoloIoUpstreamV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractorsToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.body),
    header: cdktf.stringToTerraform(struct!.header),
    mode: cdktf.stringToTerraform(struct!.mode),
    regex: cdktf.stringToTerraform(struct!.regex),
    replacement_text: cdktf.stringToTerraform(struct!.replacementText),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractorsToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.body),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replacement_text: {
      value: cdktf.stringToHclTerraform(struct!.replacementText),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._replacementText !== undefined) {
      hasAnyValues = true;
      internalValueResult.replacementText = this._replacementText;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsExtractors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._header = undefined;
      this._mode = undefined;
      this._regex = undefined;
      this._replacementText = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._header = value.header;
      this._mode = value.mode;
      this._regex = value.regex;
      this._replacementText = value.replacementText;
      this._subgroup = value.subgroup;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: { [key: string]: string }; 
  public get body() {
    return this.getStringMapAttribute('body');
  }
  public set body(value: { [key: string]: string }) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // replacement_text - computed: false, optional: true, required: false
  private _replacementText?: string; 
  public get replacementText() {
    return this.getStringAttribute('replacement_text');
  }
  public set replacementText(value: string) {
    this._replacementText = value;
  }
  public resetReplacementText() {
    this._replacementText = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replacementTextInput() {
    return this._replacementText;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
export interface DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/gloo_solo_io_upstream_v1_manifest#text DataK8SGlooSoloIoUpstreamV1Manifest#text}
  */
  readonly text?: string;
}

export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValueToTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    text: cdktf.stringToTerraform(struct!.text),
  }
}


export function dataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValueToHclTerraform(struct?: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    text: {
      value: cdktf.stringToHclTerraform(struct!.text),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._text !== undefined) {
      hasAnyValues = true;
      internalValueResult.text = this._text;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGlooSoloIoUpstreamV1ManifestSpecPipeServiceSpecRestTransformationsHeadersToAppendValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._text = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._text = value.text;
    }
  }

  // text - computed: false, optional: true, required: false
  private _text?: string; 
  public get text() {
    return this.getStringAttribute('text');
  }
  public set text(value: string) {
    this._text = value;
  }
  public resetText() {
    this._text = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textInput() {
    return this._text;
  }
}
