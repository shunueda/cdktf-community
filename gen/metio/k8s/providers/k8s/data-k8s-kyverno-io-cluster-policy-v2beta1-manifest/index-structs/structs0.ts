import * as cdktf from 'cdktf';
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadataToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadataToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditions {
  /**
  * Expression represents the expression which will be evaluated by CEL. Must evaluate to bool. CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables: 'object' - The object from the incoming request. The value is null for DELETE requests. 'oldObject' - The existing object. The value is null for CREATE requests. 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest). 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request. See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the request resource. Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/ Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#expression DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#expression}
  */
  readonly expression: string;
  /**
  * Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName', or 'my.name', or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName') Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expression: cdktf.stringToTerraform(struct!.expression),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expression = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expression = value.expression;
      this._name = value.name;
    }
  }

  // expression - computed: false, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesCelPreconditionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData {
  /**
  * Key is a unique identifier for the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders {
  /**
  * Key is the header key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService {
  /**
  * CABundle is a PEM encoded CA bundle which will be used to validate the server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ca_bundle DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Headers is a list of optional HTTP headers to be included in the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#headers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#headers}
  */
  readonly headers?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders[] | cdktf.IResolvable;
  /**
  * URL is the JSON web service URL. A typical form is 'https://{service}.{namespace}:{port}/{path}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    headers: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersToTerraform, false)(struct!.headers),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersList",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._headers.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._headers.internalValue = value.headers;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall {
  /**
  * The data object specifies the POST data sent to the server. Only applicable when the method field is set to POST.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData[] | cdktf.IResolvable;
  /**
  * Default is an optional arbitrary JSON object that the context value is set to, if the apiCall returns error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Method is the HTTP request type (GET or POST). Defaults to GET.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#method DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#method}
  */
  readonly method?: string;
  /**
  * Service is an API call to a JSON web service. This is used for non-Kubernetes API server calls. It's mutually exclusive with the URLPath field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#service DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#service}
  */
  readonly service?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService;
  /**
  * URLPath is the URL path to be used in the HTTP GET or POST request to the Kubernetes API server (e.g. '/api/v1/namespaces' or '/apis/apps/v1/deployments'). The format required is the same format used by the 'kubectl get --raw' command. See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls for details. It's mutually exclusive with the Service field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url_path}
  */
  readonly urlPath?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataToTerraform, false)(struct!.data),
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    method: cdktf.stringToTerraform(struct!.method),
    service: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceToTerraform(struct!.service),
    url_path: cdktf.stringToTerraform(struct!.urlPath),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataList",
    },
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService",
    },
    url_path: {
      value: cdktf.stringToHclTerraform(struct!.urlPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._urlPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlPath = this._urlPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._method = undefined;
      this._service.internalValue = undefined;
      this._urlPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._method = value.method;
      this._service.internalValue = value.service;
      this._urlPath = value.urlPath;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // url_path - computed: false, optional: true, required: false
  private _urlPath?: string; 
  public get urlPath() {
    return this.getStringAttribute('url_path');
  }
  public set urlPath(value: string) {
    this._urlPath = value;
  }
  public resetUrlPath() {
    this._urlPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlPathInput() {
    return this._urlPath;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap {
  /**
  * Name is the ConfigMap name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace is the ConfigMap namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMapToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMapToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference {
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Name of the global context entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReferenceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReferenceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jmesPath = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jmesPath = value.jmesPath;
      this._name = value.name;
    }
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials {
  /**
  * AllowInsecureRegistry allows insecure access to a registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#allow_insecure_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#allow_insecure_registry}
  */
  readonly allowInsecureRegistry?: boolean | cdktf.IResolvable;
  /**
  * Providers specifies a list of OCI Registry names, whose authentication providers are provided. It can be of one of these values: default,google,azure,amazon,github.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#providers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#providers}
  */
  readonly providers?: string[];
  /**
  * Secrets specifies a list of secrets that are provided for credentials. Secrets must live in the Kyverno namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#secrets DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#secrets}
  */
  readonly secrets?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentialsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_insecure_registry: cdktf.booleanToTerraform(struct!.allowInsecureRegistry),
    providers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.providers),
    secrets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.secrets),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentialsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_insecure_registry: {
      value: cdktf.booleanToHclTerraform(struct!.allowInsecureRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.providers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secrets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.secrets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowInsecureRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowInsecureRegistry = this._allowInsecureRegistry;
    }
    if (this._providers !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers;
    }
    if (this._secrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = undefined;
      this._providers = undefined;
      this._secrets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = value.allowInsecureRegistry;
      this._providers = value.providers;
      this._secrets = value.secrets;
    }
  }

  // allow_insecure_registry - computed: false, optional: true, required: false
  private _allowInsecureRegistry?: boolean | cdktf.IResolvable; 
  public get allowInsecureRegistry() {
    return this.getBooleanAttribute('allow_insecure_registry');
  }
  public set allowInsecureRegistry(value: boolean | cdktf.IResolvable) {
    this._allowInsecureRegistry = value;
  }
  public resetAllowInsecureRegistry() {
    this._allowInsecureRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInsecureRegistryInput() {
    return this._allowInsecureRegistry;
  }

  // providers - computed: false, optional: true, required: false
  private _providers?: string[]; 
  public get providers() {
    return this.getListAttribute('providers');
  }
  public set providers(value: string[]) {
    this._providers = value;
  }
  public resetProviders() {
    this._providers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets?: string[]; 
  public get secrets() {
    return this.getListAttribute('secrets');
  }
  public set secrets(value: string[]) {
    this._secrets = value;
  }
  public resetSecrets() {
    this._secrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry {
  /**
  * ImageRegistryCredentials provides credentials that will be used for authentication with registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry_credentials DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry_credentials}
  */
  readonly imageRegistryCredentials?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials;
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#reference}
  */
  readonly reference: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_registry_credentials: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentialsToTerraform(struct!.imageRegistryCredentials),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_registry_credentials: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentialsToHclTerraform(struct!.imageRegistryCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageRegistryCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistryCredentials = this._imageRegistryCredentials?.internalValue;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = undefined;
      this._jmesPath = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = value.imageRegistryCredentials;
      this._jmesPath = value.jmesPath;
      this._reference = value.reference;
    }
  }

  // image_registry_credentials - computed: false, optional: true, required: false
  private _imageRegistryCredentials = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentialsOutputReference(this, "image_registry_credentials");
  public get imageRegistryCredentials() {
    return this._imageRegistryCredentials;
  }
  public putImageRegistryCredentials(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryImageRegistryCredentials) {
    this._imageRegistryCredentials.internalValue = value;
  }
  public resetImageRegistryCredentials() {
    this._imageRegistryCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryCredentialsInput() {
    return this._imageRegistryCredentials.internalValue;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable {
  /**
  * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Value is any arbitrary JSON object representable in YAML or JSON form.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariableToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariableToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._value = value.value;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContext {
  /**
  * APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_call DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_call}
  */
  readonly apiCall?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall;
  /**
  * ConfigMap is the ConfigMap reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#config_map DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap;
  /**
  * GlobalContextEntryReference is a reference to a cached global context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#global_reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#global_reference}
  */
  readonly globalReference?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference;
  /**
  * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry}
  */
  readonly imageRegistry?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry;
  /**
  * Name is the variable name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable defines an arbitrary JMESPath context variable that can be defined inline.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#variable DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#variable}
  */
  readonly variable?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_call: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallToTerraform(struct!.apiCall),
    config_map: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMapToTerraform(struct!.configMap),
    global_reference: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReferenceToTerraform(struct!.globalReference),
    image_registry: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryToTerraform(struct!.imageRegistry),
    name: cdktf.stringToTerraform(struct!.name),
    variable: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariableToTerraform(struct!.variable),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_call: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallToHclTerraform(struct!.apiCall),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall",
    },
    config_map: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap",
    },
    global_reference: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReferenceToHclTerraform(struct!.globalReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference",
    },
    image_registry: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryToHclTerraform(struct!.imageRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variable: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariableToHclTerraform(struct!.variable),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiCall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiCall = this._apiCall?.internalValue;
    }
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._globalReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalReference = this._globalReference?.internalValue;
    }
    if (this._imageRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistry = this._imageRegistry?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._variable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variable = this._variable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = undefined;
      this._configMap.internalValue = undefined;
      this._globalReference.internalValue = undefined;
      this._imageRegistry.internalValue = undefined;
      this._name = undefined;
      this._variable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = value.apiCall;
      this._configMap.internalValue = value.configMap;
      this._globalReference.internalValue = value.globalReference;
      this._imageRegistry.internalValue = value.imageRegistry;
      this._name = value.name;
      this._variable.internalValue = value.variable;
    }
  }

  // api_call - computed: false, optional: true, required: false
  private _apiCall = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCallOutputReference(this, "api_call");
  public get apiCall() {
    return this._apiCall;
  }
  public putApiCall(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextApiCall) {
    this._apiCall.internalValue = value;
  }
  public resetApiCall() {
    this._apiCall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiCallInput() {
    return this._apiCall.internalValue;
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // global_reference - computed: false, optional: true, required: false
  private _globalReference = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReferenceOutputReference(this, "global_reference");
  public get globalReference() {
    return this._globalReference;
  }
  public putGlobalReference(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextGlobalReference) {
    this._globalReference.internalValue = value;
  }
  public resetGlobalReference() {
    this._globalReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalReferenceInput() {
    return this._globalReference.internalValue;
  }

  // image_registry - computed: false, optional: true, required: false
  private _imageRegistry = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistryOutputReference(this, "image_registry");
  public get imageRegistry() {
    return this._imageRegistry;
  }
  public putImageRegistry(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextImageRegistry) {
    this._imageRegistry.internalValue = value;
  }
  public resetImageRegistry() {
    this._imageRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryInput() {
    return this._imageRegistry.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // variable - computed: false, optional: true, required: false
  private _variable = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariableOutputReference(this, "variable");
  public get variable() {
    return this._variable;
  }
  public putVariable(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextVariable) {
    this._variable.internalValue = value;
  }
  public resetVariable() {
    this._variable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get variableInput() {
    return this._variable.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContext[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesContextOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources {
  /**
  * Annotations is a map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters '*' (matches zero or many characters) and '?' (matches at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Kinds is a list of resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kinds DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kinds}
  */
  readonly kinds?: string[];
  /**
  * Name is the name of the resource. The name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character). NOTE: 'Name' is being deprecated in favor of 'Names'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Names are the names of the resources. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#names DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#names}
  */
  readonly names?: string[];
  /**
  * NamespaceSelector is a label selector for the resource namespace. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character).Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace_selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector;
  /**
  * Namespaces is a list of namespaces names. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespaces DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Operations can contain values ['CREATE, 'UPDATE', 'CONNECT', 'DELETE'], which are used to match a specific action.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operations}
  */
  readonly operations?: string[];
  /**
  * Selector is a label selector. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character). Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    kinds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kinds),
    name: cdktf.stringToTerraform(struct!.name),
    names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.names),
    namespace_selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    operations: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.operations),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kinds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.names),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    operations: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.operations),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._kinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinds = this._kinds;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._names !== undefined) {
      hasAnyValues = true;
      internalValueResult.names = this._names;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._operations !== undefined) {
      hasAnyValues = true;
      internalValueResult.operations = this._operations;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._kinds = undefined;
      this._name = undefined;
      this._names = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._operations = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._kinds = value.kinds;
      this._name = value.name;
      this._names = value.names;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._operations = value.operations;
      this._selector.internalValue = value.selector;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // kinds - computed: false, optional: true, required: false
  private _kinds?: string[]; 
  public get kinds() {
    return this.getListAttribute('kinds');
  }
  public set kinds(value: string[]) {
    this._kinds = value;
  }
  public resetKinds() {
    this._kinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindsInput() {
    return this._kinds;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // names - computed: false, optional: true, required: false
  private _names?: string[]; 
  public get names() {
    return this.getListAttribute('names');
  }
  public set names(value: string[]) {
    this._names = value;
  }
  public resetNames() {
    this._names = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namesInput() {
    return this._names;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // operations - computed: false, optional: true, required: false
  private _operations?: string[]; 
  public get operations() {
    return this.getListAttribute('operations');
  }
  public set operations(value: string[]) {
    this._operations = value;
  }
  public resetOperations() {
    this._operations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationsInput() {
    return this._operations;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects {
  /**
  * APIGroup holds the API group of the referenced subject. Defaults to '' for ServiceAccount subjects. Defaults to 'rbac.authorization.k8s.io' for User and Group subjects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_group DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind of object being referenced. Values defined by this API group are 'User', 'Group', and 'ServiceAccount'. If the Authorizer does not recognized the kind value, the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the object being referenced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the referenced object. If the object kind is non-namespace, such as 'User' or 'Group', and this value is not empty the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll {
  /**
  * ClusterRoles is the list of cluster-wide role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#cluster_roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#cluster_roles}
  */
  readonly clusterRoles?: string[];
  /**
  * ResourceDescription contains information about the resource being created or modified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#resources DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#resources}
  */
  readonly resources?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources;
  /**
  * Roles is the list of namespaced role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#roles}
  */
  readonly roles?: string[];
  /**
  * Subjects is the list of subject names like users, user groups, and service accounts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#subjects DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#subjects}
  */
  readonly subjects?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterRoles),
    resources: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesToTerraform(struct!.resources),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
    subjects: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsToTerraform, false)(struct!.subjects),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    resources: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subjects: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsToHclTerraform, false)(struct!.subjects),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterRoles = this._clusterRoles;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    if (this._subjects?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjects = this._subjects?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterRoles = undefined;
      this._resources.internalValue = undefined;
      this._roles = undefined;
      this._subjects.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterRoles = value.clusterRoles;
      this._resources.internalValue = value.resources;
      this._roles = value.roles;
      this._subjects.internalValue = value.subjects;
    }
  }

  // cluster_roles - computed: false, optional: true, required: false
  private _clusterRoles?: string[]; 
  public get clusterRoles() {
    return this.getListAttribute('cluster_roles');
  }
  public set clusterRoles(value: string[]) {
    this._clusterRoles = value;
  }
  public resetClusterRoles() {
    this._clusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterRolesInput() {
    return this._clusterRoles;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }

  // subjects - computed: false, optional: true, required: false
  private _subjects = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjectsList(this, "subjects", false);
  public get subjects() {
    return this._subjects;
  }
  public putSubjects(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllSubjects[] | cdktf.IResolvable) {
    this._subjects.internalValue = value;
  }
  public resetSubjects() {
    this._subjects.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectsInput() {
    return this._subjects.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources {
  /**
  * Annotations is a map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters '*' (matches zero or many characters) and '?' (matches at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Kinds is a list of resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kinds DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kinds}
  */
  readonly kinds?: string[];
  /**
  * Name is the name of the resource. The name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character). NOTE: 'Name' is being deprecated in favor of 'Names'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Names are the names of the resources. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#names DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#names}
  */
  readonly names?: string[];
  /**
  * NamespaceSelector is a label selector for the resource namespace. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character).Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace_selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector;
  /**
  * Namespaces is a list of namespaces names. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespaces DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Operations can contain values ['CREATE, 'UPDATE', 'CONNECT', 'DELETE'], which are used to match a specific action.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operations}
  */
  readonly operations?: string[];
  /**
  * Selector is a label selector. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character). Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    kinds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kinds),
    name: cdktf.stringToTerraform(struct!.name),
    names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.names),
    namespace_selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    operations: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.operations),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kinds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.names),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    operations: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.operations),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._kinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinds = this._kinds;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._names !== undefined) {
      hasAnyValues = true;
      internalValueResult.names = this._names;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._operations !== undefined) {
      hasAnyValues = true;
      internalValueResult.operations = this._operations;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._kinds = undefined;
      this._name = undefined;
      this._names = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._operations = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._kinds = value.kinds;
      this._name = value.name;
      this._names = value.names;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._operations = value.operations;
      this._selector.internalValue = value.selector;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // kinds - computed: false, optional: true, required: false
  private _kinds?: string[]; 
  public get kinds() {
    return this.getListAttribute('kinds');
  }
  public set kinds(value: string[]) {
    this._kinds = value;
  }
  public resetKinds() {
    this._kinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindsInput() {
    return this._kinds;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // names - computed: false, optional: true, required: false
  private _names?: string[]; 
  public get names() {
    return this.getListAttribute('names');
  }
  public set names(value: string[]) {
    this._names = value;
  }
  public resetNames() {
    this._names = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namesInput() {
    return this._names;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // operations - computed: false, optional: true, required: false
  private _operations?: string[]; 
  public get operations() {
    return this.getListAttribute('operations');
  }
  public set operations(value: string[]) {
    this._operations = value;
  }
  public resetOperations() {
    this._operations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationsInput() {
    return this._operations;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects {
  /**
  * APIGroup holds the API group of the referenced subject. Defaults to '' for ServiceAccount subjects. Defaults to 'rbac.authorization.k8s.io' for User and Group subjects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_group DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind of object being referenced. Values defined by this API group are 'User', 'Group', and 'ServiceAccount'. If the Authorizer does not recognized the kind value, the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the object being referenced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the referenced object. If the object kind is non-namespace, such as 'User' or 'Group', and this value is not empty the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny {
  /**
  * ClusterRoles is the list of cluster-wide role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#cluster_roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#cluster_roles}
  */
  readonly clusterRoles?: string[];
  /**
  * ResourceDescription contains information about the resource being created or modified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#resources DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#resources}
  */
  readonly resources?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources;
  /**
  * Roles is the list of namespaced role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#roles}
  */
  readonly roles?: string[];
  /**
  * Subjects is the list of subject names like users, user groups, and service accounts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#subjects DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#subjects}
  */
  readonly subjects?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterRoles),
    resources: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesToTerraform(struct!.resources),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
    subjects: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsToTerraform, false)(struct!.subjects),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    resources: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subjects: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsToHclTerraform, false)(struct!.subjects),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterRoles = this._clusterRoles;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    if (this._subjects?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjects = this._subjects?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterRoles = undefined;
      this._resources.internalValue = undefined;
      this._roles = undefined;
      this._subjects.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterRoles = value.clusterRoles;
      this._resources.internalValue = value.resources;
      this._roles = value.roles;
      this._subjects.internalValue = value.subjects;
    }
  }

  // cluster_roles - computed: false, optional: true, required: false
  private _clusterRoles?: string[]; 
  public get clusterRoles() {
    return this.getListAttribute('cluster_roles');
  }
  public set clusterRoles(value: string[]) {
    this._clusterRoles = value;
  }
  public resetClusterRoles() {
    this._clusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterRolesInput() {
    return this._clusterRoles;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }

  // subjects - computed: false, optional: true, required: false
  private _subjects = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjectsList(this, "subjects", false);
  public get subjects() {
    return this._subjects;
  }
  public putSubjects(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnySubjects[] | cdktf.IResolvable) {
    this._subjects.internalValue = value;
  }
  public resetSubjects() {
    this._subjects.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectsInput() {
    return this._subjects.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExclude {
  /**
  * All allows specifying resources which will be ANDed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll[] | cdktf.IResolvable;
  /**
  * Any allows specifying resources which will be ORed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExclude | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExclude | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExclude | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExclude | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesExcludeAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone {
  /**
  * Name specifies name of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace specifies source resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct {
  /**
  * Kinds is a list of resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kinds DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kinds}
  */
  readonly kinds?: string[];
  /**
  * Namespace specifies source resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector is a label selector. Label keys and values in 'matchLabels'. wildcard characters are not supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStructToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kinds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kinds),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStructToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kinds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStructOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinds = this._kinds;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kinds = undefined;
      this._namespace = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kinds = value.kinds;
      this._namespace = value.namespace;
      this._selector.internalValue = value.selector;
    }
  }

  // kinds - computed: false, optional: true, required: false
  private _kinds?: string[]; 
  public get kinds() {
    return this.getListAttribute('kinds');
  }
  public set kinds(value: string[]) {
    this._kinds = value;
  }
  public resetKinds() {
    this._kinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindsInput() {
    return this._kinds;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone {
  /**
  * Name specifies name of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace specifies source resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct {
  /**
  * Kinds is a list of resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kinds DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kinds}
  */
  readonly kinds?: string[];
  /**
  * Namespace specifies source resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector is a label selector. Label keys and values in 'matchLabels'. wildcard characters are not supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStructToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kinds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kinds),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStructToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kinds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStructOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinds = this._kinds;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kinds = undefined;
      this._namespace = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kinds = value.kinds;
      this._namespace = value.namespace;
      this._selector.internalValue = value.selector;
    }
  }

  // kinds - computed: false, optional: true, required: false
  private _kinds?: string[]; 
  public get kinds() {
    return this.getListAttribute('kinds');
  }
  public set kinds(value: string[]) {
    this._kinds = value;
  }
  public resetKinds() {
    this._kinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindsInput() {
    return this._kinds;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData {
  /**
  * Key is a unique identifier for the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders {
  /**
  * Key is the header key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService {
  /**
  * CABundle is a PEM encoded CA bundle which will be used to validate the server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ca_bundle DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Headers is a list of optional HTTP headers to be included in the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#headers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#headers}
  */
  readonly headers?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable;
  /**
  * URL is the JSON web service URL. A typical form is 'https://{service}.{namespace}:{port}/{path}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    headers: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersToTerraform, false)(struct!.headers),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersList",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._headers.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._headers.internalValue = value.headers;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall {
  /**
  * The data object specifies the POST data sent to the server. Only applicable when the method field is set to POST.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData[] | cdktf.IResolvable;
  /**
  * Default is an optional arbitrary JSON object that the context value is set to, if the apiCall returns error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Method is the HTTP request type (GET or POST). Defaults to GET.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#method DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#method}
  */
  readonly method?: string;
  /**
  * Service is an API call to a JSON web service. This is used for non-Kubernetes API server calls. It's mutually exclusive with the URLPath field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#service DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#service}
  */
  readonly service?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService;
  /**
  * URLPath is the URL path to be used in the HTTP GET or POST request to the Kubernetes API server (e.g. '/api/v1/namespaces' or '/apis/apps/v1/deployments'). The format required is the same format used by the 'kubectl get --raw' command. See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls for details. It's mutually exclusive with the Service field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url_path}
  */
  readonly urlPath?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataToTerraform, false)(struct!.data),
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    method: cdktf.stringToTerraform(struct!.method),
    service: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceToTerraform(struct!.service),
    url_path: cdktf.stringToTerraform(struct!.urlPath),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataList",
    },
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService",
    },
    url_path: {
      value: cdktf.stringToHclTerraform(struct!.urlPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._urlPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlPath = this._urlPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._method = undefined;
      this._service.internalValue = undefined;
      this._urlPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._method = value.method;
      this._service.internalValue = value.service;
      this._urlPath = value.urlPath;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // url_path - computed: false, optional: true, required: false
  private _urlPath?: string; 
  public get urlPath() {
    return this.getStringAttribute('url_path');
  }
  public set urlPath(value: string) {
    this._urlPath = value;
  }
  public resetUrlPath() {
    this._urlPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlPathInput() {
    return this._urlPath;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap {
  /**
  * Name is the ConfigMap name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace is the ConfigMap namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMapToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMapToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference {
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Name of the global context entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReferenceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReferenceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jmesPath = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jmesPath = value.jmesPath;
      this._name = value.name;
    }
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials {
  /**
  * AllowInsecureRegistry allows insecure access to a registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#allow_insecure_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#allow_insecure_registry}
  */
  readonly allowInsecureRegistry?: boolean | cdktf.IResolvable;
  /**
  * Providers specifies a list of OCI Registry names, whose authentication providers are provided. It can be of one of these values: default,google,azure,amazon,github.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#providers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#providers}
  */
  readonly providers?: string[];
  /**
  * Secrets specifies a list of secrets that are provided for credentials. Secrets must live in the Kyverno namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#secrets DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#secrets}
  */
  readonly secrets?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_insecure_registry: cdktf.booleanToTerraform(struct!.allowInsecureRegistry),
    providers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.providers),
    secrets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.secrets),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_insecure_registry: {
      value: cdktf.booleanToHclTerraform(struct!.allowInsecureRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.providers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secrets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.secrets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowInsecureRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowInsecureRegistry = this._allowInsecureRegistry;
    }
    if (this._providers !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers;
    }
    if (this._secrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = undefined;
      this._providers = undefined;
      this._secrets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = value.allowInsecureRegistry;
      this._providers = value.providers;
      this._secrets = value.secrets;
    }
  }

  // allow_insecure_registry - computed: false, optional: true, required: false
  private _allowInsecureRegistry?: boolean | cdktf.IResolvable; 
  public get allowInsecureRegistry() {
    return this.getBooleanAttribute('allow_insecure_registry');
  }
  public set allowInsecureRegistry(value: boolean | cdktf.IResolvable) {
    this._allowInsecureRegistry = value;
  }
  public resetAllowInsecureRegistry() {
    this._allowInsecureRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInsecureRegistryInput() {
    return this._allowInsecureRegistry;
  }

  // providers - computed: false, optional: true, required: false
  private _providers?: string[]; 
  public get providers() {
    return this.getListAttribute('providers');
  }
  public set providers(value: string[]) {
    this._providers = value;
  }
  public resetProviders() {
    this._providers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets?: string[]; 
  public get secrets() {
    return this.getListAttribute('secrets');
  }
  public set secrets(value: string[]) {
    this._secrets = value;
  }
  public resetSecrets() {
    this._secrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry {
  /**
  * ImageRegistryCredentials provides credentials that will be used for authentication with registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry_credentials DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry_credentials}
  */
  readonly imageRegistryCredentials?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials;
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#reference}
  */
  readonly reference: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_registry_credentials: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsToTerraform(struct!.imageRegistryCredentials),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_registry_credentials: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsToHclTerraform(struct!.imageRegistryCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageRegistryCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistryCredentials = this._imageRegistryCredentials?.internalValue;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = undefined;
      this._jmesPath = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = value.imageRegistryCredentials;
      this._jmesPath = value.jmesPath;
      this._reference = value.reference;
    }
  }

  // image_registry_credentials - computed: false, optional: true, required: false
  private _imageRegistryCredentials = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentialsOutputReference(this, "image_registry_credentials");
  public get imageRegistryCredentials() {
    return this._imageRegistryCredentials;
  }
  public putImageRegistryCredentials(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryImageRegistryCredentials) {
    this._imageRegistryCredentials.internalValue = value;
  }
  public resetImageRegistryCredentials() {
    this._imageRegistryCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryCredentialsInput() {
    return this._imageRegistryCredentials.internalValue;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable {
  /**
  * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Value is any arbitrary JSON object representable in YAML or JSON form.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariableToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariableToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._value = value.value;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext {
  /**
  * APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_call DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_call}
  */
  readonly apiCall?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall;
  /**
  * ConfigMap is the ConfigMap reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#config_map DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap;
  /**
  * GlobalContextEntryReference is a reference to a cached global context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#global_reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#global_reference}
  */
  readonly globalReference?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference;
  /**
  * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry}
  */
  readonly imageRegistry?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry;
  /**
  * Name is the variable name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable defines an arbitrary JMESPath context variable that can be defined inline.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#variable DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#variable}
  */
  readonly variable?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_call: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallToTerraform(struct!.apiCall),
    config_map: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMapToTerraform(struct!.configMap),
    global_reference: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReferenceToTerraform(struct!.globalReference),
    image_registry: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryToTerraform(struct!.imageRegistry),
    name: cdktf.stringToTerraform(struct!.name),
    variable: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariableToTerraform(struct!.variable),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_call: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallToHclTerraform(struct!.apiCall),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall",
    },
    config_map: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap",
    },
    global_reference: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReferenceToHclTerraform(struct!.globalReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference",
    },
    image_registry: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryToHclTerraform(struct!.imageRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variable: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariableToHclTerraform(struct!.variable),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiCall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiCall = this._apiCall?.internalValue;
    }
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._globalReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalReference = this._globalReference?.internalValue;
    }
    if (this._imageRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistry = this._imageRegistry?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._variable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variable = this._variable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = undefined;
      this._configMap.internalValue = undefined;
      this._globalReference.internalValue = undefined;
      this._imageRegistry.internalValue = undefined;
      this._name = undefined;
      this._variable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = value.apiCall;
      this._configMap.internalValue = value.configMap;
      this._globalReference.internalValue = value.globalReference;
      this._imageRegistry.internalValue = value.imageRegistry;
      this._name = value.name;
      this._variable.internalValue = value.variable;
    }
  }

  // api_call - computed: false, optional: true, required: false
  private _apiCall = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCallOutputReference(this, "api_call");
  public get apiCall() {
    return this._apiCall;
  }
  public putApiCall(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextApiCall) {
    this._apiCall.internalValue = value;
  }
  public resetApiCall() {
    this._apiCall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiCallInput() {
    return this._apiCall.internalValue;
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // global_reference - computed: false, optional: true, required: false
  private _globalReference = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReferenceOutputReference(this, "global_reference");
  public get globalReference() {
    return this._globalReference;
  }
  public putGlobalReference(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextGlobalReference) {
    this._globalReference.internalValue = value;
  }
  public resetGlobalReference() {
    this._globalReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalReferenceInput() {
    return this._globalReference.internalValue;
  }

  // image_registry - computed: false, optional: true, required: false
  private _imageRegistry = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistryOutputReference(this, "image_registry");
  public get imageRegistry() {
    return this._imageRegistry;
  }
  public putImageRegistry(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextImageRegistry) {
    this._imageRegistry.internalValue = value;
  }
  public resetImageRegistry() {
    this._imageRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryInput() {
    return this._imageRegistry.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // variable - computed: false, optional: true, required: false
  private _variable = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariableOutputReference(this, "variable");
  public get variable() {
    return this._variable;
  }
  public putVariable(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextVariable) {
    this._variable.internalValue = value;
  }
  public resetVariable() {
    this._variable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get variableInput() {
    return this._variable.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions {
  /**
  * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll[] | cdktf.IResolvable;
  /**
  * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach {
  /**
  * APIVersion specifies resource apiVersion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_version DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Clone specifies the source resource used to populate each generated resource. At most one of Data or Clone can be specified. If neither are provided, the generated resource will be created with default data only.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#clone DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#clone}
  */
  readonly clone?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone;
  /**
  * CloneList specifies the list of source resource used to populate each generated resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#clone_list DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#clone_list}
  */
  readonly cloneList?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct;
  /**
  * Context defines variables and data sources that can be used during rule execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#context DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#context}
  */
  readonly context?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext[] | cdktf.IResolvable;
  /**
  * Data provides the resource declaration used to populate each generated resource. At most one of Data or Clone must be specified. If neither are provided, the generated resource will be created with default data only.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: { [key: string]: string };
  /**
  * Kind specifies resource kind.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * List specifies a JMESPath expression that results in one or more elements to which the validation logic is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#list DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#list}
  */
  readonly list?: string;
  /**
  * Name specifies the resource name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace specifies resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested 'any' or 'all' statements. See: https://kyverno.io/docs/writing-policies/preconditions/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#preconditions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#preconditions}
  */
  readonly preconditions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions;
  /**
  * UID specifies the resource uid.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#uid DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    clone: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneToTerraform(struct!.clone),
    clone_list: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStructToTerraform(struct!.cloneList),
    context: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextToTerraform, false)(struct!.context),
    data: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.data),
    kind: cdktf.stringToTerraform(struct!.kind),
    list: cdktf.stringToTerraform(struct!.list),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    preconditions: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsToTerraform(struct!.preconditions),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clone: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneToHclTerraform(struct!.clone),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone",
    },
    clone_list: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStructToHclTerraform(struct!.cloneList),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct",
    },
    context: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextToHclTerraform, false)(struct!.context),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextList",
    },
    data: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.data),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    list: {
      value: cdktf.stringToHclTerraform(struct!.list),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preconditions: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsToHclTerraform(struct!.preconditions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._clone?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clone = this._clone?.internalValue;
    }
    if (this._cloneList?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloneList = this._cloneList?.internalValue;
    }
    if (this._context?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context?.internalValue;
    }
    if (this._data !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._list !== undefined) {
      hasAnyValues = true;
      internalValueResult.list = this._list;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._preconditions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preconditions = this._preconditions?.internalValue;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._clone.internalValue = undefined;
      this._cloneList.internalValue = undefined;
      this._context.internalValue = undefined;
      this._data = undefined;
      this._kind = undefined;
      this._list = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._preconditions.internalValue = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._clone.internalValue = value.clone;
      this._cloneList.internalValue = value.cloneList;
      this._context.internalValue = value.context;
      this._data = value.data;
      this._kind = value.kind;
      this._list = value.list;
      this._name = value.name;
      this._namespace = value.namespace;
      this._preconditions.internalValue = value.preconditions;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // clone - computed: false, optional: true, required: false
  private _clone = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneOutputReference(this, "clone");
  public get clone() {
    return this._clone;
  }
  public putClone(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachClone) {
    this._clone.internalValue = value;
  }
  public resetClone() {
    this._clone.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloneInput() {
    return this._clone.internalValue;
  }

  // clone_list - computed: false, optional: true, required: false
  private _cloneList = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStructOutputReference(this, "clone_list");
  public get cloneList() {
    return this._cloneList;
  }
  public putCloneList(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachCloneListStruct) {
    this._cloneList.internalValue = value;
  }
  public resetCloneList() {
    this._cloneList.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloneListInput() {
    return this._cloneList.internalValue;
  }

  // context - computed: false, optional: true, required: false
  private _context = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContextList(this, "context", false);
  public get context() {
    return this._context;
  }
  public putContext(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachContext[] | cdktf.IResolvable) {
    this._context.internalValue = value;
  }
  public resetContext() {
    this._context.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context.internalValue;
  }

  // data - computed: false, optional: true, required: false
  private _data?: { [key: string]: string }; 
  public get data() {
    return this.getStringMapAttribute('data');
  }
  public set data(value: { [key: string]: string }) {
    this._data = value;
  }
  public resetData() {
    this._data = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // list - computed: false, optional: true, required: false
  private _list?: string; 
  public get list() {
    return this.getStringAttribute('list');
  }
  public set list(value: string) {
    this._list = value;
  }
  public resetList() {
    this._list = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listInput() {
    return this._list;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // preconditions - computed: false, optional: true, required: false
  private _preconditions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditionsOutputReference(this, "preconditions");
  public get preconditions() {
    return this._preconditions;
  }
  public putPreconditions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachPreconditions) {
    this._preconditions.internalValue = value;
  }
  public resetPreconditions() {
    this._preconditions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preconditionsInput() {
    return this._preconditions.internalValue;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerate {
  /**
  * APIVersion specifies resource apiVersion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_version DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Clone specifies the source resource used to populate each generated resource. At most one of Data or Clone can be specified. If neither are provided, the generated resource will be created with default data only.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#clone DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#clone}
  */
  readonly clone?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone;
  /**
  * CloneList specifies the list of source resource used to populate each generated resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#clone_list DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#clone_list}
  */
  readonly cloneList?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct;
  /**
  * Data provides the resource declaration used to populate each generated resource. At most one of Data or Clone must be specified. If neither are provided, the generated resource will be created with default data only.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: { [key: string]: string };
  /**
  * ForEach applies generate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#foreach DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#foreach}
  */
  readonly foreach?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach[] | cdktf.IResolvable;
  /**
  * GenerateExisting controls whether to trigger the rule in existing resources If is set to 'true' the rule will be triggered and applied to existing matched resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#generate_existing DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#generate_existing}
  */
  readonly generateExisting?: boolean | cdktf.IResolvable;
  /**
  * Kind specifies resource kind.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name specifies the resource name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace specifies resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * OrphanDownstreamOnPolicyDelete controls whether generated resources should be deleted when the rule that generated them is deleted with synchronization enabled. This option is only applicable to generate rules of the data type. See https://kyverno.io/docs/writing-policies/generate/#data-examples. Defaults to 'false' if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#orphan_downstream_on_policy_delete DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#orphan_downstream_on_policy_delete}
  */
  readonly orphanDownstreamOnPolicyDelete?: boolean | cdktf.IResolvable;
  /**
  * Synchronize controls if generated resources should be kept in-sync with their source resource. If Synchronize is set to 'true' changes to generated resources will be overwritten with resource data from Data or the resource specified in the Clone declaration. Optional. Defaults to 'false' if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#synchronize DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#synchronize}
  */
  readonly synchronize?: boolean | cdktf.IResolvable;
  /**
  * UID specifies the resource uid.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#uid DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    clone: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneToTerraform(struct!.clone),
    clone_list: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStructToTerraform(struct!.cloneList),
    data: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.data),
    foreach: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachToTerraform, false)(struct!.foreach),
    generate_existing: cdktf.booleanToTerraform(struct!.generateExisting),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    orphan_downstream_on_policy_delete: cdktf.booleanToTerraform(struct!.orphanDownstreamOnPolicyDelete),
    synchronize: cdktf.booleanToTerraform(struct!.synchronize),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clone: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneToHclTerraform(struct!.clone),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone",
    },
    clone_list: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStructToHclTerraform(struct!.cloneList),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct",
    },
    data: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.data),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    foreach: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachToHclTerraform, false)(struct!.foreach),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachList",
    },
    generate_existing: {
      value: cdktf.booleanToHclTerraform(struct!.generateExisting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    orphan_downstream_on_policy_delete: {
      value: cdktf.booleanToHclTerraform(struct!.orphanDownstreamOnPolicyDelete),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    synchronize: {
      value: cdktf.booleanToHclTerraform(struct!.synchronize),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._clone?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clone = this._clone?.internalValue;
    }
    if (this._cloneList?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloneList = this._cloneList?.internalValue;
    }
    if (this._data !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data;
    }
    if (this._foreach?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.foreach = this._foreach?.internalValue;
    }
    if (this._generateExisting !== undefined) {
      hasAnyValues = true;
      internalValueResult.generateExisting = this._generateExisting;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._orphanDownstreamOnPolicyDelete !== undefined) {
      hasAnyValues = true;
      internalValueResult.orphanDownstreamOnPolicyDelete = this._orphanDownstreamOnPolicyDelete;
    }
    if (this._synchronize !== undefined) {
      hasAnyValues = true;
      internalValueResult.synchronize = this._synchronize;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._clone.internalValue = undefined;
      this._cloneList.internalValue = undefined;
      this._data = undefined;
      this._foreach.internalValue = undefined;
      this._generateExisting = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._orphanDownstreamOnPolicyDelete = undefined;
      this._synchronize = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._clone.internalValue = value.clone;
      this._cloneList.internalValue = value.cloneList;
      this._data = value.data;
      this._foreach.internalValue = value.foreach;
      this._generateExisting = value.generateExisting;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._orphanDownstreamOnPolicyDelete = value.orphanDownstreamOnPolicyDelete;
      this._synchronize = value.synchronize;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // clone - computed: false, optional: true, required: false
  private _clone = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneOutputReference(this, "clone");
  public get clone() {
    return this._clone;
  }
  public putClone(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateClone) {
    this._clone.internalValue = value;
  }
  public resetClone() {
    this._clone.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloneInput() {
    return this._clone.internalValue;
  }

  // clone_list - computed: false, optional: true, required: false
  private _cloneList = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStructOutputReference(this, "clone_list");
  public get cloneList() {
    return this._cloneList;
  }
  public putCloneList(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateCloneListStruct) {
    this._cloneList.internalValue = value;
  }
  public resetCloneList() {
    this._cloneList.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloneListInput() {
    return this._cloneList.internalValue;
  }

  // data - computed: false, optional: true, required: false
  private _data?: { [key: string]: string }; 
  public get data() {
    return this.getStringMapAttribute('data');
  }
  public set data(value: { [key: string]: string }) {
    this._data = value;
  }
  public resetData() {
    this._data = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data;
  }

  // foreach - computed: false, optional: true, required: false
  private _foreach = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeachList(this, "foreach", false);
  public get foreach() {
    return this._foreach;
  }
  public putForeach(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesGenerateForeach[] | cdktf.IResolvable) {
    this._foreach.internalValue = value;
  }
  public resetForeach() {
    this._foreach.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get foreachInput() {
    return this._foreach.internalValue;
  }

  // generate_existing - computed: false, optional: true, required: false
  private _generateExisting?: boolean | cdktf.IResolvable; 
  public get generateExisting() {
    return this.getBooleanAttribute('generate_existing');
  }
  public set generateExisting(value: boolean | cdktf.IResolvable) {
    this._generateExisting = value;
  }
  public resetGenerateExisting() {
    this._generateExisting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get generateExistingInput() {
    return this._generateExisting;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // orphan_downstream_on_policy_delete - computed: false, optional: true, required: false
  private _orphanDownstreamOnPolicyDelete?: boolean | cdktf.IResolvable; 
  public get orphanDownstreamOnPolicyDelete() {
    return this.getBooleanAttribute('orphan_downstream_on_policy_delete');
  }
  public set orphanDownstreamOnPolicyDelete(value: boolean | cdktf.IResolvable) {
    this._orphanDownstreamOnPolicyDelete = value;
  }
  public resetOrphanDownstreamOnPolicyDelete() {
    this._orphanDownstreamOnPolicyDelete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orphanDownstreamOnPolicyDeleteInput() {
    return this._orphanDownstreamOnPolicyDelete;
  }

  // synchronize - computed: false, optional: true, required: false
  private _synchronize?: boolean | cdktf.IResolvable; 
  public get synchronize() {
    return this.getBooleanAttribute('synchronize');
  }
  public set synchronize(value: boolean | cdktf.IResolvable) {
    this._synchronize = value;
  }
  public resetSynchronize() {
    this._synchronize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get synchronizeInput() {
    return this._synchronize;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources {
  /**
  * Annotations is a map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters '*' (matches zero or many characters) and '?' (matches at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Kinds is a list of resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kinds DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kinds}
  */
  readonly kinds?: string[];
  /**
  * Name is the name of the resource. The name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character). NOTE: 'Name' is being deprecated in favor of 'Names'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Names are the names of the resources. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#names DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#names}
  */
  readonly names?: string[];
  /**
  * NamespaceSelector is a label selector for the resource namespace. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character).Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace_selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector;
  /**
  * Namespaces is a list of namespaces names. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespaces DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Operations can contain values ['CREATE, 'UPDATE', 'CONNECT', 'DELETE'], which are used to match a specific action.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operations}
  */
  readonly operations?: string[];
  /**
  * Selector is a label selector. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character). Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    kinds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kinds),
    name: cdktf.stringToTerraform(struct!.name),
    names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.names),
    namespace_selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    operations: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.operations),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kinds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.names),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    operations: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.operations),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._kinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinds = this._kinds;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._names !== undefined) {
      hasAnyValues = true;
      internalValueResult.names = this._names;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._operations !== undefined) {
      hasAnyValues = true;
      internalValueResult.operations = this._operations;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._kinds = undefined;
      this._name = undefined;
      this._names = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._operations = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._kinds = value.kinds;
      this._name = value.name;
      this._names = value.names;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._operations = value.operations;
      this._selector.internalValue = value.selector;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // kinds - computed: false, optional: true, required: false
  private _kinds?: string[]; 
  public get kinds() {
    return this.getListAttribute('kinds');
  }
  public set kinds(value: string[]) {
    this._kinds = value;
  }
  public resetKinds() {
    this._kinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindsInput() {
    return this._kinds;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // names - computed: false, optional: true, required: false
  private _names?: string[]; 
  public get names() {
    return this.getListAttribute('names');
  }
  public set names(value: string[]) {
    this._names = value;
  }
  public resetNames() {
    this._names = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namesInput() {
    return this._names;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // operations - computed: false, optional: true, required: false
  private _operations?: string[]; 
  public get operations() {
    return this.getListAttribute('operations');
  }
  public set operations(value: string[]) {
    this._operations = value;
  }
  public resetOperations() {
    this._operations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationsInput() {
    return this._operations;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects {
  /**
  * APIGroup holds the API group of the referenced subject. Defaults to '' for ServiceAccount subjects. Defaults to 'rbac.authorization.k8s.io' for User and Group subjects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_group DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind of object being referenced. Values defined by this API group are 'User', 'Group', and 'ServiceAccount'. If the Authorizer does not recognized the kind value, the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the object being referenced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the referenced object. If the object kind is non-namespace, such as 'User' or 'Group', and this value is not empty the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll {
  /**
  * ClusterRoles is the list of cluster-wide role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#cluster_roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#cluster_roles}
  */
  readonly clusterRoles?: string[];
  /**
  * ResourceDescription contains information about the resource being created or modified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#resources DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#resources}
  */
  readonly resources?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources;
  /**
  * Roles is the list of namespaced role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#roles}
  */
  readonly roles?: string[];
  /**
  * Subjects is the list of subject names like users, user groups, and service accounts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#subjects DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#subjects}
  */
  readonly subjects?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterRoles),
    resources: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesToTerraform(struct!.resources),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
    subjects: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsToTerraform, false)(struct!.subjects),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    resources: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subjects: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsToHclTerraform, false)(struct!.subjects),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterRoles = this._clusterRoles;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    if (this._subjects?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjects = this._subjects?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterRoles = undefined;
      this._resources.internalValue = undefined;
      this._roles = undefined;
      this._subjects.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterRoles = value.clusterRoles;
      this._resources.internalValue = value.resources;
      this._roles = value.roles;
      this._subjects.internalValue = value.subjects;
    }
  }

  // cluster_roles - computed: false, optional: true, required: false
  private _clusterRoles?: string[]; 
  public get clusterRoles() {
    return this.getListAttribute('cluster_roles');
  }
  public set clusterRoles(value: string[]) {
    this._clusterRoles = value;
  }
  public resetClusterRoles() {
    this._clusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterRolesInput() {
    return this._clusterRoles;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }

  // subjects - computed: false, optional: true, required: false
  private _subjects = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjectsList(this, "subjects", false);
  public get subjects() {
    return this._subjects;
  }
  public putSubjects(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllSubjects[] | cdktf.IResolvable) {
    this._subjects.internalValue = value;
  }
  public resetSubjects() {
    this._subjects.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectsInput() {
    return this._subjects.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources {
  /**
  * Annotations is a map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters '*' (matches zero or many characters) and '?' (matches at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Kinds is a list of resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kinds DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kinds}
  */
  readonly kinds?: string[];
  /**
  * Name is the name of the resource. The name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character). NOTE: 'Name' is being deprecated in favor of 'Names'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Names are the names of the resources. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#names DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#names}
  */
  readonly names?: string[];
  /**
  * NamespaceSelector is a label selector for the resource namespace. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character).Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace_selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector;
  /**
  * Namespaces is a list of namespaces names. Each name supports wildcard characters '*' (matches zero or many characters) and '?' (at least one character).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespaces DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Operations can contain values ['CREATE, 'UPDATE', 'CONNECT', 'DELETE'], which are used to match a specific action.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operations}
  */
  readonly operations?: string[];
  /**
  * Selector is a label selector. Label keys and values in 'matchLabels' support the wildcard characters '*' (matches zero or many characters) and '?' (matches one character). Wildcards allows writing label selectors like ['storage.k8s.io/*': '*']. Note that using ['*' : '*'] matches any key and value but does not match an empty label set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    kinds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.kinds),
    name: cdktf.stringToTerraform(struct!.name),
    names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.names),
    namespace_selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    operations: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.operations),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    kinds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.kinds),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.names),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    operations: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.operations),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._kinds !== undefined) {
      hasAnyValues = true;
      internalValueResult.kinds = this._kinds;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._names !== undefined) {
      hasAnyValues = true;
      internalValueResult.names = this._names;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._operations !== undefined) {
      hasAnyValues = true;
      internalValueResult.operations = this._operations;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._kinds = undefined;
      this._name = undefined;
      this._names = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._operations = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._kinds = value.kinds;
      this._name = value.name;
      this._names = value.names;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._operations = value.operations;
      this._selector.internalValue = value.selector;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // kinds - computed: false, optional: true, required: false
  private _kinds?: string[]; 
  public get kinds() {
    return this.getListAttribute('kinds');
  }
  public set kinds(value: string[]) {
    this._kinds = value;
  }
  public resetKinds() {
    this._kinds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindsInput() {
    return this._kinds;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // names - computed: false, optional: true, required: false
  private _names?: string[]; 
  public get names() {
    return this.getListAttribute('names');
  }
  public set names(value: string[]) {
    this._names = value;
  }
  public resetNames() {
    this._names = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namesInput() {
    return this._names;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // operations - computed: false, optional: true, required: false
  private _operations?: string[]; 
  public get operations() {
    return this.getListAttribute('operations');
  }
  public set operations(value: string[]) {
    this._operations = value;
  }
  public resetOperations() {
    this._operations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operationsInput() {
    return this._operations;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects {
  /**
  * APIGroup holds the API group of the referenced subject. Defaults to '' for ServiceAccount subjects. Defaults to 'rbac.authorization.k8s.io' for User and Group subjects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_group DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_group}
  */
  readonly apiGroup?: string;
  /**
  * Kind of object being referenced. Values defined by this API group are 'User', 'Group', and 'ServiceAccount'. If the Authorizer does not recognized the kind value, the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the object being referenced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the referenced object. If the object kind is non-namespace, such as 'User' or 'Group', and this value is not empty the Authorizer should report an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_group: cdktf.stringToTerraform(struct!.apiGroup),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_group: {
      value: cdktf.stringToHclTerraform(struct!.apiGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiGroup = this._apiGroup;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiGroup = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiGroup = value.apiGroup;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_group - computed: false, optional: true, required: false
  private _apiGroup?: string; 
  public get apiGroup() {
    return this.getStringAttribute('api_group');
  }
  public set apiGroup(value: string) {
    this._apiGroup = value;
  }
  public resetApiGroup() {
    this._apiGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiGroupInput() {
    return this._apiGroup;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny {
  /**
  * ClusterRoles is the list of cluster-wide role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#cluster_roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#cluster_roles}
  */
  readonly clusterRoles?: string[];
  /**
  * ResourceDescription contains information about the resource being created or modified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#resources DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#resources}
  */
  readonly resources?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources;
  /**
  * Roles is the list of namespaced role names for the user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#roles DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#roles}
  */
  readonly roles?: string[];
  /**
  * Subjects is the list of subject names like users, user groups, and service accounts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#subjects DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#subjects}
  */
  readonly subjects?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.clusterRoles),
    resources: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesToTerraform(struct!.resources),
    roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.roles),
    subjects: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsToTerraform, false)(struct!.subjects),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.clusterRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    resources: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesToHclTerraform(struct!.resources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources",
    },
    roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.roles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subjects: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsToHclTerraform, false)(struct!.subjects),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterRoles = this._clusterRoles;
    }
    if (this._resources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resources = this._resources?.internalValue;
    }
    if (this._roles !== undefined) {
      hasAnyValues = true;
      internalValueResult.roles = this._roles;
    }
    if (this._subjects?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjects = this._subjects?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterRoles = undefined;
      this._resources.internalValue = undefined;
      this._roles = undefined;
      this._subjects.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterRoles = value.clusterRoles;
      this._resources.internalValue = value.resources;
      this._roles = value.roles;
      this._subjects.internalValue = value.subjects;
    }
  }

  // cluster_roles - computed: false, optional: true, required: false
  private _clusterRoles?: string[]; 
  public get clusterRoles() {
    return this.getListAttribute('cluster_roles');
  }
  public set clusterRoles(value: string[]) {
    this._clusterRoles = value;
  }
  public resetClusterRoles() {
    this._clusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterRolesInput() {
    return this._clusterRoles;
  }

  // resources - computed: false, optional: true, required: false
  private _resources = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResourcesOutputReference(this, "resources");
  public get resources() {
    return this._resources;
  }
  public putResources(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyResources) {
    this._resources.internalValue = value;
  }
  public resetResources() {
    this._resources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourcesInput() {
    return this._resources.internalValue;
  }

  // roles - computed: false, optional: true, required: false
  private _roles?: string[]; 
  public get roles() {
    return this.getListAttribute('roles');
  }
  public set roles(value: string[]) {
    this._roles = value;
  }
  public resetRoles() {
    this._roles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rolesInput() {
    return this._roles;
  }

  // subjects - computed: false, optional: true, required: false
  private _subjects = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjectsList(this, "subjects", false);
  public get subjects() {
    return this._subjects;
  }
  public putSubjects(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnySubjects[] | cdktf.IResolvable) {
    this._subjects.internalValue = value;
  }
  public resetSubjects() {
    this._subjects.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectsInput() {
    return this._subjects.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatch {
  /**
  * All allows specifying resources which will be ANDed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll[] | cdktf.IResolvable;
  /**
  * Any allows specifying resources which will be ORed
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMatchAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData {
  /**
  * Key is a unique identifier for the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders {
  /**
  * Key is the header key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService {
  /**
  * CABundle is a PEM encoded CA bundle which will be used to validate the server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ca_bundle DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Headers is a list of optional HTTP headers to be included in the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#headers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#headers}
  */
  readonly headers?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable;
  /**
  * URL is the JSON web service URL. A typical form is 'https://{service}.{namespace}:{port}/{path}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    headers: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersToTerraform, false)(struct!.headers),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersList",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._headers.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._headers.internalValue = value.headers;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall {
  /**
  * The data object specifies the POST data sent to the server. Only applicable when the method field is set to POST.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData[] | cdktf.IResolvable;
  /**
  * Default is an optional arbitrary JSON object that the context value is set to, if the apiCall returns error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Method is the HTTP request type (GET or POST). Defaults to GET.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#method DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#method}
  */
  readonly method?: string;
  /**
  * Service is an API call to a JSON web service. This is used for non-Kubernetes API server calls. It's mutually exclusive with the URLPath field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#service DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#service}
  */
  readonly service?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService;
  /**
  * URLPath is the URL path to be used in the HTTP GET or POST request to the Kubernetes API server (e.g. '/api/v1/namespaces' or '/apis/apps/v1/deployments'). The format required is the same format used by the 'kubectl get --raw' command. See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls for details. It's mutually exclusive with the Service field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url_path}
  */
  readonly urlPath?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataToTerraform, false)(struct!.data),
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    method: cdktf.stringToTerraform(struct!.method),
    service: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceToTerraform(struct!.service),
    url_path: cdktf.stringToTerraform(struct!.urlPath),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataList",
    },
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService",
    },
    url_path: {
      value: cdktf.stringToHclTerraform(struct!.urlPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._urlPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlPath = this._urlPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._method = undefined;
      this._service.internalValue = undefined;
      this._urlPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._method = value.method;
      this._service.internalValue = value.service;
      this._urlPath = value.urlPath;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // url_path - computed: false, optional: true, required: false
  private _urlPath?: string; 
  public get urlPath() {
    return this.getStringAttribute('url_path');
  }
  public set urlPath(value: string) {
    this._urlPath = value;
  }
  public resetUrlPath() {
    this._urlPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlPathInput() {
    return this._urlPath;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap {
  /**
  * Name is the ConfigMap name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace is the ConfigMap namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMapToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMapToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference {
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Name of the global context entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReferenceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReferenceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jmesPath = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jmesPath = value.jmesPath;
      this._name = value.name;
    }
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials {
  /**
  * AllowInsecureRegistry allows insecure access to a registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#allow_insecure_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#allow_insecure_registry}
  */
  readonly allowInsecureRegistry?: boolean | cdktf.IResolvable;
  /**
  * Providers specifies a list of OCI Registry names, whose authentication providers are provided. It can be of one of these values: default,google,azure,amazon,github.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#providers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#providers}
  */
  readonly providers?: string[];
  /**
  * Secrets specifies a list of secrets that are provided for credentials. Secrets must live in the Kyverno namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#secrets DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#secrets}
  */
  readonly secrets?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_insecure_registry: cdktf.booleanToTerraform(struct!.allowInsecureRegistry),
    providers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.providers),
    secrets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.secrets),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_insecure_registry: {
      value: cdktf.booleanToHclTerraform(struct!.allowInsecureRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.providers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secrets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.secrets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowInsecureRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowInsecureRegistry = this._allowInsecureRegistry;
    }
    if (this._providers !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers;
    }
    if (this._secrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = undefined;
      this._providers = undefined;
      this._secrets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = value.allowInsecureRegistry;
      this._providers = value.providers;
      this._secrets = value.secrets;
    }
  }

  // allow_insecure_registry - computed: false, optional: true, required: false
  private _allowInsecureRegistry?: boolean | cdktf.IResolvable; 
  public get allowInsecureRegistry() {
    return this.getBooleanAttribute('allow_insecure_registry');
  }
  public set allowInsecureRegistry(value: boolean | cdktf.IResolvable) {
    this._allowInsecureRegistry = value;
  }
  public resetAllowInsecureRegistry() {
    this._allowInsecureRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInsecureRegistryInput() {
    return this._allowInsecureRegistry;
  }

  // providers - computed: false, optional: true, required: false
  private _providers?: string[]; 
  public get providers() {
    return this.getListAttribute('providers');
  }
  public set providers(value: string[]) {
    this._providers = value;
  }
  public resetProviders() {
    this._providers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets?: string[]; 
  public get secrets() {
    return this.getListAttribute('secrets');
  }
  public set secrets(value: string[]) {
    this._secrets = value;
  }
  public resetSecrets() {
    this._secrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry {
  /**
  * ImageRegistryCredentials provides credentials that will be used for authentication with registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry_credentials DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry_credentials}
  */
  readonly imageRegistryCredentials?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials;
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#reference}
  */
  readonly reference: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_registry_credentials: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsToTerraform(struct!.imageRegistryCredentials),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_registry_credentials: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsToHclTerraform(struct!.imageRegistryCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageRegistryCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistryCredentials = this._imageRegistryCredentials?.internalValue;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = undefined;
      this._jmesPath = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = value.imageRegistryCredentials;
      this._jmesPath = value.jmesPath;
      this._reference = value.reference;
    }
  }

  // image_registry_credentials - computed: false, optional: true, required: false
  private _imageRegistryCredentials = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentialsOutputReference(this, "image_registry_credentials");
  public get imageRegistryCredentials() {
    return this._imageRegistryCredentials;
  }
  public putImageRegistryCredentials(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryImageRegistryCredentials) {
    this._imageRegistryCredentials.internalValue = value;
  }
  public resetImageRegistryCredentials() {
    this._imageRegistryCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryCredentialsInput() {
    return this._imageRegistryCredentials.internalValue;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable {
  /**
  * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Value is any arbitrary JSON object representable in YAML or JSON form.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariableToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariableToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._value = value.value;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext {
  /**
  * APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_call DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_call}
  */
  readonly apiCall?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall;
  /**
  * ConfigMap is the ConfigMap reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#config_map DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap;
  /**
  * GlobalContextEntryReference is a reference to a cached global context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#global_reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#global_reference}
  */
  readonly globalReference?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference;
  /**
  * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry}
  */
  readonly imageRegistry?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry;
  /**
  * Name is the variable name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable defines an arbitrary JMESPath context variable that can be defined inline.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#variable DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#variable}
  */
  readonly variable?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_call: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallToTerraform(struct!.apiCall),
    config_map: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMapToTerraform(struct!.configMap),
    global_reference: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReferenceToTerraform(struct!.globalReference),
    image_registry: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryToTerraform(struct!.imageRegistry),
    name: cdktf.stringToTerraform(struct!.name),
    variable: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariableToTerraform(struct!.variable),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_call: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallToHclTerraform(struct!.apiCall),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall",
    },
    config_map: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap",
    },
    global_reference: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReferenceToHclTerraform(struct!.globalReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference",
    },
    image_registry: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryToHclTerraform(struct!.imageRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variable: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariableToHclTerraform(struct!.variable),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiCall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiCall = this._apiCall?.internalValue;
    }
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._globalReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalReference = this._globalReference?.internalValue;
    }
    if (this._imageRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistry = this._imageRegistry?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._variable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variable = this._variable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = undefined;
      this._configMap.internalValue = undefined;
      this._globalReference.internalValue = undefined;
      this._imageRegistry.internalValue = undefined;
      this._name = undefined;
      this._variable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = value.apiCall;
      this._configMap.internalValue = value.configMap;
      this._globalReference.internalValue = value.globalReference;
      this._imageRegistry.internalValue = value.imageRegistry;
      this._name = value.name;
      this._variable.internalValue = value.variable;
    }
  }

  // api_call - computed: false, optional: true, required: false
  private _apiCall = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCallOutputReference(this, "api_call");
  public get apiCall() {
    return this._apiCall;
  }
  public putApiCall(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextApiCall) {
    this._apiCall.internalValue = value;
  }
  public resetApiCall() {
    this._apiCall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiCallInput() {
    return this._apiCall.internalValue;
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // global_reference - computed: false, optional: true, required: false
  private _globalReference = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReferenceOutputReference(this, "global_reference");
  public get globalReference() {
    return this._globalReference;
  }
  public putGlobalReference(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextGlobalReference) {
    this._globalReference.internalValue = value;
  }
  public resetGlobalReference() {
    this._globalReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalReferenceInput() {
    return this._globalReference.internalValue;
  }

  // image_registry - computed: false, optional: true, required: false
  private _imageRegistry = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistryOutputReference(this, "image_registry");
  public get imageRegistry() {
    return this._imageRegistry;
  }
  public putImageRegistry(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextImageRegistry) {
    this._imageRegistry.internalValue = value;
  }
  public resetImageRegistry() {
    this._imageRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryInput() {
    return this._imageRegistry.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // variable - computed: false, optional: true, required: false
  private _variable = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariableOutputReference(this, "variable");
  public get variable() {
    return this._variable;
  }
  public putVariable(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextVariable) {
    this._variable.internalValue = value;
  }
  public resetVariable() {
    this._variable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get variableInput() {
    return this._variable.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions {
  /**
  * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll[] | cdktf.IResolvable;
  /**
  * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach {
  /**
  * Context defines variables and data sources that can be used during rule execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#context DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#context}
  */
  readonly context?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext[] | cdktf.IResolvable;
  /**
  * Foreach declares a nested foreach iterator
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#foreach DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#foreach}
  */
  readonly foreach?: { [key: string]: string };
  /**
  * List specifies a JMESPath expression that results in one or more elements to which the validation logic is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#list DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#list}
  */
  readonly list?: string;
  /**
  * Order defines the iteration order on the list. Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#order DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#order}
  */
  readonly order?: string;
  /**
  * PatchStrategicMerge is a strategic merge patch used to modify resources. See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/ and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#patch_strategic_merge DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#patch_strategic_merge}
  */
  readonly patchStrategicMerge?: { [key: string]: string };
  /**
  * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources. See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#patches_json6902 DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#patches_json6902}
  */
  readonly patchesJson6902?: string;
  /**
  * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested 'any' or 'all' statements. See: https://kyverno.io/docs/writing-policies/preconditions/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#preconditions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#preconditions}
  */
  readonly preconditions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextToTerraform, false)(struct!.context),
    foreach: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.foreach),
    list: cdktf.stringToTerraform(struct!.list),
    order: cdktf.stringToTerraform(struct!.order),
    patch_strategic_merge: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.patchStrategicMerge),
    patches_json6902: cdktf.stringToTerraform(struct!.patchesJson6902),
    preconditions: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsToTerraform(struct!.preconditions),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextToHclTerraform, false)(struct!.context),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextList",
    },
    foreach: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.foreach),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    list: {
      value: cdktf.stringToHclTerraform(struct!.list),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    order: {
      value: cdktf.stringToHclTerraform(struct!.order),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    patch_strategic_merge: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.patchStrategicMerge),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    patches_json6902: {
      value: cdktf.stringToHclTerraform(struct!.patchesJson6902),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preconditions: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsToHclTerraform(struct!.preconditions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context?.internalValue;
    }
    if (this._foreach !== undefined) {
      hasAnyValues = true;
      internalValueResult.foreach = this._foreach;
    }
    if (this._list !== undefined) {
      hasAnyValues = true;
      internalValueResult.list = this._list;
    }
    if (this._order !== undefined) {
      hasAnyValues = true;
      internalValueResult.order = this._order;
    }
    if (this._patchStrategicMerge !== undefined) {
      hasAnyValues = true;
      internalValueResult.patchStrategicMerge = this._patchStrategicMerge;
    }
    if (this._patchesJson6902 !== undefined) {
      hasAnyValues = true;
      internalValueResult.patchesJson6902 = this._patchesJson6902;
    }
    if (this._preconditions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preconditions = this._preconditions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context.internalValue = undefined;
      this._foreach = undefined;
      this._list = undefined;
      this._order = undefined;
      this._patchStrategicMerge = undefined;
      this._patchesJson6902 = undefined;
      this._preconditions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context.internalValue = value.context;
      this._foreach = value.foreach;
      this._list = value.list;
      this._order = value.order;
      this._patchStrategicMerge = value.patchStrategicMerge;
      this._patchesJson6902 = value.patchesJson6902;
      this._preconditions.internalValue = value.preconditions;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContextList(this, "context", false);
  public get context() {
    return this._context;
  }
  public putContext(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachContext[] | cdktf.IResolvable) {
    this._context.internalValue = value;
  }
  public resetContext() {
    this._context.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context.internalValue;
  }

  // foreach - computed: false, optional: true, required: false
  private _foreach?: { [key: string]: string }; 
  public get foreach() {
    return this.getStringMapAttribute('foreach');
  }
  public set foreach(value: { [key: string]: string }) {
    this._foreach = value;
  }
  public resetForeach() {
    this._foreach = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get foreachInput() {
    return this._foreach;
  }

  // list - computed: false, optional: true, required: false
  private _list?: string; 
  public get list() {
    return this.getStringAttribute('list');
  }
  public set list(value: string) {
    this._list = value;
  }
  public resetList() {
    this._list = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listInput() {
    return this._list;
  }

  // order - computed: false, optional: true, required: false
  private _order?: string; 
  public get order() {
    return this.getStringAttribute('order');
  }
  public set order(value: string) {
    this._order = value;
  }
  public resetOrder() {
    this._order = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderInput() {
    return this._order;
  }

  // patch_strategic_merge - computed: false, optional: true, required: false
  private _patchStrategicMerge?: { [key: string]: string }; 
  public get patchStrategicMerge() {
    return this.getStringMapAttribute('patch_strategic_merge');
  }
  public set patchStrategicMerge(value: { [key: string]: string }) {
    this._patchStrategicMerge = value;
  }
  public resetPatchStrategicMerge() {
    this._patchStrategicMerge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patchStrategicMergeInput() {
    return this._patchStrategicMerge;
  }

  // patches_json6902 - computed: false, optional: true, required: false
  private _patchesJson6902?: string; 
  public get patchesJson6902() {
    return this.getStringAttribute('patches_json6902');
  }
  public set patchesJson6902(value: string) {
    this._patchesJson6902 = value;
  }
  public resetPatchesJson6902() {
    this._patchesJson6902 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patchesJson6902Input() {
    return this._patchesJson6902;
  }

  // preconditions - computed: false, optional: true, required: false
  private _preconditions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditionsOutputReference(this, "preconditions");
  public get preconditions() {
    return this._preconditions;
  }
  public putPreconditions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachPreconditions) {
    this._preconditions.internalValue = value;
  }
  public resetPreconditions() {
    this._preconditions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preconditionsInput() {
    return this._preconditions.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData {
  /**
  * Key is a unique identifier for the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders {
  /**
  * Key is the header key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService {
  /**
  * CABundle is a PEM encoded CA bundle which will be used to validate the server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ca_bundle DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Headers is a list of optional HTTP headers to be included in the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#headers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#headers}
  */
  readonly headers?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders[] | cdktf.IResolvable;
  /**
  * URL is the JSON web service URL. A typical form is 'https://{service}.{namespace}:{port}/{path}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    headers: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersToTerraform, false)(struct!.headers),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersList",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._headers.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._headers.internalValue = value.headers;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall {
  /**
  * The data object specifies the POST data sent to the server. Only applicable when the method field is set to POST.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData[] | cdktf.IResolvable;
  /**
  * Default is an optional arbitrary JSON object that the context value is set to, if the apiCall returns error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Method is the HTTP request type (GET or POST). Defaults to GET.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#method DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#method}
  */
  readonly method?: string;
  /**
  * Service is an API call to a JSON web service. This is used for non-Kubernetes API server calls. It's mutually exclusive with the URLPath field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#service DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#service}
  */
  readonly service?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService;
  /**
  * URLPath is the URL path to be used in the HTTP GET or POST request to the Kubernetes API server (e.g. '/api/v1/namespaces' or '/apis/apps/v1/deployments'). The format required is the same format used by the 'kubectl get --raw' command. See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls for details. It's mutually exclusive with the Service field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url_path}
  */
  readonly urlPath?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataToTerraform, false)(struct!.data),
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    method: cdktf.stringToTerraform(struct!.method),
    service: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceToTerraform(struct!.service),
    url_path: cdktf.stringToTerraform(struct!.urlPath),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataList",
    },
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService",
    },
    url_path: {
      value: cdktf.stringToHclTerraform(struct!.urlPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._urlPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlPath = this._urlPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._method = undefined;
      this._service.internalValue = undefined;
      this._urlPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._method = value.method;
      this._service.internalValue = value.service;
      this._urlPath = value.urlPath;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // url_path - computed: false, optional: true, required: false
  private _urlPath?: string; 
  public get urlPath() {
    return this.getStringAttribute('url_path');
  }
  public set urlPath(value: string) {
    this._urlPath = value;
  }
  public resetUrlPath() {
    this._urlPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlPathInput() {
    return this._urlPath;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap {
  /**
  * Name is the ConfigMap name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace is the ConfigMap namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMapToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMapToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference {
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Name of the global context entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReferenceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReferenceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jmesPath = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jmesPath = value.jmesPath;
      this._name = value.name;
    }
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials {
  /**
  * AllowInsecureRegistry allows insecure access to a registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#allow_insecure_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#allow_insecure_registry}
  */
  readonly allowInsecureRegistry?: boolean | cdktf.IResolvable;
  /**
  * Providers specifies a list of OCI Registry names, whose authentication providers are provided. It can be of one of these values: default,google,azure,amazon,github.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#providers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#providers}
  */
  readonly providers?: string[];
  /**
  * Secrets specifies a list of secrets that are provided for credentials. Secrets must live in the Kyverno namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#secrets DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#secrets}
  */
  readonly secrets?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_insecure_registry: cdktf.booleanToTerraform(struct!.allowInsecureRegistry),
    providers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.providers),
    secrets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.secrets),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_insecure_registry: {
      value: cdktf.booleanToHclTerraform(struct!.allowInsecureRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.providers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secrets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.secrets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowInsecureRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowInsecureRegistry = this._allowInsecureRegistry;
    }
    if (this._providers !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers;
    }
    if (this._secrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = undefined;
      this._providers = undefined;
      this._secrets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = value.allowInsecureRegistry;
      this._providers = value.providers;
      this._secrets = value.secrets;
    }
  }

  // allow_insecure_registry - computed: false, optional: true, required: false
  private _allowInsecureRegistry?: boolean | cdktf.IResolvable; 
  public get allowInsecureRegistry() {
    return this.getBooleanAttribute('allow_insecure_registry');
  }
  public set allowInsecureRegistry(value: boolean | cdktf.IResolvable) {
    this._allowInsecureRegistry = value;
  }
  public resetAllowInsecureRegistry() {
    this._allowInsecureRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInsecureRegistryInput() {
    return this._allowInsecureRegistry;
  }

  // providers - computed: false, optional: true, required: false
  private _providers?: string[]; 
  public get providers() {
    return this.getListAttribute('providers');
  }
  public set providers(value: string[]) {
    this._providers = value;
  }
  public resetProviders() {
    this._providers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets?: string[]; 
  public get secrets() {
    return this.getListAttribute('secrets');
  }
  public set secrets(value: string[]) {
    this._secrets = value;
  }
  public resetSecrets() {
    this._secrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry {
  /**
  * ImageRegistryCredentials provides credentials that will be used for authentication with registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry_credentials DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry_credentials}
  */
  readonly imageRegistryCredentials?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials;
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#reference}
  */
  readonly reference: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_registry_credentials: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsToTerraform(struct!.imageRegistryCredentials),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_registry_credentials: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsToHclTerraform(struct!.imageRegistryCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageRegistryCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistryCredentials = this._imageRegistryCredentials?.internalValue;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = undefined;
      this._jmesPath = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = value.imageRegistryCredentials;
      this._jmesPath = value.jmesPath;
      this._reference = value.reference;
    }
  }

  // image_registry_credentials - computed: false, optional: true, required: false
  private _imageRegistryCredentials = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentialsOutputReference(this, "image_registry_credentials");
  public get imageRegistryCredentials() {
    return this._imageRegistryCredentials;
  }
  public putImageRegistryCredentials(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryImageRegistryCredentials) {
    this._imageRegistryCredentials.internalValue = value;
  }
  public resetImageRegistryCredentials() {
    this._imageRegistryCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryCredentialsInput() {
    return this._imageRegistryCredentials.internalValue;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable {
  /**
  * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Value is any arbitrary JSON object representable in YAML or JSON form.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariableToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariableToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._value = value.value;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext {
  /**
  * APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_call DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_call}
  */
  readonly apiCall?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall;
  /**
  * ConfigMap is the ConfigMap reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#config_map DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap;
  /**
  * GlobalContextEntryReference is a reference to a cached global context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#global_reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#global_reference}
  */
  readonly globalReference?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference;
  /**
  * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry}
  */
  readonly imageRegistry?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry;
  /**
  * Name is the variable name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable defines an arbitrary JMESPath context variable that can be defined inline.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#variable DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#variable}
  */
  readonly variable?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_call: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallToTerraform(struct!.apiCall),
    config_map: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMapToTerraform(struct!.configMap),
    global_reference: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReferenceToTerraform(struct!.globalReference),
    image_registry: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryToTerraform(struct!.imageRegistry),
    name: cdktf.stringToTerraform(struct!.name),
    variable: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariableToTerraform(struct!.variable),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_call: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallToHclTerraform(struct!.apiCall),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall",
    },
    config_map: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap",
    },
    global_reference: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReferenceToHclTerraform(struct!.globalReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference",
    },
    image_registry: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryToHclTerraform(struct!.imageRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variable: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariableToHclTerraform(struct!.variable),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiCall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiCall = this._apiCall?.internalValue;
    }
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._globalReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalReference = this._globalReference?.internalValue;
    }
    if (this._imageRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistry = this._imageRegistry?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._variable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variable = this._variable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = undefined;
      this._configMap.internalValue = undefined;
      this._globalReference.internalValue = undefined;
      this._imageRegistry.internalValue = undefined;
      this._name = undefined;
      this._variable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = value.apiCall;
      this._configMap.internalValue = value.configMap;
      this._globalReference.internalValue = value.globalReference;
      this._imageRegistry.internalValue = value.imageRegistry;
      this._name = value.name;
      this._variable.internalValue = value.variable;
    }
  }

  // api_call - computed: false, optional: true, required: false
  private _apiCall = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCallOutputReference(this, "api_call");
  public get apiCall() {
    return this._apiCall;
  }
  public putApiCall(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextApiCall) {
    this._apiCall.internalValue = value;
  }
  public resetApiCall() {
    this._apiCall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiCallInput() {
    return this._apiCall.internalValue;
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // global_reference - computed: false, optional: true, required: false
  private _globalReference = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReferenceOutputReference(this, "global_reference");
  public get globalReference() {
    return this._globalReference;
  }
  public putGlobalReference(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextGlobalReference) {
    this._globalReference.internalValue = value;
  }
  public resetGlobalReference() {
    this._globalReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalReferenceInput() {
    return this._globalReference.internalValue;
  }

  // image_registry - computed: false, optional: true, required: false
  private _imageRegistry = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistryOutputReference(this, "image_registry");
  public get imageRegistry() {
    return this._imageRegistry;
  }
  public putImageRegistry(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextImageRegistry) {
    this._imageRegistry.internalValue = value;
  }
  public resetImageRegistry() {
    this._imageRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryInput() {
    return this._imageRegistry.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // variable - computed: false, optional: true, required: false
  private _variable = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariableOutputReference(this, "variable");
  public get variable() {
    return this._variable;
  }
  public putVariable(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextVariable) {
    this._variable.internalValue = value;
  }
  public resetVariable() {
    this._variable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get variableInput() {
    return this._variable.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets {
  /**
  * APIVersion specifies resource apiVersion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_version DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Context defines variables and data sources that can be used during rule execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#context DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#context}
  */
  readonly context?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext[] | cdktf.IResolvable;
  /**
  * Kind specifies resource kind.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name specifies the resource name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace specifies resource namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Preconditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested 'any' or 'all' statements. A direct list of conditions (without 'any' or 'all' statements is supported for backwards compatibility but will be deprecated in the next major release. See: https://kyverno.io/docs/writing-policies/preconditions/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#preconditions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#preconditions}
  */
  readonly preconditions?: { [key: string]: string };
  /**
  * Selector allows you to select target resources with their labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector;
  /**
  * UID specifies the resource uid.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#uid DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#uid}
  */
  readonly uid?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    context: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextToTerraform, false)(struct!.context),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    preconditions: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.preconditions),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorToTerraform(struct!.selector),
    uid: cdktf.stringToTerraform(struct!.uid),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    context: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextToHclTerraform, false)(struct!.context),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextList",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preconditions: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.preconditions),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector",
    },
    uid: {
      value: cdktf.stringToHclTerraform(struct!.uid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._context?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._preconditions !== undefined) {
      hasAnyValues = true;
      internalValueResult.preconditions = this._preconditions;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    if (this._uid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uid = this._uid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._context.internalValue = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._preconditions = undefined;
      this._selector.internalValue = undefined;
      this._uid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._context.internalValue = value.context;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._preconditions = value.preconditions;
      this._selector.internalValue = value.selector;
      this._uid = value.uid;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // context - computed: false, optional: true, required: false
  private _context = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContextList(this, "context", false);
  public get context() {
    return this._context;
  }
  public putContext(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsContext[] | cdktf.IResolvable) {
    this._context.internalValue = value;
  }
  public resetContext() {
    this._context.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context.internalValue;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // preconditions - computed: false, optional: true, required: false
  private _preconditions?: { [key: string]: string }; 
  public get preconditions() {
    return this.getStringMapAttribute('preconditions');
  }
  public set preconditions(value: { [key: string]: string }) {
    this._preconditions = value;
  }
  public resetPreconditions() {
    this._preconditions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preconditionsInput() {
    return this._preconditions;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }

  // uid - computed: false, optional: true, required: false
  private _uid?: string; 
  public get uid() {
    return this.getStringAttribute('uid');
  }
  public set uid(value: string) {
    this._uid = value;
  }
  public resetUid() {
    this._uid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidInput() {
    return this._uid;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutate {
  /**
  * ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#foreach DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#foreach}
  */
  readonly foreach?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach[] | cdktf.IResolvable;
  /**
  * MutateExistingOnPolicyUpdate controls if the mutateExisting rule will be applied on policy events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#mutate_existing_on_policy_update DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#mutate_existing_on_policy_update}
  */
  readonly mutateExistingOnPolicyUpdate?: boolean | cdktf.IResolvable;
  /**
  * PatchStrategicMerge is a strategic merge patch used to modify resources. See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/ and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#patch_strategic_merge DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#patch_strategic_merge}
  */
  readonly patchStrategicMerge?: { [key: string]: string };
  /**
  * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources. See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#patches_json6902 DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#patches_json6902}
  */
  readonly patchesJson6902?: string;
  /**
  * Targets defines the target resources to be mutated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#targets DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#targets}
  */
  readonly targets?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    foreach: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachToTerraform, false)(struct!.foreach),
    mutate_existing_on_policy_update: cdktf.booleanToTerraform(struct!.mutateExistingOnPolicyUpdate),
    patch_strategic_merge: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.patchStrategicMerge),
    patches_json6902: cdktf.stringToTerraform(struct!.patchesJson6902),
    targets: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsToTerraform, false)(struct!.targets),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    foreach: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachToHclTerraform, false)(struct!.foreach),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachList",
    },
    mutate_existing_on_policy_update: {
      value: cdktf.booleanToHclTerraform(struct!.mutateExistingOnPolicyUpdate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    patch_strategic_merge: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.patchStrategicMerge),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    patches_json6902: {
      value: cdktf.stringToHclTerraform(struct!.patchesJson6902),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    targets: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsToHclTerraform, false)(struct!.targets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._foreach?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.foreach = this._foreach?.internalValue;
    }
    if (this._mutateExistingOnPolicyUpdate !== undefined) {
      hasAnyValues = true;
      internalValueResult.mutateExistingOnPolicyUpdate = this._mutateExistingOnPolicyUpdate;
    }
    if (this._patchStrategicMerge !== undefined) {
      hasAnyValues = true;
      internalValueResult.patchStrategicMerge = this._patchStrategicMerge;
    }
    if (this._patchesJson6902 !== undefined) {
      hasAnyValues = true;
      internalValueResult.patchesJson6902 = this._patchesJson6902;
    }
    if (this._targets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targets = this._targets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._foreach.internalValue = undefined;
      this._mutateExistingOnPolicyUpdate = undefined;
      this._patchStrategicMerge = undefined;
      this._patchesJson6902 = undefined;
      this._targets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._foreach.internalValue = value.foreach;
      this._mutateExistingOnPolicyUpdate = value.mutateExistingOnPolicyUpdate;
      this._patchStrategicMerge = value.patchStrategicMerge;
      this._patchesJson6902 = value.patchesJson6902;
      this._targets.internalValue = value.targets;
    }
  }

  // foreach - computed: false, optional: true, required: false
  private _foreach = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeachList(this, "foreach", false);
  public get foreach() {
    return this._foreach;
  }
  public putForeach(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateForeach[] | cdktf.IResolvable) {
    this._foreach.internalValue = value;
  }
  public resetForeach() {
    this._foreach.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get foreachInput() {
    return this._foreach.internalValue;
  }

  // mutate_existing_on_policy_update - computed: false, optional: true, required: false
  private _mutateExistingOnPolicyUpdate?: boolean | cdktf.IResolvable; 
  public get mutateExistingOnPolicyUpdate() {
    return this.getBooleanAttribute('mutate_existing_on_policy_update');
  }
  public set mutateExistingOnPolicyUpdate(value: boolean | cdktf.IResolvable) {
    this._mutateExistingOnPolicyUpdate = value;
  }
  public resetMutateExistingOnPolicyUpdate() {
    this._mutateExistingOnPolicyUpdate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mutateExistingOnPolicyUpdateInput() {
    return this._mutateExistingOnPolicyUpdate;
  }

  // patch_strategic_merge - computed: false, optional: true, required: false
  private _patchStrategicMerge?: { [key: string]: string }; 
  public get patchStrategicMerge() {
    return this.getStringMapAttribute('patch_strategic_merge');
  }
  public set patchStrategicMerge(value: { [key: string]: string }) {
    this._patchStrategicMerge = value;
  }
  public resetPatchStrategicMerge() {
    this._patchStrategicMerge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patchStrategicMergeInput() {
    return this._patchStrategicMerge;
  }

  // patches_json6902 - computed: false, optional: true, required: false
  private _patchesJson6902?: string; 
  public get patchesJson6902() {
    return this.getStringAttribute('patches_json6902');
  }
  public set patchesJson6902(value: string) {
    this._patchesJson6902 = value;
  }
  public resetPatchesJson6902() {
    this._patchesJson6902 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patchesJson6902Input() {
    return this._patchesJson6902;
  }

  // targets - computed: false, optional: true, required: false
  private _targets = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargetsList(this, "targets", false);
  public get targets() {
    return this._targets;
  }
  public putTargets(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesMutateTargets[] | cdktf.IResolvable) {
    this._targets.internalValue = value;
  }
  public resetTargets() {
    this._targets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetsInput() {
    return this._targets.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditions {
  /**
  * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll[] | cdktf.IResolvable;
  /**
  * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesPreconditionsAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations {
  /**
  * key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length. The key is combined with the resource name of the ValidatingAdmissionPolicy to construct an audit annotation key: '{ValidatingAdmissionPolicy name}/{key}'. If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy and the same audit annotation key, the annotation key will be identical. In this case, the first annotation written with the key will be included in the audit event and all subsequent annotations with the same key will be discarded. Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb. If multiple ValidatingAdmissionPolicyBinding resources match an API request, then the valueExpression will be evaluated for each binding. All unique values produced by the valueExpressions will be joined together in a comma-separated list. Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value_expression DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value_expression}
  */
  readonly valueExpression: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value_expression: cdktf.stringToTerraform(struct!.valueExpression),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_expression: {
      value: cdktf.stringToHclTerraform(struct!.valueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._valueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueExpression = this._valueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._valueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._valueExpression = value.valueExpression;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value_expression - computed: false, optional: false, required: true
  private _valueExpression?: string; 
  public get valueExpression() {
    return this.getStringAttribute('value_expression');
  }
  public set valueExpression(value: string) {
    this._valueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueExpressionInput() {
    return this._valueExpression;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions {
  /**
  * Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables: - 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value. For example, a variable named 'foo' can be accessed as 'variables.foo'. - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request. See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the request resource. The 'apiVersion', 'kind', 'metadata.name' and 'metadata.generateName' are always accessible from the root of the object. No other metadata properties are accessible. Only property names of the form '[a-zA-Z_.-/][a-zA-Z0-9_.-/]*' are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are: 'true', 'false', 'null', 'in', 'as', 'break', 'const', 'continue', 'else', 'for', 'function', 'if', 'import', 'let', 'loop', 'package', 'namespace', 'return'. Examples: - Expression accessing a property named 'namespace': {'Expression': 'object.__namespace__ > 0'} - Expression accessing a property named 'x-prop': {'Expression': 'object.x__dash__prop > 0'} - Expression accessing a property named 'redact__d': {'Expression': 'object.redact__underscores__d > 0'} Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type: - 'set': 'X + Y' performs a union where the array positions of all elements in 'X' are preserved and non-intersecting elements in 'Y' are appended, retaining their partial order. - 'map': 'X + Y' performs a merge where the array positions of all keys in 'X' are preserved but the values are overwritten by values in 'Y' when the key sets of 'X' and 'Y' intersect. Elements in 'Y' with non-intersecting keys are appended, retaining their partial order. Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#expression DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#expression}
  */
  readonly expression: string;
  /**
  * Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is 'failed rule: {Rule}'. e.g. 'must be a URL with the host matching spec.host' If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is 'failed Expression: {Expression}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the 'expression' except for 'authorizer' and 'authorizer.requestResource'. Example: 'object.x must be less than max ('+string(params.max)+')'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message_expression DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message_expression}
  */
  readonly messageExpression?: string;
  /**
  * Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: 'Unauthorized', 'Forbidden', 'Invalid', 'RequestEntityTooLarge'. If not set, StatusReasonInvalid is used in the response to the client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#reason DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#reason}
  */
  readonly reason?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expression: cdktf.stringToTerraform(struct!.expression),
    message: cdktf.stringToTerraform(struct!.message),
    message_expression: cdktf.stringToTerraform(struct!.messageExpression),
    reason: cdktf.stringToTerraform(struct!.reason),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_expression: {
      value: cdktf.stringToHclTerraform(struct!.messageExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reason: {
      value: cdktf.stringToHclTerraform(struct!.reason),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageExpression = this._messageExpression;
    }
    if (this._reason !== undefined) {
      hasAnyValues = true;
      internalValueResult.reason = this._reason;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expression = undefined;
      this._message = undefined;
      this._messageExpression = undefined;
      this._reason = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expression = value.expression;
      this._message = value.message;
      this._messageExpression = value.messageExpression;
      this._reason = value.reason;
    }
  }

  // expression - computed: false, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_expression - computed: false, optional: true, required: false
  private _messageExpression?: string; 
  public get messageExpression() {
    return this.getStringAttribute('message_expression');
  }
  public set messageExpression(value: string) {
    this._messageExpression = value;
  }
  public resetMessageExpression() {
    this._messageExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageExpressionInput() {
    return this._messageExpression;
  }

  // reason - computed: false, optional: true, required: false
  private _reason?: string; 
  public get reason() {
    return this.getStringAttribute('reason');
  }
  public set reason(value: string) {
    this._reason = value;
  }
  public resetReason() {
    this._reason = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reasonInput() {
    return this._reason;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind {
  /**
  * APIVersion is the API group version the resources belong to. In format of 'group/version'. Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_version DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Kind is the API kind the resources belong to. Required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKindToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKindToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKindOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef {
  /**
  * name is the name of the resource being referenced. One of 'name' or 'selector' must be set, but 'name' and 'selector' are mutually exclusive properties. If one is set, the other must be unset. A single parameter used for all admission requests can be configured by setting the 'name' field, leaving 'selector' blank, and setting namespace if 'paramKind' is namespace-scoped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both 'name' and 'selector' fields. A per-namespace parameter may be used by specifying a namespace-scoped 'paramKind' in the policy and leaving this field empty. - If 'paramKind' is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error. - If 'paramKind' is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * 'parameterNotFoundAction' controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to 'Allow', then no matched parameters will be treated as successful validation by the binding. If set to 'Deny', then no matched parameters will be subject to the 'failurePolicy' of the policy. Allowed values are 'Allow' or 'Deny' Required
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#parameter_not_found_action DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#parameter_not_found_action}
  */
  readonly parameterNotFoundAction?: string;
  /**
  * selector can be used to match multiple param objects based on their labels. Supply selector: {} to match all resources of the ParamKind. If multiple params are found, they are all evaluated with the policy expressions and the results are ANDed together. One of 'name' or 'selector' must be set, but 'name' and 'selector' are mutually exclusive properties. If one is set, the other must be unset.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#selector}
  */
  readonly selector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    parameter_not_found_action: cdktf.stringToTerraform(struct!.parameterNotFoundAction),
    selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parameter_not_found_action: {
      value: cdktf.stringToHclTerraform(struct!.parameterNotFoundAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._parameterNotFoundAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameterNotFoundAction = this._parameterNotFoundAction;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._parameterNotFoundAction = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._parameterNotFoundAction = value.parameterNotFoundAction;
      this._selector.internalValue = value.selector;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // parameter_not_found_action - computed: false, optional: true, required: false
  private _parameterNotFoundAction?: string; 
  public get parameterNotFoundAction() {
    return this.getStringAttribute('parameter_not_found_action');
  }
  public set parameterNotFoundAction(value: string) {
    this._parameterNotFoundAction = value;
  }
  public resetParameterNotFoundAction() {
    this._parameterNotFoundAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parameterNotFoundActionInput() {
    return this._parameterNotFoundAction;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables {
  /**
  * Expression is the expression that will be evaluated as the value of the variable. The CEL expression has access to the same identifiers as the CEL expressions in Validation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#expression DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#expression}
  */
  readonly expression: string;
  /**
  * Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables. The variable can be accessed in other expressions through 'variables' For example, if name is 'foo', the variable will be available as 'variables.foo'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expression: cdktf.stringToTerraform(struct!.expression),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expression = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expression = value.expression;
      this._name = value.name;
    }
  }

  // expression - computed: false, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCel {
  /**
  * AuditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#audit_annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#audit_annotations}
  */
  readonly auditAnnotations?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations[] | cdktf.IResolvable;
  /**
  * Expressions is a list of CELExpression types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#expressions}
  */
  readonly expressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions[] | cdktf.IResolvable;
  /**
  * ParamKind is a tuple of Group Kind and Version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#param_kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#param_kind}
  */
  readonly paramKind?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind;
  /**
  * ParamRef references a parameter resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#param_ref DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#param_ref}
  */
  readonly paramRef?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef;
  /**
  * Variables contain definitions of variables that can be used in composition of other expressions. Each variable is defined as a named CEL expression. The variables defined here will be available under 'variables' in other expressions of the policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#variables DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#variables}
  */
  readonly variables?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audit_annotations: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsToTerraform, false)(struct!.auditAnnotations),
    expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsToTerraform, false)(struct!.expressions),
    param_kind: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKindToTerraform(struct!.paramKind),
    param_ref: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefToTerraform(struct!.paramRef),
    variables: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesToTerraform, false)(struct!.variables),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audit_annotations: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsToHclTerraform, false)(struct!.auditAnnotations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsList",
    },
    expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsToHclTerraform, false)(struct!.expressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsList",
    },
    param_kind: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKindToHclTerraform(struct!.paramKind),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind",
    },
    param_ref: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefToHclTerraform(struct!.paramRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef",
    },
    variables: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesToHclTerraform, false)(struct!.variables),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auditAnnotations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auditAnnotations = this._auditAnnotations?.internalValue;
    }
    if (this._expressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressions = this._expressions?.internalValue;
    }
    if (this._paramKind?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.paramKind = this._paramKind?.internalValue;
    }
    if (this._paramRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.paramRef = this._paramRef?.internalValue;
    }
    if (this._variables?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variables = this._variables?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auditAnnotations.internalValue = undefined;
      this._expressions.internalValue = undefined;
      this._paramKind.internalValue = undefined;
      this._paramRef.internalValue = undefined;
      this._variables.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auditAnnotations.internalValue = value.auditAnnotations;
      this._expressions.internalValue = value.expressions;
      this._paramKind.internalValue = value.paramKind;
      this._paramRef.internalValue = value.paramRef;
      this._variables.internalValue = value.variables;
    }
  }

  // audit_annotations - computed: false, optional: true, required: false
  private _auditAnnotations = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotationsList(this, "audit_annotations", false);
  public get auditAnnotations() {
    return this._auditAnnotations;
  }
  public putAuditAnnotations(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelAuditAnnotations[] | cdktf.IResolvable) {
    this._auditAnnotations.internalValue = value;
  }
  public resetAuditAnnotations() {
    this._auditAnnotations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auditAnnotationsInput() {
    return this._auditAnnotations.internalValue;
  }

  // expressions - computed: false, optional: true, required: false
  private _expressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressionsList(this, "expressions", false);
  public get expressions() {
    return this._expressions;
  }
  public putExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelExpressions[] | cdktf.IResolvable) {
    this._expressions.internalValue = value;
  }
  public resetExpressions() {
    this._expressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionsInput() {
    return this._expressions.internalValue;
  }

  // param_kind - computed: false, optional: true, required: false
  private _paramKind = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKindOutputReference(this, "param_kind");
  public get paramKind() {
    return this._paramKind;
  }
  public putParamKind(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamKind) {
    this._paramKind.internalValue = value;
  }
  public resetParamKind() {
    this._paramKind.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get paramKindInput() {
    return this._paramKind.internalValue;
  }

  // param_ref - computed: false, optional: true, required: false
  private _paramRef = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRefOutputReference(this, "param_ref");
  public get paramRef() {
    return this._paramRef;
  }
  public putParamRef(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelParamRef) {
    this._paramRef.internalValue = value;
  }
  public resetParamRef() {
    this._paramRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get paramRefInput() {
    return this._paramRef.internalValue;
  }

  // variables - computed: false, optional: true, required: false
  private _variables = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariablesList(this, "variables", false);
  public get variables() {
    return this._variables;
  }
  public putVariables(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateCelVariables[] | cdktf.IResolvable) {
    this._variables.internalValue = value;
  }
  public resetVariables() {
    this._variables.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get variablesInput() {
    return this._variables.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions {
  /**
  * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll[] | cdktf.IResolvable;
  /**
  * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDeny {
  /**
  * Multiple conditions can be declared under an 'any' or 'all' statement. See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#conditions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#conditions}
  */
  readonly conditions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    conditions: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsToTerraform(struct!.conditions),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    conditions: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsToHclTerraform(struct!.conditions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDeny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._conditions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditions = this._conditions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDeny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._conditions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._conditions.internalValue = value.conditions;
    }
  }

  // conditions - computed: false, optional: true, required: false
  private _conditions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditionsOutputReference(this, "conditions");
  public get conditions() {
    return this._conditions;
  }
  public putConditions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateDenyConditions) {
    this._conditions.internalValue = value;
  }
  public resetConditions() {
    this._conditions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionsInput() {
    return this._conditions.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#values DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_expressions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#match_labels DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverrides {
  /**
  * ValidationFailureAction defines the policy validation failure action
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#action DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#action}
  */
  readonly action?: string;
  /**
  * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace_selector DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespaces DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    namespace_selector: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_selector: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._action = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._action = value.action;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverrides[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateFailureActionOverridesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData {
  /**
  * Key is a unique identifier for the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the data value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders {
  /**
  * Key is the header key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Value is the header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService {
  /**
  * CABundle is a PEM encoded CA bundle which will be used to validate the server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ca_bundle DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Headers is a list of optional HTTP headers to be included in the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#headers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#headers}
  */
  readonly headers?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable;
  /**
  * URL is the JSON web service URL. A typical form is 'https://{service}.{namespace}:{port}/{path}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    headers: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersToTerraform, false)(struct!.headers),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersList",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._headers.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._headers.internalValue = value.headers;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall {
  /**
  * The data object specifies the POST data sent to the server. Only applicable when the method field is set to POST.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#data DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#data}
  */
  readonly data?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData[] | cdktf.IResolvable;
  /**
  * Default is an optional arbitrary JSON object that the context value is set to, if the apiCall returns error.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Method is the HTTP request type (GET or POST). Defaults to GET.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#method DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#method}
  */
  readonly method?: string;
  /**
  * Service is an API call to a JSON web service. This is used for non-Kubernetes API server calls. It's mutually exclusive with the URLPath field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#service DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#service}
  */
  readonly service?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService;
  /**
  * URLPath is the URL path to be used in the HTTP GET or POST request to the Kubernetes API server (e.g. '/api/v1/namespaces' or '/apis/apps/v1/deployments'). The format required is the same format used by the 'kubectl get --raw' command. See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls for details. It's mutually exclusive with the Service field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url_path}
  */
  readonly urlPath?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataToTerraform, false)(struct!.data),
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    method: cdktf.stringToTerraform(struct!.method),
    service: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceToTerraform(struct!.service),
    url_path: cdktf.stringToTerraform(struct!.urlPath),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataList",
    },
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceToHclTerraform(struct!.service),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService",
    },
    url_path: {
      value: cdktf.stringToHclTerraform(struct!.urlPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._service?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service?.internalValue;
    }
    if (this._urlPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlPath = this._urlPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._method = undefined;
      this._service.internalValue = undefined;
      this._urlPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._method = value.method;
      this._service.internalValue = value.service;
      this._urlPath = value.urlPath;
    }
  }

  // data - computed: false, optional: true, required: false
  private _data = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  public resetData() {
    this._data.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // service - computed: false, optional: true, required: false
  private _service = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallServiceOutputReference(this, "service");
  public get service() {
    return this._service;
  }
  public putService(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallService) {
    this._service.internalValue = value;
  }
  public resetService() {
    this._service.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service.internalValue;
  }

  // url_path - computed: false, optional: true, required: false
  private _urlPath?: string; 
  public get urlPath() {
    return this.getStringAttribute('url_path');
  }
  public set urlPath(value: string) {
    this._urlPath = value;
  }
  public resetUrlPath() {
    this._urlPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlPathInput() {
    return this._urlPath;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap {
  /**
  * Name is the ConfigMap name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace is the ConfigMap namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMapToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMapToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference {
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the server. For example a JMESPath of 'items | length(@)' applied to the API server response for the URLPath '/apis/apps/v1/deployments' will return the total count of deployments across all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Name of the global context entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReferenceToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReferenceToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jmesPath = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jmesPath = value.jmesPath;
      this._name = value.name;
    }
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials {
  /**
  * AllowInsecureRegistry allows insecure access to a registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#allow_insecure_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#allow_insecure_registry}
  */
  readonly allowInsecureRegistry?: boolean | cdktf.IResolvable;
  /**
  * Providers specifies a list of OCI Registry names, whose authentication providers are provided. It can be of one of these values: default,google,azure,amazon,github.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#providers DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#providers}
  */
  readonly providers?: string[];
  /**
  * Secrets specifies a list of secrets that are provided for credentials. Secrets must live in the Kyverno namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#secrets DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#secrets}
  */
  readonly secrets?: string[];
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_insecure_registry: cdktf.booleanToTerraform(struct!.allowInsecureRegistry),
    providers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.providers),
    secrets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.secrets),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_insecure_registry: {
      value: cdktf.booleanToHclTerraform(struct!.allowInsecureRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.providers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secrets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.secrets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowInsecureRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowInsecureRegistry = this._allowInsecureRegistry;
    }
    if (this._providers !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers;
    }
    if (this._secrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = undefined;
      this._providers = undefined;
      this._secrets = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowInsecureRegistry = value.allowInsecureRegistry;
      this._providers = value.providers;
      this._secrets = value.secrets;
    }
  }

  // allow_insecure_registry - computed: false, optional: true, required: false
  private _allowInsecureRegistry?: boolean | cdktf.IResolvable; 
  public get allowInsecureRegistry() {
    return this.getBooleanAttribute('allow_insecure_registry');
  }
  public set allowInsecureRegistry(value: boolean | cdktf.IResolvable) {
    this._allowInsecureRegistry = value;
  }
  public resetAllowInsecureRegistry() {
    this._allowInsecureRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowInsecureRegistryInput() {
    return this._allowInsecureRegistry;
  }

  // providers - computed: false, optional: true, required: false
  private _providers?: string[]; 
  public get providers() {
    return this.getListAttribute('providers');
  }
  public set providers(value: string[]) {
    this._providers = value;
  }
  public resetProviders() {
    this._providers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets?: string[]; 
  public get secrets() {
    return this.getListAttribute('secrets');
  }
  public set secrets(value: string[]) {
    this._secrets = value;
  }
  public resetSecrets() {
    this._secrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry {
  /**
  * ImageRegistryCredentials provides credentials that will be used for authentication with registry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry_credentials DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry_credentials}
  */
  readonly imageRegistryCredentials?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials;
  /**
  * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#reference}
  */
  readonly reference: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image_registry_credentials: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsToTerraform(struct!.imageRegistryCredentials),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image_registry_credentials: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsToHclTerraform(struct!.imageRegistryCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._imageRegistryCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistryCredentials = this._imageRegistryCredentials?.internalValue;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = undefined;
      this._jmesPath = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._imageRegistryCredentials.internalValue = value.imageRegistryCredentials;
      this._jmesPath = value.jmesPath;
      this._reference = value.reference;
    }
  }

  // image_registry_credentials - computed: false, optional: true, required: false
  private _imageRegistryCredentials = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentialsOutputReference(this, "image_registry_credentials");
  public get imageRegistryCredentials() {
    return this._imageRegistryCredentials;
  }
  public putImageRegistryCredentials(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryImageRegistryCredentials) {
    this._imageRegistryCredentials.internalValue = value;
  }
  public resetImageRegistryCredentials() {
    this._imageRegistryCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryCredentialsInput() {
    return this._imageRegistryCredentials.internalValue;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable {
  /**
  * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#default DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#default}
  */
  readonly default?: { [key: string]: string };
  /**
  * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#jmes_path DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#jmes_path}
  */
  readonly jmesPath?: string;
  /**
  * Value is any arbitrary JSON object representable in YAML or JSON form.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariableToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.default),
    jmes_path: cdktf.stringToTerraform(struct!.jmesPath),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariableToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.default),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    jmes_path: {
      value: cdktf.stringToHclTerraform(struct!.jmesPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._jmesPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmesPath = this._jmesPath;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._default = undefined;
      this._jmesPath = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._default = value.default;
      this._jmesPath = value.jmesPath;
      this._value = value.value;
    }
  }

  // default - computed: false, optional: true, required: false
  private _default?: { [key: string]: string }; 
  public get default() {
    return this.getStringMapAttribute('default');
  }
  public set default(value: { [key: string]: string }) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // jmes_path - computed: false, optional: true, required: false
  private _jmesPath?: string; 
  public get jmesPath() {
    return this.getStringAttribute('jmes_path');
  }
  public set jmesPath(value: string) {
    this._jmesPath = value;
  }
  public resetJmesPath() {
    this._jmesPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmesPathInput() {
    return this._jmesPath;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext {
  /**
  * APICall is an HTTP request to the Kubernetes API server, or other JSON web service. The data returned is stored in the context with the name for the context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#api_call DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#api_call}
  */
  readonly apiCall?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall;
  /**
  * ConfigMap is the ConfigMap reference.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#config_map DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#config_map}
  */
  readonly configMap?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap;
  /**
  * GlobalContextEntryReference is a reference to a cached global context entry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#global_reference DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#global_reference}
  */
  readonly globalReference?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference;
  /**
  * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#image_registry DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#image_registry}
  */
  readonly imageRegistry?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry;
  /**
  * Name is the variable name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable defines an arbitrary JMESPath context variable that can be defined inline.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#variable DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#variable}
  */
  readonly variable?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_call: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallToTerraform(struct!.apiCall),
    config_map: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMapToTerraform(struct!.configMap),
    global_reference: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReferenceToTerraform(struct!.globalReference),
    image_registry: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryToTerraform(struct!.imageRegistry),
    name: cdktf.stringToTerraform(struct!.name),
    variable: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariableToTerraform(struct!.variable),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_call: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallToHclTerraform(struct!.apiCall),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall",
    },
    config_map: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap",
    },
    global_reference: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReferenceToHclTerraform(struct!.globalReference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference",
    },
    image_registry: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryToHclTerraform(struct!.imageRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variable: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariableToHclTerraform(struct!.variable),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiCall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiCall = this._apiCall?.internalValue;
    }
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._globalReference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.globalReference = this._globalReference?.internalValue;
    }
    if (this._imageRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageRegistry = this._imageRegistry?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._variable?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variable = this._variable?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = undefined;
      this._configMap.internalValue = undefined;
      this._globalReference.internalValue = undefined;
      this._imageRegistry.internalValue = undefined;
      this._name = undefined;
      this._variable.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiCall.internalValue = value.apiCall;
      this._configMap.internalValue = value.configMap;
      this._globalReference.internalValue = value.globalReference;
      this._imageRegistry.internalValue = value.imageRegistry;
      this._name = value.name;
      this._variable.internalValue = value.variable;
    }
  }

  // api_call - computed: false, optional: true, required: false
  private _apiCall = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCallOutputReference(this, "api_call");
  public get apiCall() {
    return this._apiCall;
  }
  public putApiCall(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextApiCall) {
    this._apiCall.internalValue = value;
  }
  public resetApiCall() {
    this._apiCall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiCallInput() {
    return this._apiCall.internalValue;
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // global_reference - computed: false, optional: true, required: false
  private _globalReference = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReferenceOutputReference(this, "global_reference");
  public get globalReference() {
    return this._globalReference;
  }
  public putGlobalReference(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextGlobalReference) {
    this._globalReference.internalValue = value;
  }
  public resetGlobalReference() {
    this._globalReference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get globalReferenceInput() {
    return this._globalReference.internalValue;
  }

  // image_registry - computed: false, optional: true, required: false
  private _imageRegistry = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistryOutputReference(this, "image_registry");
  public get imageRegistry() {
    return this._imageRegistry;
  }
  public putImageRegistry(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextImageRegistry) {
    this._imageRegistry.internalValue = value;
  }
  public resetImageRegistry() {
    this._imageRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageRegistryInput() {
    return this._imageRegistry.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // variable - computed: false, optional: true, required: false
  private _variable = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariableOutputReference(this, "variable");
  public get variable() {
    return this._variable;
  }
  public putVariable(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextVariable) {
    this._variable.internalValue = value;
  }
  public resetVariable() {
    this._variable.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get variableInput() {
    return this._variable.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny {
  /**
  * Multiple conditions can be declared under an 'any' or 'all' statement. A direct list of conditions (without 'any' or 'all' statements) is also supported for backwards compatibility but will be deprecated in the next major release. See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#conditions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#conditions}
  */
  readonly conditions?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDenyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    conditions: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.conditions),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDenyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    conditions: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.conditions),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDenyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._conditions !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditions = this._conditions;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._conditions = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._conditions = value.conditions;
    }
  }

  // conditions - computed: false, optional: true, required: false
  private _conditions?: { [key: string]: string }; 
  public get conditions() {
    return this.getStringMapAttribute('conditions');
  }
  public set conditions(value: { [key: string]: string }) {
    this._conditions = value;
  }
  public resetConditions() {
    this._conditions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionsInput() {
    return this._conditions;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny {
  /**
  * Key is the context entry (using JMESPath) for conditional rule evaluation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#key DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#key}
  */
  readonly key?: { [key: string]: string };
  /**
  * Message is an optional display message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#message DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#message}
  */
  readonly message?: string;
  /**
  * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#operator DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#value DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.key),
    message: cdktf.stringToTerraform(struct!.message),
    operator: cdktf.stringToTerraform(struct!.operator),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.key),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._message = undefined;
      this._operator = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._message = value.message;
      this._operator = value.operator;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: { [key: string]: string }; 
  public get key() {
    return this.getStringMapAttribute('key');
  }
  public set key(value: { [key: string]: string }) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions {
  /**
  * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#all DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#all}
  */
  readonly all?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll[] | cdktf.IResolvable;
  /**
  * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any}
  */
  readonly any?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllToTerraform, false)(struct!.all),
    any: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyToTerraform, false)(struct!.any),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllToHclTerraform, false)(struct!.all),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllList",
    },
    any: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyToHclTerraform, false)(struct!.any),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all?.internalValue;
    }
    if (this._any?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all.internalValue = undefined;
      this._any.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all.internalValue = value.all;
      this._any.internalValue = value.any;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAllList(this, "all", false);
  public get all() {
    return this._all;
  }
  public putAll(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAll[] | cdktf.IResolvable) {
    this._all.internalValue = value;
  }
  public resetAll() {
    this._all.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all.internalValue;
  }

  // any - computed: false, optional: true, required: false
  private _any = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAnyList(this, "any", false);
  public get any() {
    return this._any;
  }
  public putAny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsAny[] | cdktf.IResolvable) {
    this._any.internalValue = value;
  }
  public resetAny() {
    this._any.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeach {
  /**
  * AnyPattern specifies list of validation patterns. At least one of the patterns must be satisfied for the validation rule to succeed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#any_pattern DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#any_pattern}
  */
  readonly anyPattern?: { [key: string]: string };
  /**
  * Context defines variables and data sources that can be used during rule execution.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#context DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#context}
  */
  readonly context?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext[] | cdktf.IResolvable;
  /**
  * Deny defines conditions used to pass or fail a validation rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#deny DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#deny}
  */
  readonly deny?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny;
  /**
  * ElementScope specifies whether to use the current list element as the scope for validation. Defaults to 'true' if not specified. When set to 'false', 'request.object' is used as the validation scope within the foreach block to allow referencing other elements in the subtree.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#element_scope DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#element_scope}
  */
  readonly elementScope?: boolean | cdktf.IResolvable;
  /**
  * Foreach declares a nested foreach iterator
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#foreach DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#foreach}
  */
  readonly foreach?: { [key: string]: string };
  /**
  * List specifies a JMESPath expression that results in one or more elements to which the validation logic is applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#list DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#list}
  */
  readonly list?: string;
  /**
  * Pattern specifies an overlay-style pattern used to check resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pattern DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pattern}
  */
  readonly pattern?: { [key: string]: string };
  /**
  * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested 'any' or 'all' statements. See: https://kyverno.io/docs/writing-policies/preconditions/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#preconditions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#preconditions}
  */
  readonly preconditions?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeach | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    any_pattern: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.anyPattern),
    context: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextToTerraform, false)(struct!.context),
    deny: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDenyToTerraform(struct!.deny),
    element_scope: cdktf.booleanToTerraform(struct!.elementScope),
    foreach: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.foreach),
    list: cdktf.stringToTerraform(struct!.list),
    pattern: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.pattern),
    preconditions: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsToTerraform(struct!.preconditions),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeach | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    any_pattern: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.anyPattern),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    context: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextToHclTerraform, false)(struct!.context),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextList",
    },
    deny: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDenyToHclTerraform(struct!.deny),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny",
    },
    element_scope: {
      value: cdktf.booleanToHclTerraform(struct!.elementScope),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    foreach: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.foreach),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    list: {
      value: cdktf.stringToHclTerraform(struct!.list),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.pattern),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    preconditions: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsToHclTerraform(struct!.preconditions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeach | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anyPattern !== undefined) {
      hasAnyValues = true;
      internalValueResult.anyPattern = this._anyPattern;
    }
    if (this._context?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context?.internalValue;
    }
    if (this._deny?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.deny = this._deny?.internalValue;
    }
    if (this._elementScope !== undefined) {
      hasAnyValues = true;
      internalValueResult.elementScope = this._elementScope;
    }
    if (this._foreach !== undefined) {
      hasAnyValues = true;
      internalValueResult.foreach = this._foreach;
    }
    if (this._list !== undefined) {
      hasAnyValues = true;
      internalValueResult.list = this._list;
    }
    if (this._pattern !== undefined) {
      hasAnyValues = true;
      internalValueResult.pattern = this._pattern;
    }
    if (this._preconditions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preconditions = this._preconditions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeach | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anyPattern = undefined;
      this._context.internalValue = undefined;
      this._deny.internalValue = undefined;
      this._elementScope = undefined;
      this._foreach = undefined;
      this._list = undefined;
      this._pattern = undefined;
      this._preconditions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anyPattern = value.anyPattern;
      this._context.internalValue = value.context;
      this._deny.internalValue = value.deny;
      this._elementScope = value.elementScope;
      this._foreach = value.foreach;
      this._list = value.list;
      this._pattern = value.pattern;
      this._preconditions.internalValue = value.preconditions;
    }
  }

  // any_pattern - computed: false, optional: true, required: false
  private _anyPattern?: { [key: string]: string }; 
  public get anyPattern() {
    return this.getStringMapAttribute('any_pattern');
  }
  public set anyPattern(value: { [key: string]: string }) {
    this._anyPattern = value;
  }
  public resetAnyPattern() {
    this._anyPattern = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyPatternInput() {
    return this._anyPattern;
  }

  // context - computed: false, optional: true, required: false
  private _context = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContextList(this, "context", false);
  public get context() {
    return this._context;
  }
  public putContext(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachContext[] | cdktf.IResolvable) {
    this._context.internalValue = value;
  }
  public resetContext() {
    this._context.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context.internalValue;
  }

  // deny - computed: false, optional: true, required: false
  private _deny = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDenyOutputReference(this, "deny");
  public get deny() {
    return this._deny;
  }
  public putDeny(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachDeny) {
    this._deny.internalValue = value;
  }
  public resetDeny() {
    this._deny.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denyInput() {
    return this._deny.internalValue;
  }

  // element_scope - computed: false, optional: true, required: false
  private _elementScope?: boolean | cdktf.IResolvable; 
  public get elementScope() {
    return this.getBooleanAttribute('element_scope');
  }
  public set elementScope(value: boolean | cdktf.IResolvable) {
    this._elementScope = value;
  }
  public resetElementScope() {
    this._elementScope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elementScopeInput() {
    return this._elementScope;
  }

  // foreach - computed: false, optional: true, required: false
  private _foreach?: { [key: string]: string }; 
  public get foreach() {
    return this.getStringMapAttribute('foreach');
  }
  public set foreach(value: { [key: string]: string }) {
    this._foreach = value;
  }
  public resetForeach() {
    this._foreach = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get foreachInput() {
    return this._foreach;
  }

  // list - computed: false, optional: true, required: false
  private _list?: string; 
  public get list() {
    return this.getStringAttribute('list');
  }
  public set list(value: string) {
    this._list = value;
  }
  public resetList() {
    this._list = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listInput() {
    return this._list;
  }

  // pattern - computed: false, optional: true, required: false
  private _pattern?: { [key: string]: string }; 
  public get pattern() {
    return this.getStringMapAttribute('pattern');
  }
  public set pattern(value: { [key: string]: string }) {
    this._pattern = value;
  }
  public resetPattern() {
    this._pattern = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternInput() {
    return this._pattern;
  }

  // preconditions - computed: false, optional: true, required: false
  private _preconditions = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditionsOutputReference(this, "preconditions");
  public get preconditions() {
    return this._preconditions;
  }
  public putPreconditions(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachPreconditions) {
    this._preconditions.internalValue = value;
  }
  public resetPreconditions() {
    this._preconditions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preconditionsInput() {
    return this._preconditions.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeach[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateForeachOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog {
  /**
  * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate timestamp. Default is false. Set to true if this was opted out during signing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ignore_sct DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ignore_sct}
  */
  readonly ignoreSct?: boolean | cdktf.IResolvable;
  /**
  * PubKey, if set, is used to validate SCTs against a custom source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pubkey DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pubkey}
  */
  readonly pubkey?: string;
  /**
  * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must contain the root CA certificate. Optionally may contain intermediate CA certificates, and may contain the leaf TSA certificate if not present in the timestamurce.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#tsa_cert_chain DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#tsa_cert_chain}
  */
  readonly tsaCertChain?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlogToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_sct: cdktf.booleanToTerraform(struct!.ignoreSct),
    pubkey: cdktf.stringToTerraform(struct!.pubkey),
    tsa_cert_chain: cdktf.stringToTerraform(struct!.tsaCertChain),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlogToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_sct: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreSct),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pubkey: {
      value: cdktf.stringToHclTerraform(struct!.pubkey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tsa_cert_chain: {
      value: cdktf.stringToHclTerraform(struct!.tsaCertChain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreSct !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreSct = this._ignoreSct;
    }
    if (this._pubkey !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubkey = this._pubkey;
    }
    if (this._tsaCertChain !== undefined) {
      hasAnyValues = true;
      internalValueResult.tsaCertChain = this._tsaCertChain;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ignoreSct = undefined;
      this._pubkey = undefined;
      this._tsaCertChain = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ignoreSct = value.ignoreSct;
      this._pubkey = value.pubkey;
      this._tsaCertChain = value.tsaCertChain;
    }
  }

  // ignore_sct - computed: false, optional: true, required: false
  private _ignoreSct?: boolean | cdktf.IResolvable; 
  public get ignoreSct() {
    return this.getBooleanAttribute('ignore_sct');
  }
  public set ignoreSct(value: boolean | cdktf.IResolvable) {
    this._ignoreSct = value;
  }
  public resetIgnoreSct() {
    this._ignoreSct = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreSctInput() {
    return this._ignoreSct;
  }

  // pubkey - computed: false, optional: true, required: false
  private _pubkey?: string; 
  public get pubkey() {
    return this.getStringAttribute('pubkey');
  }
  public set pubkey(value: string) {
    this._pubkey = value;
  }
  public resetPubkey() {
    this._pubkey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pubkeyInput() {
    return this._pubkey;
  }

  // tsa_cert_chain - computed: false, optional: true, required: false
  private _tsaCertChain?: string; 
  public get tsaCertChain() {
    return this.getStringAttribute('tsa_cert_chain');
  }
  public set tsaCertChain(value: string) {
    this._tsaCertChain = value;
  }
  public resetTsaCertChain() {
    this._tsaCertChain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tsaCertChainInput() {
    return this._tsaCertChain;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor {
  /**
  * IgnoreTlog skips transparency log verification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ignore_tlog DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ignore_tlog}
  */
  readonly ignoreTlog?: boolean | cdktf.IResolvable;
  /**
  * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor. If set, this will be used to validate transparency log signatures from a custom Rekor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pubkey DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pubkey}
  */
  readonly pubkey?: string;
  /**
  * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_tlog: cdktf.booleanToTerraform(struct!.ignoreTlog),
    pubkey: cdktf.stringToTerraform(struct!.pubkey),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_tlog: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreTlog),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pubkey: {
      value: cdktf.stringToHclTerraform(struct!.pubkey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreTlog !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreTlog = this._ignoreTlog;
    }
    if (this._pubkey !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubkey = this._pubkey;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ignoreTlog = undefined;
      this._pubkey = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ignoreTlog = value.ignoreTlog;
      this._pubkey = value.pubkey;
      this._url = value.url;
    }
  }

  // ignore_tlog - computed: false, optional: true, required: false
  private _ignoreTlog?: boolean | cdktf.IResolvable; 
  public get ignoreTlog() {
    return this.getBooleanAttribute('ignore_tlog');
  }
  public set ignoreTlog(value: boolean | cdktf.IResolvable) {
    this._ignoreTlog = value;
  }
  public resetIgnoreTlog() {
    this._ignoreTlog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreTlogInput() {
    return this._ignoreTlog;
  }

  // pubkey - computed: false, optional: true, required: false
  private _pubkey?: string; 
  public get pubkey() {
    return this.getStringAttribute('pubkey');
  }
  public set pubkey(value: string) {
    this._pubkey = value;
  }
  public resetPubkey() {
    this._pubkey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pubkeyInput() {
    return this._pubkey;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates {
  /**
  * Cert is an optional PEM-encoded public certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#cert DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#cert}
  */
  readonly cert?: string;
  /**
  * CertChain is an optional PEM encoded set of certificates used to verify.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#cert_chain DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#cert_chain}
  */
  readonly certChain?: string;
  /**
  * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ctlog DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ctlog}
  */
  readonly ctlog?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog;
  /**
  * Rekor provides configuration for the Rekor transparency log service. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#rekor DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#rekor}
  */
  readonly rekor?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert: cdktf.stringToTerraform(struct!.cert),
    cert_chain: cdktf.stringToTerraform(struct!.certChain),
    ctlog: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlogToTerraform(struct!.ctlog),
    rekor: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekorToTerraform(struct!.rekor),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert: {
      value: cdktf.stringToHclTerraform(struct!.cert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_chain: {
      value: cdktf.stringToHclTerraform(struct!.certChain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ctlog: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlogToHclTerraform(struct!.ctlog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog",
    },
    rekor: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekorToHclTerraform(struct!.rekor),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cert !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert;
    }
    if (this._certChain !== undefined) {
      hasAnyValues = true;
      internalValueResult.certChain = this._certChain;
    }
    if (this._ctlog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ctlog = this._ctlog?.internalValue;
    }
    if (this._rekor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rekor = this._rekor?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cert = undefined;
      this._certChain = undefined;
      this._ctlog.internalValue = undefined;
      this._rekor.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cert = value.cert;
      this._certChain = value.certChain;
      this._ctlog.internalValue = value.ctlog;
      this._rekor.internalValue = value.rekor;
    }
  }

  // cert - computed: false, optional: true, required: false
  private _cert?: string; 
  public get cert() {
    return this.getStringAttribute('cert');
  }
  public set cert(value: string) {
    this._cert = value;
  }
  public resetCert() {
    this._cert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert;
  }

  // cert_chain - computed: false, optional: true, required: false
  private _certChain?: string; 
  public get certChain() {
    return this.getStringAttribute('cert_chain');
  }
  public set certChain(value: string) {
    this._certChain = value;
  }
  public resetCertChain() {
    this._certChain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certChainInput() {
    return this._certChain;
  }

  // ctlog - computed: false, optional: true, required: false
  private _ctlog = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlogOutputReference(this, "ctlog");
  public get ctlog() {
    return this._ctlog;
  }
  public putCtlog(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesCtlog) {
    this._ctlog.internalValue = value;
  }
  public resetCtlog() {
    this._ctlog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ctlogInput() {
    return this._ctlog.internalValue;
  }

  // rekor - computed: false, optional: true, required: false
  private _rekor = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekorOutputReference(this, "rekor");
  public get rekor() {
    return this._rekor;
  }
  public putRekor(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesRekor) {
    this._rekor.internalValue = value;
  }
  public resetRekor() {
    this._rekor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rekorInput() {
    return this._rekor.internalValue;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog {
  /**
  * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate timestamp. Default is false. Set to true if this was opted out during signing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ignore_sct DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ignore_sct}
  */
  readonly ignoreSct?: boolean | cdktf.IResolvable;
  /**
  * PubKey, if set, is used to validate SCTs against a custom source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pubkey DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pubkey}
  */
  readonly pubkey?: string;
  /**
  * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must contain the root CA certificate. Optionally may contain intermediate CA certificates, and may contain the leaf TSA certificate if not present in the timestamurce.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#tsa_cert_chain DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#tsa_cert_chain}
  */
  readonly tsaCertChain?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlogToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_sct: cdktf.booleanToTerraform(struct!.ignoreSct),
    pubkey: cdktf.stringToTerraform(struct!.pubkey),
    tsa_cert_chain: cdktf.stringToTerraform(struct!.tsaCertChain),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlogToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_sct: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreSct),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pubkey: {
      value: cdktf.stringToHclTerraform(struct!.pubkey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tsa_cert_chain: {
      value: cdktf.stringToHclTerraform(struct!.tsaCertChain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreSct !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreSct = this._ignoreSct;
    }
    if (this._pubkey !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubkey = this._pubkey;
    }
    if (this._tsaCertChain !== undefined) {
      hasAnyValues = true;
      internalValueResult.tsaCertChain = this._tsaCertChain;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ignoreSct = undefined;
      this._pubkey = undefined;
      this._tsaCertChain = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ignoreSct = value.ignoreSct;
      this._pubkey = value.pubkey;
      this._tsaCertChain = value.tsaCertChain;
    }
  }

  // ignore_sct - computed: false, optional: true, required: false
  private _ignoreSct?: boolean | cdktf.IResolvable; 
  public get ignoreSct() {
    return this.getBooleanAttribute('ignore_sct');
  }
  public set ignoreSct(value: boolean | cdktf.IResolvable) {
    this._ignoreSct = value;
  }
  public resetIgnoreSct() {
    this._ignoreSct = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreSctInput() {
    return this._ignoreSct;
  }

  // pubkey - computed: false, optional: true, required: false
  private _pubkey?: string; 
  public get pubkey() {
    return this.getStringAttribute('pubkey');
  }
  public set pubkey(value: string) {
    this._pubkey = value;
  }
  public resetPubkey() {
    this._pubkey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pubkeyInput() {
    return this._pubkey;
  }

  // tsa_cert_chain - computed: false, optional: true, required: false
  private _tsaCertChain?: string; 
  public get tsaCertChain() {
    return this.getStringAttribute('tsa_cert_chain');
  }
  public set tsaCertChain(value: string) {
    this._tsaCertChain = value;
  }
  public resetTsaCertChain() {
    this._tsaCertChain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tsaCertChainInput() {
    return this._tsaCertChain;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor {
  /**
  * IgnoreTlog skips transparency log verification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ignore_tlog DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ignore_tlog}
  */
  readonly ignoreTlog?: boolean | cdktf.IResolvable;
  /**
  * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor. If set, this will be used to validate transparency log signatures from a custom Rekor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pubkey DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pubkey}
  */
  readonly pubkey?: string;
  /**
  * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_tlog: cdktf.booleanToTerraform(struct!.ignoreTlog),
    pubkey: cdktf.stringToTerraform(struct!.pubkey),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_tlog: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreTlog),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pubkey: {
      value: cdktf.stringToHclTerraform(struct!.pubkey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreTlog !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreTlog = this._ignoreTlog;
    }
    if (this._pubkey !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubkey = this._pubkey;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ignoreTlog = undefined;
      this._pubkey = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ignoreTlog = value.ignoreTlog;
      this._pubkey = value.pubkey;
      this._url = value.url;
    }
  }

  // ignore_tlog - computed: false, optional: true, required: false
  private _ignoreTlog?: boolean | cdktf.IResolvable; 
  public get ignoreTlog() {
    return this.getBooleanAttribute('ignore_tlog');
  }
  public set ignoreTlog(value: boolean | cdktf.IResolvable) {
    this._ignoreTlog = value;
  }
  public resetIgnoreTlog() {
    this._ignoreTlog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreTlogInput() {
    return this._ignoreTlog;
  }

  // pubkey - computed: false, optional: true, required: false
  private _pubkey?: string; 
  public get pubkey() {
    return this.getStringAttribute('pubkey');
  }
  public set pubkey(value: string) {
    this._pubkey = value;
  }
  public resetPubkey() {
    this._pubkey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pubkeyInput() {
    return this._pubkey;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless {
  /**
  * AdditionalExtensions are certificate-extensions used for keyless signing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#additional_extensions DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#additional_extensions}
  */
  readonly additionalExtensions?: { [key: string]: string };
  /**
  * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ctlog DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ctlog}
  */
  readonly ctlog?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog;
  /**
  * Issuer is the certificate issuer used for keyless signing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#issuer DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#issuer}
  */
  readonly issuer?: string;
  /**
  * IssuerRegExp is the regular expression to match certificate issuer used for keyless signing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#issuer_reg_exp DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#issuer_reg_exp}
  */
  readonly issuerRegExp?: string;
  /**
  * Rekor provides configuration for the Rekor transparency log service. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#rekor DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#rekor}
  */
  readonly rekor?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor;
  /**
  * Roots is an optional set of PEM encoded trusted root certificates. If not provided, the system roots are used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#roots DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#roots}
  */
  readonly roots?: string;
  /**
  * Subject is the verified identity used for keyless signing, for example the email address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#subject DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#subject}
  */
  readonly subject?: string;
  /**
  * SubjectRegExp is the regular expression to match identity used for keyless signing, for example the email address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#subject_reg_exp DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#subject_reg_exp}
  */
  readonly subjectRegExp?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_extensions: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.additionalExtensions),
    ctlog: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlogToTerraform(struct!.ctlog),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    issuer_reg_exp: cdktf.stringToTerraform(struct!.issuerRegExp),
    rekor: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekorToTerraform(struct!.rekor),
    roots: cdktf.stringToTerraform(struct!.roots),
    subject: cdktf.stringToTerraform(struct!.subject),
    subject_reg_exp: cdktf.stringToTerraform(struct!.subjectRegExp),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_extensions: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.additionalExtensions),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    ctlog: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlogToHclTerraform(struct!.ctlog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    issuer_reg_exp: {
      value: cdktf.stringToHclTerraform(struct!.issuerRegExp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rekor: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekorToHclTerraform(struct!.rekor),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor",
    },
    roots: {
      value: cdktf.stringToHclTerraform(struct!.roots),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject: {
      value: cdktf.stringToHclTerraform(struct!.subject),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_reg_exp: {
      value: cdktf.stringToHclTerraform(struct!.subjectRegExp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalExtensions !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalExtensions = this._additionalExtensions;
    }
    if (this._ctlog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ctlog = this._ctlog?.internalValue;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._issuerRegExp !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuerRegExp = this._issuerRegExp;
    }
    if (this._rekor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rekor = this._rekor?.internalValue;
    }
    if (this._roots !== undefined) {
      hasAnyValues = true;
      internalValueResult.roots = this._roots;
    }
    if (this._subject !== undefined) {
      hasAnyValues = true;
      internalValueResult.subject = this._subject;
    }
    if (this._subjectRegExp !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectRegExp = this._subjectRegExp;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalExtensions = undefined;
      this._ctlog.internalValue = undefined;
      this._issuer = undefined;
      this._issuerRegExp = undefined;
      this._rekor.internalValue = undefined;
      this._roots = undefined;
      this._subject = undefined;
      this._subjectRegExp = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalExtensions = value.additionalExtensions;
      this._ctlog.internalValue = value.ctlog;
      this._issuer = value.issuer;
      this._issuerRegExp = value.issuerRegExp;
      this._rekor.internalValue = value.rekor;
      this._roots = value.roots;
      this._subject = value.subject;
      this._subjectRegExp = value.subjectRegExp;
    }
  }

  // additional_extensions - computed: false, optional: true, required: false
  private _additionalExtensions?: { [key: string]: string }; 
  public get additionalExtensions() {
    return this.getStringMapAttribute('additional_extensions');
  }
  public set additionalExtensions(value: { [key: string]: string }) {
    this._additionalExtensions = value;
  }
  public resetAdditionalExtensions() {
    this._additionalExtensions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalExtensionsInput() {
    return this._additionalExtensions;
  }

  // ctlog - computed: false, optional: true, required: false
  private _ctlog = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlogOutputReference(this, "ctlog");
  public get ctlog() {
    return this._ctlog;
  }
  public putCtlog(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessCtlog) {
    this._ctlog.internalValue = value;
  }
  public resetCtlog() {
    this._ctlog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ctlogInput() {
    return this._ctlog.internalValue;
  }

  // issuer - computed: false, optional: true, required: false
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  public resetIssuer() {
    this._issuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // issuer_reg_exp - computed: false, optional: true, required: false
  private _issuerRegExp?: string; 
  public get issuerRegExp() {
    return this.getStringAttribute('issuer_reg_exp');
  }
  public set issuerRegExp(value: string) {
    this._issuerRegExp = value;
  }
  public resetIssuerRegExp() {
    this._issuerRegExp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerRegExpInput() {
    return this._issuerRegExp;
  }

  // rekor - computed: false, optional: true, required: false
  private _rekor = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekorOutputReference(this, "rekor");
  public get rekor() {
    return this._rekor;
  }
  public putRekor(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessRekor) {
    this._rekor.internalValue = value;
  }
  public resetRekor() {
    this._rekor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rekorInput() {
    return this._rekor.internalValue;
  }

  // roots - computed: false, optional: true, required: false
  private _roots?: string; 
  public get roots() {
    return this.getStringAttribute('roots');
  }
  public set roots(value: string) {
    this._roots = value;
  }
  public resetRoots() {
    this._roots = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootsInput() {
    return this._roots;
  }

  // subject - computed: false, optional: true, required: false
  private _subject?: string; 
  public get subject() {
    return this.getStringAttribute('subject');
  }
  public set subject(value: string) {
    this._subject = value;
  }
  public resetSubject() {
    this._subject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectInput() {
    return this._subject;
  }

  // subject_reg_exp - computed: false, optional: true, required: false
  private _subjectRegExp?: string; 
  public get subjectRegExp() {
    return this.getStringAttribute('subject_reg_exp');
  }
  public set subjectRegExp(value: string) {
    this._subjectRegExp = value;
  }
  public resetSubjectRegExp() {
    this._subjectRegExp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectRegExpInput() {
    return this._subjectRegExp;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog {
  /**
  * IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate timestamp. Default is false. Set to true if this was opted out during signing.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ignore_sct DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ignore_sct}
  */
  readonly ignoreSct?: boolean | cdktf.IResolvable;
  /**
  * PubKey, if set, is used to validate SCTs against a custom source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pubkey DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pubkey}
  */
  readonly pubkey?: string;
  /**
  * TSACertChain, if set, is the PEM-encoded certificate chain file for the RFC3161 timestamp authority. Must contain the root CA certificate. Optionally may contain intermediate CA certificates, and may contain the leaf TSA certificate if not present in the timestamurce.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#tsa_cert_chain DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#tsa_cert_chain}
  */
  readonly tsaCertChain?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlogToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_sct: cdktf.booleanToTerraform(struct!.ignoreSct),
    pubkey: cdktf.stringToTerraform(struct!.pubkey),
    tsa_cert_chain: cdktf.stringToTerraform(struct!.tsaCertChain),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlogToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_sct: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreSct),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pubkey: {
      value: cdktf.stringToHclTerraform(struct!.pubkey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tsa_cert_chain: {
      value: cdktf.stringToHclTerraform(struct!.tsaCertChain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreSct !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreSct = this._ignoreSct;
    }
    if (this._pubkey !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubkey = this._pubkey;
    }
    if (this._tsaCertChain !== undefined) {
      hasAnyValues = true;
      internalValueResult.tsaCertChain = this._tsaCertChain;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ignoreSct = undefined;
      this._pubkey = undefined;
      this._tsaCertChain = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ignoreSct = value.ignoreSct;
      this._pubkey = value.pubkey;
      this._tsaCertChain = value.tsaCertChain;
    }
  }

  // ignore_sct - computed: false, optional: true, required: false
  private _ignoreSct?: boolean | cdktf.IResolvable; 
  public get ignoreSct() {
    return this.getBooleanAttribute('ignore_sct');
  }
  public set ignoreSct(value: boolean | cdktf.IResolvable) {
    this._ignoreSct = value;
  }
  public resetIgnoreSct() {
    this._ignoreSct = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreSctInput() {
    return this._ignoreSct;
  }

  // pubkey - computed: false, optional: true, required: false
  private _pubkey?: string; 
  public get pubkey() {
    return this.getStringAttribute('pubkey');
  }
  public set pubkey(value: string) {
    this._pubkey = value;
  }
  public resetPubkey() {
    this._pubkey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pubkeyInput() {
    return this._pubkey;
  }

  // tsa_cert_chain - computed: false, optional: true, required: false
  private _tsaCertChain?: string; 
  public get tsaCertChain() {
    return this.getStringAttribute('tsa_cert_chain');
  }
  public set tsaCertChain(value: string) {
    this._tsaCertChain = value;
  }
  public resetTsaCertChain() {
    this._tsaCertChain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tsaCertChainInput() {
    return this._tsaCertChain;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor {
  /**
  * IgnoreTlog skips transparency log verification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ignore_tlog DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ignore_tlog}
  */
  readonly ignoreTlog?: boolean | cdktf.IResolvable;
  /**
  * RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor. If set, this will be used to validate transparency log signatures from a custom Rekor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#pubkey DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#pubkey}
  */
  readonly pubkey?: string;
  /**
  * URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#url DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekorToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_tlog: cdktf.booleanToTerraform(struct!.ignoreTlog),
    pubkey: cdktf.stringToTerraform(struct!.pubkey),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekorToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_tlog: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreTlog),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pubkey: {
      value: cdktf.stringToHclTerraform(struct!.pubkey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreTlog !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreTlog = this._ignoreTlog;
    }
    if (this._pubkey !== undefined) {
      hasAnyValues = true;
      internalValueResult.pubkey = this._pubkey;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ignoreTlog = undefined;
      this._pubkey = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ignoreTlog = value.ignoreTlog;
      this._pubkey = value.pubkey;
      this._url = value.url;
    }
  }

  // ignore_tlog - computed: false, optional: true, required: false
  private _ignoreTlog?: boolean | cdktf.IResolvable; 
  public get ignoreTlog() {
    return this.getBooleanAttribute('ignore_tlog');
  }
  public set ignoreTlog(value: boolean | cdktf.IResolvable) {
    this._ignoreTlog = value;
  }
  public resetIgnoreTlog() {
    this._ignoreTlog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreTlogInput() {
    return this._ignoreTlog;
  }

  // pubkey - computed: false, optional: true, required: false
  private _pubkey?: string; 
  public get pubkey() {
    return this.getStringAttribute('pubkey');
  }
  public set pubkey(value: string) {
    this._pubkey = value;
  }
  public resetPubkey() {
    this._pubkey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pubkeyInput() {
    return this._pubkey;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret {
  /**
  * Name of the secret. The provided secret must contain a key named cosign.pub.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace name where the Secret exists.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecretToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecretToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys {
  /**
  * CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#ctlog DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#ctlog}
  */
  readonly ctlog?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog;
  /**
  * KMS provides the URI to the public key stored in a Key Management System. See: https://github.com/sigstore/cosign/blob/main/KMS.md
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kms DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kms}
  */
  readonly kms?: string;
  /**
  * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly specified or can be a variable reference to a key specified in a ConfigMap (see https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret elsewhere in the cluster by specifying it in the format 'k8s://<namespace>/<secret_name>'. The named Secret must specify a key 'cosign.pub' containing the public key used for verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret). When multiple keys are specified each key is processed as a separate staticKey entry (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#public_keys DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#public_keys}
  */
  readonly publicKeys?: string;
  /**
  * Rekor provides configuration for the Rekor transparency log service. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#rekor DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#rekor}
  */
  readonly rekor?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor;
  /**
  * Reference to a Secret resource that contains a public key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#secret DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#secret}
  */
  readonly secret?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret;
  /**
  * Deprecated. Use attestor.signatureAlgorithm instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#signature_algorithm DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#signature_algorithm}
  */
  readonly signatureAlgorithm?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ctlog: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlogToTerraform(struct!.ctlog),
    kms: cdktf.stringToTerraform(struct!.kms),
    public_keys: cdktf.stringToTerraform(struct!.publicKeys),
    rekor: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekorToTerraform(struct!.rekor),
    secret: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecretToTerraform(struct!.secret),
    signature_algorithm: cdktf.stringToTerraform(struct!.signatureAlgorithm),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ctlog: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlogToHclTerraform(struct!.ctlog),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog",
    },
    kms: {
      value: cdktf.stringToHclTerraform(struct!.kms),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    public_keys: {
      value: cdktf.stringToHclTerraform(struct!.publicKeys),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rekor: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekorToHclTerraform(struct!.rekor),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor",
    },
    secret: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret",
    },
    signature_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.signatureAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ctlog?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ctlog = this._ctlog?.internalValue;
    }
    if (this._kms !== undefined) {
      hasAnyValues = true;
      internalValueResult.kms = this._kms;
    }
    if (this._publicKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.publicKeys = this._publicKeys;
    }
    if (this._rekor?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rekor = this._rekor?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._signatureAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureAlgorithm = this._signatureAlgorithm;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ctlog.internalValue = undefined;
      this._kms = undefined;
      this._publicKeys = undefined;
      this._rekor.internalValue = undefined;
      this._secret.internalValue = undefined;
      this._signatureAlgorithm = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ctlog.internalValue = value.ctlog;
      this._kms = value.kms;
      this._publicKeys = value.publicKeys;
      this._rekor.internalValue = value.rekor;
      this._secret.internalValue = value.secret;
      this._signatureAlgorithm = value.signatureAlgorithm;
    }
  }

  // ctlog - computed: false, optional: true, required: false
  private _ctlog = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlogOutputReference(this, "ctlog");
  public get ctlog() {
    return this._ctlog;
  }
  public putCtlog(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysCtlog) {
    this._ctlog.internalValue = value;
  }
  public resetCtlog() {
    this._ctlog.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ctlogInput() {
    return this._ctlog.internalValue;
  }

  // kms - computed: false, optional: true, required: false
  private _kms?: string; 
  public get kms() {
    return this.getStringAttribute('kms');
  }
  public set kms(value: string) {
    this._kms = value;
  }
  public resetKms() {
    this._kms = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsInput() {
    return this._kms;
  }

  // public_keys - computed: false, optional: true, required: false
  private _publicKeys?: string; 
  public get publicKeys() {
    return this.getStringAttribute('public_keys');
  }
  public set publicKeys(value: string) {
    this._publicKeys = value;
  }
  public resetPublicKeys() {
    this._publicKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publicKeysInput() {
    return this._publicKeys;
  }

  // rekor - computed: false, optional: true, required: false
  private _rekor = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekorOutputReference(this, "rekor");
  public get rekor() {
    return this._rekor;
  }
  public putRekor(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysRekor) {
    this._rekor.internalValue = value;
  }
  public resetRekor() {
    this._rekor.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rekorInput() {
    return this._rekor.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // signature_algorithm - computed: false, optional: true, required: false
  private _signatureAlgorithm?: string; 
  public get signatureAlgorithm() {
    return this.getStringAttribute('signature_algorithm');
  }
  public set signatureAlgorithm(value: string) {
    this._signatureAlgorithm = value;
  }
  public resetSignatureAlgorithm() {
    this._signatureAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureAlgorithmInput() {
    return this._signatureAlgorithm;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries {
  /**
  * Annotations are used for image verification. Every specified key-value pair must exist and match in the verified payload. The payload may contain other key-value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#annotations DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#attestor DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#attestor}
  */
  readonly attestor?: { [key: string]: string };
  /**
  * Certificates specifies one or more certificates.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#certificates DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#certificates}
  */
  readonly certificates?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates;
  /**
  * Keyless is a set of attribute used to verify a Sigstore keyless attestor. See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#keyless DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#keyless}
  */
  readonly keyless?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless;
  /**
  * Keys specifies one or more public keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#keys DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#keys}
  */
  readonly keys?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys;
  /**
  * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule. If specified Repository will override other OCI image repository locations for this Attestor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#repository DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#repository}
  */
  readonly repository?: string;
  /**
  * Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#signature_algorithm DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#signature_algorithm}
  */
  readonly signatureAlgorithm?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    attestor: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attestor),
    certificates: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesToTerraform(struct!.certificates),
    keyless: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessToTerraform(struct!.keyless),
    keys: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysToTerraform(struct!.keys),
    repository: cdktf.stringToTerraform(struct!.repository),
    signature_algorithm: cdktf.stringToTerraform(struct!.signatureAlgorithm),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attestor: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attestor),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    certificates: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesToHclTerraform(struct!.certificates),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates",
    },
    keyless: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessToHclTerraform(struct!.keyless),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless",
    },
    keys: {
      value: dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysToHclTerraform(struct!.keys),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys",
    },
    repository: {
      value: cdktf.stringToHclTerraform(struct!.repository),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signature_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.signatureAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._attestor !== undefined) {
      hasAnyValues = true;
      internalValueResult.attestor = this._attestor;
    }
    if (this._certificates?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificates = this._certificates?.internalValue;
    }
    if (this._keyless?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyless = this._keyless?.internalValue;
    }
    if (this._keys?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keys = this._keys?.internalValue;
    }
    if (this._repository !== undefined) {
      hasAnyValues = true;
      internalValueResult.repository = this._repository;
    }
    if (this._signatureAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureAlgorithm = this._signatureAlgorithm;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._attestor = undefined;
      this._certificates.internalValue = undefined;
      this._keyless.internalValue = undefined;
      this._keys.internalValue = undefined;
      this._repository = undefined;
      this._signatureAlgorithm = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._attestor = value.attestor;
      this._certificates.internalValue = value.certificates;
      this._keyless.internalValue = value.keyless;
      this._keys.internalValue = value.keys;
      this._repository = value.repository;
      this._signatureAlgorithm = value.signatureAlgorithm;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // attestor - computed: false, optional: true, required: false
  private _attestor?: { [key: string]: string }; 
  public get attestor() {
    return this.getStringMapAttribute('attestor');
  }
  public set attestor(value: { [key: string]: string }) {
    this._attestor = value;
  }
  public resetAttestor() {
    this._attestor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attestorInput() {
    return this._attestor;
  }

  // certificates - computed: false, optional: true, required: false
  private _certificates = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificatesOutputReference(this, "certificates");
  public get certificates() {
    return this._certificates;
  }
  public putCertificates(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesCertificates) {
    this._certificates.internalValue = value;
  }
  public resetCertificates() {
    this._certificates.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificatesInput() {
    return this._certificates.internalValue;
  }

  // keyless - computed: false, optional: true, required: false
  private _keyless = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeylessOutputReference(this, "keyless");
  public get keyless() {
    return this._keyless;
  }
  public putKeyless(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeyless) {
    this._keyless.internalValue = value;
  }
  public resetKeyless() {
    this._keyless.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keylessInput() {
    return this._keyless.internalValue;
  }

  // keys - computed: false, optional: true, required: false
  private _keys = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeysOutputReference(this, "keys");
  public get keys() {
    return this._keys;
  }
  public putKeys(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesKeys) {
    this._keys.internalValue = value;
  }
  public resetKeys() {
    this._keys.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keysInput() {
    return this._keys.internalValue;
  }

  // repository - computed: false, optional: true, required: false
  private _repository?: string; 
  public get repository() {
    return this.getStringAttribute('repository');
  }
  public set repository(value: string) {
    this._repository = value;
  }
  public resetRepository() {
    this._repository = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repositoryInput() {
    return this._repository;
  }

  // signature_algorithm - computed: false, optional: true, required: false
  private _signatureAlgorithm?: string; 
  public get signatureAlgorithm() {
    return this.getStringAttribute('signature_algorithm');
  }
  public set signatureAlgorithm(value: string) {
    this._signatureAlgorithm = value;
  }
  public resetSignatureAlgorithm() {
    this._signatureAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureAlgorithmInput() {
    return this._signatureAlgorithm;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestors {
  /**
  * Count specifies the required number of entries that must match. If the count is null, all entries must match (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a value N, then N must be less than or equal to the size of entries, and at least N entries must match.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#count DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#count}
  */
  readonly count?: number;
  /**
  * Entries contains the available attestors. An attestor can be a static key, attributes for keyless verification, or a nested attestor declaration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#entries DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#entries}
  */
  readonly entries?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    count: cdktf.numberToTerraform(struct!.count),
    entries: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesToTerraform, false)(struct!.entries),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    count: {
      value: cdktf.numberToHclTerraform(struct!.count),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    entries: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesToHclTerraform, false)(struct!.entries),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._count !== undefined) {
      hasAnyValues = true;
      internalValueResult.count = this._count;
    }
    if (this._entries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entries = this._entries?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._count = undefined;
      this._entries.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._count = value.count;
      this._entries.internalValue = value.entries;
    }
  }

  // count - computed: false, optional: true, required: false
  private _count?: number; 
  public get count() {
    return this.getNumberAttribute('count');
  }
  public set count(value: number) {
    this._count = value;
  }
  public resetCount() {
    this._count = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get countInput() {
    return this._count;
  }

  // entries - computed: false, optional: true, required: false
  private _entries = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntriesList(this, "entries", false);
  public get entries() {
    return this._entries;
  }
  public putEntries(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsEntries[] | cdktf.IResolvable) {
    this._entries.internalValue = value;
  }
  public resetEntries() {
    this._entries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entriesInput() {
    return this._entries.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsAttestorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRun {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#enable DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRunToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRun | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRunToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRun | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRunOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRun | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsDryRun | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._namespace = value.namespace;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#group DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#group}
  */
  readonly group?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#kind DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#name DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#namespace DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#version DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group: cdktf.stringToTerraform(struct!.group),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._group = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._group = value.group;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._version = value.version;
    }
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#fields DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#fields}
  */
  readonly fields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.10.20/docs/data-sources/kyverno_io_cluster_policy_v2beta1_manifest#objects DataK8SKyvernoIoClusterPolicyV2Beta1Manifest#objects}
  */
  readonly objects?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects[] | cdktf.IResolvable;
}

export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsToTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fields),
    objects: cdktf.listMapper(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsToTerraform, false)(struct!.objects),
  }
}


export function dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsToHclTerraform(struct?: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    objects: {
      value: cdktf.listMapperHcl(dataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsToHclTerraform, false)(struct!.objects),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields;
    }
    if (this._objects?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.objects = this._objects?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields = undefined;
      this._objects.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields = value.fields;
      this._objects.internalValue = value.objects;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields?: string[]; 
  public get fields() {
    return this.getListAttribute('fields');
  }
  public set fields(value: string[]) {
    this._fields = value;
  }
  public resetFields() {
    this._fields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields;
  }

  // objects - computed: false, optional: true, required: false
  private _objects = new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjectsList(this, "objects", false);
  public get objects() {
    return this._objects;
  }
  public putObjects(value: DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsObjects[] | cdktf.IResolvable) {
    this._objects.internalValue = value;
  }
  public resetObjects() {
    this._objects.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectsInput() {
    return this._objects.internalValue;
  }
}

export class DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsOutputReference {
    return new DataK8SKyvernoIoClusterPolicyV2Beta1ManifestSpecRulesValidateManifestsIgnoreFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
